<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>日志传送的替代方法</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="高可用性与负载均衡，复制" HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html"><LINK REL="PREVIOUS" TITLE="失效切换" HREF="warm-standby-failover.html"><LINK REL="NEXT" TITLE="热备" HREF="hot-standby.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/high-availability.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="失效切换" HREF="warm-standby-failover.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 25. 高可用性与负载均衡，复制</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="热备" HREF="hot-standby.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LOG-SHIPPING-ALTERNATIVE">25.4. 日志传送的替代方法</A></H1><P> 一种替代在前节描述的内建备用模式的方法是使用<TT CLASS="VARNAME">restore_command</TT>轮询归档位置。
这是只能在8.4及以下版本选择使用。在此设置<TT CLASS="VARNAME">standby_mode</TT>关闭，
因为你要实现备服务器运行你自己所需的轮询。
请参考<A HREF="pgstandby.html"><SPAN CLASS="APPLICATION">pg_standby</SPAN></A>模块关于这类的实现。</P><P> 请注意在这种模式，服务器将一次应用一个WAL文件，所以如果你使用备服务器对于查询（见热备），
在主服务器中的动作和当这个动作在备服务器中可见之间有个延迟，
相应的时间用在填写WAL文件。<TT CLASS="VARNAME">archive_timeout</TT>可以使延迟较短。
还要注意你不能用这种方法结合流复制。</P><P> 主备用服务器上发生的操作是正常的连续归档和恢复任务。
两个数据库服务器相联系的一点是两者共享的WAL归档文件：
主写入归档，备从归档读取。必须小心，以确保从单独的主服务器，
不会混在一起或混淆WAL归档。如果只是备服务器操作要求，归档需要并不大。</P><P> 使松散耦合的两个服务器一起工作简直是奇迹，在备服务器上简单使用<TT CLASS="VARNAME">restore_command</TT>，
当询问下一个WAL文件，等待其为主服务器可用的。
在备服务器的<TT CLASS="FILENAME">recovery.conf</TT>文件指定<TT CLASS="VARNAME">restore_command</TT>。
通常恢复进程将从一个WAL归档中请求文件，如果该文件不可用，则报告失败。
对备服务器进程来说下一个WAL文件不可用是正常的，因此备服务器进程需要等待它出现。
对于在<TT CLASS="LITERAL">.backup</TT>或者<TT CLASS="LITERAL">.history</TT>文件结束不需要等待，
并且返回一个非零值。等待<TT CLASS="VARNAME">restore_command</TT>可以写为一个自定义脚本，
即循环轮询下一个WAL文件的存在。还必须有一些方法来触发失效切换，
应该中断的<TT CLASS="VARNAME">restore_command</TT>，跳出循环，
并返回备用服务器一个文件未找到错误。这两端的恢复和备用服务器，
然后将作为一个正常的服务器。</P><P>
一个合适<TT CLASS="VARNAME">restore_command</TT>的伪码是：
</P><PRE CLASS="PROGRAMLISTING">triggered = false;
while (!NextWALFileReady() &amp;&amp; !triggered)
{
    sleep(100000L);         /* wait for ~0.1 sec */
    if (CheckForExternalTrigger())
        triggered = true;
}
if (!triggered)
        CopyWALFileForRecovery();</PRE><P>
</P><P> 在<A HREF="pgstandby.html"><SPAN CLASS="APPLICATION">pg_standby</SPAN></A>模块中提供一个等待<TT CLASS="VARNAME">restore_command</TT>的实际例子。
应该用来作为参考如何正确地贯彻执行上述逻辑。它也可以扩展需要，
以支持特定的配置和环境。</P><P> 触发失效切换的方法是规划和设计的一个重要组成部分。
一个潜在的选项是<TT CLASS="VARNAME">restore_command</TT>命令。每个WAL文件执行一次，
但是运行<TT CLASS="VARNAME">restore_command</TT>的进程对于每个文件创建和消亡的，
所以没有守护进程或服务器进程和信号或不能使用的信号处理。
因此，<TT CLASS="VARNAME">restore_command</TT>不适合触发失效切换。使用简单超时机制可能的，
尤其如果与已知的<TT CLASS="VARNAME">archive_timeout</TT>在主服务器上配合设置使用。
尽管，这比较容易出错，因为网络问题或繁忙的主服务器可能有足够的启动失效切换。
如果可以安排，通报机制如显式创建一个触发器文件是理想的。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="WARM-STANDBY-CONFIG">25.4.1. 实施</A></H2><P>
配置备用服务器，使用这种替代方法简短步骤如下。对于每一步的细节，
请参阅前面的章节。
<P></P></P><OL TYPE="1"><LI><P>
建立主备系统尽可能接近相同，包括两个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>副本在相同版本级别。
</P></LI><LI><P> 设置从主服务器上连续归档到备服务器WAL归档目录。
确保在主服务器上相应的设置<A HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</A>,
<A HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</A>和<A HREF="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT">archive_timeout</A>。
(参阅<A HREF="continuous-archiving.html#BACKUP-ARCHIVING-WAL">第 24.3.1 &#33410;</A>)。</P></LI><LI><P> 做一个主服务器的基准备份(参阅<A HREF="continuous-archiving.html#BACKUP-BASE-BACKUP">第 24.3.2 &#33410;</A>)，
在备服务器上加载这个数据。</P></LI><LI><P> 在备服务器上从一个本地的WAL归档开始恢复，
如前所述等待使用<TT CLASS="FILENAME">recovery.conf</TT>所指定的<TT CLASS="VARNAME">restore_command</TT>。
（请参阅<A HREF="continuous-archiving.html#BACKUP-PITR-RECOVERY">第 24.3.4 &#33410;</A>）。</P></LI></OL><P>
</P><P> 恢复对WAL归档做只读处理，所以一旦在WAL的文件已被复制到备用系统，
就可以在同一时间复制到磁带，因为正通过备用数据库服务器读取。
因此，运行高可用性的备用服务器可以同时作为文件存储长远的灾难恢复目的做处理。</P><P> 出于测试目的，它是可以在同一系统上运行的主备服务器。
没提供任何值得改进服务器的健壮性，也不会描述为HA。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="WARM-STANDBY-RECORD">25.4.2. 基于记录的日志传送</A></H2><P> 使用这种替代方法也有可能实现基于记录的日志传送，
尽管这需要定制开发，一个完整的WAL文件传送之后变化只为热备查询可见。</P><P> 一个外部程序可以调用<CODE CLASS="FUNCTION">pg_xlogfile_name_offset()</CODE>（参阅<A HREF="functions-admin.html">第 9.26 &#33410;</A>）
这个函数用来找出文件名和当前WAL结尾的准
确字节偏移。然后，可以直接访问WAL文件，
并从WAL的上次已知的结尾到当前结束数据复制数据到备用服务器。用这种方法，
数据丢失窗口是复制程序的轮询周期时间， 其可以非常小，
并没有迫使部分使用的段文件要归档的带宽浪费。
请注意备服务器上的<TT CLASS="VARNAME">restore_command</TT>脚本只能处理完整的WAL文件，
所以通常的增量备份数据到备服务器不可用。只有在主服务器死掉&mdash;
在允许它到来前，最后一部分WAL文件送到备服务器。在这个进程中的正确实现，
需要<TT CLASS="VARNAME">restore_command</TT>脚本与数据复制程序协作。</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>9.0版本开始，
你可以使用流复制达到事半功倍的效果（请参阅<A HREF="warm-standby.html#STREAMING-REPLICATION">第 25.2.5 &#33410;</A>）。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="warm-standby-failover.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="hot-standby.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">失效切换</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">热备</TD></TR></TABLE></DIV></BODY></HTML>
