<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>分析器阶段</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PostgreSQL内部概述" HREF="http://school.yunwei.edu/manual/PostgreSQL/overview.html"><LINK REL="PREVIOUS" TITLE="连接是如何建立起来的" HREF="connect-estab.html"><LINK REL="NEXT" TITLE="PostgreSQL规则系统" HREF="rule-system.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/arch-dev.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="连接是如何建立起来的" HREF="connect-estab.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/overview.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 46. PostgreSQL内部概述</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="PostgreSQL规则系统" HREF="rule-system.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PARSER-STAGE">46.3. 分析器阶段</A></H1><P><I CLASS="FIRSTTERM">分析器阶段</I>含两个部分：
<P></P></P><UL><LI><P>在<TT CLASS="FILENAME">gram.y</TT>和<TT CLASS="FILENAME">scan.l</TT>里定义的<I CLASS="FIRSTTERM">分析器</I>
是使用 Unix 工具<SPAN CLASS="APPLICATION">bison</SPAN>和<SPAN CLASS="APPLICATION">flex</SPAN>创建的。</P></LI><LI><P><I CLASS="FIRSTTERM">转换处理</I>对分析器返回的数据结构进行修改和增补。</P></LI></UL><P>
</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN90538">46.3.1. 分析器</A></H2><P>分析器必须检查(以纯 ASCII 文本方式到来的)查询字符串的语法。如果语法正确，
则创建一个<I CLASS="FIRSTTERM">分析树</I>并将之传回，否则，返回一个错误。
实现分析器和词法器使用了著名的 Unix 工具<SPAN CLASS="APPLICATION">bison</SPAN>和<SPAN CLASS="APPLICATION">flex</SPAN>。</P><P><I CLASS="FIRSTTERM">词法器</I>在文件<TT CLASS="FILENAME">scan.l</TT>里定义，
负责识别<I CLASS="FIRSTTERM">标识符</I>和 <I CLASS="FIRSTTERM">SQL 关键字</I>等。
对于发现的每个关键字或者标识符都会生成一个<I CLASS="FIRSTTERM">记号</I>并且传递给分析器。</P><P>分析器在文件<TT CLASS="FILENAME">gram.y</TT>里定义并且包含一套<I CLASS="FIRSTTERM">语法规则</I>
以及触发规则时执行的<I CLASS="FIRSTTERM">动作</I>。动作代码(实际上是 C 代码)用于建立分析树。</P><P>文件<TT CLASS="FILENAME">scan.l</TT>用<SPAN CLASS="APPLICATION">flex</SPAN>转换成 C 源文件
<TT CLASS="FILENAME">scan.c</TT>，而<TT CLASS="FILENAME">gram.y</TT>用<SPAN CLASS="APPLICATION">bison</SPAN>
转换成<TT CLASS="FILENAME">gram.c</TT>。在完成这些转换后，一个通用的 C 编译器就可以用于创建分析器。
千万不要对生成的 C 源文件做修改，因为下一次调用<SPAN CLASS="APPLICATION">flex</SPAN>
或<SPAN CLASS="APPLICATION">bison</SPAN>时会把它们覆盖。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>上面提到的转换和编译是使用跟随<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>发布的
<I CLASS="FIRSTTERM">makefiles</I>自动完成的。</P></BLOCKQUOTE></DIV><P>
</P><P>对<SPAN CLASS="APPLICATION">bison</SPAN>或者<TT CLASS="FILENAME">gram.y</TT>
里的语法规则的详细描述超出本文的范围。有很多关于<SPAN CLASS="APPLICATION">flex</SPAN>
和<SPAN CLASS="APPLICATION">bison</SPAN>的书籍和文档。你在开始研究<TT CLASS="FILENAME">gram.y</TT>
里给出的语法之前应该对<SPAN CLASS="APPLICATION">bison</SPAN>很熟悉，否则你将看不懂那里面的内容，
理解不了发生了什么事情。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN90574">46.3.2. 转换处理</A></H2><P>分析器阶段只使用和 SQL 语法结构相关的固定规则创建一个分析树。它不会查找任何系统表，
因此就不可能理解请求操作里详细的语义。在分析器阶段完成之后，
<I CLASS="FIRSTTERM">转换处理</I>接受分析器传过来的分析树然后进行语义解析，解析查询中引用了哪些表、
哪些函数、哪些操作符。最终生成表示这些信息的数据结构，称之为<I CLASS="FIRSTTERM">查询树</I>。</P><P>把裸分析（raw parsing）和语义分析分成两个过程的原因是系统表查找只能在一个事务中进行，
而不想在一接收到查询字符串就发起一个事务。裸分析阶段已经足够可以标识事务控制命令(
<TT CLASS="COMMAND">BEGIN</TT>，<TT CLASS="COMMAND">ROLLBACK</TT>等)，并且这些东西不用任何进一步的分析就可以执行。
一旦知道正在处理一个真正的查询(比如<TT CLASS="COMMAND">SELECT</TT>或<TT CLASS="COMMAND">UPDATE</TT>)，
就可以启动一个事务(如果尚未启动一个事务的话)，只有这个时候转换处理才可以被调用。</P><P>转换处理生成的查询树在结构上与裸分析树很相似，但是在细节上有很多区别。
比如，在分析树里的<TT CLASS="STRUCTNAME">FuncCall</TT>节点代表那些看上去像函数调用的东西。
根据引用的名字是一个普通函数还是一个聚集函数，这个可能被转换成一个<TT CLASS="STRUCTNAME">FuncExpr</TT>
或<TT CLASS="STRUCTNAME">Aggref</TT>节点。同样，有关字段和表达式结果的具体数据类型也添加到查询树中。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="connect-estab.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="rule-system.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">连接是如何建立起来的</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/overview.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>规则系统</TD></TR></TABLE></DIV></BODY></HTML>
