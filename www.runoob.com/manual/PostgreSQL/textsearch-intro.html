<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>介绍</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="全文检索" HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html"><LINK REL="PREVIOUS" TITLE="全文检索" HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html"><LINK REL="NEXT" TITLE="表和索引" HREF="textsearch-tables.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/textsearch.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="全文检索" HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 12. 全文检索</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="表和索引" HREF="textsearch-tables.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="TEXTSEARCH-INTRO">12.1. 介绍</A></H1><P>全文搜索（或只是<I CLASS="FIRSTTERM">文本搜索</I>）提供满足<I CLASS="FIRSTTERM">查询</I>的识别自然语言<I CLASS="FIRSTTERM">文档</I>的能力，
并且任意地通过相关性查询进行排序。搜索最常见的类型是找到所有包含给定的<I CLASS="FIRSTTERM">查询术语</I>的记录，并且以<I CLASS="FIRSTTERM">相似性</I>的查
询顺序返回它们。 <TT CLASS="VARNAME">query</TT>和<TT CLASS="VARNAME">similarity</TT>的概念是非常灵活的，取决于特定的应用。最简单的
搜索认为<TT CLASS="VARNAME">query</TT>是一组词，并且<TT CLASS="VARNAME">similarity</TT>为文档中的查询词出现的频率。</P><P>文本搜索操作符已经在数据库中存在多年。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>为文本数据类型提供<TT CLASS="LITERAL">~</TT>, <TT CLASS="LITERAL">~*</TT>,
<TT CLASS="LITERAL">LIKE</TT>和<TT CLASS="LITERAL">ILIKE</TT>操作符，但它们缺乏许多通过现代信息系统要求的必要属性：</P><P></P><UL COMPACT="COMPACT"><LI STYLE="list-style-type: disc"><P>没有语言的支持，即使是英语。正则表达式是不充分的，因为他们不能很容易地处理派生词，
比如， <TT CLASS="LITERAL">satisfies</TT> 和<TT CLASS="LITERAL">satisfy</TT>。你可能会丢失包含<TT CLASS="LITERAL">satisfies</TT>的文档，
虽然你可能会发现他们在寻找<TT CLASS="LITERAL">satisfy</TT>。使用<TT CLASS="LITERAL">OR</TT>搜索多个派生形式是可能的，但这很繁琐，
而且容易出错（有些词可能会有上千的派生词）。</P></LI><LI STYLE="list-style-type: disc"><P>他们没有提供搜索结果的分类（排序），当成千的匹配文档被发现时，这使得它们无效。</P></LI><LI STYLE="list-style-type: disc"><P>他们往往比较缓慢，因为没有索引的支持，因此他们必须为每一个搜索处理所有文档。</P></LI></UL><P>全文索引允许文档被<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">预处理</I></SPAN>，并且为后边的快速搜索保存一个索引。预处理包括：</P><P></P><UL><LI STYLE="list-style-type: none"><P><SPAN CLASS="emphasis"><I CLASS="EMPHASIS">解析文档<I CLASS="FIRSTTERM">标记</I></I></SPAN>。标识不同类别的记号是非常有用的，
例如，数字，词，复合词，电子邮件地址，这样他们可以用不同的方法来处理。原则上令牌类依赖于具体的应用，
但出于大多数的目的，可以使用一组预定义的类。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>使用<I CLASS="FIRSTTERM">解析器</I>来
执行这一步。提供了一种标准的解析器，以及为特定的需求创造的自定义分析器。</P></LI><LI STYLE="list-style-type: none"><P><SPAN CLASS="emphasis"><I CLASS="EMPHASIS">转换标记为<I CLASS="FIRSTTERM">词</I></I></SPAN>。词是一个字符串，就像一个标记，但它已经<I CLASS="FIRSTTERM">标准化</I>，
这样同一个词的不同形式是一样的。例如，标准化几乎总是包括可折叠的大写字母到小写字母，往往涉及删除后缀（如英语中
的<TT CLASS="LITERAL">s</TT> 或者<TT CLASS="LITERAL">es</TT> ）。这允许搜索找到同一个词的不同形式，没有繁琐的输入所有可能的变种。同时，这一步
通常删除<I CLASS="FIRSTTERM">屏蔽词</I>，这是很常见的，他们对于搜索无用。（总之，标记是文档文本的原片段，而词汇被认
为是有用的索引和搜索的词。）<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>使用<I CLASS="FIRSTTERM">词典</I>执行这一步。提供各种标准词典，
以及为特定的需求创造的自定义词典。</P></LI><LI STYLE="list-style-type: none"><P> <SPAN CLASS="emphasis"><I CLASS="EMPHASIS">为优化搜索存储预处理文档</I></SPAN>。比如，每个文档可以表示为标准化词汇排序数组。
伴随着词汇往往为<I CLASS="FIRSTTERM">邻近排序</I>存储位置信息，这是理想的。因此包含查询词的<SPAN CLASS="QUOTE">"密集"</SPAN>区域的
文档比分散查询词分配到一个更高的顺序。</P></LI></UL><P>字典允许细粒度控制如何使用合适的字典规范化标记。你可以：</P><P></P><UL COMPACT="COMPACT"><LI STYLE="list-style-type: disc"><P>定义不被索引的屏蔽词。</P></LI><LI STYLE="list-style-type: disc"><P>使用<SPAN CLASS="APPLICATION">Ispell</SPAN>映射同义词到一个词。</P></LI><LI STYLE="list-style-type: disc"><P>使用同义词词典将短语映射到一个词。</P></LI><LI STYLE="list-style-type: disc"><P>使用<SPAN CLASS="APPLICATION">Ispell</SPAN>词典将词的不同形式映射到一种范式。 </P></LI><LI STYLE="list-style-type: disc"><P>使用<SPAN CLASS="APPLICATION">Snowball</SPAN>词根规则将一个词的不同形式映射到一种范式。</P></LI></UL><P>一种数据类型<TT CLASS="TYPE">tsvector</TT>用于存储预处理文档，以及类型<TT CLASS="TYPE">tsquery</TT> 表示处理的查询（<A HREF="datatype-textsearch.html">第 8.11 &#33410;</A>）。
为这些数据类型提供很多的函数和操作符（<A HREF="functions-textsearch.html">第 9.13 &#33410;</A>），其中最重要的是匹配运算符<TT CLASS="LITERAL">@@</TT>，将在<A HREF="textsearch-intro.html#TEXTSEARCH-MATCHING">第 12.1.2 &#33410;</A>中介绍。
全文搜索可以使用索引进行加速（<A HREF="textsearch-indexes.html">第 12.9 &#33410;</A>）。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="TEXTSEARCH-DOCUMENT">12.1.1. 文档是什么？</A></H2><P>一个<I CLASS="FIRSTTERM">文档</I>是全文搜索系统的搜索单元；例如，杂志上的一篇文章或电子邮件消息。
文本搜索引擎必须能够解析文档，而且可以存储它们父文档词（关键词）的联系性。之后，
这些联系用来搜索包含查询词的文档。</P><P>
在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>中搜索，文档通常是一个数据库表中一行的文本字段，或者这些字段的可能组合（级联），
可能存储在多个表中或者动态地获得。换句话说，一个文档可以由索引的不同部分构成，它不可能随时随地作
为一个整体存储。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body AS document
FROM messages
WHERE mid = 12;

SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body AS document
FROM messages m, docs d
WHERE mid = did AND mid = 12;</PRE><P>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>注意:实际上，在这些示例查询中，<CODE CLASS="FUNCTION">coalesce</CODE>使用时应防止一个独立的<TT CLASS="LITERAL">NULL</TT>属性导致整个文档的<TT CLASS="LITERAL">NULL</TT>结果。</P></BLOCKQUOTE></DIV><P>另外一个可能性是在文档系统中作为简单的文本文档存储。在这种情况下，数据库可以用于存储全
文索引并且执行搜索，同时使用一些唯一标识从文件系统中检索文档。然而，从外部检索文件，数据库
需要拥有超级用户权限或者特殊函数支持，因此比把所有数据保存在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>中相比较，
这往往不太方便。同时，保持所有的数据在数据库里面允许轻松访问文档的元数据以帮助索引和显示。</P><P>为了文本搜索目的，每个文档必须减少到预处理<TT CLASS="TYPE">tsvector</TT>格式。在文档的<TT CLASS="TYPE">tsvector</TT>表示形式上完整的执行搜索
和排序&mdash;当为了显示给用户来选择文档时，只需要检索原文本。因此我们常说的<TT CLASS="TYPE">tsvector</TT>作为文档，当然它仅仅是
完整文档的一种紧凑表示。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="TEXTSEARCH-MATCHING">12.1.2. 基本文本匹配</A></H2><P>
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>中的全文搜索基于匹配算子<TT CLASS="LITERAL">@@</TT>，如果一个<TT CLASS="TYPE">tsvector</TT>(document)匹配一个<TT CLASS="TYPE">tsquery</TT>(query)，
则返回<TT CLASS="LITERAL">true</TT>。不管哪个数据类型先被重写：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat &amp; rat'::tsquery;
 ?column?
----------
 t

SELECT 'fat &amp; cow'::tsquery @@ 'a fat cat sat on a mat and ate a fat rat'::tsvector;
 ?column?
----------
 f</PRE><P>
</P><P>
正如上面例子表明，一个<TT CLASS="TYPE">tsquery</TT>不仅仅是原文本，更多的是一个<TT CLASS="TYPE">tsvector</TT>。一个包含搜索条件的<TT CLASS="TYPE">tsquery</TT>，
必须是已经标准化的词，并且可能使用AND, OR, 和 NOT操作符连接多个术语（详情请见<A HREF="datatype-textsearch.html">第 8.11 &#33410;</A>）。
函数<CODE CLASS="FUNCTION">to_tsquery</CODE>和<CODE CLASS="FUNCTION">plainto_tsquery</CODE>在将用户书写文本转换成一个合适的<TT CLASS="TYPE">tsquery</TT>是非常有帮助的。
比如通过标准化文本中的词。类似的，<CODE CLASS="FUNCTION">to_tsvector</CODE>用于解析和标准化文档字符串。因此在实践中文本搜索匹配
可能看起来更像这样：
</P><PRE CLASS="PROGRAMLISTING">SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat &amp; rat');
 ?column? 
----------
 t</PRE><P>
观察这个匹配可能不会成功，如果写成这样：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat &amp; rat');
 ?column? 
----------
 f</PRE><P>
由于这儿没有发生词<TT CLASS="LITERAL">rats</TT>的标准化。一个<TT CLASS="TYPE">tsvector</TT>的元素是词，假设已经被标准化，所以<TT CLASS="LITERAL">rats</TT>不匹配<TT CLASS="LITERAL">rat</TT>。
</P><P>
<TT CLASS="LITERAL">@@</TT>操作符也支持<TT CLASS="TYPE">text</TT>输入，允许一个文本字符串的显示转换为<TT CLASS="TYPE">tsvector</TT>或者在简单情况下忽略<TT CLASS="TYPE">tsquery</TT>。
可用形式是：
</P><PRE CLASS="PROGRAMLISTING">tsvector @@ tsquery
tsquery  @@ tsvector
text @@ tsquery
text @@ text</PRE><P>
</P><P>我们已经看到了前面两种，形式 <TT CLASS="TYPE">text</TT> <TT CLASS="LITERAL">@@</TT> <TT CLASS="TYPE">tsquery</TT>等价于<TT CLASS="LITERAL">to_tsvector(x) @@ y</TT>。<TT CLASS="TYPE">text</TT> <TT CLASS="LITERAL">@@</TT> <TT CLASS="TYPE">text</TT>等价于
<TT CLASS="LITERAL">to_tsvector(x) @@ plainto_tsquery(y)</TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="TEXTSEARCH-INTRO-CONFIGURATIONS">12.1.3. 配置</A></H2><P>上面是所有简单文本搜索例子。如前所述，全文搜索功能还有能力做更多事情：忽略索引某个词（屏蔽词），
过程同义词和使用复杂解析，比如：不仅仅基于空白格的解析。这些功能通过<I CLASS="FIRSTTERM">文本搜索配置</I>控制。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>来自多语言的预先定义的配置，并且你也可以很容易的创建你自己的配置（<SPAN CLASS="APPLICATION">psql</SPAN>的<TT CLASS="COMMAND">\dF</TT> 命令显示了
所有可用配置）。</P><P>在安装期间选择一个合适的配置，并且在<TT CLASS="FILENAME">postgresql.conf</TT>中相应的设置<A HREF="runtime-config-client.html#GUC-DEFAULT-TEXT-SEARCH-CONFIG">default_text_search_config</A>。
如果为了整个集群使用同一个文本搜索配置你可以使用<TT CLASS="FILENAME">postgresql.conf</TT>中的值。为了在集群中使用不同配置，但是在任何其他一个数据库的同一
配置中使用<TT CLASS="COMMAND">ALTER DATABASE ... SET</TT>。否则，你可以在每个会话中设置<TT CLASS="VARNAME">default_text_search_config</TT>。</P><P>每个依赖于配置的文本搜索函数有一个可选的<TT CLASS="TYPE">regconfig</TT>参数，因此可以明确声明使用的配置。
仅当忽略这些参数的时候，才使用<TT CLASS="VARNAME">default_text_search_config</TT>。</P><P>为了更方便的建立自定义文本搜索配置，从简单的数据库对象中建立了配置。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>文本搜索功能提供了四种类型的配置相关的数据库对象：</P><P></P><UL COMPACT="COMPACT"><LI STYLE="list-style-type: disc"><P><I CLASS="FIRSTTERM">文本搜索解析器</I>打破文档标记，并且分类每个标记（比如，词和数字）。</P></LI><LI STYLE="list-style-type: disc"><P><I CLASS="FIRSTTERM">文本搜索词典</I>把标记转换成规范格式并且拒绝屏蔽词。</P></LI><LI STYLE="list-style-type: disc"><P><I CLASS="FIRSTTERM">文本搜索模板</I>提供潜在的词典功能（一个词典简单的指定一个模板，并且为模板设置参数）。</P></LI><LI STYLE="list-style-type: disc"><P><I CLASS="FIRSTTERM">文本搜索配置</I>选择一个解析器，并且使用一系列词典规范化语法分析器产生的标记。</P></LI></UL><P>文本搜索解析器和模板是从低层次的C函数建立的；因此它需要C程序能力开发新产品，
并且需要超级用户权限安装到数据库中（在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>发布的<TT CLASS="FILENAME">contrib/</TT>范围内有附加解析器和模板的实例）。
因为词典和配置仅仅参数化并且连接到一些潜在的解析器和模板上，创建一个新的词典或者配置不需要特定的权限。
创建自定义词典和配置实例出现在本章节的后面。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="textsearch-tables.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">全文检索</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">表和索引</TD></TR></TABLE></DIV></BODY></HTML>
