<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pgcrypto</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="pg_buffercache" HREF="pgbuffercache.html"><LINK REL="NEXT" TITLE="pg_freespacemap" HREF="pgfreespacemap.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/pgcrypto.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_buffercache" HREF="pgbuffercache.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="pg_freespacemap" HREF="pgfreespacemap.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PGCRYPTO">F.25. pgcrypto</A></H1><P><TT CLASS="FILENAME">pgcrypto</TT>模块为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>提供cryptographic函数。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN148068">F.25.1. 一般散列函数</A></H2><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148070">F.25.1.1. <CODE CLASS="FUNCTION">digest()</CODE></A></H3><PRE CLASS="SYNOPSIS">digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea</PRE><P>计算给定<TT CLASS="PARAMETER">data</TT>的二进制散列。<TT CLASS="PARAMETER">type</TT>是要使用的算法。
标准算法是<TT CLASS="LITERAL">md5</TT>, <TT CLASS="LITERAL">sha1</TT>,
<TT CLASS="LITERAL">sha224</TT>, <TT CLASS="LITERAL">sha256</TT>,
<TT CLASS="LITERAL">sha384</TT> 和 <TT CLASS="LITERAL">sha512</TT>。
如果<TT CLASS="FILENAME">pgcrypto</TT>带有OpenSSL建立，那么更多算法可用，在
<A HREF="pgcrypto.html#PGCRYPTO-WITH-WITHOUT-OPENSSL">&#34920; F-18</A>中详细说明。</P><P>如果你希望digest作为一个十六进制字符串，那么在结果上使用<CODE CLASS="FUNCTION">encode()</CODE>。
例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;</PRE><P></P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148090">F.25.1.2. <CODE CLASS="FUNCTION">hmac()</CODE></A></H3><PRE CLASS="SYNOPSIS">hmac(data text, key text, type text) returns bytea
hmac(data bytea, key text, type text) returns bytea</PRE><P>为带有键<TT CLASS="PARAMETER">key</TT>的<TT CLASS="PARAMETER">data</TT>计算散列的MAC。<TT CLASS="PARAMETER">type</TT>
和在<CODE CLASS="FUNCTION">digest()</CODE>中相同。</P><P>类似于<CODE CLASS="FUNCTION">digest()</CODE>但是散列只能在知道键的时候计算。
这样就阻止了某个人更改数据并改变匹配的散列的情况。</P><P>如果键比散列块大小要大，那么将首先把键散列然后散列的结果作为键使用。</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN148104">F.25.2. 口令散列函数</A></H2><P>函数<CODE CLASS="FUNCTION">crypt()</CODE>和<CODE CLASS="FUNCTION">gen_salt()</CODE>是特别为散列口令设计的。
<CODE CLASS="FUNCTION">crypt()</CODE>做散列法，<CODE CLASS="FUNCTION">gen_salt()</CODE>为其准备算法参数。</P><P><CODE CLASS="FUNCTION">crypt()</CODE>中的算法与普通散列算法（如MD5或SHA1）有以下方面的不同：</P><P></P><OL TYPE="1"><LI><P>他们的速度很慢。因为数据很少，所以这是唯一的让蛮力破解口令困难些的方法。</P></LI><LI><P>它们使用随机值，称为<I CLASS="FIRSTTERM">salt</I>，所以有相同口令的用户将会有不同加密了的口令。
也是也对反向算法的附加防御。</P></LI><LI><P>它们在结果中包括算法类型，所以不同算法的口令散列可以共存。</P></LI><LI><P>它们中的一些是自适应的，这意味着当计算机更快速时，你可以将算法调整的慢一些，
而不会引入与现有口令的不相容。</P></LI></OL><P><A HREF="pgcrypto.html#PGCRYPTO-CRYPT-ALGORITHMS">&#34920; F-15</A>列出了<CODE CLASS="FUNCTION">crypt()</CODE>
函数支持的算法。</P><DIV CLASS="TABLE"><A NAME="PGCRYPTO-CRYPT-ALGORITHMS"></A><P><B>&#34920; F-15. <CODE CLASS="FUNCTION">crypt()</CODE>支持的算法</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><COL><THEAD><TR><TH>算法</TH><TH>最大口令长度</TH><TH>自适应?</TH><TH>Salt位</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">bf</TT></TD><TD>72</TD><TD>yes</TD><TD>128</TD><TD>基于Blowfish，2a的变体</TD></TR><TR><TD><TT CLASS="LITERAL">md5</TT></TD><TD>unlimited</TD><TD>no</TD><TD>48</TD><TD>基于MD5加密</TD></TR><TR><TD><TT CLASS="LITERAL">xdes</TT></TD><TD>8</TD><TD>yes</TD><TD>24</TD><TD>扩展的DES</TD></TR><TR><TD><TT CLASS="LITERAL">des</TT></TD><TD>8</TD><TD>no</TD><TD>12</TD><TD>原始的UNIX加密</TD></TR></TBODY></TABLE></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148166">F.25.2.1. <CODE CLASS="FUNCTION">crypt()</CODE></A></H3><PRE CLASS="SYNOPSIS">crypt(password text, salt text) returns text</PRE><P>计算一个<TT CLASS="PARAMETER">password</TT>的crypt(3)类型散列。当存储一个新的口令时，
需要使用<CODE CLASS="FUNCTION">gen_salt()</CODE>生成一个新的<TT CLASS="PARAMETER">salt</TT>值。
要检查一个口令，作为<TT CLASS="PARAMETER">salt</TT>传递存储的散列值，
然后检验结果是否匹配存储的值。</P><P>设置一个新的口令的示例：
</P><PRE CLASS="PROGRAMLISTING">UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));</PRE><P></P><P>认证的示例：
</P><PRE CLASS="PROGRAMLISTING">SELECT pswhash = crypt('entered password', pswhash) FROM ... ;</PRE><P>
如果输入的口令是正确的这个就返回<TT CLASS="LITERAL">true</TT>。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148182">F.25.2.2. <CODE CLASS="FUNCTION">gen_salt()</CODE></A></H3><PRE CLASS="SYNOPSIS">gen_salt(type text [, iter_count integer ]) returns text</PRE><P>为<CODE CLASS="FUNCTION">crypt()</CODE>的使用生成一个新的随机salt字符串。
salt字符串也告诉<CODE CLASS="FUNCTION">crypt()</CODE>使用哪种算法。</P><P><TT CLASS="PARAMETER">type</TT>参数指定散列算法。接受的类型有：<TT CLASS="LITERAL">des</TT>, <TT CLASS="LITERAL">xdes</TT>,
<TT CLASS="LITERAL">md5</TT> 和 <TT CLASS="LITERAL">bf</TT>。</P><P><TT CLASS="PARAMETER">iter_count</TT>参数让用户指定重复计数，为这一个算法。计数值越高，
拿它去散列口令的次数越多，因此解开它的次数也越多。尽管太高的计数来计算一个散列可能会用几年的时间，
这有点不切实际。如果省略了<TT CLASS="PARAMETER">iter_count</TT>参数，那么使用缺省的重复计数。
<TT CLASS="PARAMETER">iter_count</TT>的允许值取决于算法，在<A HREF="pgcrypto.html#PGCRYPTO-ICFC-TABLE">&#34920; F-16</A>中显示。</P><DIV CLASS="TABLE"><A NAME="PGCRYPTO-ICFC-TABLE"></A><P><B>&#34920; F-16. <CODE CLASS="FUNCTION">crypt()</CODE>的重复计数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>算法</TH><TH>缺省</TH><TH>最小</TH><TH>最大</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">xdes</TT></TD><TD>725</TD><TD>1</TD><TD>16777215</TD></TR><TR><TD><TT CLASS="LITERAL">bf</TT></TD><TD>6</TD><TD>4</TD><TD>31</TD></TR></TBODY></TABLE></DIV><P>对于<TT CLASS="LITERAL">xdes</TT>，这里有一个附加的限制，那就是重复计数必须是奇数。</P><P>要选择一个合适的重复计数，考虑原始的DES加密设计是要在那个时间的硬件上每秒有4个散列的速度。
比4个散列每秒慢的可能会降低可用性。高于100散列每秒的可能太快了。</P><P><A HREF="pgcrypto.html#PGCRYPTO-HASH-SPEED-TABLE">&#34920; F-17</A>给出了不同散列算法的相对缓慢的概述。
该表显示了在8字符口令里尝试所有字符的组合将会花费多长时间，假设口令只包含小写字母，
或者包含大小写字母和数字。在<TT CLASS="LITERAL">crypt-bf</TT>记录中，
斜线后的数字是<CODE CLASS="FUNCTION">gen_salt</CODE>的<TT CLASS="PARAMETER">iter_count</TT>参数。</P><DIV CLASS="TABLE"><A NAME="PGCRYPTO-HASH-SPEED-TABLE"></A><P><B>&#34920; F-17. 散列算法速度</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>算法</TH><TH>散列/sec</TH><TH>对于 <TT CLASS="LITERAL">[a-z]</TT></TH><TH>对于 <TT CLASS="LITERAL">[A-Za-z0-9]</TT></TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">crypt-bf/8</TT></TD><TD>28</TD><TD>246 年</TD><TD>251322 年</TD></TR><TR><TD><TT CLASS="LITERAL">crypt-bf/7</TT></TD><TD>57</TD><TD>121 年</TD><TD>123457 年</TD></TR><TR><TD><TT CLASS="LITERAL">crypt-bf/6</TT></TD><TD>112</TD><TD>62 年</TD><TD>62831 年</TD></TR><TR><TD><TT CLASS="LITERAL">crypt-bf/5</TT></TD><TD>211</TD><TD>33 年</TD><TD>33351 年</TD></TR><TR><TD><TT CLASS="LITERAL">crypt-md5</TT></TD><TD>2681</TD><TD>2.6 年</TD><TD>2625 年</TD></TR><TR><TD><TT CLASS="LITERAL">crypt-des</TT></TD><TD>362837</TD><TD>7 天</TD><TD>19 年</TD></TR><TR><TD><TT CLASS="LITERAL">sha1</TT></TD><TD>590223</TD><TD>4 天</TD><TD>12 年</TD></TR><TR><TD><TT CLASS="LITERAL">md5</TT></TD><TD>2345086</TD><TD>1 天</TD><TD>3 年</TD></TR></TBODY></TABLE></DIV><P>注意：</P><P></P><UL><LI><P>使用的这个机器是1.5GHz Pentium 4。</P></LI><LI><P><TT CLASS="LITERAL">crypt-des</TT>和<TT CLASS="LITERAL">crypt-md5</TT>计算的数字是从
John the Ripper v1.6.38 <TT CLASS="LITERAL">-test</TT>的输出获得的。</P></LI><LI><P><TT CLASS="LITERAL">md5</TT>数字来自mdcrack 1.2。</P></LI><LI><P><TT CLASS="LITERAL">sha1</TT>数字来自lcrack-20031130-beta。</P></LI><LI><P><TT CLASS="LITERAL">crypt-bf</TT>数字使用一个简单的程序获得，这个程序重复超过1000次8字符口令。
这样可以显示速度和不同数字的迭代。例如：<TT CLASS="LITERAL">john -test</TT>显示了
<TT CLASS="LITERAL">crypt-bf/5</TT>的213次循环/秒。（结果中非常小的不同与事实一致，
<TT CLASS="FILENAME">pgcrypto</TT>中的<TT CLASS="LITERAL">crypt-bf</TT>实现和John the Ripper中使用的是同一个。）</P></LI></UL><P>请注意，<SPAN CLASS="QUOTE">"尝试所有组合"</SPAN>是不现实的。不寻常的密码破解在字典的帮助下完成，
包含普通的单词和它们的各种转变。所以，即使有点类似单词的密码可能比上述建议的数字破解的更快，
而一个6字符不像单词的密码可能避开破解。或者不能。</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN148317">F.25.3. PGP 加密功能</A></H2><P>该功能实现了部分OpenPGP (RFC 4880)标准的加密。支持对称秘钥和公共秘钥的加密。</P><P>一条加密的PGP消息包含2个部分，或<I CLASS="FIRSTTERM">数据包</I>：</P><P></P><UL><LI><P>数据包包含一个会话秘钥&mdash;加密了的对称秘钥或者是公共秘钥。</P></LI><LI><P>数据包包含带有会话秘钥的加密数据。</P></LI></UL><P>当带有对称秘钥（如一个口令）加密时：</P><P></P><OL TYPE="1"><LI><P>给定的口令使用String2Key (S2K)算法散列。这和<CODE CLASS="FUNCTION">crypt()</CODE>算法很相似&mdash;
自觉地变慢并且带有随机salt&mdash;但是它产生一个全长的二进制秘钥。</P></LI><LI><P>如果需要一个单独的会话秘钥，将会产生一个新的随机秘钥。否则将直接使用S2K秘钥作为会话秘钥。</P></LI><LI><P>如果直接使用S2K秘钥，那么只有S2K设置将被放入到会话秘钥包。
否则会话秘钥将用S2K秘钥加密然后放入会话秘钥包。</P></LI></OL><P>当使用公共秘钥加密时：</P><P></P><OL TYPE="1"><LI><P>将会产生一个新的随机会话秘钥。</P></LI><LI><P>它使用公共密钥加密并放入会话秘钥包中。</P></LI></OL><P>两种情况下数据被加密的处理如下：</P><P></P><OL TYPE="1"><LI><P>可选的数据操作：压缩，转换成UTF-8，和/或行尾的转换。</P></LI><LI><P>数据带有一块随机字节的前缀。这相当于使用一个随机的IV。</P></LI><LI><P>附加上一个随机前缀和数据的SHA1散列。</P></LI><LI><P>所有这些都带有会话秘钥加密，并放入数据包中。</P></LI></OL><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148352">F.25.3.1. <CODE CLASS="FUNCTION">pgp_sym_encrypt()</CODE></A></H3><PRE CLASS="SYNOPSIS">pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea</PRE><P>带有一个对称的PGP秘钥<TT CLASS="PARAMETER">psw</TT>加密<TT CLASS="PARAMETER">data</TT>。
<TT CLASS="PARAMETER">options</TT>参数可以包含选项设置，就像下面描述的那样。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148364">F.25.3.2. <CODE CLASS="FUNCTION">pgp_sym_decrypt()</CODE></A></H3><PRE CLASS="SYNOPSIS">pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea</PRE><P>解密一个对称秘钥加密的PGP信息。</P><P>用<CODE CLASS="FUNCTION">pgp_sym_decrypt</CODE>解密<TT CLASS="TYPE">bytea</TT>数据是不允许的。
这是为了避免输出不合法的字符数据。用<CODE CLASS="FUNCTION">pgp_sym_decrypt_bytea</CODE>
解密原始的文本数据是可以的。</P><P><TT CLASS="PARAMETER">options</TT>参数可以包含选项设置，就像下面描述的那样。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148379">F.25.3.3. <CODE CLASS="FUNCTION">pgp_pub_encrypt()</CODE></A></H3><PRE CLASS="SYNOPSIS">pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea</PRE><P>用一个公共的PGP秘钥<TT CLASS="PARAMETER">key</TT>加密<TT CLASS="PARAMETER">data</TT>。
给这个函数一个秘密秘钥将产生一个错误。</P><P><TT CLASS="PARAMETER">options</TT>参数可以包含选项设置，就像下面描述的那样。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148392">F.25.3.4. <CODE CLASS="FUNCTION">pgp_pub_decrypt()</CODE></A></H3><PRE CLASS="SYNOPSIS">pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea</PRE><P>解密一个公共密钥加密的信息。<TT CLASS="PARAMETER">key</TT>必须是与用来加密的公共秘钥对应的秘密秘钥。
如果该秘密秘钥是密码保护的，你必须在<TT CLASS="PARAMETER">psw</TT>中给出密码。
如果没有密码，但是你希望指定选项，你需要给出一个空的密码。</P><P>用<CODE CLASS="FUNCTION">pgp_pub_decrypt</CODE>解密<TT CLASS="TYPE">bytea</TT>数据是不允许的。
这是为了避免输出不合法的字符数据。用<CODE CLASS="FUNCTION">pgp_pub_decrypt_bytea</CODE>
解密原始的文本数据是可以的。</P><P><TT CLASS="PARAMETER">options</TT>参数可以包含选项设置，就像下面描述的那样。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148409">F.25.3.5. <CODE CLASS="FUNCTION">pgp_key_id()</CODE></A></H3><PRE CLASS="SYNOPSIS">pgp_key_id(bytea) returns text</PRE><P><CODE CLASS="FUNCTION">pgp_key_id</CODE>摘取一个PGP公共或秘密秘钥的秘钥 ID。
或如果给出一个加密的信息，它给出用于加密数据的秘钥 ID。</P><P>它可以返回两个特殊的秘钥 ID：</P><P></P><UL><LI><P> <TT CLASS="LITERAL">SYMKEY</TT>
</P><P>该信息是用对称秘钥加密的。</P></LI><LI><P> <TT CLASS="LITERAL">ANYKEY</TT>
</P><P>该信息是公共秘钥加密的，但是秘钥ID已经删除了。这意味着你将要尝试所有你的秘密秘钥，
看看哪个能解密它。<TT CLASS="FILENAME">pgcrypto</TT>本身并不产生这样的信息。</P></LI></UL><P>请注意，不同的秘钥可能有相同的ID。这是稀少的，但是是一个普通事件。
然后客户端应用应该尝试解密每一个，看看哪个合适&mdash;类似处理<TT CLASS="LITERAL">ANYKEY</TT>。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148430">F.25.3.6. <CODE CLASS="FUNCTION">armor()</CODE>, <CODE CLASS="FUNCTION">dearmor()</CODE></A></H3><PRE CLASS="SYNOPSIS">armor(data bytea) returns text
dearmor(data text) returns bytea</PRE><P>这些功能打包/解包二进制数据到PGP ASCII-armor格式，
这些基本上是带有CRC的Base64和额外的格式。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148440">F.25.3.7. PGP功能的选项</A></H3><P>选项的命名类似于GnuPG。选项的值应该在等号后面给出；选项之间用逗号隔开。例如：
</P><PRE CLASS="PROGRAMLISTING">pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')</PRE><P></P><P>除了<TT CLASS="LITERAL">convert-crlf</TT>之外的所有选项只应用到加密函数。
解密函数从PGP数据中获得参数。</P><P>最有趣的选项可能就是<TT CLASS="LITERAL">compress-algo</TT>和<TT CLASS="LITERAL">unicode-mode</TT>了。
其余的应该有合理的默认值。</P><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148449">F.25.3.7.1. cipher-algo</A></H4><P>要使用的密码算法。</P><P CLASS="LITERALLAYOUT">值:&nbsp;bf,&nbsp;aes128,&nbsp;aes192,&nbsp;aes256&nbsp;(OpenSSL-only:&nbsp;<TT CLASS="LITERAL">3des</TT>,&nbsp;<TT CLASS="LITERAL">cast5</TT>)<br>
缺省:&nbsp;aes128<br>
适用于:&nbsp;pgp_sym_encrypt,&nbsp;pgp_pub_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148455">F.25.3.7.2. compress-algo</A></H4><P>要使用的压缩算法。只有<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>带有zlib建立时可以使用。</P><P CLASS="LITERALLAYOUT">值:<br>
&nbsp;&nbsp;0&nbsp;-&nbsp;没有压缩<br>
&nbsp;&nbsp;1&nbsp;-&nbsp;ZIP&nbsp;压缩<br>
&nbsp;&nbsp;2&nbsp;-&nbsp;ZLIB&nbsp;压缩&nbsp;(=&nbsp;ZIP&nbsp;加上元数据和块&nbsp;CRCs)<br>
缺省:&nbsp;0<br>
适用于:&nbsp;pgp_sym_encrypt,&nbsp;pgp_pub_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148460">F.25.3.7.3. 压缩级别</A></H4><P>压缩多少。较高层次压缩较小但是较慢。0表示禁用压缩。</P><P CLASS="LITERALLAYOUT">值:&nbsp;0,&nbsp;1-9<br>
缺省:&nbsp;6<br>
适用于:&nbsp;pgp_sym_encrypt,&nbsp;pgp_pub_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148464">F.25.3.7.4. 转换 crlf</A></H4><P>在加密时是否将<TT CLASS="LITERAL">\n</TT>转换为<TT CLASS="LITERAL">\r\n</TT>和在解密时是否将
<TT CLASS="LITERAL">\r\n</TT>转换为<TT CLASS="LITERAL">\n</TT>。RFC 4880指定文本数据应该使用
<TT CLASS="LITERAL">\r\n</TT>换行存储。使用这个获得全部的RFC兼容性能。</P><P CLASS="LITERALLAYOUT">值:&nbsp;0,&nbsp;1<br>
缺省:&nbsp;0<br>
适用于:&nbsp;pgp_sym_encrypt,&nbsp;pgp_pub_encrypt,&nbsp;pgp_sym_decrypt,&nbsp;pgp_pub_decrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148473">F.25.3.7.5. 禁用 mdc</A></H4><P>不要用SHA-1保护数据。唯一使用这个选项的理由是为了实现与古老的PGP产品的兼容，
该产品早于SHA-1受保护的包添加到RFC 4880。最近的gnupg.org和pgp.com软件也很好的支持它。</P><P CLASS="LITERALLAYOUT">值:&nbsp;0,&nbsp;1<br>
缺省:&nbsp;0<br>
适用于:&nbsp;pgp_sym_encrypt,&nbsp;pgp_pub_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148477">F.25.3.7.6. 启用会话秘钥</A></H4><P>使用单独的会话秘钥。公共秘钥加密总是使用一个单独的会话秘钥；这是为了对称秘钥加密，
这在默认情况下是直接使用S2K秘钥的。</P><P CLASS="LITERALLAYOUT">值:&nbsp;0,&nbsp;1<br>
缺省:&nbsp;0<br>
适用于:&nbsp;pgp_sym_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148481">F.25.3.7.7. s2k 模式</A></H4><P>使用S2K算法。</P><P CLASS="LITERALLAYOUT">值:<br>
&nbsp;&nbsp;0&nbsp;-&nbsp;没有salt。&nbsp;危险的!<br>
&nbsp;&nbsp;1&nbsp;-&nbsp;有salt但是带有固定的重复计数。<br>
&nbsp;&nbsp;3&nbsp;-&nbsp;变量重复计数。<br>
缺省:&nbsp;3<br>
适用于:&nbsp;pgp_sym_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148485">F.25.3.7.8. s2k 摘要算法</A></H4><P>在S2K计算中使用哪个摘要算法。</P><P CLASS="LITERALLAYOUT">值:&nbsp;md5,&nbsp;sha1<br>
缺省:&nbsp;sha1<br>
适用于:&nbsp;pgp_sym_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148489">F.25.3.7.9. s2k 密码算法</A></H4><P>加密单独的会话秘钥使用哪个密码。</P><P CLASS="LITERALLAYOUT">值:&nbsp;bf,&nbsp;aes,&nbsp;aes128,&nbsp;aes192,&nbsp;aes256<br>
缺省:&nbsp;use&nbsp;cipher-algo<br>
适用于:&nbsp;pgp_sym_encrypt</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="AEN148493">F.25.3.7.10. unicode 模式</A></H4><P>是否要转换文本数据从数据库内部编码到UTF-8及以前。如果你的数据库已经是UTF-8，
将不需要转换，但是消息将被标记为UTF-8。没有这个选项将不会这样。</P><P CLASS="LITERALLAYOUT">值:&nbsp;0,&nbsp;1<br>
缺省:&nbsp;0<br>
适用于:&nbsp;pgp_sym_encrypt,&nbsp;pgp_pub_encrypt</P></DIV></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148497">F.25.3.8. 用 GnuPG 产生 PGP 秘钥</A></H3><P>
要生成一个新的秘钥：
</P><PRE CLASS="PROGRAMLISTING">gpg --gen-key</PRE><P>
</P><P>首选的秘钥类型是<SPAN CLASS="QUOTE">"DSA and Elgamal"</SPAN>。</P><P>对于RSA加密，你必须创建DSA或RSA唯一签署秘钥作为主秘钥，然后用
<TT CLASS="LITERAL">gpg --edit-key</TT>添加一个RSA加密子秘钥。</P><P>
要列出秘钥：
</P><PRE CLASS="PROGRAMLISTING">gpg --list-secret-keys</PRE><P>
</P><P>
以ASCII-armor格式导出一个公共秘钥：
</P><PRE CLASS="PROGRAMLISTING">gpg -a --export KEYID &#62; public.key</PRE><P>
</P><P>
以ASCII-armor格式导出一个秘密秘钥：
</P><PRE CLASS="PROGRAMLISTING">gpg -a --export-secret-keys KEYID &#62; secret.key</PRE><P>
</P><P>在将它们送给PGP函数之前需要在这些秘钥上使用<CODE CLASS="FUNCTION">dearmor()</CODE>。
或者如果你可以处理二进制数据，你可以从命令行中删除<TT CLASS="LITERAL">-a</TT>。</P><P>要获取更多详细信息，请参阅<TT CLASS="LITERAL">man gpg</TT>，
<A HREF="http://www.gnupg.org/gph/en/manual.html" TARGET="_top">The GNU
Privacy Handbook</A>和其他<A HREF="http://www.gnupg.org" TARGET="_top">http://www.gnupg.org</A>上的文档。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148518">F.25.3.9. PGP 代码的限制</A></H3><P></P><UL><LI><P>不支持签名。这也意味着不检查加密子秘钥是否属于主秘钥。</P></LI><LI><P>不支持加密秘钥作为主秘钥。因为通常不建议这样的做法，这应该不是一个问题。</P></LI><LI><P>不支持几个子秘钥。这可能看起来像是一个问题，因为这是习惯的做法。另一方面，
不应该使用带有<TT CLASS="FILENAME">pgcrypto</TT>的定期GPG/PGP秘钥，而是创建一个新的秘钥，
因为使用场景相当不同。</P></LI></UL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN148528">F.25.4. 行加密功能</A></H2><P>这些功能在数据上只运行一个密码；它们没有任何比PGP加密更先进的特性。
因此它们有一些主要的问题：</P><P></P><OL TYPE="1"><LI><P>它们使用用户秘钥直接作为加密秘钥。</P></LI><LI><P>它们不提供任何完整性检查，来看看加密的数据是否被修改了。</P></LI><LI><P>它们希望用户自己管理所有加密参数，即使是IV。</P></LI><LI><P>它们不处理文本。</P></LI></OL><P>所以，随着PGP加密的引入，不建议使用行加密功能了。</P><PRE CLASS="SYNOPSIS">encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea

encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea</PRE><P>
加密/解密数据使用<TT CLASS="PARAMETER">type</TT>指定的加密方法。
<TT CLASS="PARAMETER">type</TT>字符串的语法是：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>algorithm</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="LITERAL"
>-</TT
> <TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
> </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="LITERAL"
>/pad:</TT
> <TT
CLASS="REPLACEABLE"
><I
>padding</I
></TT
> </SPAN
>]</PRE><P>
而<TT CLASS="REPLACEABLE"><I>algorithm</I></TT>是下列之一：
<P></P></P><UL><LI><P><TT CLASS="LITERAL">bf</TT> &mdash; Blowfish</P></LI><LI><P><TT CLASS="LITERAL">aes</TT> &mdash; AES (Rijndael-128)</P></LI></UL><P>
<TT CLASS="REPLACEABLE"><I>mode</I></TT>是下列之一：
<P></P></P><UL><LI><P><TT CLASS="LITERAL">cbc</TT> &mdash; 下一个块取决于前一个块（缺省）</P></LI><LI><P><TT CLASS="LITERAL">ecb</TT> &mdash; 每个块单独加密（只为了测试）</P></LI></UL><P>
<TT CLASS="REPLACEABLE"><I>padding</I></TT>是下列之一：
<P></P></P><UL><LI><P><TT CLASS="LITERAL">pkcs</TT> &mdash; 数据可以是任意长度（缺省）</P></LI><LI><P><TT CLASS="LITERAL">none</TT> &mdash; 数据必须是加密块尺寸的几倍</P></LI></UL><P>
</P><P>
所以，例如，这些是相等的：
</P><PRE CLASS="PROGRAMLISTING">encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')</PRE><P>
</P><P>在<CODE CLASS="FUNCTION">encrypt_iv</CODE>和<CODE CLASS="FUNCTION">decrypt_iv</CODE>中，<TT CLASS="PARAMETER">iv</TT>
参数是CBC模式的初始值；在ECB中忽略。如果不正好是块的大小则截断或用0补齐。
在没有这个参数的函数里缺省全部为0。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN148591">F.25.5. 随机数据函数</A></H2><PRE CLASS="SYNOPSIS">gen_random_bytes(count integer) returns bytea</PRE><P>密码强随机字节的返回<TT CLASS="PARAMETER">count</TT>。一次最多可以提取1024个字节。
这是为了避免排干随机发生器池。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN148598">F.25.6. 注意</A></H2><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148600">F.25.6.1. 配置</A></H3><P><TT CLASS="FILENAME">pgcrypto</TT>根据主PostgreSQL <TT CLASS="LITERAL">configure</TT>脚本的调查结果配置它本身。
影响它的选项是<TT CLASS="LITERAL">--with-zlib</TT>和<TT CLASS="LITERAL">--with-openssl</TT>。</P><P>当用zlib编译时，PGP加密函数可以在加密之前压缩数据。</P><P>当用OpenSSL编译时，有更多算法可用。公共秘钥加密函数也会更快，
因为OpenSSL有更多优化了的BIGNUM函数。</P><DIV CLASS="TABLE"><A NAME="PGCRYPTO-WITH-WITHOUT-OPENSSL"></A><P><B>&#34920; F-18. 带有和不带有 OpenSSL 的功能性总结</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>功能性</TH><TH>内建</TH><TH>带有 OpenSSL</TH></TR></THEAD><TBODY><TR><TD>MD5</TD><TD>yes</TD><TD>yes</TD></TR><TR><TD>SHA1</TD><TD>yes</TD><TD>yes</TD></TR><TR><TD>SHA224/256/384/512</TD><TD>yes</TD><TD>yes (注意 1)</TD></TR><TR><TD>其他摘要算法</TD><TD>no</TD><TD>yes (注意 2)</TD></TR><TR><TD>Blowfish</TD><TD>yes</TD><TD>yes</TD></TR><TR><TD>AES</TD><TD>yes</TD><TD>yes (注意 3)</TD></TR><TR><TD>DES/3DES/CAST5</TD><TD>no</TD><TD>yes</TD></TR><TR><TD>行加密</TD><TD>yes</TD><TD>yes</TD></TR><TR><TD>PGP 对称加密</TD><TD>yes</TD><TD>yes</TD></TR><TR><TD>PGP 公共秘钥加密</TD><TD>yes</TD><TD>yes</TD></TR></TBODY></TABLE></DIV><P>注意：</P><P></P><OL TYPE="1"><LI><P>SHA2算法在版本 0.9.8 的时候添加到了OpenSSL。对于更老的版本，
<TT CLASS="FILENAME">pgcrypto</TT>使用内建的代码。</P></LI><LI><P>任何OpenSSL支持的摘要算法是自动获得的。这对于密码来说是不可能的，密码需要明确的支持。</P></LI><LI><P>AES自版本 0.9.7 以来包含在OpenSSL中了。对于更老的版本，
<TT CLASS="FILENAME">pgcrypto</TT>使用内建的代码。</P></LI></OL></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148668">F.25.6.2. NULL 处理</A></H3><P>就像SQL中的标准，如果任一参数是NULL，那么所有函数都返回NULL。
这在粗心的使用中可能会造成安全风险。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148671">F.25.6.3. 安全限制</A></H3><P>所有<TT CLASS="FILENAME">pgcrypto</TT>函数在数据库服务器内部运行。这意味着<TT CLASS="FILENAME">pgcrypto</TT>
和客户端应用之间的所有数据和口令移动都是以明文的形式。因此必须：</P><P></P><OL TYPE="1"><LI><P>本地连接或使用SSL连接。</P></LI><LI><P>同时信任系统和数据库管理员。</P></LI></OL><P>如果你做不到，那么最好在客户端应用内部做crypto。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148682">F.25.6.4. 有用的阅读</A></H3><P></P><UL><LI><P><A HREF="http://www.gnupg.org/gph/en/manual.html" TARGET="_top">http://www.gnupg.org/gph/en/manual.html</A></P><P>GNU 隐私手册。</P></LI><LI><P><A HREF="http://www.openwall.com/crypt/" TARGET="_top">http://www.openwall.com/crypt/</A></P><P>crypt-blowfish算法描述。</P></LI><LI><P> <A HREF="http://www.stack.nl/~galactus/remailers/passphrase-faq.html" TARGET="_top">http://www.stack.nl/~galactus/remailers/passphrase-faq.html</A>
</P><P>如何选择一个好的密码。</P></LI><LI><P><A HREF="http://world.std.com/~reinhold/diceware.html" TARGET="_top">http://world.std.com/~reinhold/diceware.html</A></P><P>选择密码的有趣想法。</P></LI><LI><P> <A HREF="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html" TARGET="_top">http://www.interhack.net/people/cmcurtin/snake-oil-faq.html</A>
</P><P>描述密码学的优劣。</P></LI></UL></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN148705">F.25.6.5. 技术参考文献</A></H3><P></P><UL><LI><P><A HREF="http://www.ietf.org/rfc/rfc4880.txt" TARGET="_top">http://www.ietf.org/rfc/rfc4880.txt</A></P><P>OpenPGP 消息格式。</P></LI><LI><P><A HREF="http://www.ietf.org/rfc/rfc1321.txt" TARGET="_top">http://www.ietf.org/rfc/rfc1321.txt</A></P><P>MD5 消息摘要算法。</P></LI><LI><P><A HREF="http://www.ietf.org/rfc/rfc2104.txt" TARGET="_top">http://www.ietf.org/rfc/rfc2104.txt</A></P><P>HMAC:散列的消息认证。</P></LI><LI><P> <A HREF="http://www.usenix.org/events/usenix99/provos.html" TARGET="_top">http://www.usenix.org/events/usenix99/provos.html</A>
</P><P>crypt-des、crypt-md5和bcrypt算法的比较。</P></LI><LI><P><A HREF="http://csrc.nist.gov/cryptval/des.htm" TARGET="_top">http://csrc.nist.gov/cryptval/des.htm</A></P><P>DES、3DES和AES标准。</P></LI><LI><P> <A HREF="http://en.wikipedia.org/wiki/Fortuna_(PRNG)" TARGET="_top">http://en.wikipedia.org/wiki/Fortuna_(PRNG)</A>
</P><P>Fortuna CSPRNG的描述。</P></LI><LI><P><A HREF="http://jlcooke.ca/random/" TARGET="_top">http://jlcooke.ca/random/</A></P><P>基于Jean-Luc Cooke Fortuna的Linux <TT CLASS="FILENAME">/dev/random</TT>驱动器。</P></LI><LI><P><A HREF="http://research.cyber.ee/~lipmaa/crypto/" TARGET="_top">http://research.cyber.ee/~lipmaa/crypto/</A></P><P>密码学指针集合。</P></LI></UL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN148741">F.25.7. 作者</A></H2><P> Marko Kreen <CODE CLASS="EMAIL">&#60;<A HREF="mailto:markokr@gmail.com">markokr@gmail.com</A>&#62;</CODE>
</P><P><TT CLASS="FILENAME">pgcrypto</TT>使用来自下列源码的代码：</P><DIV CLASS="INFORMALTABLE"><P></P><A NAME="AEN148747"></A><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>算法</TH><TH>作者</TH><TH>起源</TH></TR></THEAD><TBODY><TR><TD>DES 加密</TD><TD>David Burren 和其他人</TD><TD>FreeBSD libcrypt</TD></TR><TR><TD>MD5 加密</TD><TD>Poul-Henning Kamp</TD><TD>FreeBSD libcrypt</TD></TR><TR><TD>Blowfish 加密</TD><TD>Solar Designer</TD><TD>www.openwall.com</TD></TR><TR><TD>Blowfish 密码</TD><TD>Simon Tatham</TD><TD>PuTTY</TD></TR><TR><TD>Rijndael 密码</TD><TD>Brian Gladman</TD><TD>OpenBSD sys/crypto</TD></TR><TR><TD>MD5 和 SHA1</TD><TD>WIDE Project</TD><TD>KAME kame/sys/crypto</TD></TR><TR><TD>SHA256/384/512 </TD><TD>Aaron D. Gifford</TD><TD>OpenBSD sys/crypto</TD></TR><TR><TD>BIGNUM math</TD><TD>Michael J. Fromberger</TD><TD>dartmouth.edu/~sting/sw/imath</TD></TR></TBODY></TABLE><P></P></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="pgbuffercache.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="pgfreespacemap.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">pg_buffercache</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">pg_freespacemap</TD></TR></TABLE></DIV></BODY></HTML>
