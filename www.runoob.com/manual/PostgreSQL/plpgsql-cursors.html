<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>游标</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PL/pgSQL - SQL过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html"><LINK REL="PREVIOUS" TITLE="控制结构" HREF="plpgsql-control-structures.html"><LINK REL="NEXT" TITLE="错误和消息" HREF="plpgsql-errors-and-messages.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/plpgsql.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="控制结构" HREF="plpgsql-control-structures.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 40. <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN> - <ACRONYM CLASS="ACRONYM">SQL</ACRONYM>过程语言</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="错误和消息" HREF="plpgsql-errors-and-messages.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PLPGSQL-CURSORS">40.7. 游标</A></H1><P> 如果不想一次执行整个命令，可以设置一个封装该命令的游标（<I CLASS="FIRSTTERM">cursor</I>），
然后每次读取几行命令结果。这么干的一个原因是在结果包含数量非常大的行时避免内存耗尽。
不过<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>用户不必担心这个，因为<TT CLASS="LITERAL">FOR</TT>
循环自动在内部使用一个游标以避免内存问题。
一个更有趣的用法是某个函数可以返回一个它创建的游标的引用，这样就允许调用者读取各行。
从而提供了一种从函数返回一个结果集的手段。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-CURSOR-DECLARATIONS">40.7.1. 声明游标变量</A></H2><P>
所有在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>里对游标的访问都是通过游标变量实现的，
它总是特殊的数据类型<TT CLASS="TYPE">refcursor</TT>。
创建游标变量的一个方法是把它声明为一个类型为<TT CLASS="TYPE">refcursor</TT>的变量。
另外一个方法是使用游标声明语法，像下面这样：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> [<SPAN
CLASS="OPTIONAL"
> NO </SPAN
>] SCROLL </SPAN
>] CURSOR [<SPAN
CLASS="OPTIONAL"
> ( <TT
CLASS="REPLACEABLE"
><I
>arguments</I
></TT
> ) </SPAN
>] FOR <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>;</PRE><P>
(<SPAN CLASS="PRODUCTNAME">Oracle</SPAN>兼容中<TT CLASS="LITERAL">FOR</TT>可以用<TT CLASS="LITERAL">IS</TT>代替)。
如果定义了<TT CLASS="LITERAL">SCROLL</TT>，则游标可以向后回滚；如果定义了<TT CLASS="LITERAL">NO SCROLL</TT>，
则向后抓取的动作被拒绝；如果二者都没有定义，
那么是否进行向后取的动作会根据查询来判断。
如果有<TT CLASS="REPLACEABLE"><I>arguments</I></TT>，
那么它是一个逗号分隔<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>name</I></TT><TT CLASS="REPLACEABLE"><I>datatype</I></TT></TT>列表，
这个列表定义由已给查询中的参数值来替代的name。
实际用于代换这些名字的数值将在游标打开之后声明。
</P><P>
例如：
</P><PRE CLASS="PROGRAMLISTING">DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;</PRE><P>
所有这三个变量都是<TT CLASS="TYPE">refcursor</TT>类型，但是第一个可以用于任何命令，
而第二个已经绑定（<I CLASS="FIRSTTERM">bound</I>）了一个声明完整的命令，最后一个是绑定了一个带参数的命令。
<TT CLASS="LITERAL">key</TT>将在游标打开的时候被代换成一个整数。
变量<TT CLASS="LITERAL">curs1</TT>可以称之为<I CLASS="FIRSTTERM">未绑定</I>的，
因为它没有和任何查询相绑定。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-CURSOR-OPENING">40.7.2. 打开游标</A></H2><P> 在你使用游标检索行之前，你必需先<I CLASS="FIRSTTERM">打开</I>它。
这是和SQL命令<TT CLASS="COMMAND">DECLARE CURSOR</TT>相等的操作。
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>有三种形式的<TT CLASS="COMMAND">OPEN</TT>语句，
两种用于未绑定的游标变量，
另外一种用于已绑定的游标变量。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 可以通过<A HREF="plpgsql-cursors.html#PLPGSQL-CURSOR-FOR-LOOP">第 40.7.4 &#33410;</A>中描述的<TT CLASS="COMMAND">FOR</TT>语句，
在不用打开游标的情况下使用已绑定的游标。</P></BLOCKQUOTE></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN58613">40.7.2.1. <TT CLASS="COMMAND">OPEN FOR</TT> <TT CLASS="REPLACEABLE"><I>query</I></TT></A></H3><PRE CLASS="SYNOPSIS">OPEN <TT
CLASS="REPLACEABLE"
><I
>unbound_cursorvar</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> [<SPAN
CLASS="OPTIONAL"
> NO </SPAN
>] SCROLL </SPAN
>] FOR <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>;</PRE><P> 该游标变量打开并且执行给出的查询。游标不能是已经打开的，
并且它必需是声明为一个未绑定的游标(也就是声明为一个简单的<TT CLASS="TYPE">refcursor</TT>变量)。
查询必须是一条<TT CLASS="COMMAND">SELECT</TT>或者其它返回行的东西(比如<TT CLASS="COMMAND">EXPLAIN</TT>)。
查询是和其它在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>里的SQL命令平等对待的：先代换<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>的变量名，
而且执行计划为将来可能的复用缓存起来。
当一个<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量被替换到游标查询中时，
被替换的值是在<TT CLASS="COMMAND">OPEN</TT>时它所具有的值。
后续的改变不会影响游标的动作，对于一个已经绑定的游标来说，
<TT CLASS="LITERAL">SCROLL</TT>和<TT CLASS="LITERAL">NO SCROLL</TT>这两个选项具有相同的含义。</P><P>
一个例子：
</P><PRE CLASS="PROGRAMLISTING">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN58634">40.7.2.2. <TT CLASS="COMMAND">OPEN FOR EXECUTE</TT></A></H3><PRE CLASS="SYNOPSIS">OPEN <TT
CLASS="REPLACEABLE"
><I
>unbound_cursorvar</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> [<SPAN
CLASS="OPTIONAL"
> NO </SPAN
>] SCROLL </SPAN
>] FOR EXECUTE <TT
CLASS="REPLACEABLE"
><I
>query_string</I
></TT
>
                                     [<SPAN
CLASS="OPTIONAL"
> USING <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ... </SPAN
>] </SPAN
>];</PRE><P>
打开游标变量并且执行给出的查询。游标不能是已打开的，
并且必须声明为一个未绑定的游标(也就是一个简单的<TT CLASS="TYPE">refcursor</TT>变量)。
命令是用和那些用于<TT CLASS="COMMAND">EXECUTE</TT>命令一样的方法声明的字符串表达式，
这样，就有了命令可以在两次运行间发生变化的灵活性。
参阅<A HREF="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING">第 40.10.2 &#33410;</A>）这也意味着在命令字符串上不能进行变量替换。
跟<TT CLASS="COMMAND">EXECUTE</TT>一起，通过使用<TT CLASS="LITERAL">USING</TT>，参数值可以被插入到动态命令中。
对于一个已经绑定的游标来说，<TT CLASS="LITERAL">SCROLL</TT>和<TT CLASS="LITERAL">NO SCROLL</TT>这两个选项具有相同的含义。&#13;</P><P>
一个例子：
</P><PRE CLASS="PROGRAMLISTING">OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident(tabname)
                                        || ' WHERE col1 = $1' USING keyvalue;</PRE><P>
在这个例子中，表名被插入到文本查询中，
因此使用<CODE CLASS="FUNCTION">quote_ident()</CODE>时要注意SQL注入。
通过<TT CLASS="LITERAL">USING</TT>参数对插入的<TT CLASS="LITERAL">col1</TT>进行比较值，因此不需要使用引号。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="PLPGSQL-OPEN-BOUND-CURSOR">40.7.2.3. 打开一个绑定的游标</A></H3><PRE CLASS="SYNOPSIS">OPEN <TT
CLASS="REPLACEABLE"
><I
>bound_cursorvar</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> ( [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>argument_name</I
></TT
> := </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>argument_value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>] ) </SPAN
>];</PRE><P> 这种形式的<TT CLASS="COMMAND">OPEN</TT>用于打开一个游标变量，
该游标变量的命令是在声明的时候和它绑定在一起的。游标不能是已经打开的。
当且仅当该游标声明为接受参数的时候，语句中才必需出现一个实际参数值表达式的列表。
这些值将代换到命令中。</P><P> 一个绑定的游标的命令计划总是认为可缓冲的，这种情况下没有等效的<TT CLASS="COMMAND">EXECUTE</TT>。
需要注意的是<TT CLASS="LITERAL">SCROLL</TT>和<TT CLASS="LITERAL">NO SCROLL</TT>不能在<TT CLASS="COMMAND">OPEN</TT>中被声明，
因为游标的滚动动作已经被定义了。 </P><P> 参数值可以使用<I CLASS="FIRSTTERM">positional</I>或者<I CLASS="FIRSTTERM">named</I>符号传递。
在位置符号中，所有的参数以顺序指定。
在命名法中，每个参数的名称使用<TT CLASS="LITERAL">:=</TT>声明以
从参数表达式中分开。类似于调用函数，在<A HREF="sql-syntax-calling-funcs.html">第 4.3 &#33410;</A>中描述，
它也允许混合位置和命名法。</P><P>
例子（以上使用游标声明的例子）:
</P><PRE CLASS="PROGRAMLISTING">OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);</PRE><P>
</P><P>
因为在绑定游标查询上做了变量替换，有两种方法将值传递到游标：要么
使用明确参数到<TT CLASS="COMMAND">OPEN</TT>，或者隐式地在查询中引用<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量。
然而，只有在绑定游标之前声明的变量将取代它。在这两种情况下
可以在<TT CLASS="COMMAND">OPEN</TT>时决定将被传递的值。例如，另一种方式来获得相同的效果
如<TT CLASS="LITERAL">curs3</TT>上面的例子
</P><PRE CLASS="PROGRAMLISTING">DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;</PRE><P>
</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-CURSOR-USING">40.7.3. 使用游标</A></H2><P> 一旦你已经打开了一个游标，那么你就可以用这里描述的语句操作它。</P><P> 这些操作不需要发生在和打开该游标开始操作的同一个函数里。
你可以从函数里返回一个<TT CLASS="TYPE">refcursor</TT>值，然后让调用者操作该游标。
在内部，<TT CLASS="TYPE">refcursor</TT>值只是一个包含该游标命令的活跃查询的信使的字符串名。
这个名字可以传来传去，可以赋予其它<TT CLASS="TYPE">refcursor</TT>变量等等，也不用担心扰乱信使。</P><P> 所有信使在事务的结尾都会隐含地关闭。
因此一个<TT CLASS="TYPE">refcursor</TT>值只能在该事务结束前用于引用一个打开的游标。</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN58696">40.7.3.1. <TT CLASS="LITERAL">FETCH</TT></A></H3><PRE CLASS="SYNOPSIS">FETCH [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>direction</I
></TT
> { FROM | IN } </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>cursor</I
></TT
> INTO <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>;</PRE><P> <TT CLASS="COMMAND">FETCH</TT>从游标中检索下一行到目标中，
目标可以是一个行变量、记录变量、逗号分隔的普通变量列表，
就像<TT CLASS="COMMAND">SELECT INTO</TT>一样，
如果下一行中没有，目标会设为NULL。如同<TT CLASS="COMMAND">SELECT INTO</TT>，
可以使用特殊变量<TT CLASS="LITERAL">FOUND</TT>来检查是否检索出一个行。</P><P> <TT CLASS="REPLACEABLE"><I>direction</I></TT>子句可以是任何
一个SQL <A HREF="sql-fetch.html">FETCH</A>命令允许的变量，
除了那些可以抓取不止一行的；形如：<TT CLASS="LITERAL">NEXT</TT>,
<TT CLASS="LITERAL">PRIOR</TT>，<TT CLASS="LITERAL">FIRST</TT>，<TT CLASS="LITERAL">LAST</TT>，
<TT CLASS="LITERAL">ABSOLUTE</TT> <TT CLASS="REPLACEABLE"><I>count</I></TT>，
<TT CLASS="LITERAL">RELATIVE</TT> <TT CLASS="REPLACEABLE"><I>count</I></TT>，
<TT CLASS="LITERAL">FORWARD</TT>或者<TT CLASS="LITERAL">BACKWARD</TT>。
忽略<TT CLASS="REPLACEABLE"><I>direction</I></TT>作为声明的<TT CLASS="LITERAL">NEXT</TT>是相同的。
<TT CLASS="REPLACEABLE"><I>direction</I></TT>值需要往后移动可能会失败，除非声明的或者打开的
游标带有<TT CLASS="LITERAL">SCROLL</TT>选项。
</P><P> <TT CLASS="REPLACEABLE"><I>cursor</I></TT>必须是一个指向一个
打开的游标的<TT CLASS="TYPE">refcursor</TT>变量的名字。</P><P>
一个例子：
</P><PRE CLASS="PROGRAMLISTING">FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN58731">40.7.3.2. <TT CLASS="LITERAL">MOVE</TT></A></H3><PRE CLASS="SYNOPSIS">MOVE [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>direction</I
></TT
> { FROM | IN } </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>cursor</I
></TT
>;</PRE><P> <TT CLASS="COMMAND">MOVE</TT>重新定位一个游标，而不需要检索任何数据。
<TT CLASS="COMMAND">MOVE</TT>的工作方式与<TT CLASS="COMMAND">FETCH</TT>及其相似，
除了它只是重新定位游标并且不返回至移动到的行。
在进行<TT CLASS="COMMAND">SELECT INTO</TT>命令时，
声明的<TT CLASS="LITERAL">FOUND</TT>变量可以用来检查下一个需要移动到的行是否存在。</P><P> <TT CLASS="REPLACEABLE"><I>direction</I></TT>可以是任何一个SQL <A HREF="sql-fetch.html">FETCH</A>
命令允许的变量，如下<TT CLASS="LITERAL">NEXT</TT>,
<TT CLASS="LITERAL">PRIOR</TT>，
<TT CLASS="LITERAL">FIRST</TT>，
<TT CLASS="LITERAL">LAST</TT>，
<TT CLASS="LITERAL">ABSOLUTE</TT> <TT CLASS="REPLACEABLE"><I>count</I></TT>,
<TT CLASS="LITERAL">RELATIVE</TT> <TT CLASS="REPLACEABLE"><I>count</I></TT>,
<TT CLASS="LITERAL">ALL</TT>，
<TT CLASS="LITERAL">FORWARD</TT> [<SPAN CLASS="OPTIONAL"> <TT CLASS="REPLACEABLE"><I>count</I></TT> | <TT CLASS="LITERAL">ALL</TT> </SPAN>]
或者<TT CLASS="LITERAL">BACKWARD</TT> [<SPAN CLASS="OPTIONAL"> <TT CLASS="REPLACEABLE"><I>count</I></TT> | <TT CLASS="LITERAL">ALL</TT> </SPAN>]。
忽略<TT CLASS="REPLACEABLE"><I>direction</I></TT>作为声明的<TT CLASS="LITERAL">NEXT</TT>是相同的。
<TT CLASS="REPLACEABLE"><I>direction</I></TT>值需要往后移动可能会失败，除非声明的或者打开的
游标带有<TT CLASS="LITERAL">SCROLL</TT>选项。</P><P>
例如：
</P><PRE CLASS="PROGRAMLISTING">MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN58770">40.7.3.3. <TT CLASS="LITERAL">UPDATE/DELETE WHERE CURRENT OF</TT></A></H3><PRE CLASS="SYNOPSIS">UPDATE <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
> SET ... WHERE CURRENT OF <TT
CLASS="REPLACEABLE"
><I
>cursor</I
></TT
>;
DELETE FROM <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
> WHERE CURRENT OF <TT
CLASS="REPLACEABLE"
><I
>cursor</I
></TT
>;</PRE><P> 当一个游标被定位到一个表的行上，那么通过使用该游标来识别该行，
从而进行更新或删除操作。当然，对于如何定义游标查询（特别是没有分组时）是存在一定限制的；
在游标中使用<TT CLASS="LITERAL">FOR UPDATE</TT>是个不错的主意。更多信息可参阅<A HREF="sql-declare.html">DECLARE</A>。</P><P>
例如：
</P><PRE CLASS="PROGRAMLISTING">UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN58783">40.7.3.4. <TT CLASS="LITERAL">CLOSE</TT></A></H3><PRE CLASS="SYNOPSIS">CLOSE <TT
CLASS="REPLACEABLE"
><I
>cursor</I
></TT
>;</PRE><P> <TT CLASS="COMMAND">CLOSE</TT>关闭支撑在一个打开的游标下面的信使。
这样就可以在事务结束之前释放资源，
或者释放掉该游标变量，用于稍后再次打开。</P><P>
例如：
</P><PRE CLASS="PROGRAMLISTING">CLOSE curs1;</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN58792">40.7.3.5. 返回游标</A></H3><P> <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数可以向调用者返回游标这个功能用于从函数里返回多行或多列，
特别是巨大的结果集。要想这么做，该函数必须打开游标并且把该游标的名字返回给调用者，
或者简单的使用指定的入口名或调用者已知的名字打开游标。
调用者然后从游标里抓取行。游标可以由调用者关闭，或者是在事务结束的时候自动关闭。</P><P> 函数返回的游标名可以由调用者声明或者自动生成。
要声明一个信使的名字，只要在打开游标之前，给<TT CLASS="TYPE">refcursor</TT>变量赋予一个字符串就可以了。
<TT CLASS="TYPE">refcursor</TT>变量的字符串值将被<TT CLASS="COMMAND">OPEN</TT>当作下层的信使的名字使用。
不过，如果<TT CLASS="TYPE">refcursor</TT>变量是空，
那么<TT CLASS="COMMAND">OPEN</TT>将自动生成一个和现有信使不冲突的名字，
然后将它赋予<TT CLASS="TYPE">refcursor</TT>变量。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 一个绑定的游标变量其名字初始化为对应的字符串值，
因此信使的名字和游标变量名同名，除非程序员在打开游标之前通过赋值覆盖了这个名字。
但是一个未绑定的游标变量初始化的时候缺省是空，
因此它会收到一个自动生成的唯一名字，除非被覆盖。</P></BLOCKQUOTE></DIV><P>
下面的例子显示了一个调用者声明游标名字的方法：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;</PRE><P>
</P><P>
下面的例子使用了自动生成的游标名：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;
-- 需要在一个事务中使用游标。
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;</PRE><P>
</P><P>
下面的例子显示了从一个函数里返回多个游标的方法：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;
-- 需要在事务里使用游标。
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;</PRE><P>
</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-CURSOR-FOR-LOOP">40.7.4. 通过游标结果进行循环</A></H2><P>
有这么一个<TT CLASS="COMMAND">FOR</TT>语法的变形，它允许通过游标返回的行进行迭代。如下：
</P><PRE CLASS="SYNOPSIS">[<SPAN
CLASS="OPTIONAL"
> &lt;&lt;<TT
CLASS="REPLACEABLE"
><I
>label</I
></TT
>&gt;&gt; </SPAN
>]
FOR <TT
CLASS="REPLACEABLE"
><I
>recordvar</I
></TT
> IN <TT
CLASS="REPLACEABLE"
><I
>bound_cursorvar</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> ( [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>argument_name</I
></TT
> := </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>argument_value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>] ) </SPAN
>] LOOP
    <TT
CLASS="REPLACEABLE"
><I
>statements</I
></TT
>
END LOOP [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>label</I
></TT
> </SPAN
>];</PRE><P>
在声明游标变量时，它必须已经绑定到一些查询语句上，并且<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不能</I></SPAN>是打开状态。
<TT CLASS="COMMAND">FOR</TT>语法会自动打开游标，并且当退出循环时自动关闭游标。只有当游标被声明要使用参数时，
必须有一列实际参数值表达式。这些值会被替换到查询中，采用如同<TT CLASS="COMMAND">OPEN</TT>的方式
(参阅<A HREF="plpgsql-cursors.html#PLPGSQL-OPEN-BOUND-CURSOR">第 40.7.2.3 &#33410;</A>)。
</P><P> <TT CLASS="REPLACEABLE"><I>recordvar</I></TT>变量会自动定义为<TT CLASS="TYPE">record</TT>类型，
并且只存在于循环中（循环中任何的定义变量名的动作都会被忽略）。
每一个由游标返回的行都会陆续的被分配到记录变量中，然后执行循环体。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="plpgsql-control-structures.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="plpgsql-errors-and-messages.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">控制结构</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">错误和消息</TD></TR></TABLE></DIV></BODY></HTML>
