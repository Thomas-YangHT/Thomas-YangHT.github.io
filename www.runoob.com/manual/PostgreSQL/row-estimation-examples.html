<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>行预估的例子</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="规划器如何使用统计信息" HREF="http://school.yunwei.edu/manual/PostgreSQL/planner-stats-details.html"><LINK REL="PREVIOUS" TITLE="规划器如何使用统计信息" HREF="http://school.yunwei.edu/manual/PostgreSQL/planner-stats-details.html"><LINK REL="NEXT" TITLE="附录" HREF="http://school.yunwei.edu/manual/PostgreSQL/appendixes.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/planstats.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="规划器如何使用统计信息" HREF="http://school.yunwei.edu/manual/PostgreSQL/planner-stats-details.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/planner-stats-details.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 60. 规划器如何使用统计信息</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="附录" HREF="http://school.yunwei.edu/manual/PostgreSQL/appendixes.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="ROW-ESTIMATION-EXAMPLES">60.1. 行预估的例子</A></H1><P> 下面的例子使用<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>回归测试数据库中的表。
输出结果是从8.3版获得的。之前或之后版本的动作可能会有所变化。
同时需要注意的是，在产生统计信息时，<TT CLASS="COMMAND">ANALYZE</TT>使用的是随机采样，
再次执行<TT CLASS="COMMAND">ANALYZE</TT>命令，结果可能会发生轻微的改变。</P><P>
让我们以一个很简单的查询开始：
</P><PRE CLASS="PROGRAMLISTING">EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)</PRE><P>
规划器如何判断<TT CLASS="STRUCTNAME">tenk1</TT>里面行的基数
在<A HREF="planner-stats.html">第 14.2 &#33410;</A>介绍，
但为了完整，在这里重复一下。行数或页数是从<TT CLASS="STRUCTNAME">pg_class</TT>中查出来的：
</P><PRE CLASS="PROGRAMLISTING">SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';

 relpages | reltuples
----------+-----------
      358 |     10000</PRE><P>
这些数字表示当前最近的<TT CLASS="COMMAND">VACUUM</TT>或者<TT CLASS="COMMAND">ANALYZE</TT>。
之后，表的块数和元组数。规划器随即取出表中当前实际的块数
（这个操作的开销很小，不需要扫描全表），如果实际的块数与
<TT CLASS="STRUCTFIELD">relpages</TT>不同，为估算当前的行数，
会对<TT CLASS="STRUCTFIELD">reltuples</TT>进行一定的缩放。
在这种情况下，<TT CLASS="STRUCTFIELD">relpages</TT>的值是最新的，
因此估计的行与<TT CLASS="STRUCTFIELD">reltuples</TT>相同。
</P><P>
换一个WHERE子句是范围条件的例子：
</P><PRE CLASS="PROGRAMLISTING">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;

                                   QUERY PLAN
--------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)
   Recheck Cond: (unique1 &lt; 1000)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)
         Index Cond: (unique1 &lt; 1000)</PRE><P>
规划器检查<TT CLASS="LITERAL">WHERE</TT>子句条件，
并在<TT CLASS="STRUCTNAME">pg_operator</TT>中查找操作符<TT CLASS="LITERAL">&lt;</TT>的选择性函数（selectivity function），
选择度函数在<TT CLASS="STRUCTFIELD">oprrest</TT>列中记录，
在本例中，对应的条目是<CODE CLASS="FUNCTION">scalarltsel</CODE>。
<CODE CLASS="FUNCTION">scalarltsel</CODE>函数从 <TT CLASS="STRUCTNAME">pg_statistics</TT>中获取
<TT CLASS="STRUCTFIELD">unique1</TT>的直方图。
对于手工查询来说，在<TT CLASS="STRUCTNAME">pg_stats</TT>视图中查找更方便：
</P><PRE CLASS="PROGRAMLISTING">SELECT histogram_bounds FROM pg_stats
WHERE tablename='tenk1' AND attname='unique1';

                   histogram_bounds
------------------------------------------------------
 {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}</PRE><P>
然后，把直方图中<SPAN CLASS="QUOTE">"&lt; 1000"</SPAN>的部分找出来。这就是选择性。
直方图把范围分隔成等频的桶， 所以我们要做的是将我们的数值所在的桶找出来，
然后计算它的<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">部分</I></SPAN>以及<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">所有</I></SPAN>该值之前的部分。
值1000很明显在第二个桶(993-1997)里，因此，假设每个桶里面的分布是线性的，
那么就可以计算出选择性：
</P><PRE CLASS="PROGRAMLISTING">selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets
            = (1 + (1000 - 993)/(1997 - 993))/10
            = 0.100697</PRE><P>
也就是一个桶加上第二个桶的线性部分，除以总的桶数。
那么估计的行数现在可以用选择性和<TT CLASS="STRUCTNAME">tenk1</TT>的基数之积计算：
</P><PRE CLASS="PROGRAMLISTING">rows = rel_cardinality * selectivity
     = 10000 * 0.100697
     = 1007  (rounding off)</PRE><P>
</P><P>
然后考虑一个<TT CLASS="LITERAL">WHERE</TT>子句是等于条件的例子：
</P><PRE CLASS="PROGRAMLISTING">EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';

                        QUERY PLAN
----------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)
   Filter: (stringu1 = 'CRAAAA'::name)</PRE><P>
规划器再次检查<TT CLASS="LITERAL">WHERE</TT>子句条件，并为<TT CLASS="LITERAL">=</TT>查找选择性函数（是<CODE CLASS="FUNCTION">eqsel</CODE>）。
对于等价估计而言，直方图并没什么用；相反，
<I CLASS="FIRSTTERM">最常用值 most common values</I>(<ACRONYM CLASS="ACRONYM">MCV</ACRONYM>)表可以用于计算选择性。
让我们来看一下MCV，带有一些额外的列会很有效：
</P><PRE CLASS="PROGRAMLISTING">SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats
WHERE tablename='tenk1' AND attname='stringu1';

null_frac         | 0
n_distinct        | 676
most_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}
most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}&#13;</PRE><P>
因为MCV中有<TT CLASS="LITERAL">CRAAAA</TT>，那么选择性只是<ACRONYM CLASS="ACRONYM">MCF</ACRONYM>中的一个对应条目：
</P><PRE CLASS="PROGRAMLISTING">selectivity = mcf[3]
            = 0.003</PRE><P>
像之前一样，行的估计数用<TT CLASS="STRUCTNAME">tenk1</TT>的基数乘以选择性：
</P><PRE CLASS="PROGRAMLISTING">rows = 10000 * 0.003
     = 30</PRE><P>
</P><P>
现在看看同样的查询，但是字符串常量不在<ACRONYM CLASS="ACRONYM">MCV</ACRONYM>列表中的情况:
</P><PRE CLASS="PROGRAMLISTING">EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';

                        QUERY PLAN
----------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)
   Filter: (stringu1 = 'xxx'::name)</PRE><P>
这是一个完全不同的问题：在数值<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不在</I></SPAN> <ACRONYM CLASS="ACRONYM">MCV</ACRONYM>中时，
如何估计选择性。解决方法是利用该值不在MCV中的事实，
结合所有已知的<ACRONYM CLASS="ACRONYM">MCV</ACRONYM>出现的频率，用减法得出：
</P><PRE CLASS="PROGRAMLISTING">selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)
            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +
                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)
            = 0.0014559</PRE><P>
也就是说，将<ACRONYM CLASS="ACRONYM">MCV</ACRONYM>中对应项的所有频率相加，并且将其从1减去，然后除以<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">其它</I></SPAN>不重复值的个数。
这相当于假设不在MCV中的列在所有其他不重复值中是均匀分布的。
需要注意的是，没有NULL值，因此不需要担心这些（否则需要从分子中减去NULL的部分）。
按照往常的方式估算行数：
</P><PRE CLASS="PROGRAMLISTING">rows = 10000 * 0.0014559
     = 15  (rounding off)</PRE><P>
</P><P>
之前带有<TT CLASS="LITERAL">unique1 &lt; 1000</TT>的例子对<CODE CLASS="FUNCTION">scalarltsel</CODE>的实际执行过于简化了。
既然已经看过了使用MCV的例子，现在添加一些具体细节。
这个例子这样子是正确的，因为<TT CLASS="STRUCTFIELD">unique1</TT>是一个唯一属性列，
那么它没有MCV（显然，没有一个值能比其它值更常用）。
对一个非唯一属性列而言，通常会有直方图和MCV列表，
并且直方图不包括MCV表示的那部分列。在这种情况下，
<CODE CLASS="FUNCTION">scalarltsel</CODE>直接在每个 MCV列表的值上应用这些条件（如<SPAN CLASS="QUOTE">"&lt; 1000"</SPAN>），
并且增加那些条件判断为真的MCV的频率，这对于表中位于MCV的部分给出一个准确的选择性估计。
直方图用于使用上述相同的方法估算表中不在MCV中的部分的选择性，
最终将这两个数字组合起来估计总的选择性。例如，考虑
</P><PRE CLASS="PROGRAMLISTING">EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)
   Filter: (stringu1 &lt; 'IAAAAA'::name)</PRE><P>
我们已看到关于stringu1的MCV信息，这里是它的直方图：
</P><PRE CLASS="PROGRAMLISTING">SELECT histogram_bounds FROM pg_stats
WHERE tablename='tenk1' AND attname='stringu1';

                                histogram_bounds
--------------------------------------------------------------------------------
 {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}</PRE><P>
检查MCV列表，我们发现前6项满足条件<TT CLASS="LITERAL">stringu1 &lt;'IAAAAA'</TT>，而最后4项不满足，
所以在MCV中的选择性是
</P><PRE CLASS="PROGRAMLISTING">selectivity = sum(relevant mvfs)
            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003
            = 0.01833333</PRE><P>
累加所有的MCF，也告诉我们由 MCV表示的成员的总比例是0.03033333，
而由直方图表示的比例是0.96966667
（同样没有NULL，否则这里我们必须去掉它们）。我们可以看到<TT CLASS="LITERAL">IAAAAA</TT>值落在直方图第三个桶的结尾部分。
关于不同字符串的频率，使用较普通的假设，规划器对于
直方图中小于<TT CLASS="LITERAL">IAAAAA</TT>的部分估计为0.298387，然后组合MCV部分和非MCV部分的估计值:
</P><PRE CLASS="PROGRAMLISTING">selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction
            = 0.01833333 + 0.298387 * 0.96966667
            = 0.307669

rows        = 10000 * 0.307669
            = 3077  (四舍五入)</PRE><P>
在这个例子中，MCV列表的纠正很小，因为实际上列分布很平坦
（统计分析显示，这些特殊值往往比其它的更常见，大部分由于抽样误差造成的）。
在更典型的情况下，有些值很明显的比其它的更常见，这中复杂的过程有利于提高准确度，因为那些最常见的值的选择性可以被精确的找到。
</P><P>
现在考虑一个<TT CLASS="LITERAL">WHERE</TT>子句中带有多个条件的情况：
</P><PRE CLASS="PROGRAMLISTING">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';

                                   QUERY PLAN
--------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)
   Recheck Cond: (unique1 &lt; 1000)
   Filter: (stringu1 = 'xxx'::name)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)
         Index Cond: (unique1 &lt; 1000)</PRE><P>
规划器假定这两个条件是独立的，因此子句各自的选择性可以相乘在一起：
</P><PRE CLASS="PROGRAMLISTING">selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')
            = 0.100697 * 0.0014559
            = 0.0001466

rows        = 10000 * 0.0001466
            = 1  (四舍五入)</PRE><P>
需要注意的是，从位图索引扫描中返回的行数估计值仅反映使用索引的条件；
这一点很重要，因为它会影响之后获取堆的开销估计。
</P><P>
最后来看一个包含连接的查询：
</P><PRE CLASS="PROGRAMLISTING">EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=4.64..456.23 rows=50 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)
         Recheck Cond: (unique1 &lt; 50)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)
               Index Cond: (unique1 &lt; 50)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)</PRE><P>
<TT CLASS="STRUCTNAME">tenk1</TT>上的约束，<TT CLASS="LITERAL">unique1 &lt; 50</TT>，在嵌套循环连接之前计算，
这个条件是用类似上面的那个范围例子的方法处理的，这次数值50落在<TT CLASS="STRUCTFIELD">unique1</TT>直方图的第一个桶：
</P><PRE CLASS="PROGRAMLISTING">selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets
            = (0 + (50 - 0)/(993 - 0))/10
            = 0.005035

rows        = 10000 * 0.005035
            = 50  (四舍五入)</PRE><P>
这个连接的约束是<TT CLASS="LITERAL">t2.unique2 = t1.unique2</TT>，操作符是我们熟悉的<TT CLASS="LITERAL">=</TT>，
从<TT CLASS="STRUCTNAME">pg_operator</TT>的<TT CLASS="STRUCTFIELD">oprjoin</TT>字段获得的选择性函数是<CODE CLASS="FUNCTION">eqjoinsel</CODE>。
<CODE CLASS="FUNCTION">eqjoinsel</CODE>为<TT CLASS="STRUCTNAME">tenk2</TT>和
<TT CLASS="STRUCTNAME">tenk1</TT>查找统计信息：
</P><PRE CLASS="PROGRAMLISTING">SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats
WHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';

tablename  | null_frac | n_distinct | most_common_vals
-----------+-----------+------------+------------------
 tenk1     |         0 |         -1 |
 tenk2     |         0 |         -1 |</PRE><P>
在这个例子中，没有<TT CLASS="STRUCTFIELD">unique2</TT>的<ACRONYM CLASS="ACRONYM">MCV</ACRONYM>信息，
因为所有数值看上去都是唯一的，
因此可以使用一个只依赖唯一数值数目和NULL数目百分比的算法来计算选择性：
</P><PRE CLASS="PROGRAMLISTING">selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)
            = (1 - 0) * (1 - 0) / max(10000, 10000)
            = 0.0001</PRE><P>
也就是说，把每个表都减去里面NULL的比例，然后除以不同数值的最大数量。
连接可能选出来的行数是以两个输入的笛卡尔积作为基数，乘以选择性计算出来的：
</P><PRE CLASS="PROGRAMLISTING">rows = (outer_cardinality * inner_cardinality) * selectivity
     = (50 * 10000) * 0.0001
     = 50</PRE><P>
</P><P> 这里有两列的MCV列表，
<CODE CLASS="FUNCTION">eqjoinsel</CODE>将直接使用MCV列表比较来决定由MCV列表表示的列成员的连接选择性。
其余成员的估计值使用这里介绍的方法即可。</P><P> 需要注意的是，<TT CLASS="LITERAL">inner_cardinality</TT>是10000，即未修改的<TT CLASS="STRUCTNAME">tenk2</TT>大小。
它可能出现在<TT CLASS="COMMAND">EXPLAIN</TT>的输出，其连接行的估计值为50 * 1，也就是，外部行的数量乘以<TT CLASS="STRUCTNAME">tenk2</TT>上每个内部索引扫描获取的行的估计数。还有一种情况是在考虑任何特定的连接计划之前就估计连接关系大小。如果一切都正常工作，那么两种方式估计的连接大小将是相同的，但由于四舍五入的误差和其它因素，它们有时会有较明显的差异。</P><P> 在<TT CLASS="FILENAME">src/backend/optimizer/util/plancat.c</TT>中有对一个表（在任何<TT CLASS="LITERAL">WHERE</TT>子句之前）大小估计的细节；
在<TT CLASS="FILENAME">src/backend/optimizer/path/clausesel.c</TT>中有子句选择性的通用逻辑；
在<TT CLASS="FILENAME">src/backend/utils/adt/selfuncs.c</TT>中有特定操作符的选择性函数。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/planner-stats-details.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/appendixes.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">规划器如何使用统计信息</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/planner-stats-details.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">附录</TD></TR></TABLE></DIV></BODY></HTML>
