<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pg_locks</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="系统表" HREF="http://school.yunwei.edu/manual/PostgreSQL/catalogs.html"><LINK REL="PREVIOUS" TITLE="pg_indexes" HREF="view-pg-indexes.html"><LINK REL="NEXT" TITLE="pg_matviews" HREF="view-pg-matviews.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/catalogs.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_indexes" HREF="view-pg-indexes.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/catalogs.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 47. 系统表</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="pg_matviews" HREF="view-pg-matviews.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="VIEW-PG-LOCKS">47.59. <TT CLASS="STRUCTNAME">pg_locks</TT></A></H1><P><TT CLASS="STRUCTNAME">pg_locks</TT>提供有关在数据库服务器中由打开的事务持有的锁的信息。
参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/mvcc.html">第 13 &#31456;</A>获取有关锁的更多的讨论。</P><P><TT CLASS="STRUCTNAME">pg_locks</TT>对每个活跃的可锁定对象、请求的锁模式、
以及相关的事务保存一行。因此，如果多个事务持有或者等待对同一个对象的锁，
那么同一个可锁定的对象可能出现多次。不过，一个目前没有锁在其上的对象将肯定不会出现。</P><P>有好几种不同的可锁定对象：一个关系(也就是一个表)、关系中独立页面、
关系中独立的行、一个事务 ID（虚拟和永久ID）、以及一般的数据库对象
(用类别 OID 和对象 OID 标识，表示方法和<TT CLASS="STRUCTNAME">pg_description</TT>
或<TT CLASS="STRUCTNAME">pg_depend</TT>一样)还有，扩展一个关系的权限也是用一种独立的可锁定对象表示的。
另外，<SPAN CLASS="QUOTE">"advisory"</SPAN>锁可以用在有用户定义的含义的数据上。</P><DIV CLASS="TABLE"><A NAME="AEN97074"></A><P><B>&#34920; 47-60. <TT CLASS="STRUCTNAME">pg_locks</TT> 字段</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>类型</TH><TH>引用</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">locktype</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>&nbsp;</TD><TD>
可锁定对象的类型：
<TT CLASS="LITERAL">relation</TT>,
<TT CLASS="LITERAL">extend</TT>,
<TT CLASS="LITERAL">page</TT>,
<TT CLASS="LITERAL">tuple</TT>,
<TT CLASS="LITERAL">transactionid</TT>,
<TT CLASS="LITERAL">virtualxid</TT>,
<TT CLASS="LITERAL">object</TT>,
<TT CLASS="LITERAL">userlock</TT>, 或
<TT CLASS="LITERAL">advisory</TT>
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">database</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD><TT CLASS="LITERAL"><A HREF="catalog-pg-database.html"><TT CLASS="STRUCTNAME">pg_database</TT></A>.oid</TT></TD><TD>
目标所在的数据库的 OID ，如果目标是共享对象，那么就是零，
如果目标是一个事务 ID ，就是 null 。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">relation</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD><TT CLASS="LITERAL"><A HREF="catalog-pg-class.html"><TT CLASS="STRUCTNAME">pg_class</TT></A>.oid</TT></TD><TD>
关系的 OID ，如果目标不是关系，也不是关系的一部分，则为 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">page</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>&nbsp;</TD><TD>
关系内部的页面编号，如果目标不是行页不是关系页，则为null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tuple</TT></TD><TD><TT CLASS="TYPE">smallint</TT></TD><TD>&nbsp;</TD><TD>
页面里面的行编号，如果目标不是行，则为 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">virtualxid</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>&nbsp;</TD><TD>
事务的虚拟 ID ，如果目标不是虚拟事务 ID ，就是 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">transactionid</TT></TD><TD><TT CLASS="TYPE">xid</TT></TD><TD>&nbsp;</TD><TD>
事务的 ID ，如果目标不是事务 ID ，就是 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">classid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD><TT CLASS="LITERAL"><A HREF="catalog-pg-class.html"><TT CLASS="STRUCTNAME">pg_class</TT></A>.oid</TT></TD><TD>
包含该目标的系统表的 OID ，如果目标不是普通数据库对象，则为 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">objid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>任意OID属性</TD><TD>
目标在其系统表内的 OID ，如果目标不是普通数据库对象，则为 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">objsubid</TT></TD><TD><TT CLASS="TYPE">smallint</TT></TD><TD>&nbsp;</TD><TD>
字段编号(<TT CLASS="STRUCTFIELD">classid</TT>和<TT CLASS="STRUCTFIELD">objid</TT>指向表自身)。
如果目标是其它普通数据库对象，这个字段是零。如果这个目标不是普通数据库对象，则为 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">virtualtransaction</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>&nbsp;</TD><TD>
持有此锁或者在等待此锁的事务的虚拟 ID
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">pid</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>&nbsp;</TD><TD>
持有或者等待这个锁的服务器进程的进程 ID 。如果锁是被一个预备事务持有的，那么为 null
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">mode</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>&nbsp;</TD><TD>这个进程持有的或者是期望的锁模式(参阅<A HREF="explicit-locking.html#LOCKING-TABLES">第 13.3.1 &#33410;</A> 和 <A HREF="transaction-iso.html#XACT-SERIALIZABLE">第 13.2.3 &#33410;</A>)</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">granted</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>&nbsp;</TD><TD>如果持有锁，为真，如果等待锁，为假</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">fastpath</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>&nbsp;</TD><TD>如果锁通过快速路径获得为真，如果通过主锁表获得为假</TD></TR></TBODY></TABLE></DIV><P><TT CLASS="STRUCTFIELD">granted</TT>为真时表明指定事务持有一个锁。为假则表明该事务当前等待使用这个锁，
这就暗示着某个其它的事务正在同样的可锁定对象上持有冲突的锁模式。等待的会话将一直睡眠，
直到另外一个锁释放(或者侦测到一个死锁条件)。一个事务一次最多等待一个锁。</P><P>每个事务都在它持续的时间里在他自己的虚拟事务 ID 上持有一个排他锁。如果给事务赋予一个永久ID
（通常只在事务改变数据库的状态时发生），那么它也在它的永久事务ID上持有一个排它锁，直到它结束。
如果一个事务认为它必须等待另外一个事务，它会以企图在另外一个事务 ID 上获取共享锁的方式实现之
（虚拟的或永久的ID取决于情景）。这个锁只有在另外一个事务终止并且释放它的锁的前提下才能成功。</P><P>尽管行是一种可以锁定的对象，但是有关行级别锁的信息是存储在磁盘上的，而不是在内存里，
因此，行级别的锁通常不会出现在这个视图里。如果一个事务在等待一个行级别的锁，
那么它通常会在这个视图里以等待当前持有该行锁的永久事务 ID 的方式出现。</P><P>建议锁可以在由单独一个<TT CLASS="TYPE">bigint</TT>值或两个integer值组成的键上获得。
一个 <TT CLASS="TYPE">bigint</TT>键的高/低位部分分别在<TT CLASS="STRUCTFIELD">classid</TT>和 <TT CLASS="STRUCTFIELD">objid</TT>
字段中显示，并且<TT CLASS="STRUCTFIELD">objsubid</TT>等于 1 。原先的<TT CLASS="TYPE">bigint</TT>值可以通过
表达式<TT CLASS="LITERAL">(classid::bigint &lt;&lt; 32) | objid::bigint</TT>重新组装。
integer 组成的键前半部分在<TT CLASS="STRUCTFIELD">classid</TT>字段中显示、后半部分在<TT CLASS="STRUCTFIELD">objid</TT>
字段中显示，并且<TT CLASS="STRUCTFIELD">objsubid</TT>等于 2 。键的实际含义取决于用户的定义。
建议锁是针对单个数据库的，因此<TT CLASS="STRUCTFIELD">database</TT>字段对于建议锁就显得很有意义了。</P><P><TT CLASS="STRUCTNAME">pg_locks</TT>提供了一个数据库集群里的所有的锁的全局视图，
而不仅仅那些和当前数据库相关的。尽管它的<TT CLASS="STRUCTFIELD">relation</TT>
字段可以和<TT CLASS="STRUCTNAME">pg_class</TT>.<TT CLASS="STRUCTFIELD">oid</TT>连接起来以标识被锁住的关系，
但是这个方法目前只能对在当前数据库里的关系有用(那些<TT CLASS="STRUCTFIELD">database</TT>
字段是当前数据库的 OID 或者零的数据库)。</P><P><TT CLASS="STRUCTFIELD">pid</TT>字段可以可以和<TT CLASS="STRUCTNAME">pg_stat_activity</TT>
视图的<TT CLASS="STRUCTFIELD">pid</TT>字段连接起来获取持有或者等待持有每个锁的会话的更多信息。
同样，如果你使用预备事务，可以把<TT CLASS="STRUCTFIELD">transaction</TT>字段和<TT CLASS="STRUCTNAME">pg_prepared_xacts</TT>
视图的<TT CLASS="STRUCTFIELD">transaction</TT>字段连接起来获取持有锁的那个预备事务的更多信息。
一个预备事务不能等待任何锁，但是在运行的时候，它继续持有它已经请求到的锁。</P><P><TT CLASS="STRUCTNAME">pg_locks</TT>显示独立系统的普通锁管理器和谓词锁管理器的数据；
另外，普通锁管理器细分它的锁为普通和<I CLASS="FIRSTTERM">fast-path</I>锁。这个数据不保证是完全一致的。
当请求视图时，fast-path锁的数据（<TT CLASS="STRUCTFIELD">fastpath</TT> = <TT CLASS="LITERAL">true</TT>）
从每个后端一次收集，在整个锁管器中没有冻结状态，所以当收集信息时，可以获取锁或释放锁。
不过，要注意的是，这些锁不和任意其他当前锁发生冲突。在所有后端已经查询fast-path锁之后，
剩余的普通锁管理器作为一个单元，并且一个所有剩余锁的一致的快照作为原子动作收集。
在解锁普通锁管理器之后，谓词锁管理器同样的锁住，并且所有谓词锁作为一个原子动作收集。
因此，除了fast-path锁，每个锁管理器将给出一致的结果集，但是因为我们不同时锁住锁管理器，
锁可能在我们访问普通锁管理器之后、访问谓词锁管理器之前获取或释放。</P><P>如果这个视图访问的非常频繁，那么锁住普通和/或谓词锁管理器可能会对数据库性能有些影响。
锁只持有从锁管理器获取数据所需要的最小的时间，但是这并不能完全消除性能影响的可能性。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="view-pg-indexes.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="view-pg-matviews.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><TT CLASS="STRUCTNAME">pg_indexes</TT></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/catalogs.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><TT CLASS="STRUCTNAME">pg_matviews</TT></TD></TR></TABLE></DIV></BODY></HTML>
