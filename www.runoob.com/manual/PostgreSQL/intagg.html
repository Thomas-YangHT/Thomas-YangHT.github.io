<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>intagg</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="hstore" HREF="hstore.html"><LINK REL="NEXT" TITLE="intarray" HREF="intarray.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/intagg.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="hstore" HREF="hstore.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="intarray" HREF="intarray.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="INTAGG">F.17. intagg</A></H1><P><TT CLASS="FILENAME">intagg</TT>模块提供一个整数聚合器和一个枚举器。<TT CLASS="FILENAME">intagg</TT>
现在已经废弃了，因为内置的函数提供它的能力的一个超集。不过，
该模块仍然作为内置函数的兼容性封装器提供。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN146648">F.17.1. 函数</A></H2><P>聚合器是一个生产正好包含输入的整数的整数数组的聚合函数<CODE CLASS="FUNCTION">int_array_aggregate(integer)</CODE>。
这是<CODE CLASS="FUNCTION">array_agg</CODE>的封装器，<CODE CLASS="FUNCTION">array_agg</CODE>对于任意数组类型做相同的事情。</P><P>枚举器是返回<TT CLASS="TYPE">setof integer</TT>类型的函数<CODE CLASS="FUNCTION">int_array_enum(integer[])</CODE>。
本质上是聚合器的反向操作：给出一个整数数组，将其展开为一组行。
这是<CODE CLASS="FUNCTION">unnest</CODE>的封装器，<CODE CLASS="FUNCTION">unnest</CODE>对于任意数组类型做相同的事情。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN146665">F.17.2. 示例使用</A></H2><P>许多数据库系统有一到多个表的概念。这样的一个表通常位于两个索引表之间，例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE left (id INT PRIMARY KEY, ...);
CREATE TABLE right (id INT PRIMARY KEY, ...);
CREATE TABLE one_to_many(left INT REFERENCES left, right INT REFERENCES right);</PRE><P>
通常这样使用：
</P><PRE CLASS="PROGRAMLISTING">SELECT right.* from right JOIN one_to_many ON (right.id = one_to_many.right)
  WHERE one_to_many.left = <TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
>;</PRE><P>
这将返回所有在左手边的表里有记录的右手边表里的条目。这在SQL中是一个非常普通的构造。
</P><P>现在，这个方法在一个有非常大数量的记录的<TT CLASS="STRUCTNAME">one_to_many</TT>表里是很难处理的。
通常，像这样的连接将会导致索引扫描和抓取表中有左手边记录的每个右手边记录。
如果你有一个非常动态的系统，那么没有什么你可以做的。不过，如果你有一些静态的数据，
你可以使用该聚合器创建一个汇总表。
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE summary AS
  SELECT left, int_array_aggregate(right) AS right
  FROM one_to_many
  GROUP BY left;</PRE><P>
这将创建一个表，这个表有每个左边的条目和一个左边条目的数组。
现在，如果没有使用该数组的方法则是相当无用的；这就是为什么有一个数组枚举器。
你可以
</P><PRE CLASS="PROGRAMLISTING">SELECT left, int_array_enum(right) FROM summary WHERE left = <TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
>;</PRE><P>
上面的查询使用<CODE CLASS="FUNCTION">int_array_enum</CODE>产生下面相同的结果
</P><PRE CLASS="PROGRAMLISTING">SELECT left, right FROM one_to_many WHERE left = <TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
>;</PRE><P>
不同之处是针对summary表的查询必须只从表中获取一行，而针对<TT CLASS="STRUCTNAME">one_to_many</TT>
的直接查询必须索引扫描然后从每条记录中获取一行。
</P><P>在一个系统上，一个显示了消耗8488的查询的<TT CLASS="COMMAND">EXPLAIN</TT>减少到消耗329。
原始查询时一个包括<TT CLASS="STRUCTNAME">one_to_many</TT>表的连接，替换为:
</P><PRE CLASS="PROGRAMLISTING">SELECT right, count(right) FROM
  ( SELECT left, int_array_enum(right) AS right
    FROM summary JOIN (SELECT left FROM left_table WHERE left = <TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
>) AS lefts
         ON (summary.left = lefts.left)
  ) AS list
  GROUP BY right
  ORDER BY count DESC;</PRE><P>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="hstore.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="intarray.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">hstore</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">intarray</TD></TR></TABLE></DIV></BODY></HTML>
