<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>客户端接口</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="大对象" HREF="http://school.yunwei.edu/manual/PostgreSQL/largeobjects.html"><LINK REL="PREVIOUS" TITLE="实现特点" HREF="lo-implementation.html"><LINK REL="NEXT" TITLE="服务器端函数" HREF="lo-funcs.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/lobj.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="实现特点" HREF="lo-implementation.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/largeobjects.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 32. 大对象</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="服务器端函数" HREF="lo-funcs.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LO-INTERFACES">32.3. 客户端接口</A></H1><P> 本节描述<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的<SPAN CLASS="APPLICATION">libpq</SPAN>客户端接口库提供来访问大对象的设施。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>大对象接口是对<ACRONYM CLASS="ACRONYM">Unix</ACRONYM>文件系统的模仿，
有仿真的<CODE CLASS="FUNCTION">open</CODE>，<CODE CLASS="FUNCTION">read</CODE>，<CODE CLASS="FUNCTION">write</CODE>，
<CODE CLASS="FUNCTION">lseek</CODE>等。</P><P> 使用这些函数的所有大对象操作<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必须</I></SPAN>在一个SQL事务块中发生，
由于大对象的文件描述符对事务的整段时间内是唯一有效的。</P><P> 如果在执行这些函数的任何一个发生错误的时候，
该函数将返回一个不可能的值，通常为0或1。
一个描述该错误的消息存储在连接对象中，
并且可以用<CODE CLASS="FUNCTION">PQerrorMessage</CODE>检索。</P><P> 客户端应用程序使用包含<TT CLASS="FILENAME">libpq/libpq-fs.h</TT>头文件的这些函数，并且
可以与<SPAN CLASS="APPLICATION">libpq</SPAN>库连接。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-CREATE">32.3.1. 创建大对象</A></H2><P>
函数
</P><PRE CLASS="SYNOPSIS">Oid lo_creat(PGconn *conn, int mode);</PRE><P>
创建一个新的大对象。返回值是赋予新大对象的OID，
或者是失败的时候是<TT CLASS="SYMBOL">InvalidOid</TT>（零）。在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.1里，
没有再使用<TT CLASS="REPLACEABLE"><I>mode</I></TT>，并且它被忽略；
不过，为了和早期的版本向下兼容，
我们最好将其设置为<TT CLASS="SYMBOL">INV_READ</TT>, <TT CLASS="SYMBOL">INV_WRITE</TT>,
或者<TT CLASS="SYMBOL">INV_READ</TT> <TT CLASS="LITERAL">|</TT> <TT CLASS="SYMBOL">INV_WRITE</TT>。
（这些符号常量在头文件<TT CLASS="FILENAME">libpq/libpq-fs.h</TT>里定义。）
</P><P>
例如：
</P><PRE CLASS="PROGRAMLISTING">inv_oid = lo_creat(conn, INV_READ|INV_WRITE);</PRE><P>
</P><P>
函数
</P><PRE CLASS="SYNOPSIS">Oid lo_create(PGconn *conn, Oid lobjId);</PRE><P>
也创建一个新的大对象。要赋予数值的OID可以用<TT CLASS="REPLACEABLE"><I>lobjId</I></TT>声明；
如果这么做，那么在该OID已经被其他大对象使用的情况下就会生成错误。
如果<TT CLASS="REPLACEABLE"><I>lobjId</I></TT>为<TT CLASS="SYMBOL">InvalidOid</TT>（零），
那么<CODE CLASS="FUNCTION">lo_create</CODE>赋予一个未用的OID，这个和<CODE CLASS="FUNCTION">lo_creat</CODE>的行为一致。）
返回值是赋予新的大对象的OID，或者是失败情况下的<TT CLASS="SYMBOL">InvalidOid</TT>（零）。
</P><P> <CODE CLASS="FUNCTION">lo_create</CODE>函数是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.1里面新增加的；
如果在老的服务器上运行这个函数，它会失败并返回<TT CLASS="SYMBOL">InvalidOid</TT>。</P><P>
例子：
</P><PRE CLASS="PROGRAMLISTING">inv_oid = lo_create(conn, desired_oid);</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-IMPORT">32.3.2. 输入大对象</A></H2><P>
要把一个操作系统文件输入成为大对象，调用
</P><PRE CLASS="SYNOPSIS">Oid lo_import(PGconn *conn, const char *filename);</PRE><P>
<TT CLASS="REPLACEABLE"><I>filename</I></TT>参数指明要被输入成为大对象的操作系统文件路径名。
返回值是赋予新大对象的OID。
如果失败则返回<TT CLASS="SYMBOL">InvalidOid</TT>（零）。请注意这个文件是由客户端接口库读取的，
而不是服务器端；因此它必须存在于客户端文件系统上并且可以被客户应用读取。
</P><P>
函数
</P><PRE CLASS="SYNOPSIS">Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);</PRE><P>
也能引入一个新的大对象。要赋予数值的OID可以用<TT CLASS="REPLACEABLE"><I>lobjId</I></TT>声明；
如果这么做，那么在该OID已经被其他大对象使用的情况下就会生成错误。
如果<TT CLASS="REPLACEABLE"><I>lobjId</I></TT>为<TT CLASS="SYMBOL">InvalidOid</TT>（零），
那么<CODE CLASS="FUNCTION">lo_import_with_oid</CODE>赋予一个未用的OID，这个和<CODE CLASS="FUNCTION">lo_import</CODE>的行为一致。）
返回值是赋予新的大对象的OID，或者是失败情况下的<TT CLASS="SYMBOL">InvalidOid</TT>（零）。
</P><P> <CODE CLASS="FUNCTION">lo_import_with_oid</CODE>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4里面新增加的，
并且内部调用<CODE CLASS="FUNCTION">lo_create</CODE>(8.1新增的)，
如果此功能在8.0或之前运行这个函数，它会失败并返回<TT CLASS="SYMBOL">InvalidOid</TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-EXPORT">32.3.3. 输出大对象</A></H2><P>
要把一个大对象输出为操作系统文件，调用
</P><PRE CLASS="SYNOPSIS">int lo_export(PGconn *conn, Oid lobjId, const char *filename);</PRE><P>
<TT CLASS="PARAMETER">lobjId</TT>参数指明要输出的大对象OID，
<TT CLASS="PARAMETER">filename</TT>参数指明操作系统文件的路径名。请注意这个文件是由客户端接口库写入的，
而不是服务器端。成功时返回1，失败时返回-1。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-OPEN">32.3.4. 打开一个现有的大对象</A></H2><P>
要打开一个现存的大对象读写，调用
</P><PRE CLASS="SYNOPSIS">int lo_open(PGconn *conn, Oid lobjId, int mode);</PRE><P>
参数<TT CLASS="PARAMETER">lobjId</TT>指明要打开的大对象的OID（对象标识）。
<TT CLASS="PARAMETER">mode</TT>位控制该对象是用于只读（<TT CLASS="SYMBOL">INV_READ</TT>），
只写（<TT CLASS="SYMBOL">INV_WRITE</TT>）还是读写。
（这些符号常量在头文件<TT CLASS="FILENAME">libpq/libpq-fs.h</TT>.里定义。）
<CODE CLASS="FUNCTION">lo_open</CODE>返回非负大对象标识用于
以后的<CODE CLASS="FUNCTION">lo_read</CODE>，
<CODE CLASS="FUNCTION">lo_write</CODE>，<CODE CLASS="FUNCTION">lo_lseek</CODE>，
<CODE CLASS="FUNCTION">lo_lseek64</CODE>，<CODE CLASS="FUNCTION">lo_tell</CODE>，
<CODE CLASS="FUNCTION">lo_tell64</CODE>，<CODE CLASS="FUNCTION">lo_truncate</CODE>，
<CODE CLASS="FUNCTION">lo_truncate64</CODE>和<CODE CLASS="FUNCTION">lo_close</CODE>。
这个描述符只是在当前事务中有效。 失败的时候，返回-1。
</P><P> 服务器目前并不区分<TT CLASS="SYMBOL">INV_WRITE</TT>和<TT CLASS="SYMBOL">INV_READ</TT> <TT CLASS="LITERAL">|</TT>
<TT CLASS="SYMBOL">INV_WRITE</TT>模式：
可以从这些任一模式中读取描述符。但与<TT CLASS="SYMBOL">INV_READ</TT>有明显的不同：
对于<TT CLASS="SYMBOL">INV_READ</TT>，你不能写入描述符，
并且从其中读取的数据将反映执行<CODE CLASS="FUNCTION">lo_open</CODE>的时候事务快照对应的大对象的数据，
而不会考虑本次事务后面写入的或者其他事务写入的数据。
从一个用<TT CLASS="SYMBOL">INV_WRITE</TT>打开的描述符里面读取的数据反映所有其他
已经提交的事务和当前事务的写操作写入的大对象的数据。
这个行为类似普通SQL语句<TT CLASS="COMMAND">SELECT</TT>在事务模式中
<TT CLASS="LITERAL">REPEATABLE READ</TT>对比<TT CLASS="LITERAL">READ COMMITTED</TT>的行为。</P><P>
例子：
</P><PRE CLASS="PROGRAMLISTING">inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-WRITE">32.3.5. 向大对象中写数据</A></H2><P>
函数
</P><PRE CLASS="SYNOPSIS">int lo_write(PGconn *conn, int fd, const char *buf, size_t len);</PRE><P>
从<TT CLASS="PARAMETER">buf</TT>中（这个大小必须是<TT CLASS="PARAMETER">len</TT>）
向大对象描述符<TT CLASS="PARAMETER">fd</TT>写入<TT CLASS="PARAMETER">len</TT>字节。
<TT CLASS="PARAMETER">fd</TT>参数必须是前面的一个<CODE CLASS="FUNCTION">lo_open</CODE>调用的返回。
返回实际写入的字节数（当前实现过程中，它总是等于<TT CLASS="PARAMETER">len</TT>，除非有错误）。
出错时，返回值是-1。</P><P> 尽管<TT CLASS="PARAMETER">len</TT>参数被声明为<TT CLASS="TYPE">size_t</TT>，
这个函数将拒绝长度值大于<TT CLASS="LITERAL">INT_MAX</TT>。实践中，最好以兆字节传输块中数据。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-READ">32.3.6. 从大对象中读取数据</A></H2><P>
函数
</P><PRE CLASS="SYNOPSIS">int lo_read(PGconn *conn, int fd, char *buf, size_t len);</PRE><P>
从大对象描述符<TT CLASS="PARAMETER">fd</TT>中读取<TT CLASS="PARAMETER">len</TT>
字节数据到<TT CLASS="PARAMETER">buf</TT>中(大小必须是<TT CLASS="PARAMETER">len</TT>)。
<TT CLASS="PARAMETER">fd</TT>参数必须是前面的一个<CODE CLASS="FUNCTION">lo_open</CODE>调用的返回。
返回实际读取的字节数。如果大对象的结尾达到第一，则小于<TT CLASS="PARAMETER">len</TT>。
出错时，返回值是-1。</P><P> 尽管<TT CLASS="PARAMETER">len</TT>参数被声明为<TT CLASS="TYPE">size_t</TT>，这个函数将拒绝长度值
大于<TT CLASS="LITERAL">INT_MAX</TT>。实践中，最好以兆字节传输块中数据。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-SEEK">32.3.7. 大对象中查找</A></H2><P>
要改变与一个大对象描述符相关的读写位置，调用
</P><PRE CLASS="SYNOPSIS">int lo_lseek(PGconn *conn, int fd, int offset, int whence);</PRE><P>
这个过程把当前<TT CLASS="PARAMETER">fd</TT>代表的大对象描述符位置指针移动到<TT CLASS="PARAMETER">offset</TT>指明的新的位置。
参数<TT CLASS="PARAMETER">whence</TT>的合法的取值是<TT CLASS="SYMBOL">SEEK_SET</TT>（从对象开头开始找），
<TT CLASS="SYMBOL">SEEK_CUR</TT>（从当前位置开始找），
和<TT CLASS="SYMBOL">SEEK_END</TT>（从对象结尾开始找）。
返回值是新位置指针，如果出错为-1。</P><P>
当处理可能超过2GB的大对象时，而是使用：
</P><PRE CLASS="SYNOPSIS">pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);</PRE><P>
这个函数有<CODE CLASS="FUNCTION">lo_lseek</CODE>同样的操作，但是它可以接受<TT CLASS="PARAMETER">offset</TT>大于2GB和/或者
传递大于2GB的一个结果。注意如果新的位置指针大于2GB，那么<CODE CLASS="FUNCTION">lo_lseek</CODE>将失败。 </P><P>
<CODE CLASS="FUNCTION">lo_lseek64</CODE>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.3中新的。如果这个函数
运行在一个旧的服务器版本上，则将失败并且返回-1。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-TELL">32.3.8. 获取一个大对象的当前索引位置</A></H2><P>
要获取一个大对象描述符的当前读或写位置，调用
</P><PRE CLASS="SYNOPSIS">int lo_tell(PGconn *conn, int fd);</PRE><P>
如果有错误，返回值是-1。</P><P>
当处理可能超过2GB的大对象时，而是使用
</P><PRE CLASS="SYNOPSIS">pg_int64 lo_tell64(PGconn *conn, int fd);</PRE><P>
这个函数有<CODE CLASS="FUNCTION">lo_tell</CODE>的相同操作。但是它传递大于2GB的结果。
注意如果当前读/写位置大于2GB，则<CODE CLASS="FUNCTION">lo_tell</CODE>失败。</P><P> <CODE CLASS="FUNCTION">lo_tell64</CODE>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.3中新的。如果
这个函数在一个旧服务器版本上运行，它将失败并且返回-1。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-TRUNCATE">32.3.9. 截断一个大对象</A></H2><P>
截断一个给定长度的大对象，调用
</P><PRE CLASS="SYNOPSIS">int lo_truncate(PGcon *conn, int fd, size_t len);</PRE><P>
截断大对象描述符<TT CLASS="PARAMETER">fd</TT>到长度<TT CLASS="PARAMETER">len</TT>的大对象，
<TT CLASS="PARAMETER">fd</TT>参数必须通过先前的<CODE CLASS="FUNCTION">lo_open</CODE>返回。
如果<TT CLASS="PARAMETER">len</TT>大于当前大对象的长度，大对象延长到空字节('\0')。
一旦成功，<CODE CLASS="FUNCTION">lo_truncate</CODE>返回零。错误时，返回值是-1。</P><P> 与描述符<TT CLASS="PARAMETER">fd</TT>相联系的读/写位置没有被改变。</P><P> 尽管<TT CLASS="PARAMETER">len</TT>参数被声明为<TT CLASS="TYPE">size_t</TT>，则<CODE CLASS="FUNCTION">lo_truncate</CODE>
将拒绝长度值大于<TT CLASS="LITERAL">INT_MAX</TT>。</P><P>
当处理可能超过2GB大小的大对象时，而是使用
</P><PRE CLASS="SYNOPSIS">int lo_truncate64(PGcon *conn, int fd, pg_int64 len);</PRE><P>
这个函数和<CODE CLASS="FUNCTION">lo_truncate</CODE>有同样操作，但是它可以接受
超过2GB的<TT CLASS="PARAMETER">len</TT>值。</P><P> <CODE CLASS="FUNCTION">lo_truncate</CODE>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.3中新的；
如果这个函数在一个旧的服务器版本上运行，它将失败并且返回-1。</P><P> <CODE CLASS="FUNCTION">lo_truncate64</CODE>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.3中新的；
如果这个函数在一个旧的服务器版本上运行，它将失败并且返回-1。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-CLOSE">32.3.10. 关闭一个大对象描述符</A></H2><P>
一个大对象描述符关闭可以通过调用
</P><PRE CLASS="SYNOPSIS">int lo_close(PGconn *conn, int fd);</PRE><P>
<TT CLASS="PARAMETER">fd</TT>是通过<CODE CLASS="FUNCTION">lo_open</CODE>返回的大对象描述符。
成功时，<CODE CLASS="FUNCTION">lo_close</CODE>返回零。失败时，返回值是-1。</P><P> 任何在事务结尾时仍然打开的大对象描述符将自动关闭。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LO-UNLINK">32.3.11. 删除一个大对象</A></H2><P>
从数据库中删除一个大对象，调用
</P><PRE CLASS="SYNOPSIS">int lo_unlink(PGconn *conn, Oid lobjId);</PRE><P>
<TT CLASS="PARAMETER">lobjId</TT>参数声明要删除的大对象的OID。成功时返回1，失败时返回-1。
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="lo-implementation.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="lo-funcs.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">实现特点</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/largeobjects.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">服务器端函数</TD></TR></TABLE></DIV></BODY></HTML>
