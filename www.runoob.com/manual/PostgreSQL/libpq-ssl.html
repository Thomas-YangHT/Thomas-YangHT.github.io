<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>SSL 支持</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="LDAP查找连接参数" HREF="libpq-ldap.html"><LINK REL="NEXT" TITLE="在多线程程序里的行为" HREF="libpq-threading.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="LDAP查找连接参数" HREF="libpq-ldap.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="在多线程程序里的行为" HREF="libpq-threading.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-SSL">31.18. SSL 支持</A></H1><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>本机支持使用<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接对客户端/服务器通讯进行加密，
以增强安全性。参阅<A HREF="ssl-tcp.html">第 17.9 &#33410;</A>获取服务器端<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>功能的细节。</P><P><SPAN CLASS="APPLICATION">libpq</SPAN>读取全系统<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN>配置文件，
默认情况下，文件命名为<TT CLASS="FILENAME">openssl.cnf</TT>并且存放在<TT CLASS="LITERAL">openssl version -d</TT>
报告的目录中。此默认可以通过设置环境变量<TT CLASS="ENVAR">OPENSSL_CONF</TT>为所需配置文件的名称来重写。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBQ-SSL-CERTIFICATES">31.18.1. 服务器证书的客户端验证</A></H2><P>缺省，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不会执行任何服务器证书验证。
这就意味着可以在客户端没有察觉的情况下骗过服务认证（如，通过修改一个DNS记录或接管服务IP地址）。
为了避免这种情况，必须使用<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>证书认证。</P><P>如果<TT CLASS="LITERAL">sslmode</TT>参数设置为<TT CLASS="LITERAL">verify-ca</TT>，
libpq将通过检查受信任的证书颁发机构的证书链(<ACRONYM CLASS="ACRONYM">CA</ACRONYM>)来验证服务是可信任的。
如果<TT CLASS="LITERAL">sslmode</TT>设置为<TT CLASS="LITERAL">verify-full</TT>，
libpq<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">也</I></SPAN>会通过验证服务主机名匹配认证来认为服务是可信任的。
如果服务验证不能被通过，那么SSL连接会失败。在大多数对安全要求较高的环境中，
建议使用<TT CLASS="LITERAL">verify-full</TT>。</P><P>在<TT CLASS="LITERAL">verify-full</TT>模式下，认证的<TT CLASS="LITERAL">cn</TT>(Common Name)属性与主机名进行匹配。
如果<TT CLASS="LITERAL">cn</TT>以<TT CLASS="LITERAL">*</TT>开始，会被看做是一个通配符，并且会匹配<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">除了</I></SPAN>
点（<TT CLASS="LITERAL">.</TT>）之外的所有字符。这就意味着认证不会匹配子域名。
如果是使用IP而不是主机名进行连接，会进行IP匹配检查（不会做DNS检查）。</P><P>为了允许服务器认证通过，一个或多个信任的<ACRONYM CLASS="ACRONYM">CA</ACRONYM>认证必须放在用户的home目录下的
<TT CLASS="FILENAME">~/.postgresql/root.crt</TT>文件中。Windows下的文件名是<TT CLASS="FILENAME">%APPDATA%\postgresql\root.crt</TT>。</P><P>如果存在<TT CLASS="FILENAME">~/.postgresql/root.crl</TT>文件（Windows下是
<TT CLASS="FILENAME">%APPDATA%\postgresql\root.crl</TT>文件），同样也会检查证书吊销列表（CRL）。</P><P>root认证文件和CRL的位置可以通过设置<TT CLASS="LITERAL">sslrootcert</TT>和<TT CLASS="LITERAL">sslcrl</TT>连接参数，
或<TT CLASS="ENVAR">PGSSLROOTCERT</TT>和<TT CLASS="ENVAR">PGSSLCRL</TT>环境变量进行修改。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>为了与早期PostgreSQL版本兼容，如果存在一个根CA文件，<TT CLASS="LITERAL">sslmode</TT>=<TT CLASS="LITERAL">require</TT>
的行为将和<TT CLASS="LITERAL">verify-ca</TT>表现的相同，意味着服务器证书是经过CA验证的。
不建议依赖于这个行为，需要证书验证的应用应该总是使用<TT CLASS="LITERAL">verify-ca</TT>
或<TT CLASS="LITERAL">verify-full</TT>。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-SSL-CLIENTCERT">31.18.2. 客户端证书</A></H2><P>如果服务器要求一个信任的客户端认证，<SPAN CLASS="APPLICATION">libpq</SPAN>将发送存储在用户home目录中
<TT CLASS="FILENAME">~/.postgresql/postgresql.crt</TT>文件中的证书。该证书必须由服务器信任的证书认证
（<ACRONYM CLASS="ACRONYM">CA</ACRONYM>）之一签名。同时也必须出示一个匹配的私钥文件
<TT CLASS="FILENAME">~/.postgresql/postgresql.key</TT>。私钥文件不允许任何对世界或组的访问；
通过<TT CLASS="COMMAND">chmod 0600 ~/.postgresql/postgresql.key</TT>命令可以实现。
在Windows上，这个文件是<TT CLASS="FILENAME">%APPDATA%\postgresql\postgresql.crt</TT>
和<TT CLASS="FILENAME">%APPDATA%\postgresql\postgresql.key</TT>，同时没有特定的权限检查，
因为目录被认为是安全的。证书和key文件的位置可以通过<TT CLASS="LITERAL">sslcert</TT>和<TT CLASS="LITERAL">sslkey</TT>连接参数，
或<TT CLASS="ENVAR">PGSSLCERT</TT>和<TT CLASS="ENVAR">PGSSLKEY</TT>环境变量进行覆盖重写。</P><P>在一些情况下，客户端认证可能会被一个<SPAN CLASS="QUOTE">"intermediate"</SPAN>的证书认证来签名，
而不是一个能直接被服务信任的。为了使用一个这种认证，向<TT CLASS="FILENAME">postgresql.crt</TT>
文件追加证书签字权，并且直到<SPAN CLASS="QUOTE">"root"</SPAN>都可以被服务器信任。
root认证应该被包含在任何一种情况（<TT CLASS="FILENAME">postgresql.crt</TT>包含多个认证）下。</P><P>需要注意的是，<TT CLASS="FILENAME">root.crt</TT>列出了最高级别的CA，
认为对签名服务证书来说是可信任的。原则上，不需要列出签名客户端认证的CA，
尽管在大多数情况下，CA仍会被认为对服务器认证是可信任的。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-SSL-PROTECTION">31.18.3. 在不同的模式提供保护</A></H2><P><TT CLASS="LITERAL">sslmode</TT>参数的不同值提供了不同的保护级别。SSL可以为三种攻击提供保护：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT>Eavesdropping（窃听）</DT><DD><P>如果一个第三方可以在客户端与服务器端之间检查网络通信，那么它就能读取两边的连接信息
（包括用户名和密码）以及传递的数据。对此，<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>通过加密进行防护。</P></DD><DT>裁判(<ACRONYM CLASS="ACRONYM">MITM</ACRONYM>)</DT><DD><P>如果客户端和服务器端进行传递数据的时候，第三方可以对其进行修改，那么他就能伪装成服务器，
然后查看或修改数据（<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">即使是加密的</I></SPAN>）。第三方接着可以向原始服务器发出连接信息和数据，
最终造成无法防护这种攻击。这种攻击常用的载体有DNS中毒或IP绑架，
即客户端被定向到预期之外的不同的服务器。同样还有几种其他的方法也能做到这种攻击。
<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>通过服务器到客户端的证书验证来阻止这种攻击。</P></DD><DT>Impersonation（模拟）</DT><DD><P>如果第三方可以伪装成一个认证了的客户端，那么它就能轻松访问到它本来不能访问的数据。
典型的，如不安全的密钥管理，就会造成这种情况。<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>
通过客户端认证来阻止这种情况，即确保只有知道有效认证的人员才能访问连接服务器。</P></DD></DL></DIV><P>
</P><P>对于一个被称为安全的连接来说，进行连接之前，必须在<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">客户端和服务器端都</I></SPAN>进行SSL配置。
如果只在服务器端进行配置，在它知道服务器端需要高级认证之前不会发送敏感信息（如密码等）。
在libpq中，可以通过将<TT CLASS="LITERAL">sslmode</TT>参数设置为<TT CLASS="LITERAL">verify-full</TT>或<TT CLASS="LITERAL">verify-ca</TT>
来确保安全连接，并且为系统提供一个root认证以进行安全认证。类似于使用<TT CLASS="LITERAL">https</TT>
和<ACRONYM CLASS="ACRONYM">URL</ACRONYM>进行加密网页浏览。</P><P>一旦服务器已经认证，客户端就可以发送敏感信息。这就意味着直到这一刻，客户端都不需要知道，
是否认证需要证书，只在服务器配置，对其安全地指定。</P><P>所有以加密和密钥交换方式得<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>选项都会产生开销，因此在性能和安全之间需要进行一个权衡。
<A HREF="libpq-ssl.html#LIBPQ-SSL-SSLMODE-STATEMENTS">&#34920; 31-1</A>说明不同<TT CLASS="LITERAL">sslmode</TT>值的安全风险，
以及关于安全和开销所做出的声明：</P><DIV CLASS="TABLE"><A NAME="LIBPQ-SSL-SSLMODE-STATEMENTS"></A><P><B>&#34920; 31-1. SSL 模式说明</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH><TT CLASS="LITERAL">sslmode</TT></TH><TH>窃听保护</TH><TH><ACRONYM CLASS="ACRONYM">MITM</ACRONYM>保护</TH><TH>声明</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">disable</TT></TD><TD>否</TD><TD>否</TD><TD>我不关心安全，我不想来支付加密的开销。
</TD></TR><TR><TD><TT CLASS="LITERAL">allow</TT></TD><TD>可能</TD><TD>否</TD><TD>我不关心安全性，但我会支付的加密开销，如果服务器的坚持的话。
</TD></TR><TR><TD><TT CLASS="LITERAL">prefer</TT></TD><TD>可能</TD><TD>否</TD><TD>我不关心加密，但我想支付加密开销，如果服务器支持它。
</TD></TR><TR><TD><TT CLASS="LITERAL">require</TT></TD><TD>是</TD><TD>否</TD><TD>我希望我的数据加密，我接受开销。我相信该网络将确保我始终连接到我想要的服务器。
</TD></TR><TR><TD><TT CLASS="LITERAL">verify-ca</TT></TD><TD>是</TD><TD><TT CLASS="LITERAL">取决于CA</TT>的政策</TD><TD>我希望我的数据加密，我接受开销。我想要确保我连接到了一个我信任的服务器。
</TD></TR><TR><TD><TT CLASS="LITERAL">verify-full</TT></TD><TD>是</TD><TD>是</TD><TD>我希望我的数据加密，我接受开销。我想要确保我连接到了一个我信任的服务器，
并且是我指定的那个服务器。
</TD></TR></TBODY></TABLE></DIV><P><TT CLASS="LITERAL">verify-ca</TT>和<TT CLASS="LITERAL">verify-full</TT>之间的不同是根据root <ACRONYM CLASS="ACRONYM">CA</ACRONYM>的政策。
如果使用的是一个公用<ACRONYM CLASS="ACRONYM">CA</ACRONYM>，<TT CLASS="LITERAL">verify-ca</TT>允许那些带有<ACRONYM CLASS="ACRONYM">CA</ACRONYM>
注册的客户端对服务器进行连接访问。在这种情况下，应该使用<TT CLASS="LITERAL">verify-full</TT>。
如果使用的是一个本地<ACRONYM CLASS="ACRONYM">CA</ACRONYM>，甚至是一个自签名证书，
使用<TT CLASS="LITERAL">verify-ca</TT>通常会提供充分的保护。</P><P><TT CLASS="LITERAL">sslmode</TT>缺省值是<TT CLASS="LITERAL">prefer</TT>。如在表中说明的那样，
从安全角度来看这样做是没有意义的，并且如果可能的话，它只承诺性能的开销。
它仅提供了缺省向后兼容性，在安全部署中不建议使用。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-SSL-FILEUSAGE">31.18.4. SSL 客户端文件的使用</A></H2><P><A HREF="libpq-ssl.html#LIBPQ-SSL-FILE-USAGE">&#34920; 31-2</A>总结了与客户端SSL设置相关的文件。</P><DIV CLASS="TABLE"><A NAME="LIBPQ-SSL-FILE-USAGE"></A><P><B>&#34920; 31-2. libpq/客户端SSL文件的使用</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>文件</TH><TH>内容</TH><TH>影响</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="FILENAME">~/.postgresql/postgresql.crt</TT></TD><TD>客户端证书</TD><TD>服务器要求的</TD></TR><TR><TD><TT CLASS="FILENAME">~/.postgresql/postgresql.key</TT></TD><TD>客户端的私钥</TD><TD>证明由所有者发送的客户端证书，并不表示证书拥有者是值得信赖的</TD></TR><TR><TD><TT CLASS="FILENAME">~/.postgresql/root.crt</TT></TD><TD>受信任的证书颁发机构</TD><TD>检查服务器证书是由受信任的证书机关签署。</TD></TR><TR><TD><TT CLASS="FILENAME">~/.postgresql/root.crl</TT></TD><TD>证书颁发机构吊销证书</TD><TD>服务器证书必须不在这个名单</TD></TR></TBODY></TABLE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-SSL-INITIALIZE">31.18.5. SSL 库初始化</A></H2><P>如果应用程序初始化<TT CLASS="LITERAL">libssl</TT>和/或<TT CLASS="LITERAL">libssl</TT>库以及<SPAN CLASS="APPLICATION">libpq</SPAN>
编译为支持<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>，应该调用<CODE CLASS="FUNCTION">PQinitOpenSSL</CODE>来告诉<SPAN CLASS="APPLICATION">libpq</SPAN>
说<TT CLASS="LITERAL">libssl</TT>和/或<TT CLASS="LITERAL">libcrypto</TT>库已经被应用程序初始化了，
因此<SPAN CLASS="APPLICATION">libpq</SPAN>将不会再初始化这些库。参阅
<A HREF="http://h71000.www7.hp.com/doc/83final/BA554_90007/ch04.html" TARGET="_top">http://h71000.www7.hp.com/doc/83final/BA554_90007/ch04.html</A>
获取关于SSL API的详细信息。</P><P> <P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQINITOPENSSL"></A><CODE CLASS="FUNCTION">PQinitOpenSSL</CODE>
</DT><DD><P>
允许应用程序选择安全库初始化。
</P><PRE CLASS="SYNOPSIS">void PQinitOpenSSL(int do_ssl, int do_crypto);</PRE><P>
</P><P>当<TT CLASS="PARAMETER">do_ssl</TT>为非0时，在第一次打开一个数据库连接之前，<SPAN CLASS="APPLICATION">libpq</SPAN>
将初始化<SPAN CLASS="APPLICATION">OpenSSL</SPAN>库。当<TT CLASS="PARAMETER">do_crypto</TT>为非0时，<TT CLASS="LITERAL">libcrypto</TT>
库将被初始化。缺省(如果<CODE CLASS="FUNCTION">PQinitOpenSSL</CODE>没有被调用)，两个库都会被初始化。
如果没有编译SSL支持，会提供该函数，但不会做任何事情。</P><P>如果应用程序使用并初始化<SPAN CLASS="APPLICATION">OpenSSL</SPAN>，或其底层<TT CLASS="LITERAL">libcrypto</TT>库，
那么在第一次打开一个数据库连接之前，<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必须</I></SPAN>调用这个函数（带有适当0值的参数）。
同样要确保在打开一个数据库连接之前做过初始化。</P></DD><DT><A NAME="LIBPQ-PQINITSSL"></A><CODE CLASS="FUNCTION">PQinitSSL</CODE>
</DT><DD><P>
允许应用程序选择初始化哪个安全库。
</P><PRE CLASS="SYNOPSIS">void PQinitSSL(int do_ssl);</PRE><P>
</P><P>此功能相当于<TT CLASS="LITERAL">PQinitOpenSSL(do_ssl, do_ssl)</TT>。
它的应用是足够的同时初始化或都不初始化<SPAN CLASS="APPLICATION">OpenSSL</SPAN>和<TT CLASS="LITERAL">libcrypto</TT>。</P><P><CODE CLASS="FUNCTION">PQinitSSL</CODE>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.0就已经出现了，
而<CODE CLASS="FUNCTION">PQinitOpenSSL</CODE>是在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4添加进来的。
所以对老版本的<SPAN CLASS="APPLICATION">libpq</SPAN>的使用，<CODE CLASS="FUNCTION">PQinitSSL</CODE>是对应用程序的不错的选择。</P></DD></DL></DIV><P>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-ldap.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-threading.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">LDAP查找连接参数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">在多线程程序里的行为</TD></TR></TABLE></DIV></BODY></HTML>
