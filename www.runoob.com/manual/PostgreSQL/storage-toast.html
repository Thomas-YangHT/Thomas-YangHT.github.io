<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>TOAST</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="数据库物理存储" HREF="http://school.yunwei.edu/manual/PostgreSQL/storage.html"><LINK REL="PREVIOUS" TITLE="数据库文件布局" HREF="storage-file-layout.html"><LINK REL="NEXT" TITLE="自由空间映射" HREF="storage-fsm.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/storage.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="数据库文件布局" HREF="storage-file-layout.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/storage.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 58. 数据库物理存储</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="自由空间映射" HREF="storage-fsm.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="STORAGE-TOAST">58.2. TOAST</A></H1><P> 本节对<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>进行介绍。（超大字段存储技术）</P><P> 因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的页面大小是固定的(通常是8Kb)，
并且不允许元组跨越多个页面，因此不可能直接存储非常大的字段值。
为了突破这个限制，大的字段值被压缩和/或分割为多个物理行。
这些事情对用户都是透明的，只对多数后端代码有少许影响。
该技术被称之为<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>（或者<SPAN CLASS="QUOTE">"切片面包之后最好的东西"</SPAN>)）。</P><P> 只有一部分数据类型支持<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM> &mdash;(没必要在那些不可能生成大的字段值
的数据类型强制添加这种额外开销)。要支持<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>，数据类型必须有变长
(<I CLASS="FIRSTTERM">varlena</I>)表现形式，这个时候，存储的任何数据的头
32 位都存储着以字节计的数据的总长度(包括长度本身)。
<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>并不影响数据类型其余部分的表现形式。所有支持<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>数据类型的
C级别函数都必须仔细处理<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>的输入值。
也就是通常在对一个输入值做任何事情之前调用<CODE CLASS="FUNCTION">PG_DETOAST_DATUM</CODE>；
但是在某些情况下也存在更高效的方法。</P><P> <ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>占用变长的长度字的两位（在大端（big-endian）机器上是高位序，在小端（little-endian）机器上是低位序），
因此限制<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>数据类型任何值的逻辑大小为1 GB（2<SUP>30</SUP> - 1字节）。
当两位都是零时，该值是一个普通的非<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>数据类型的值，
长度字的剩余位给出以字节计的总数据大小（包括长度字）。当最高位或最低位被设置时，
该值仅有一个一字节长度的头而非通常的4字节的头，剩余的位给出以字节计的总数据大小（包括长度字）。
作为一个特殊的情况下，如果剩余位都是零（其将不可能包含自身的长度），
该值为一个指向存储在TOAST表的行外数据。
（TOAST指针的大小在数据的第二个字节给出。）
单字节头的值没有对齐任何特定的边界。最后，当最高或最低位被清除，
其临近位被设置时，数据内容已经被压缩，在使用前必须先行解压。
在这种情况下，长度字剩余位给出的是压缩数据的总大小，而非原始数据的大小。
请注意压缩也可能是行外数据，
但是变长的头不会告诉我们这是否发生&mdash;而是由TOAST指针的内容告诉我们的。</P><P> 如果一个表中有任何一个字段是可以<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>的，
那么该表将有一个关联的<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>表，其OID存储在表的<TT CLASS="STRUCTNAME">pg_class</TT>.<TT CLASS="STRUCTFIELD">reltoastrelid</TT>字段中，
行外<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>过的数值保存在<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>表里，下面有更详细的描述。</P><P> 这里使用的压缩技术是非常简单并且非常快速的 LZ 族压缩技术。
参阅<TT CLASS="FILENAME">src/backend/utils/adt/pg_lzcompress.c</TT>获取细节。</P><P> 将行外数据分割成(如果压缩过，在压缩之后)最多<TT CLASS="SYMBOL">TOAST_MAX_CHUNK_SIZE</TT>
(缺省选择这个值，2000字节，使4块行将适合一内存页，约2000个字节)字节的块，
每个块都作为独立的行在所属表的<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>表中存储。
每个<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>表都有<TT CLASS="STRUCTFIELD">chunk_id</TT>字段(一个表示特定<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>值的OID)、
<TT CLASS="STRUCTFIELD">chunk_seq</TT>(一个序列号，存储该块在数据中的位置)、<TT CLASS="STRUCTFIELD">chunk_data</TT>(该块实际的数据)。
在<TT CLASS="STRUCTFIELD">chunk_id</TT>和<TT CLASS="STRUCTFIELD">chunk_seq</TT>上有一个唯一索引，提供对数据的快速检索。
因此，一个表示行外<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>值的指针数据需要存储要查阅的<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>的OID
和特定数据的OID(它的<TT CLASS="STRUCTFIELD">chunk_id</TT>)。为方便考虑，指针数据还存储逻辑数据的尺寸
(原始的未压缩的数据长度)以及实际存储的尺寸 (如果使用了压缩，则两者不同)。
加上头部的长度字，一个<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>指针数据的总大小是18字节，
不管它代表的数值的实际长度是多大。</P><P><ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>代码只有在表中一行存储的数据超过<TT CLASS="SYMBOL">TOAST_TUPLE_THRESHOLD</TT>
字节(通常是2KB)时才会触发。
<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>代码将压缩和/或行外存储字段值，
直到数据少于<TT CLASS="SYMBOL">TOAST_TUPLE_TARGET</TT>字节（通常是2KB），
或者无法得到更好的结果时才停止。
在一个UPDATE操作过程中，未改变的字段值通常原样保存；
所以，如果UPDATE一个带有行外数据的行时，如果行外数据没有变化，
那么将不会有<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>开销存在。</P><P><ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>代码识别四种不同的存储<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>字段的策略：
<P></P></P><UL><LI><P>
<TT CLASS="LITERAL">PLAIN</TT>避免压缩或者行外存储；此外，它禁止为变长类型使用单字节的头。
这只对那些不能<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>的数据类型的列才有可能。
</P></LI><LI><P> <TT CLASS="LITERAL">EXTENDED</TT>允许压缩和行外存储。
这是大多数<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>数据类型的缺省策略。首先会尝试对数据进行压缩，
如果行仍然太大，则进行行外存储。</P></LI><LI><P><TT CLASS="LITERAL">EXTERNAL</TT>允许行外存储，但是不许压缩。
使用<TT CLASS="LITERAL">EXTERNAL</TT>，将使那些数据类型为<TT CLASS="TYPE">text</TT>和<TT CLASS="TYPE">bytea</TT>的字段上的子字符串操作更快
(代价是增加了存储空间)，因为这些操作是经过优化的：如果行外数据没有压缩，那么它们只会获取需要的部分。</P></LI><LI><P> <TT CLASS="LITERAL">MAIN</TT>允许压缩，但不允许行外存储。
实际上，在这样的字段上仍然会进行行外存储，
但只是作为没有办法把数据行变得更小以使之足以放置在一个页面中的最后选择。</P></LI></UL><P>
每个<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>的数据类型都为该数据类型所在的字段指定一个缺省策略，
但是特定表的字段的存储策略可以用<TT CLASS="COMMAND">ALTER TABLE SET STORAGE</TT>命令进行修改。</P><P> 这个方法比那些更直接的方法，比如允许行中的数据直接跨越多个页面，
有更多优点。假设查询通常是用相对比较短的键值进行匹配的，
那么大多数执行器的工作都将使用主行记录完成。<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>属性的大值，
只是在把结果集发送给客户端的时候才抽出来(如果选择了它的话)。因此，
主表要小得多，并且它的大部分行都存储在共享缓冲区里，因此就可以不需要任何行外存储。
排序集也缩小了，并且排序将更多地完全在内存中完成。一个小测试表明，
一个用于保存HTML页面以及它们的URL的表，包括<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>表在内，
存储将近一半大小的裸数据，而主表只包含全部数据的10%(URL和一些小的HTML页面)。
与一个没有使用<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>的表(把全部HTML页面裁剪成7KB以匹配页面大小)进行对比，没有任何运行时的区别。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="storage-file-layout.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="storage-fsm.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">数据库文件布局</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/storage.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">自由空间映射</TD></TR></TABLE></DIV></BODY></HTML>
