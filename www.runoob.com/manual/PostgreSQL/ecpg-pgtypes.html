<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pgtypes 库</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="ECPG - 在C中嵌入SQL" HREF="http://school.yunwei.edu/manual/PostgreSQL/ecpg.html"><LINK REL="PREVIOUS" TITLE="动态SQL" HREF="ecpg-dynamic.html"><LINK REL="NEXT" TITLE="使用描述符范围" HREF="ecpg-descriptors.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ecpg.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="动态SQL" HREF="ecpg-dynamic.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/ecpg.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 33. <SPAN CLASS="APPLICATION">ECPG</SPAN> - 在C中嵌入<ACRONYM CLASS="ACRONYM">SQL</ACRONYM></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="使用描述符范围" HREF="ecpg-descriptors.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="ECPG-PGTYPES">33.6. pgtypes 库</A></H1><P>
Pgtypes库映射<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>数据库类型到C等值，
它可用于C程序。没有<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器的帮助下，
它也提供一些函数在C中用这些类型做基本的运算。
请看下面的例子：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&#38;date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&#38;ts1, &#38;iv1, &#38;tsout);
out = PGTYPEStimestamp_to_asc(&#38;tsout);
printf("Started + duration: %s\n", out);
free(out);</PRE><P>
</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-PGTYPES-NUMERIC">33.6.1. 数值类型</A></H2><P> 数值类型提供任意精度的计算。
参见<A HREF="datatype-numeric.html">第 8.1 &#33410;</A>
获取<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器等价类型。
由于任意精度这一变量需要能够扩展和动态收缩。
那就是你只能在堆上创建数值变量的原因，
通过<CODE CLASS="FUNCTION">PGTYPESnumeric_new</CODE>和<CODE CLASS="FUNCTION">PGTYPESnumeric_free</CODE>函数。
和十进制类型类似但精确度有限，可以在栈中创建也可以在堆上创建。</P><P>
下列函数用于处理数值类型：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_new</CODE></DT><DD><P>
请求一个新分配的数值变量的指针。
</P><PRE CLASS="SYNOPSIS">numeric *PGTYPESnumeric_new(void);</PRE><P>
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_free</CODE></DT><DD><P>
任意数值类型释放所有内存。
</P><PRE CLASS="SYNOPSIS">void PGTYPESnumeric_free(numeric *var);</PRE><P>
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_from_asc</CODE></DT><DD><P>
从字符串标号解析数值类型。
</P><PRE CLASS="SYNOPSIS">numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);</PRE><P>
有效格式比如：<TT CLASS="LITERAL">-2</TT>,
<TT CLASS="LITERAL">.794</TT>,
<TT CLASS="LITERAL">+3.44</TT>,
<TT CLASS="LITERAL">592.49E07</TT>或者
<TT CLASS="LITERAL">-32.84e-4</TT>。
如果值解析不成功，返回一个有效指针，否则空指针。
此刻ECPG总是解析完整的字符串，
所以目前不支持存储在<TT CLASS="LITERAL">*endptr</TT>第一无效字符的地址。
你可以安全地设置<TT CLASS="LITERAL">endptr</TT>为空。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_to_asc</CODE></DT><DD><P>
返回一个指向字符串的指针，
该字符串是通过<CODE CLASS="FUNCTION">malloc</CODE>包
含数值类型<TT CLASS="LITERAL">num</TT>的字符串表示形式分配的。
</P><PRE CLASS="SYNOPSIS">char *PGTYPESnumeric_to_asc(numeric *num, int dscale);</PRE><P>
如果必要的话，数值类型的值将带有<TT CLASS="LITERAL">dscale</TT>小数位数舍入。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_add</CODE></DT><DD><P>
添加两个数值变量到三分之一。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);</PRE><P>
函数添加变量<TT CLASS="LITERAL">var1</TT>和
<TT CLASS="LITERAL">var2</TT>到结果变量<TT CLASS="LITERAL">result</TT>中。
函数成功时返回0，错误情况下返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_sub</CODE></DT><DD><P>
减去两个数值变量并且返回三分之一结果。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);</PRE><P>
函数从变量<TT CLASS="LITERAL">var1</TT>中减去变量<TT CLASS="LITERAL">var2</TT>。
操作的结果被存储在变量<TT CLASS="LITERAL">result</TT>中。
函数成功时返回0，并且错误的情况下返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_mul</CODE></DT><DD><P>
两个数值变量相乘，并且返回三分之一结果。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);</PRE><P>
函数将变量<TT CLASS="LITERAL">var1</TT>和
<TT CLASS="LITERAL">var2</TT>相乘。操作的结果被存储在变量<TT CLASS="LITERAL">result</TT>中。
函数成功时返回0，并且错误的情况下返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_div</CODE></DT><DD><P>
两个数值变量相除并且返回三分之一结果。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);</PRE><P>
函数将变量<TT CLASS="LITERAL">var1</TT>除以变量<TT CLASS="LITERAL">var2</TT>。
操作的结果被存储在变量<TT CLASS="LITERAL">result</TT>中。
函数成功时返回0并且错误的情况下返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_cmp</CODE></DT><DD><P>
比较两个数值变量。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)</PRE><P>
这个函数比较两个数值变量。在错误的情况下，返回<TT CLASS="LITERAL">INT_MAX</TT>。
成功，函数返回三个可能结果之一：
<P></P></P><UL><LI><P>
如果<TT CLASS="LITERAL">var1</TT>大于<TT CLASS="LITERAL">var2</TT>,则返回1。
</P></LI><LI><P> 如果<TT CLASS="LITERAL">var1</TT>小于<TT CLASS="LITERAL">var2</TT>,则返回-1。</P></LI><LI><P> 如果<TT CLASS="LITERAL">var1</TT>等于<TT CLASS="LITERAL">var2</TT>,则返回0。</P></LI></UL><P>
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_from_int</CODE></DT><DD><P>
转换一个int变量到数值变量。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_from_int(signed int int_val, numeric *var);</PRE><P>
这个函数接受有符号整型变量并将其存储在数值变量<TT CLASS="LITERAL">var</TT>中，
成功时，则返回0。在失败的情况下，返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_from_long</CODE></DT><DD><P>
转换长整型变量到数值变量。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);</PRE><P>
这个函数接受有符号长整型变量并将其存储在数值变量<TT CLASS="LITERAL">var</TT>中，成功时，
则返回0。在失败的情况下，返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_copy</CODE></DT><DD><P>
拷贝一个数值变量为另一个变量。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_copy(numeric *src, numeric *dst);</PRE><P>
这个函数拷贝变量的值，这个变量是<TT CLASS="LITERAL">src</TT>指向<TT CLASS="LITERAL">dst</TT>指向的变量，
成功时返回0，错误的情况下返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_from_double</CODE></DT><DD><P>
将double类型的变量转换成数值类型的。
</P><PRE CLASS="SYNOPSIS">int  PGTYPESnumeric_from_double(double d, numeric *dst);</PRE><P>
这个函数接受double变量并将其结果存储在<TT CLASS="LITERAL">dst</TT>指向的变量中，
成功时，则返回0。在失败的情况下，返回-1。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_to_double</CODE></DT><DD><P>
将数值类型变量转换成double类型的。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_to_double(numeric *nv, double *dp)</PRE><P>
这个函数从变量中转换数值类型的值，
这个变量是<TT CLASS="LITERAL">nv</TT>指向的<TT CLASS="LITERAL">dp</TT>指向的double变量，
成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
全局变量<TT CLASS="LITERAL">errno</TT>将额外设置<TT CLASS="LITERAL">PGTYPES_NUM_OVERFLOW</TT>。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_to_int</CODE></DT><DD><P>
将数值类型变量转化成整型。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_to_int(numeric *nv, int *ip);</PRE><P>
这个函数从变量中转换数值类型的值，这个变量是<TT CLASS="LITERAL">nv</TT>指向的<TT CLASS="LITERAL">ip</TT>指向的整型变量，
成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
全局变量<TT CLASS="LITERAL">errno</TT>将额外设置<TT CLASS="LITERAL">PGTYPES_NUM_OVERFLOW</TT>。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_to_long</CODE></DT><DD><P>
将数值类型的变量转换成long类型。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_to_long(numeric *nv, long *lp);</PRE><P>
这个函数从变量中转换数值类型的值，这个变量是<TT CLASS="LITERAL">nv</TT>指向的<TT CLASS="LITERAL">lp</TT>指向的长整型变量，
成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
全局变量<TT CLASS="LITERAL">errno</TT>将额外设置<TT CLASS="LITERAL">PGTYPES_NUM_OVERFLOW</TT>。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_to_decimal</CODE></DT><DD><P>
将数值类型的变量转换成十进制类型。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);</PRE><P>
这个函数从变量中转换数值类型的值，这个变量是<TT CLASS="LITERAL">src</TT>指向的
<TT CLASS="LITERAL">dst</TT>指向的十进制变量，
成功时返回0，错误的情况下返回-1，包括溢出。溢出的时候，
全局变量<TT CLASS="LITERAL">errno</TT>将额外设置<TT CLASS="LITERAL">PGTYPES_NUM_OVERFLOW</TT>。
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESnumeric_from_decimal</CODE></DT><DD><P>
将十进制类型的变量转换成数值类型。
</P><PRE CLASS="SYNOPSIS">int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);</PRE><P>
这个函数从变量中转换十进制值，这个变量是<TT CLASS="LITERAL">src</TT>指向的<TT CLASS="LITERAL">dst</TT>指向的数值变量，
成功时返回0，错误的情况下返回-1，包括溢出。
由于十进制类型作为数值类型的有限版本实现的，不会发生这种转换溢出。
</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-PGTYPES-DATE">33.6.2. 日期类型</A></H2><P> C中的日期类型允许你的程序处理SQL类型的数据。参见<A HREF="datatype-datetime.html">第 8.5 &#33410;</A>
获得<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器的等价类型。</P><P>
下面的函数可以适用于日期类型：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="PGTYPESDATEFROMTIMESTAMP"></A><CODE CLASS="FUNCTION">PGTYPESdate_from_timestamp</CODE></DT><DD><P>
从一个时间戳中提取日期部分。
</P><PRE CLASS="SYNOPSIS">date PGTYPESdate_from_timestamp(timestamp dt);</PRE><P>
这个函数接受一个时间戳作为其唯一的参数,并且从时间戳返回提取日期部分。
</P></DD><DT><A NAME="PGTYPESDATEFROMASC"></A><CODE CLASS="FUNCTION">PGTYPESdate_from_asc</CODE></DT><DD><P>
从文本表示解析日期。
</P><PRE CLASS="SYNOPSIS">date PGTYPESdate_from_asc(char *str, char **endptr);</PRE><P>
函数接收C char*字符串<TT CLASS="LITERAL">str</TT>和指向C char*字符串<TT CLASS="LITERAL">endptr</TT>的指针。
此刻ECPG总是解析完整的字符串，
所以目前不支持存储在<TT CLASS="LITERAL">*endptr</TT>中的第一无效字符的地址。
你可以安全地设置<TT CLASS="LITERAL">endptr</TT>无效。
</P><P> 注意，函数始终假定MDY格式化日期目前在ECPG还没有改变。</P><P> <A HREF="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FROM-ASC-TABLE">&#34920; 33-2</A>显示了允许输入格式。</P><DIV CLASS="TABLE"><A NAME="ECPG-PGTYPESDATE-FROM-ASC-TABLE"></A><P><B>&#34920; 33-2. <CODE CLASS="FUNCTION">PGTYPESdate_from_asc</CODE>有效输入格式</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>输入</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">1999-01-08</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">1/8/1999</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">1/18/1999</TT></TD><TD><TT CLASS="LITERAL">January 18, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">01/02/03</TT></TD><TD><TT CLASS="LITERAL">February 1, 2003</TT></TD></TR><TR><TD><TT CLASS="LITERAL">1999-Jan-08</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">Jan-08-1999</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">08-Jan-1999</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">99-Jan-08</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">08-Jan-99</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">08-Jan-06</TT></TD><TD><TT CLASS="LITERAL">January 8, 2006</TT></TD></TR><TR><TD><TT CLASS="LITERAL">Jan-08-99</TT></TD><TD><TT CLASS="LITERAL">January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">19990108</TT></TD><TD><TT CLASS="LITERAL">ISO 8601; January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">990108</TT></TD><TD><TT CLASS="LITERAL">ISO 8601; January 8, 1999</TT></TD></TR><TR><TD><TT CLASS="LITERAL">1999.008</TT></TD><TD><TT CLASS="LITERAL">year and day of year</TT></TD></TR><TR><TD><TT CLASS="LITERAL">J2451187</TT></TD><TD><TT CLASS="LITERAL">Julian day</TT></TD></TR><TR><TD><TT CLASS="LITERAL">January 8, 99 BC</TT></TD><TD><TT CLASS="LITERAL">year 99 before the Common Era</TT></TD></TR></TBODY></TABLE></DIV></DD><DT><A NAME="PGTYPESDATETOASC"></A><CODE CLASS="FUNCTION">PGTYPESdate_to_asc</CODE></DT><DD><P>
返回一个数据变量的文本表示。
</P><PRE CLASS="SYNOPSIS">char *PGTYPESdate_to_asc(date dDate);</PRE><P>
函数接收日期<TT CLASS="LITERAL">dDate</TT>作为它唯一参数。
输出数据的形式<TT CLASS="LITERAL">1999-01-18</TT>，即<TT CLASS="LITERAL">YYYY-MM-DD</TT>格式。
</P></DD><DT><A NAME="PGTYPESDATEJULMDY"></A><CODE CLASS="FUNCTION">PGTYPESdate_julmdy</CODE></DT><DD><P>
从一个日期型的变量中提取一天、本月和一年的值。
</P><PRE CLASS="SYNOPSIS">void PGTYPESdate_julmdy(date d, int *mdy);</PRE><P>
函数接收日期<TT CLASS="LITERAL">d</TT>和一个指向3个整型值<TT CLASS="LITERAL">mdy</TT>数组的指针。
变量名称显示顺序：<TT CLASS="LITERAL">mdy[0]</TT>设置为包含的几个月份，
<TT CLASS="LITERAL">mdy[1]</TT>设置为一天的值，<TT CLASS="LITERAL">mdy[2]</TT>包含一年的值。
</P></DD><DT><A NAME="PGTYPESDATEMDYJUL"></A><CODE CLASS="FUNCTION">PGTYPESdate_mdyjul</CODE></DT><DD><P>
从指定日期的年、月、日的3个整型值数组中创建一个日期值。
</P><PRE CLASS="SYNOPSIS">void PGTYPESdate_mdyjul(int *mdy, date *jdate);</PRE><P>
函数接收3个整型(<TT CLASS="LITERAL">mdy</TT>)的数组作为第一个参数，
第二个参数是指向保留运算结果的日期型变量的指针。
</P></DD><DT><A NAME="PGTYPESDATEDAYOFWEEK"></A><CODE CLASS="FUNCTION">PGTYPESdate_dayofweek</CODE></DT><DD><P>
返回表示日期值的一个星期数。
</P><PRE CLASS="SYNOPSIS">int PGTYPESdate_dayofweek(date d);</PRE><P>
函数接收日期变量<TT CLASS="LITERAL">d</TT>作为其唯一的参数，
并返回一个整数，表示这个日期的本周的一天。
<P></P></P><UL><LI><P>
0 - 星期日
</P></LI><LI><P> 1 - 星期一</P></LI><LI><P> 2 - 星期二</P></LI><LI><P> 3 - 星期三</P></LI><LI><P> 4 - 星期四</P></LI><LI><P> 5 – 星期五</P></LI><LI><P> 6 – 星期六</P></LI></UL><P>
</P></DD><DT><A NAME="PGTYPESDATETODAY"></A><CODE CLASS="FUNCTION">PGTYPESdate_today</CODE></DT><DD><P>
得到当前日期。
</P><PRE CLASS="SYNOPSIS">void PGTYPESdate_today(date *d);</PRE><P>
函数接收指向日期变量(<TT CLASS="LITERAL">d</TT>)的一个指针，它设置当前的日期。
</P></DD><DT><A NAME="PGTYPESDATEFMTASC"></A><CODE CLASS="FUNCTION">PGTYPESdate_fmt_asc</CODE></DT><DD><P>
将日期类型变量转换成使用格式掩码的文本表示形式。
</P><PRE CLASS="SYNOPSIS">int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);</PRE><P>
函数接收一个转换(<TT CLASS="LITERAL">dDate</TT>)日期，
格式掩码(<TT CLASS="LITERAL">fmtstring</TT>)以及保持日期(<TT CLASS="LITERAL">outbuf</TT>)文本表示形式的字符串。
</P><P> 成功的时候返回0，如果产生错误则返回负数。</P><P>
下列是你可以使用的字段分类符：
<P></P></P><UL><LI><P>
<TT CLASS="LITERAL">dd</TT> - 某月的天数。
</P></LI><LI><P> <TT CLASS="LITERAL">mm</TT> -某年的月数。</P></LI><LI><P> <TT CLASS="LITERAL">yy</TT> - 2位数的年数。</P></LI><LI><P> <TT CLASS="LITERAL">yyyy</TT> -4位数的年数。</P></LI><LI><P> <TT CLASS="LITERAL">ddd</TT> - 某天的名字（缩略）。</P></LI><LI><P> <TT CLASS="LITERAL">mmm</TT> - 某月份名字（缩略）。</P></LI></UL><P>
所有其它的字符按1:1复制到输出字符串中。
</P><P> <A HREF="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE">&#34920; 33-3</A>表示一些可能的格式。
这将让你知道如何使用这些功能。所有输出行基于相同的日期：1959年11月23号。</P><DIV CLASS="TABLE"><A NAME="ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE"></A><P><B>&#34920; 33-3. <CODE CLASS="FUNCTION">PGTYPESdate_fmt_asc</CODE>有效输入格式</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>格式</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">mmddyy</TT></TD><TD><TT CLASS="LITERAL">112359</TT></TD></TR><TR><TD><TT CLASS="LITERAL">ddmmyy</TT></TD><TD><TT CLASS="LITERAL">231159</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yymmdd</TT></TD><TD><TT CLASS="LITERAL">591123</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yy/mm/dd</TT></TD><TD><TT CLASS="LITERAL">59/11/23</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yy mm dd</TT></TD><TD><TT CLASS="LITERAL">59 11 23</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yy.mm.dd</TT></TD><TD><TT CLASS="LITERAL">59.11.23</TT></TD></TR><TR><TD><TT CLASS="LITERAL">.mm.yyyy.dd.</TT></TD><TD><TT CLASS="LITERAL">.11.1959.23.</TT></TD></TR><TR><TD><TT CLASS="LITERAL">mmm. dd, yyyy</TT></TD><TD><TT CLASS="LITERAL">Nov. 23, 1959</TT></TD></TR><TR><TD><TT CLASS="LITERAL">mmm dd yyyy</TT></TD><TD><TT CLASS="LITERAL">Nov 23 1959</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yyyy dd mm</TT></TD><TD><TT CLASS="LITERAL">1959 23 11</TT></TD></TR><TR><TD><TT CLASS="LITERAL">ddd, mmm. dd, yyyy</TT></TD><TD><TT CLASS="LITERAL">Mon, Nov. 23, 1959</TT></TD></TR><TR><TD><TT CLASS="LITERAL">(ddd) mmm. dd, yyyy</TT></TD><TD><TT CLASS="LITERAL">(Mon) Nov. 23, 1959</TT></TD></TR></TBODY></TABLE></DIV></DD><DT><A NAME="PGTYPESDATEDEFMTASC"></A><CODE CLASS="FUNCTION">PGTYPESdate_defmt_asc</CODE></DT><DD><P>
使用格式掩码转换C <TT CLASS="TYPE">char*</TT>到日期类型的值。
</P><PRE CLASS="SYNOPSIS">int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);</PRE><P>
函数接收一个指向保持操作(<TT CLASS="LITERAL">d</TT>)结果的日期值的指针，
解析日期(<TT CLASS="LITERAL">fmt</TT>)的格式掩码以及包含日期(<TT CLASS="LITERAL">str</TT>)文本表示的C char*字符串。
希望文本表示匹配格式掩码。但是你不需要字符串1:1映射到格式掩码。
这个函数仅分析相继顺序，
并且查找<TT CLASS="LITERAL">yy</TT>或者<TT CLASS="LITERAL">yyyy</TT>显示年的位置，
<TT CLASS="LITERAL">mm</TT>显示月的位置，<TT CLASS="LITERAL">dd</TT>显示一天的位置。
</P><P> <A HREF="ecpg-pgtypes.html#ECPG-RDEFMTDATE-EXAMPLE-TABLE">&#34920; 33-4</A>表明一些可能的格式。
这将让你知道如果使用这个函数。</P><DIV CLASS="TABLE"><A NAME="ECPG-RDEFMTDATE-EXAMPLE-TABLE"></A><P><B>&#34920; 33-4. <CODE CLASS="FUNCTION">rdefmtdate</CODE>有效输入格式</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>格式</TH><TH>字符串</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">ddmmyy</TT></TD><TD><TT CLASS="LITERAL">21-2-54</TT></TD><TD><TT CLASS="LITERAL">1954-02-21</TT></TD></TR><TR><TD><TT CLASS="LITERAL">ddmmyy</TT></TD><TD><TT CLASS="LITERAL">2-12-54</TT></TD><TD><TT CLASS="LITERAL">1954-12-02</TT></TD></TR><TR><TD><TT CLASS="LITERAL">ddmmyy</TT></TD><TD><TT CLASS="LITERAL">20111954</TT></TD><TD><TT CLASS="LITERAL">1954-11-20</TT></TD></TR><TR><TD><TT CLASS="LITERAL">ddmmyy</TT></TD><TD><TT CLASS="LITERAL">130464</TT></TD><TD><TT CLASS="LITERAL">1964-04-13</TT></TD></TR><TR><TD><TT CLASS="LITERAL">mmm.dd.yyyy</TT></TD><TD><TT CLASS="LITERAL">MAR-12-1967</TT></TD><TD><TT CLASS="LITERAL">1967-03-12</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yy/mm/dd</TT></TD><TD><TT CLASS="LITERAL">1954, February 3rd</TT></TD><TD><TT CLASS="LITERAL">1954-02-03</TT></TD></TR><TR><TD><TT CLASS="LITERAL">mmm.dd.yyyy</TT></TD><TD><TT CLASS="LITERAL">041269</TT></TD><TD><TT CLASS="LITERAL">1969-04-12</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yy/mm/dd</TT></TD><TD><TT CLASS="LITERAL">在2525年，7月28号人类仍存活。</TT></TD><TD><TT CLASS="LITERAL">2525-07-28</TT></TD></TR><TR><TD><TT CLASS="LITERAL">dd-mm-yy</TT></TD><TD><TT CLASS="LITERAL">2525年7月28号</TT></TD><TD><TT CLASS="LITERAL">2525-07-28</TT></TD></TR><TR><TD><TT CLASS="LITERAL">mmm.dd.yyyy</TT></TD><TD><TT CLASS="LITERAL">9/14/58</TT></TD><TD><TT CLASS="LITERAL">1958-09-14</TT></TD></TR><TR><TD><TT CLASS="LITERAL">yy/mm/dd</TT></TD><TD><TT CLASS="LITERAL">47/03/29</TT></TD><TD><TT CLASS="LITERAL">1947-03-29</TT></TD></TR><TR><TD><TT CLASS="LITERAL">mmm.dd.yyyy</TT></TD><TD><TT CLASS="LITERAL">oct 28 1975</TT></TD><TD><TT CLASS="LITERAL">1975-10-28</TT></TD></TR><TR><TD><TT CLASS="LITERAL">mmddyy</TT></TD><TD><TT CLASS="LITERAL">Nov 14th, 1985</TT></TD><TD><TT CLASS="LITERAL">1985-11-14</TT></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-PGTYPES-TIMESTAMP">33.6.3. 时间戳类型</A></H2><P> C中时间戳类型允许你的程序处理SQL类型时间戳数据。
参见<A HREF="datatype-datetime.html">第 8.5 &#33410;</A>
获取关于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器的等价类型。</P><P>
下面的函数可以用于时间戳类型。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="PGTYPESTIMESTAMPFROMASC"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_from_asc</CODE></DT><DD><P>
将文本表示的时间戳解析成一个时间戳变量。
</P><PRE CLASS="SYNOPSIS">timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);</PRE><P>
函数接收一个解析(<TT CLASS="LITERAL">str</TT>)字符串和指向C char*(<TT CLASS="LITERAL">endptr</TT>)指针。
此刻ECPG总是解析完整字符串，
因此它目前不支持存储<TT CLASS="LITERAL">*endptr</TT>中第一无效字符地址。
你可以安全地设置<TT CLASS="LITERAL">endptr</TT>为空。
</P><P> 成功时函数返回解析的时间戳，产生错误时返回<TT CLASS="LITERAL">PGTYPESInvalidTimestamp</TT>，
并且设置<TT CLASS="VARNAME">errno</TT>为<TT CLASS="LITERAL">PGTYPES_TS_BAD_TIMESTAMP</TT>。
参见<A HREF="ecpg-pgtypes.html#PGTYPESINVALIDTIMESTAMP"><I CLASS="TERM"><TT CLASS="LITERAL">PGTYPESInvalidTimestamp</TT></I></A>获取这个值的重要注释。</P><P> 一般情况下，输入的字符串可以包含一个所允许日期规范、
一个空格字符和允许的时间规范的任意组合。请注意，ECPG不支持时区。
它可以解析它们，但不适用于任何计算比如<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器。
时区说明符默认是省略的。</P><P> <A HREF="ecpg-pgtypes.html#ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE">&#34920; 33-5</A>包含输入字符串的一些例子。</P><DIV CLASS="TABLE"><A NAME="ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE"></A><P><B>&#34920; 33-5. <CODE CLASS="FUNCTION">PGTYPEStimestamp_from_asc</CODE>有效输入格式</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>输入</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">1999-01-08 04:05:06</TT></TD><TD><TT CLASS="LITERAL">1999-01-08 04:05:06</TT></TD></TR><TR><TD><TT CLASS="LITERAL">January 8 04:05:06 1999 PST</TT></TD><TD><TT CLASS="LITERAL">1999-01-08 04:05:06</TT></TD></TR><TR><TD><TT CLASS="LITERAL">1999-Jan-08 04:05:06.789-8</TT></TD><TD><TT CLASS="LITERAL">1999-01-08 04:05:06.789 (忽略时区说明符)</TT></TD></TR><TR><TD><TT CLASS="LITERAL">J2451187 04:05-08:00</TT></TD><TD><TT CLASS="LITERAL">1999-01-08 04:05:00 (忽略时区说明符)</TT></TD></TR></TBODY></TABLE></DIV></DD><DT><A NAME="PGTYPESTIMESTAMPTOASC"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_to_asc</CODE></DT><DD><P>
将日期转换成C char*字符串。
</P><PRE CLASS="SYNOPSIS">char *PGTYPEStimestamp_to_asc(timestamp tstamp);</PRE><P>
函数接收时间戳<TT CLASS="LITERAL">tstamp</TT>作为其唯一的参数
并返回一个包含时间戳的文本表示的分配的字符串。
</P></DD><DT><A NAME="PGTYPESTIMESTAMPCURRENT"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_current</CODE></DT><DD><P>
获取当前时间戳。
</P><PRE CLASS="SYNOPSIS">void PGTYPEStimestamp_current(timestamp *ts);</PRE><P>
该函数获取当前时间戳，并且将它保存到<TT CLASS="LITERAL">ts</TT>指向
的时间戳变量中。
</P></DD><DT><A NAME="PGTYPESTIMESTAMPFMTASC"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_fmt_asc</CODE></DT><DD><P>
使用格式掩码将时间戳变量转换为C char*。
</P><PRE CLASS="SYNOPSIS">int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);</PRE><P>
这个函数接受一个指向时间戳转换为它的第一个参数(<TT CLASS="LITERAL">ts</TT>)的指针，
一个指向缓冲输出(<TT CLASS="LITERAL">output</TT>)，
最大长度已为输出缓冲区(<TT CLASS="LITERAL">str_len</TT>)分配，
并且为转换(<TT CLASS="LITERAL">fmtstr</TT>)设置掩码格式的指针。
</P><P> 一旦成功，该函数返回0，如果产生错误，则返回负值。</P><P>
你可以为格式掩码使用以下的格式分类符。
格式分类符是和<SPAN CLASS="PRODUCTNAME">libc</SPAN>的<CODE CLASS="FUNCTION">strftime</CODE>
函数中使用的相同的。
任何非格式分类符将被复制到输出缓冲区。
<P></P></P><UL><LI><P>
<TT CLASS="LITERAL">%A</TT> - 是由工作日全称的国家表示形式替换。
</P></LI><LI><P> <TT CLASS="LITERAL">%a</TT> - 是由工作日名称缩写的国家表示形式替换。</P></LI><LI><P> <TT CLASS="LITERAL">%B</TT> - 是由月份名的全称的国家表示形式替换。</P></LI><LI><P> <TT CLASS="LITERAL">%b</TT> - 是由月份名称缩写的国家表示形式替换。</P></LI><LI><P> <TT CLASS="LITERAL">%C</TT> - 通过（年/100）作为十进制数替换；单位数前边加零。</P></LI><LI><P> <TT CLASS="LITERAL">%c</TT> - 由时间和日期的国家表示形式替换。</P></LI><LI><P> <TT CLASS="LITERAL">%D</TT> - 等同于<TT CLASS="LITERAL">%m/%d/%y</TT>。</P></LI><LI><P> <TT CLASS="LITERAL">%d</TT> - 作为十进制数（01-31）按当月的一天替换。</P></LI><LI><P> <TT CLASS="LITERAL">%E*</TT> <TT CLASS="LITERAL">%O*</TT> - POSIX区域扩展。
序列<TT CLASS="LITERAL">%Ec</TT>
<TT CLASS="LITERAL">%EC</TT>
<TT CLASS="LITERAL">%Ex</TT>
<TT CLASS="LITERAL">%EX</TT>
<TT CLASS="LITERAL">%Ey</TT>
<TT CLASS="LITERAL">%EY</TT>
<TT CLASS="LITERAL">%Od</TT>
<TT CLASS="LITERAL">%Oe</TT>
<TT CLASS="LITERAL">%OH</TT>
<TT CLASS="LITERAL">%OI</TT>
<TT CLASS="LITERAL">%Om</TT>
<TT CLASS="LITERAL">%OM</TT>
<TT CLASS="LITERAL">%OS</TT>
<TT CLASS="LITERAL">%Ou</TT>
<TT CLASS="LITERAL">%OU</TT>
<TT CLASS="LITERAL">%OV</TT>
<TT CLASS="LITERAL">%Ow</TT>
<TT CLASS="LITERAL">%OW</TT>
<TT CLASS="LITERAL">%Oy</TT>应该提供替代表示形式。</P><P> 此外，实现的<TT CLASS="LITERAL">%OB</TT>代表可选月份名字
（独立使用，没有提及天）。 </P></LI><LI><P> <TT CLASS="LITERAL">%e</TT> -作为十进制数（1-31）按当月的一天替换；
单位数前面有空格。</P></LI><LI><P> <TT CLASS="LITERAL">%F</TT> - 等同于<TT CLASS="LITERAL">%Y-%m-%d</TT>。</P></LI><LI><P> <TT CLASS="LITERAL">%G</TT> - 以每年作为一个世纪的十进制数替换。
今年是包含一周的大部分中的一个（星期一作为一周的第一天）。</P></LI><LI><P> <TT CLASS="LITERAL">%g</TT> - 由<TT CLASS="LITERAL">%G</TT>中的同一年替换，
但作为一个没有世纪（00-99）的十进制数。</P></LI><LI><P> <TT CLASS="LITERAL">%H</TT> - 作为十进制数（00-23）按小时（24小时）进行替换。</P></LI><LI><P> <TT CLASS="LITERAL">%h</TT> -等同于<TT CLASS="LITERAL">%b</TT>。</P></LI><LI><P> <TT CLASS="LITERAL">%I</TT> - 作为十进制数（01-12）按小时（12小时）进行替换。 </P></LI><LI><P> <TT CLASS="LITERAL">%j</TT> - 作为十进制数（001-366）按一年的一天来替换。</P></LI><LI><P> <TT CLASS="LITERAL">%k</TT> - 作为十进制数（0-23）按小时（24小时）替换；
单位数前面有空格。</P></LI><LI><P> <TT CLASS="LITERAL">%l</TT> - 作为十进制数（1-12）按小时（12小时）替换；
单位数前面有空格。</P></LI><LI><P> <TT CLASS="LITERAL">%M</TT> - 作为十进制数（00-59）按分钟来替换。</P></LI><LI><P> <TT CLASS="LITERAL">%m</TT> - 作为十进制数（01-12）按月替换。</P></LI><LI><P> <TT CLASS="LITERAL">%n</TT> - 通过换行符替换。</P></LI><LI><P> <TT CLASS="LITERAL">%O*</TT> - 等同于<TT CLASS="LITERAL">%E*</TT>。</P></LI><LI><P> <TT CLASS="LITERAL">%p</TT> - 由合适的<SPAN CLASS="QUOTE">"午前"</SPAN>或<SPAN CLASS="QUOTE">"午后"</SPAN>的国家表示形式进行替换。</P></LI><LI><P> <TT CLASS="LITERAL">%R</TT> - 等同于<TT CLASS="LITERAL">%H:%M</TT>。</P></LI><LI><P> <TT CLASS="LITERAL">%r</TT> - 等同于<TT CLASS="LITERAL">%I:%M:%S%p</TT></P></LI><LI><P> <TT CLASS="LITERAL">%S</TT> - 作为十进制数（00-60）按秒进行替换。</P></LI><LI><P> <TT CLASS="LITERAL">%s</TT> -通过Epoch, UTC以来的秒数替换。</P></LI><LI><P> <TT CLASS="LITERAL">%T</TT> - 等同于<TT CLASS="LITERAL">%H:%M:%S</TT>。</P></LI><LI><P> <TT CLASS="LITERAL">%t</TT> -通过制表符替换。</P></LI><LI><P> <TT CLASS="LITERAL">%U</TT> -按照十进制数（00-53）一年中的
周数取代（星期日作为一周的第一天）。</P></LI><LI><P> <TT CLASS="LITERAL">%u</TT> - 按照十进制数（1-7）工
作日取代（星期一作为一周的第一天）。</P></LI><LI><P> <TT CLASS="LITERAL">%V</TT> - 通过十进制数（01-53）一年
中的周数取代（星期一作为一周的第一天）。
如果在新的一年中包含一月一日的工作日有四天以上，
那么它是第1周；否则它是去年的最后一周，并且下一周是第1周。</P></LI><LI><P> <TT CLASS="LITERAL">%v</TT> - 等同于<TT CLASS="LITERAL">%e-%b-%Y</TT>。</P></LI><LI><P> <TT CLASS="LITERAL">%W</TT> - 通过十进制数（00-53）
一年的周数取代（星期一作为一周的第一天）。</P></LI><LI><P> <TT CLASS="LITERAL">%w</TT> - 通过十进制数（0-6）
工作日取代（星期日作为一周的第一天）。 </P></LI><LI><P> <TT CLASS="LITERAL">%X</TT> - 通过时间的国家表示形式取代。</P></LI><LI><P> <TT CLASS="LITERAL">%x</TT> - 通过日期的国家表示形式取代。</P></LI><LI><P> <TT CLASS="LITERAL">%Y</TT> - 通过十进制数世纪年来取代。 </P></LI><LI><P> <TT CLASS="LITERAL">%y</TT> - 通过十进制数（00-99）没有世纪的年来取代。</P></LI><LI><P> <TT CLASS="LITERAL">%Z</TT> - 由时区名称替换。</P></LI><LI><P> <TT CLASS="LITERAL">%z</TT> -通过UTC时区偏移量取代；
前导加号为UTC东部，减号为UTC西部，
小时和分钟各跟随着两位数，它们之间没有分隔符
（常见的形式为RFC 822日期标题）。</P></LI><LI><P> <TT CLASS="LITERAL">%+</TT> - 通过日期和时间的国家表示形式替换。</P></LI><LI><P> <TT CLASS="LITERAL">%-*</TT> - GNU libc扩展。当执行数值输出时不要做任何填充。</P></LI><LI><P> $_* - GNU libc扩展。明确声明空格填充。</P></LI><LI><P> <TT CLASS="LITERAL">%0*</TT> - GNU libc扩展。明确声明零填充。</P></LI><LI><P> <TT CLASS="LITERAL">%%</TT> - 通过<TT CLASS="LITERAL">%</TT>替换。</P></LI></UL><P>
</P></DD><DT><A NAME="PGTYPESTIMESTAMPSUB"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_sub</CODE></DT><DD><P>
从另外一个中减去一个时间戳，并且将结果保存在interval类型的变量中。
</P><PRE CLASS="SYNOPSIS">int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);</PRE><P>
该函数将减去时间戳变量，这个变量是<TT CLASS="LITERAL">ts2</TT>
指向的<TT CLASS="LITERAL">ts1</TT>指向的时间戳的变量，
并将结果存储在<TT CLASS="LITERAL">iv</TT>指向的时间戳变量中。
</P><P> 成功时，函数返回0。如果发生错误则返回一个负值。</P></DD><DT><A NAME="PGTYPESTIMESTAMPDEFMTASC"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_defmt_asc</CODE></DT><DD><P>
从使用格式掩码的文本表示中分析一个时间戳值。
</P><PRE CLASS="SYNOPSIS">int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);</PRE><P>
这个函数接受变量<TT CLASS="LITERAL">str</TT>时间戳的文本表示
以及格式掩码中使用的变量<TT CLASS="LITERAL">fmt</TT>。
结果将存储在<TT CLASS="LITERAL">d</TT>指向的变量中。
</P><P> 如果格式掩码<TT CLASS="LITERAL">fmt</TT>是空，
该函数将回落到缺省格式掩码<TT CLASS="LITERAL">%Y-%m-%d%H:%M:%S</TT>。</P><P> 这是<A HREF="ecpg-pgtypes.html#PGTYPESTIMESTAMPFMTASC"><I CLASS="TERM"><CODE CLASS="FUNCTION">PGTYPEStimestamp_fmt_asc</CODE></I></A>的反向函数。
参见文档找出可能的格式掩码项。</P></DD><DT><A NAME="PGTYPESTIMESTAMPADDINTERVAL"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_add_interval</CODE></DT><DD><P>
增加interval变量到timestamp变量。
</P><PRE CLASS="SYNOPSIS">int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);</PRE><P>
这个函数接受一个指向timestamp变量<TT CLASS="LITERAL">tin</TT>的指针，
一个指向interval变量<TT CLASS="LITERAL">span</TT>的指针。
它增加interval到timestamp，
并且将结果timestamp保存在<TT CLASS="LITERAL">tout</TT>指向的变量中。
</P><P> 成功时，这个函数返回0，如果产生错误，则返回一个负数。</P></DD><DT><A NAME="PGTYPESTIMESTAMPSUBINTERVAL"></A><CODE CLASS="FUNCTION">PGTYPEStimestamp_sub_interval</CODE></DT><DD><P>
从一个timestamp变量中减去interval变量。
</P><PRE CLASS="SYNOPSIS">int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);</PRE><P>
这个函数减去interval变量，这个变量是<TT CLASS="LITERAL">span</TT>
指向的<TT CLASS="LITERAL">tin</TT>指向的timestamp变量，
并且将结果存储在<TT CLASS="LITERAL">tout</TT>指向的变量中。
</P><P> 成功时，这个函数返回0。当产生错误的时候，返回负数。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-PGTYPES-INTERVAL">33.6.4. 区间类型</A></H2><P> C中区间类型允许你的程序处理SQL类型区间的数据。
参见<A HREF="datatype-datetime.html">第 8.5 &#33410;</A>获取
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器的等价类型。</P><P>
下面的函数可以用于区间类型：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="PGTYPESINTERVALNEW"></A><CODE CLASS="FUNCTION">PGTYPESinterval_new</CODE></DT><DD><P>
返回一个已分配的区间变量的指针。
</P><PRE CLASS="SYNOPSIS">interval *PGTYPESinterval_new(void);</PRE><P>
</P></DD><DT><A NAME="PGTYPESINTERVALFREE"></A><CODE CLASS="FUNCTION">PGTYPESinterval_free</CODE></DT><DD><P>
释放已经分配区间变量的内存。
</P><PRE CLASS="SYNOPSIS">void PGTYPESinterval_new(interval *intvl);</PRE><P>
</P></DD><DT><A NAME="PGTYPESINTERVALFROMASC"></A><CODE CLASS="FUNCTION">PGTYPESinterval_from_asc</CODE></DT><DD><P>
解析文本表示的区间。
</P><PRE CLASS="SYNOPSIS">interval *PGTYPESinterval_from_asc(char *str, char **endptr);</PRE><P>
该函数解析输入的字符串<TT CLASS="LITERAL">str</TT>并返回分配区间变量的指针。
此刻ECPG总是解析完整的字符串，所以目
前不支持存储在<TT CLASS="LITERAL">*endptr</TT>中的第一无效字符的地址。
你可以安全地设置<TT CLASS="LITERAL">endptr</TT>为空。
</P></DD><DT><A NAME="PGTYPESINTERVALTOASC"></A><CODE CLASS="FUNCTION">PGTYPESinterval_to_asc</CODE></DT><DD><P>
将类型区间的变量转换成它的文本表示。
</P><PRE CLASS="SYNOPSIS">char *PGTYPESinterval_to_asc(interval *span);</PRE><P>
该函数将转换<TT CLASS="LITERAL">span</TT>指向C char*的区间变量，
输出看起来像这样的例子：<TT CLASS="LITERAL">@ 1 day 12 hours 59 mins 10 secs</TT>。
</P></DD><DT><A NAME="PGTYPESINTERVALCOPY"></A><CODE CLASS="FUNCTION">PGTYPESinterval_copy</CODE></DT><DD><P>
复制区间类型的变量。
</P><PRE CLASS="SYNOPSIS">int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);</PRE><P>
该函数复制<TT CLASS="LITERAL">intvlsrc</TT>指向<TT CLASS="LITERAL">intvldest</TT>指向的区间变量，注意，
你需要在目标变量前分配内存。
</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-PGTYPES-DECIMAL">33.6.5. 十进制类型</A></H2><P> decimal类型和numeric类型是类似的。然而，
它仅仅是一个30位数的最大精度。相反，
numeric类型只能在堆上创建，decimal类型可以在栈或堆上创建
（通过函数<CODE CLASS="FUNCTION">PGTYPESdecimal_new</CODE>和
<CODE CLASS="FUNCTION">PGTYPESdecimal_free</CODE>）。
<A HREF="ecpg-informix-compat.html">第 33.15 &#33410;</A>中描述的
<SPAN CLASS="PRODUCTNAME">Informix</SPAN>兼容模式还有很多处
理decimal类型的其他函数。</P><P>
下面的函数可以用于decimal类型，不仅包含在<TT CLASS="LITERAL">libcompat</TT>库中。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><CODE CLASS="FUNCTION">PGTYPESdecimal_new</CODE></DT><DD><P>
请求一个新分配的decimal变量的指针。
</P><PRE CLASS="SYNOPSIS">decimal *PGTYPESdecimal_new(void);</PRE><P>
</P></DD><DT><CODE CLASS="FUNCTION">PGTYPESdecimal_free</CODE></DT><DD><P>
任意decimal类型，释放所有内存。
</P><PRE CLASS="SYNOPSIS">void PGTYPESdecimal_free(decimal *var);</PRE><P>
</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-PGTYPES-ERRNO">33.6.6. pgtypeslib的errno值</A></H2><P> <P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">PGTYPES_NUM_BAD_NUMERIC</TT></DT><DD><P>
参数应该包含一个数值变量（或者指向一个数值变量）
但事实上内存中表示是无效的。
</P></DD><DT><TT CLASS="LITERAL">PGTYPES_NUM_OVERFLOW</TT></DT><DD><P> 发生溢出。因为numeric类型可以处理几乎任意精度，
将一个numeric变量转换为其它类型可能导致溢出。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_NUM_UNDERFLOW</TT></DT><DD><P> 发生下溢。因为numeric类型可以处理几乎任意精度，
将一个numeric变量转换为其它类型可能导致下溢。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_NUM_DIVIDE_ZERO</TT></DT><DD><P> 尝试除以零。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_DATE_BAD_DATE</TT></DT><DD><P> 无效的日期字符串被传递给<CODE CLASS="FUNCTION">PGTYPESdate_from_asc</CODE>函数。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_DATE_ERR_EARGS</TT></DT><DD><P> 无效参数被传递给<CODE CLASS="FUNCTION">PGTYPESdate_defmt_asc</CODE>函数。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_DATE_ERR_ENOSHORTDATE</TT></DT><DD><P> 通过<CODE CLASS="FUNCTION">PGTYPESdate_defmt_asc</CODE>函数发现输入字符串中的无效标记。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_INTVL_BAD_INTERVAL</TT></DT><DD><P> 无效区间字符串被传递给<CODE CLASS="FUNCTION">PGTYPESinterval_from_asc</CODE>函数，
或者无效区间值被传递给<CODE CLASS="FUNCTION">PGTYPESinterval_to_asc</CODE>函数。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_DATE_ERR_ENOTDMY</TT></DT><DD><P> 在<CODE CLASS="FUNCTION">PGTYPESdate_defmt_asc</CODE>函数中日/月/年分配不匹配。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_DATE_BAD_DAY</TT></DT><DD><P> 通过<CODE CLASS="FUNCTION">PGTYPESdate_defmt_asc</CODE>函数发现某月值的无效天数。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_DATE_BAD_MONTH</TT></DT><DD><P> 通过<CODE CLASS="FUNCTION">PGTYPESdate_defmt_asc</CODE>函数发现无效月数值。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_TS_BAD_TIMESTAMP</TT></DT><DD><P> 无效的timestamp字符串被传递给<CODE CLASS="FUNCTION">PGTYPEStimestamp_from_asc</CODE>函数，
或者无效timestamp值被传递给<CODE CLASS="FUNCTION">PGTYPEStimestamp_to_asc</CODE>函数。</P></DD><DT><TT CLASS="LITERAL">PGTYPES_TS_ERR_EINFTIME</TT></DT><DD><P> 在环境中遇到的无限timestamp值不能处理它。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-PGTYPES-CONSTANTS">33.6.7. pgtypeslib的特殊常量</A></H2><P> <P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="PGTYPESINVALIDTIMESTAMP"></A><TT CLASS="LITERAL">PGTYPESInvalidTimestamp</TT></DT><DD><P>
代表一个无效的时间戳的timestamp类型的值。
这是通过函数<CODE CLASS="FUNCTION">PGTYPEStimestamp_from_asc</CODE>返回解析错误。
请注意，由于该<TT CLASS="TYPE">timestamp</TT>数据类型的内部表示，
同时<TT CLASS="LITERAL">PGTYPESInvalidTimestamp</TT>也是一个有效的timestamp。
它设置<TT CLASS="LITERAL">1899-12-31 23:59:59</TT>。为了检测错误，
确保你的应用每次调用<CODE CLASS="FUNCTION">PGTYPEStimestamp_from_asc</CODE>后
不仅测试<TT CLASS="LITERAL">PGTYPESInvalidTimestamp</TT>也能检测<TT CLASS="LITERAL">errno != 0</TT>。
</P></DD></DL></DIV><P>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="ecpg-dynamic.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="ecpg-descriptors.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">动态SQL</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/ecpg.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">使用描述符范围</TD></TR></TABLE></DIV></BODY></HTML>
