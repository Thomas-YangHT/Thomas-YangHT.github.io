<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>CREATE OPERATOR CLASS</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="CREATE OPERATOR" HREF="sql-createoperator.html"><LINK REL="NEXT" TITLE="CREATE OPERATOR FAMILY" HREF="sql-createopfamily.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/create_opclass.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="CREATE OPERATOR" HREF="sql-createoperator.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="CREATE OPERATOR FAMILY" HREF="sql-createopfamily.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-CREATEOPCLASS"></A>CREATE OPERATOR CLASS</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN71282"></A><H2>&#21517;&#31216;</H2>CREATE OPERATOR CLASS&nbsp;--&nbsp;定义一个新操作符类</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN71287"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">CREATE OPERATOR CLASS <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ DEFAULT ] FOR TYPE <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
>
  USING <TT
CLASS="REPLACEABLE"
><I
>index_method</I
></TT
> [ FAMILY <TT
CLASS="REPLACEABLE"
><I
>family_name</I
></TT
> ] AS
  {  OPERATOR <TT
CLASS="REPLACEABLE"
><I
>strategy_number</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator_name</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> ) ] [ FOR SEARCH | FOR ORDER BY <TT
CLASS="REPLACEABLE"
><I
>sort_family_name</I
></TT
> ]
   | FUNCTION <TT
CLASS="REPLACEABLE"
><I
>support_number</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> [ , <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> ] ) ] <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>argument_type</I
></TT
> [, ...] )
   | STORAGE <TT
CLASS="REPLACEABLE"
><I
>storage_type</I
></TT
>
  } [, ... ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71304"></A><H2>描述</H2><P><TT CLASS="COMMAND">CREATE OPERATOR CLASS</TT>定义一个新的操作符类。
一个操作符类定义一种特定的数据类型如何与一种索引一起使用。
操作符类声明特定的操作符可以为这种数据类型以及这种索引方法填充特定的角色或者
<SPAN CLASS="QUOTE">"策略"</SPAN>。操作符类还声明索引方法在为一个索引字段选定该操作符类的时候要
使用的支持过程。所有操作符类使用的函数和操作符都必须在创建操作符类之前定义。</P><P>如果给出了模式名字，那么操作符类就在指定的模式中创建。
否则就在当前模式中创建。在同一个模式中的两个操作符类可以有同样的名字，
但它们必须用于不同的索引方法。</P><P>定义操作符类的用户将成为其所有者。目前，创造者必须是超级用户。
做这样的限制是因为一个有问题的操作符类定义会让服务器困惑，甚至崩溃。</P><P><TT CLASS="COMMAND">CREATE OPERATOR CLASS</TT>
既不检查这个类定义是否包含所有索引方法需要的操作符以及函数，
也不检查这些操作符和函数是否形成一个自包含的集合。
定义一个合法的操作符类是用户的责任。</P><P>相关的操作符类可以集合成<I CLASS="FIRSTTERM">操作符族</I>。
添加一个新的操作符类到一个已经存在的操作符族，
在<TT CLASS="COMMAND">CREATE OPERATOR CLASS</TT>中指定<TT CLASS="LITERAL">FAMILY</TT>选项。
没有这个选项，新建的类会放置到与它同名的族中（如果不存在则创建它）。</P><P>参考<A HREF="xindex.html">第 35.14 &#33410;</A>获取更多信息。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71319"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>name</I></TT></DT><DD><P>将要创建的操作符类的名字(可以用模式修饰)。</P></DD><DT><TT CLASS="LITERAL">DEFAULT</TT></DT><DD><P>表示该操作符类将成为它的数据类型的缺省操作符类。
对于某个数据类型和访问方式而言，最多有一个操作符类是缺省的。</P></DD><DT><TT CLASS="REPLACEABLE"><I>data_type</I></TT></DT><DD><P>这个操作符类处理的字段的数据类型。</P></DD><DT><TT CLASS="REPLACEABLE"><I>index_method</I></TT></DT><DD><P>这个操作符类处理的索引方法的名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>family_name</I></TT></DT><DD><P>这个操作符类添加到的现有操作符族的名字。如果没有指定，
则使用与该操作符类相同名字的操作符族（如果不存在则创建它）。</P></DD><DT><TT CLASS="REPLACEABLE"><I>strategy_number</I></TT></DT><DD><P>一个操作符和这个操作符类关联的索引方法的策略数。</P></DD><DT><TT CLASS="REPLACEABLE"><I>operator_name</I></TT></DT><DD><P>一个和该操作符类关联的操作符的名字(可以用模式修饰)。</P></DD><DT><TT CLASS="REPLACEABLE"><I>op_type</I></TT></DT><DD><P>在<TT CLASS="LITERAL">OPERATOR</TT>子句中，该操作符的操作数的数据类型，
或者是<TT CLASS="LITERAL">NONE</TT>表示左目或者右目操作符。
通常情况下可以省略操作数的数据类型，因为这个时候它们和操作符类的数据类型相同。</P><P>在<TT CLASS="LITERAL">FUNCTION</TT>子句中，如果函数的操作数数据类型和函数的输入数据类型
（对于B-tree比较函数和哈希函数）或类的数据类型
（对于B-tree排序支持函数和所有在GiST、SP-GiST和GIN操作符类中的函数）不同，
那么就在该子句中写上这个函数要支持的操作数类型。这些缺省是正确的，
因此<TT CLASS="REPLACEABLE"><I>op_type</I></TT>
不需要在<TT CLASS="LITERAL">FUNCTION</TT>子句中指定，
除了B-tree排序支持函数支持交叉数据类型比较的情况。</P></DD><DT><TT CLASS="REPLACEABLE"><I>sort_family_name</I></TT></DT><DD><P>描述与排序操作符相关的排序顺序的现有<TT CLASS="LITERAL">btree</TT>
操作符族的名字（可以有模式修饰）。</P><P>如果既没有指定<TT CLASS="LITERAL">FOR SEARCH</TT>，也没有指定<TT CLASS="LITERAL">FOR ORDER BY</TT>，
那么缺省是<TT CLASS="LITERAL">FOR SEARCH</TT>。</P></DD><DT><TT CLASS="REPLACEABLE"><I>support_number</I></TT></DT><DD><P>索引方法对一个与操作符类关联的函数的支持过程数</P></DD><DT><TT CLASS="REPLACEABLE"><I>function_name</I></TT></DT><DD><P>一个函数的名字(可以有模式修饰)，这个函数是索引方法对此操作符类的支持过程。</P></DD><DT><TT CLASS="REPLACEABLE"><I>argument_type</I></TT></DT><DD><P>函数参数的数据类型。</P></DD><DT><TT CLASS="REPLACEABLE"><I>storage_type</I></TT></DT><DD><P>实际存储在索引里的数据类型。通常它和字段数据类型相同，
但是一些索引方法(目前是GiST和GIN)允许它是不同的。
除非索引方法允许使用一种不同的类型，否则必须省略<TT CLASS="LITERAL">STORAGE</TT>子句。</P></DD></DL></DIV><P><TT CLASS="LITERAL">OPERATOR</TT>、<TT CLASS="LITERAL">FUNCTION</TT>和<TT CLASS="LITERAL">STORAGE</TT>
子句可以按照任意顺序出现。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71403"></A><H2>注意</H2><P>因为索引机制不在使用函数前检查其访问机制，
在操作符类中包含操作符或者函数等价于授权给所有人执行权限。
这对于那些用于操作符类的函数通常不会导致什么问题。</P><P>操作符不应该用 SQL 函数定义。一个 SQL 函数很可能是内联到调用它的查询里面，
这样将阻止优化器识别这个查询是否可以使用索引。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4之前，<TT CLASS="LITERAL">OPERATOR</TT>
子句可以包括<TT CLASS="LITERAL">RECHECK</TT>选项。现在不再支持了，
因为一个索引操作符是否是<SPAN CLASS="QUOTE">"有损耗的"</SPAN>，现在是在运行时动态确定。
这允许高效的处理操作符有或没有损耗的情况。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71412"></A><H2>例子</H2><P>下面的例子命令为数据类型<TT CLASS="LITERAL">_int4</TT>(<TT CLASS="TYPE">int4</TT>数组)
定义了一个 GiST 索引操作符类。参阅<A HREF="intarray.html">intarray</A>模块获取完整的例子。</P><PRE CLASS="PROGRAMLISTING">CREATE OPERATOR CLASS gist__int_ops
    DEFAULT FOR TYPE _int4 USING gist AS
        OPERATOR        3       &amp;&amp;,
        OPERATOR        6       = (anyarray, anyarray),
        OPERATOR        7       @&gt;,
        OPERATOR        8       &lt;@,
        OPERATOR        20      @@ (_int4, query_int),
        FUNCTION        1       g_int_consistent (internal, _int4, int, oid, internal),
        FUNCTION        2       g_int_union (internal, internal),
        FUNCTION        3       g_int_compress (internal),
        FUNCTION        4       g_int_decompress (internal),
        FUNCTION        5       g_int_penalty (internal, internal, internal),
        FUNCTION        6       g_int_picksplit (internal, internal),
        FUNCTION        7       g_int_same (_int4, _int4, internal);</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71419"></A><H2>兼容性</H2><P><TT CLASS="COMMAND">CREATE OPERATOR CLASS</TT>是一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
扩展。在SQL标准中没有这个语句。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71424"></A><H2>又见</H2><A HREF="sql-alteropclass.html">ALTER OPERATOR CLASS</A>, <A HREF="sql-dropopclass.html">DROP OPERATOR CLASS</A>, <A HREF="sql-createopfamily.html">CREATE OPERATOR FAMILY</A>, <A HREF="sql-alteropfamily.html">ALTER OPERATOR FAMILY</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-createoperator.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-createopfamily.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">CREATE OPERATOR</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">CREATE OPERATOR FAMILY</TD></TR></TABLE></DIV></BODY></HTML>
