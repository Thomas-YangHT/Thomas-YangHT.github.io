<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>从Oracle PL/SQL进行移植</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PL/pgSQL - SQL过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html"><LINK REL="PREVIOUS" TITLE="开发PL/pgSQL的一些提示" HREF="plpgsql-development-tips.html"><LINK REL="NEXT" TITLE="PL/Tcl - Tcl 过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/pltcl.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/plpgsql.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="开发PL/pgSQL的一些提示" HREF="plpgsql-development-tips.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 40. <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN> - <ACRONYM CLASS="ACRONYM">SQL</ACRONYM>过程语言</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="PL/Tcl - Tcl 过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/pltcl.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PLPGSQL-PORTING">40.12. 从<SPAN CLASS="PRODUCTNAME">Oracle</SPAN> PL/SQL进行移植</A></H1><P> 本节解释了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>
和Oracle的<SPAN CLASS="APPLICATION">PL/SQL</SPAN>语言之间的差别，
希望能对那些从<SPAN CLASS="TRADEMARK">Oracle</SPAN>&reg;向
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>移植应用的人有所帮助。 </P><P>
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>与PL/SQL在许多方面都非常类似。
它是一种块结构的，祈使语气(命令性)的语言并且必须声明所有变量。
赋值、循环、条件等都很类似。在从<SPAN CLASS="APPLICATION">PL/SQL</SPAN>向
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>移植的时候必须记住一些事情：
<P></P></P><UL><LI><P>
如果一个SQL命令中使用的名字是一个表中的列名，或者是一个函数中变量的引用，
那么<SPAN CLASS="APPLICATION">PL/SQL</SPAN>会将它当作一个变量名。
这对应的是<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>的<TT CLASS="LITERAL">plpgsql.variable_conflict</TT> = <TT CLASS="LITERAL">use_column</TT>
动作（不是默认动作），
参考<A HREF="plpgsql-implementation.html#PLPGSQL-VAR-SUBST">第 40.10.1 &#33410;</A>中的描述。
首先，最好是避免这种模糊的方式，但如果不得不移植一个依赖于该动作的大量的代码，
那么设置<TT CLASS="LITERAL">variable_conflict</TT>是个不错的主意。
</P></LI><LI><P> 在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里，函数体必须写成字符串文本，
因此你需要使用美元符界定或者转义函数体里面的单引号(见<A HREF="plpgsql-development-tips.html#PLPGSQL-QUOTE-TIPS">第 40.11.1 &#33410;</A>)。</P></LI><LI><P> 应该用模式把函数组织成不同的组，而不是用包。</P></LI><LI><P> 因为没有包，所以也没有包级别的变量。这一点有时候挺讨厌。
你可以在临时表里保存会话级别的状态。</P></LI><LI><P> 带有<TT CLASS="LITERAL">REVERSE</TT>的整数的<TT CLASS="COMMAND">FOR</TT>循环的工作模式是不一样的：
<SPAN CLASS="APPLICATION">PL/SQL</SPAN>中是从第二个数向第一个数倒计，
而<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>是从第一个数想第二个数倒计，
因此在移植时，需要交换循环边界。
不幸的是这种不兼容性是不太可能改变的（参阅<A HREF="plpgsql-control-structures.html#PLPGSQL-INTEGER-FOR">第 40.6.3.5 &#33410;</A>）。</P></LI><LI><P> 遍历查询的<TT CLASS="COMMAND">FOR</TT>循环（而不是循环游标）同样有不同的工作模式：
必须已经声明了目标变量，在这一点上<SPAN CLASS="APPLICATION">PL/SQL</SPAN>通常是隐式的声明。
这样做的优点是，在退出循环后，仍然可以获得变量值。</P></LI><LI><P> 在使用游标变量方面，存在一些记数法差异。</P></LI></UL><P>
</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN59440">40.12.1. 移植样例</A></H2><P> <A HREF="plpgsql-porting.html#PGSQL-PORTING-EX1">&#20363; 40-8</A>演示了
如何从<SPAN CLASS="APPLICATION">PL/SQL</SPAN>向<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>移植一个简单的函数。</P><DIV CLASS="EXAMPLE"><A NAME="PGSQL-PORTING-EX1"></A><P><B>&#20363; 40-8. 从<SPAN CLASS="APPLICATION">PL/SQL</SPAN>向<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>移植一个简单的函数</B></P><P>
下面是一个<SPAN CLASS="PRODUCTNAME">Oracle</SPAN> <SPAN CLASS="APPLICATION">PL/SQL</SPAN>函数:
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURN varchar IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;</PRE><P>
</P><P>
让我们读一遍这个函数然后看<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>与之的不同：
<P></P></P><UL><LI><P>
在函数原型里的<TT CLASS="LITERAL">RETURN</TT>(不是函数体里的)关键字到了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里就
是<TT CLASS="LITERAL">RETURNS</TT>。还有，
<TT CLASS="LITERAL">IS</TT>变成<TT CLASS="LITERAL">AS</TT>，
并且你还需要增加一个<TT CLASS="LITERAL">LANGUAGE</TT>子句，
因为<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>并非唯一可用的函数语言。
</P></LI><LI><P> 在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里，函数体被认为是一个字符串文本，
所以你需要使用单引号或者美元符界定它，
这个包围符代替了Oracle 最后的那个<TT CLASS="LITERAL">/</TT>。</P></LI><LI><P> 在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里没有<TT CLASS="LITERAL">show errors</TT>命令，
不需要这个命令是因为错误是自动报告的。</P></LI></UL><P>
</P><P>
下面是这个函数移植到<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>之后的样子:
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;</PRE><P>
</P></DIV><P> <A HREF="plpgsql-porting.html#PLPGSQL-PORTING-EX2">&#20363; 40-9</A>演示了如何移植一个创建另外一个函数的函数的方法，
以及演示了如何处理引号转义的问题。</P><DIV CLASS="EXAMPLE"><A NAME="PLPGSQL-PORTING-EX2"></A><P><B>&#20363; 40-9. 从<SPAN CLASS="APPLICATION">PL/SQL</SPAN>向<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>移植一个创建其它函数的函数</B></P><P> 下面的过程从一个<TT CLASS="COMMAND">SELECT</TT>语句中抓取若干行，
然后为了提高效率，又用<TT CLASS="LITERAL">IF</TT>语句中的结果制作了一个巨大的函数。</P><P>
这是Oracle版本:
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,
                 v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;</PRE><P>
</P><P>
下面是这个函数在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里面的样子：
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;</PRE><P>
请注意函数体是如何独立制作并且传递给<TT CLASS="LITERAL">quote_literal</TT>，对其中的单引号复制双份的。
需要这个技巧是因为无法使用美元符界定定义新函数：
没法保证<TT CLASS="STRUCTFIELD">referrer_key.key_string</TT>字段过来的字符串会解析成什么样子。
可以假设<TT CLASS="STRUCTFIELD">referrer_key.kind</TT>是只有<TT CLASS="LITERAL">host</TT>, <TT CLASS="LITERAL">domain</TT>或者
<TT CLASS="LITERAL">url</TT>，但是<TT CLASS="STRUCTFIELD">referrer_key.key_string</TT>可能是任何东西，特别是它可能包含美元符。
这个函数实际上是对原来 Oracle 版本的一个改进，
因为如果在<TT CLASS="STRUCTFIELD">referrer_key.key_string</TT>或者
<TT CLASS="STRUCTFIELD">referrer_key.referrer_type</TT>包含单引号的时候，
它不会生成有毛病的代码。
</P></DIV><P> <A HREF="plpgsql-porting.html#PLPGSQL-PORTING-EX3">&#20363; 40-10</A>演示了如何移植一个带有<TT CLASS="LITERAL">OUT</TT>参数和字符串处理的函数。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里面没有内置<CODE CLASS="FUNCTION">instr</CODE>函数，但是你可以用其它函数的组合来绕开它。
在<A HREF="plpgsql-porting.html#PLPGSQL-PORTING-APPENDIX">第 40.12.3 &#33410;</A>里有一个<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>
的<CODE CLASS="FUNCTION">instr</CODE>实现，你可以用它让你的移植变得更简单些。</P><DIV CLASS="EXAMPLE"><A NAME="PLPGSQL-PORTING-EX3"></A><P><B>&#20363; 40-10. 从<SPAN CLASS="APPLICATION">PL/SQL</SPAN>向
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>移植一个字符串操作和<TT CLASS="LITERAL">OUT</TT>参数的过程</B></P><P> 下面的<SPAN CLASS="PRODUCTNAME">Oracle</SPAN> PL/SQL过程用于分析一个URL并且返回若干个元素(主机、路径、命令)。</P><P>
下面是Oracle版本:
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR,
v_host OUT VARCHAR,  -- 这个变量是要传回的
    v_path OUT VARCHAR,  -- 这个也是
    v_query OUT VARCHAR) -- 还有这个
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;</PRE><P>
</P><P>
下面就是把这个过程翻译成<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>可能的样子：
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
v_host OUT VARCHAR,  -- 这个将被传回
    v_path OUT VARCHAR,  -- 这个也传回
    v_query OUT VARCHAR) -- 还有这个
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;</PRE><P>
这个函数可以这么用:
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');</PRE><P>
</P></DIV><P> <A HREF="plpgsql-porting.html#PLPGSQL-PORTING-EX4">&#20363; 40-11</A>演示了如何一个使用各种Oracle专有特性的过程。</P><DIV CLASS="EXAMPLE"><A NAME="PLPGSQL-PORTING-EX4"></A><P><B>&#20363; 40-11. 从<SPAN CLASS="APPLICATION">PL/SQL</SPAN>向<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>移植一个过程</B></P><P>
Oracle版本：
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<A
NAME="CO.PLPGSQL-PORTING-PRAGMA"
><B
>(1)</B
></A
>
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<A
NAME="CO.PLPGSQL-PORTING-LOCKTABLE"
><B
>(2)</B
></A
>

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- free lock<A
NAME="CO.PLPGSQL-PORTING-COMMIT"
><B
>(3)</B
></A
>
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists
    END;
    COMMIT;
END;
/
show errors</PRE><P>
</P><P>
像这样的过程可以很容易用返回<TT CLASS="TYPE">void</TT>的函数移植到<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里。
对这个过程特别感兴趣是因为它可以教一些东西：
<DIV CLASS="CALLOUTLIST"><DL COMPACT="COMPACT"><DT><A HREF="plpgsql-porting.html#CO.PLPGSQL-PORTING-PRAGMA"><B>(1)</B></A></DT><DD>
在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里没有<TT CLASS="LITERAL">PRAGMA</TT>语句。
</DD><DT><A HREF="plpgsql-porting.html#CO.PLPGSQL-PORTING-LOCKTABLE"><B>(2)</B></A></DT><DD> 如果你在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>里做一个<TT CLASS="COMMAND">LOCK TABLE</TT>，
那么这个锁在调用该命令的事务完成之前将不会释放。</DD><DT><A HREF="plpgsql-porting.html#CO.PLPGSQL-PORTING-COMMIT"><B>(3)</B></A></DT><DD> 你不能在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数里发出<TT CLASS="COMMAND">COMMIT</TT>。
函数是在外层的事务里运行的，因此<TT CLASS="COMMAND">COMMIT</TT>蕴涵着结束函数的执行。
不过，在这个特殊场合下，这是不必要的了，
因为<TT CLASS="COMMAND">LOCK TABLE</TT>获取的锁将在抛出错误的时候释放。</DD></DL></DIV>
</P><P>
下面是把这个过程移植到<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>里的一种方法：
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<A
NAME="CO.PLPGSQL-PORTING-RAISE"
><B
>(1)</B
></A
>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN <A
NAME="CO.PLPGSQL-PORTING-EXCEPTION"
><B
>(2)</B
></A
>
            -- don't worry if it already exists
    END;
END;
$$ LANGUAGE plpgsql;</PRE><P>
<DIV CLASS="CALLOUTLIST"><DL COMPACT="COMPACT"><DT><A HREF="plpgsql-porting.html#CO.PLPGSQL-PORTING-RAISE"><B>(1)</B></A></DT><DD>
<TT CLASS="LITERAL">RAISE</TT>的语法和Oracle的类似语句差别相当明显。
尽管<TT CLASS="LITERAL">RAISE</TT><TT CLASS="REPLACEABLE"><I>exception_name</I></TT>运行的基本情况相似。
</DD><DT><A HREF="plpgsql-porting.html#CO.PLPGSQL-PORTING-EXCEPTION"><B>(2)</B></A></DT><DD> <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>里支持的异常的名字和Oracle的不同。
内置的异常名要大的多(参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/errcodes-appendix.html">&#38468;&#24405; A</A>)。
目前还不能声明用户定义的异常名。</DD></DL></DIV>
整个过程和Oracle的等效的主要的功能型差别是，
在<TT CLASS="LITERAL">cs_jobs</TT>上持有的排他锁将保持到调用的事务结束。
同样，如果调用者后来退出(比如说因为错误)，这个过程的效果将被回滚掉。
</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-PORTING-OTHER">40.12.2. 其它注意事项</A></H2><P> 本节解释几个从Oracle <SPAN CLASS="APPLICATION">PL/SQL</SPAN>函数向<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
移植的几个其它方面的事情。</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="PLPGSQL-PORTING-EXCEPTIONS">40.12.2.1. 异常后的隐含回滚</A></H3><P>
在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>里，如果一个异常被<TT CLASS="LITERAL">EXCEPTION</TT>子句捕获，
那么所有自这个块的<TT CLASS="LITERAL">BEGIN</TT>以来的数据库改变都会被自动回滚。
也就是说，这个行为等于你在Oracle里的：
</P><PRE CLASS="PROGRAMLISTING">BEGIN
    SAVEPOINT s1;
    ... code here ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
END;</PRE><P>
如果你在翻译使用<TT CLASS="COMMAND">SAVEPOINT</TT>和<TT CLASS="COMMAND">ROLLBACK TO</TT>的Oracle过程，
那么你的活儿很好干：只要省略<TT CLASS="COMMAND">SAVEPOINT</TT>和
<TT CLASS="COMMAND">ROLLBACK TO</TT>即可。
如果你要翻译的过程使用了不同的<TT CLASS="COMMAND">SAVEPOINT</TT>和<TT CLASS="COMMAND">ROLLBACK TO</TT>，那么就需要想想了。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN59586">40.12.2.2. <TT CLASS="COMMAND">EXECUTE</TT></A></H3><P> <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>版本的<TT CLASS="COMMAND">EXECUTE</TT>类似<SPAN CLASS="APPLICATION">PL/SQL</SPAN>运转，
不过你必须记住要像<A HREF="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN">第 40.5.4 &#33410;</A>里描述的那样
用<CODE CLASS="FUNCTION">quote_literal</CODE>和<CODE CLASS="FUNCTION">quote_ident</CODE>。
如果你不用这些函数，那么像<TT CLASS="LITERAL">EXECUTE 'SELECT * FROM $1';</TT>这样的构造是不会运转的。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="PLPGSQL-PORTING-OPTIMIZATION">40.12.2.3. 优化<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数</A></H3><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>给你两个创建函数的修饰词用来优化执行：<SPAN CLASS="QUOTE">"volatility"</SPAN>
(易变的，在给出的参数相同时， 函数总是返回相同结果)和<SPAN CLASS="QUOTE">"strictness"</SPAN>
(严格的，如果任何参数是NULL，那么函数返回NULL)。
参考<A HREF="sql-createfunction.html">CREATE FUNCTION</A>的手册获取细节。</P><P>
如果要使用这些优化属性，那么你的<TT CLASS="COMMAND">CREATE FUNCTION</TT>语句可能看起来像这样：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;</PRE><P>
</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-PORTING-APPENDIX">40.12.3. 附录</A></H2><P> 本节包含Oracle兼容的<CODE CLASS="FUNCTION">instr</CODE>函数，你可以用它简化你的移植过程。</P><PRE CLASS="PROGRAMLISTING">&#13;--
-- 模拟 Oracle 概念的 instr 函数
-- 语法: instr(string1, string2, [n], [m])  这里的 [] 表示可选参数
--
-- 从 string1 的第 n 个字符开始寻找 string2 的第 m 个出现。
-- 如果 n 是负数，则从后向前着。如果没有传递 m ，假定为 1(从第一个字符开始找)。
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF; 

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;</PRE></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="plpgsql-development-tips.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/pltcl.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">开发<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>的一些提示</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">PL/Tcl - Tcl 过程语言</TD></TR></TABLE></DIV></BODY></HTML>
