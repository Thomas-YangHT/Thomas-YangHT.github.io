<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>用C写触发器</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="触发器" HREF="http://school.yunwei.edu/manual/PostgreSQL/triggers.html"><LINK REL="PREVIOUS" TITLE="数据改变的可视性" HREF="trigger-datachanges.html"><LINK REL="NEXT" TITLE="一个完整的触发器例子" HREF="trigger-example.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/trigger.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="数据改变的可视性" HREF="trigger-datachanges.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/triggers.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 36. 触发器</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="一个完整的触发器例子" HREF="trigger-example.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="TRIGGER-INTERFACE">36.3. 用C写触发器</A></H1><P> 本章描述触发器函数的低层细节。只有当你用C书写触发器函数的时候才需要这些信息。
如果你用某种高级语言写触发器，那么系统就会为你处理这些细节。
在大多数情况下，你在书写自己的C触发器之前应该考虑使用过程语言。
每种过程语言的文档里面都有关于如何用该语言书写触发器的解释。</P><P> 触发器函数必须使用<SPAN CLASS="QUOTE">"version 1"</SPAN>的函数管理器接口。</P><P>
当一个函数被触发器管理器调用时，它不会收到任何普通参数，
而是收到一个指向<TT CLASS="STRUCTNAME">TriggerData</TT>结构的<SPAN CLASS="QUOTE">"context"</SPAN>指针。
C函数可以通过执行下面的宏来检查它们是否是从触发器管理器调用的
</P><PRE CLASS="PROGRAMLISTING">CALLED_AS_TRIGGER(fcinfo)</PRE><P>
扩展到：
</P><PRE CLASS="PROGRAMLISTING">((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))</PRE><P>
如果此宏返回真(TRUE)，则可以安全地把
<TT CLASS="LITERAL">fcinfo-&gt;context</TT>转换成<TT CLASS="LITERAL">TriggerData*</TT>类型，
然后使用这个指向<TT CLASS="STRUCTNAME">TriggerData</TT>的结构。
函数本身绝<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不能</I></SPAN>更改<TT CLASS="STRUCTNAME">TriggerData</TT>结构或者它指向的任何数据。
</P><P>
<TT CLASS="STRUCTNAME">struct TriggerData</TT>是在
<TT CLASS="FILENAME">commands/trigger.h</TT>中被定义的：
</P><PRE CLASS="PROGRAMLISTING">typedef struct TriggerData
{
    NodeTag       type;
    TriggerEvent  tg_event;
    Relation      tg_relation;
    HeapTuple     tg_trigtuple;
    HeapTuple     tg_newtuple;
    Trigger      *tg_trigger;
    Buffer        tg_trigtuplebuf;
    Buffer        tg_newtuplebuf;
} TriggerData;</PRE><P>
这些成员的定义如下：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="STRUCTFIELD">type</TT></DT><DD><P>
总是<TT CLASS="LITERAL">T_TriggerData</TT>。
</P></DD><DT><TT CLASS="STRUCTFIELD">tg_event</TT></DT><DD><P>
描述调用函数的事件。你可以用下面的宏检查<TT CLASS="LITERAL">tg_event</TT>：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">TRIGGER_FIRED_BEFORE(tg_event)</TT></DT><DD><P>
如果触发器是在操作前触发，返回真。
</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_AFTER(tg_event)</TT></DT><DD><P> 如果触发器是在操作后触发，返回真。&#13;</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_INSTEAD(tg_event)</TT></DT><DD><P> 如果触发器触发了相反的操作，返回真。</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_FOR_ROW(tg_event)</TT></DT><DD><P> 如果触发器是行级别事件触发，返回真。</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_FOR_STATEMENT(tg_event)</TT></DT><DD><P> 如果触发器是语句级别事件触发，返回真。</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_BY_INSERT(tg_event)</TT></DT><DD><P> 如果触发器是由<TT CLASS="COMMAND">INSERT</TT>触发，返回真。</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_BY_UPDATE(tg_event)</TT></DT><DD><P> 如果触发器是由<TT CLASS="COMMAND">UPDATE</TT>触发，返回真。</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_BY_DELETE(tg_event)</TT></DT><DD><P> 如果触发器是由<TT CLASS="COMMAND">DELETE</TT>触发，返回真。</P></DD><DT><TT CLASS="LITERAL">TRIGGER_FIRED_BY_TRUNCATE(tg_event)</TT></DT><DD><P> 如果触发器是由<TT CLASS="COMMAND">TRUNCATE</TT>命令触发，返回真。</P></DD></DL></DIV><P>
</P></DD><DT><TT CLASS="STRUCTFIELD">tg_relation</TT></DT><DD><P> 是一个指向描述被触发的关系的结构的指针。
请参考<TT CLASS="FILENAME">utils/rel.h</TT>获取关于此结构的详细信息。
最让人感兴趣的事情是<TT CLASS="LITERAL">tg_relation-&gt;rd_att</TT>(关系行的描述)
和<TT CLASS="LITERAL">tg_relation-&gt;rd_rel-&gt;relname</TT>
(关系名。这个变量的类型不是<TT CLASS="TYPE">char*</TT>而是<TT CLASS="TYPE">NameData</TT>。
如果你需要一份名字的拷贝，
用<TT CLASS="LITERAL">SPI_getrelname(tg_relation)</TT>获取<TT CLASS="TYPE">char*</TT>)。</P></DD><DT><TT CLASS="STRUCTFIELD">tg_trigtuple</TT></DT><DD><P> 是一个指向触发触发器的行的指针。
这是一个正在被插入(INSERT)、删除(DELETE)、或更新(UPDATE)的行。
如果是<TT CLASS="COMMAND">INSERT</TT>或者<TT CLASS="COMMAND">DELETE</TT>，
如果你不想用另一条行覆盖此行（就<TT CLASS="COMMAND">INSERT</TT>来说）或忽略操作，
那么这就是你将从函数返回的东西。</P></DD><DT><TT CLASS="STRUCTFIELD">tg_newtuple</TT></DT><DD><P> 如果是<TT CLASS="COMMAND">UPDATE</TT>，这是一个指向新版本的行的指针，
如果是<TT CLASS="COMMAND">INSERT</TT>或者<TT CLASS="COMMAND">DELETE</TT>，则是<TT CLASS="SYMBOL">NULL</TT>。
如果事件是<TT CLASS="COMMAND">UPDATE</TT>并且你不想用另一条行替换这条行或忽略操作的话，
这就是你将从函数返回的东西。</P></DD><DT><TT CLASS="STRUCTFIELD">tg_trigger</TT></DT><DD><P>
是一个指向结构<TT CLASS="STRUCTNAME">Trigger</TT>的指针，该结构在<TT CLASS="FILENAME">utils/reltrigger.h</TT>里定义：
</P><PRE CLASS="PROGRAMLISTING">typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
} Trigger;</PRE><P>
<TT CLASS="STRUCTFIELD">tgname</TT>是触发器的名称，<TT CLASS="STRUCTFIELD">tgnargs</TT>是在<TT CLASS="STRUCTFIELD">tgargs</TT>里参数的数量，
<TT CLASS="STRUCTFIELD">tgargs</TT>是一个指针数组，数组里每个指针指向在<TT CLASS="COMMAND">CREATE TRIGGER</TT>语句里声明的参数。
其它成员只在内部使用。
</P></DD><DT><TT CLASS="STRUCTFIELD">tg_trigtuplebuf</TT></DT><DD><P> 如果没有这样的元组或者没有存储在磁盘缓冲区里，
则是包含<TT CLASS="STRUCTFIELD">tg_trigtuple</TT>或者<TT CLASS="SYMBOL">InvalidBuffer</TT>的缓冲区。</P></DD><DT><TT CLASS="STRUCTFIELD">tg_newtuplebuf</TT></DT><DD><P> 如果没有这样的元组或者它并未存储在磁盘缓冲区里，
那么就是包含<TT CLASS="STRUCTFIELD">tg_newtuple</TT>或者<TT CLASS="SYMBOL">InvalidBuffer</TT>的缓冲区。</P></DD></DL></DIV><P>
</P><P> 一个触发器函数必须返回一个<TT CLASS="STRUCTNAME">HeapTuple</TT>
指针或者一个<TT CLASS="SYMBOL">NULL</TT>指针(<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不是</I></SPAN>SQL的NULL值，也就是说不要设置<TT CLASS="PARAMETER">isNull</TT>为真)。
请注意如果你不想修改正在被操作的行，那么要根据情况返回<TT CLASS="STRUCTFIELD">tg_trigtuple</TT>或者<TT CLASS="STRUCTFIELD">tg_newtuple</TT>。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="trigger-datachanges.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="trigger-example.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">数据改变的可视性</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/triggers.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">一个完整的触发器例子</TD></TR></TABLE></DIV></BODY></HTML>
