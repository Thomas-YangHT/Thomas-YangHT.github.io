<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>在后台下的PL/pgSQL</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PL/pgSQL - SQL过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html"><LINK REL="PREVIOUS" TITLE="触发器过程" HREF="plpgsql-trigger.html"><LINK REL="NEXT" TITLE="开发PL/pgSQL的一些提示" HREF="plpgsql-development-tips.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/plpgsql.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="触发器过程" HREF="plpgsql-trigger.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 40. <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN> - <ACRONYM CLASS="ACRONYM">SQL</ACRONYM>过程语言</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="开发PL/pgSQL的一些提示" HREF="plpgsql-development-tips.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PLPGSQL-IMPLEMENTATION">40.10. 在后台下的<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN></A></H1><P> 本节讨论<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>用户知道的比较重要的一些实现细节。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-VAR-SUBST">40.10.1. 变量替换</A></H2><P>
在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数内的SQL语句和表达式
可以参考变量和函数的参数。在后台，<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>替代这些参考查询参数。
参数只会按照句法允许一个参数或列引用的地方被取代。作为一个极端的例子，
考虑不好的编程风格的这个例子：
</P><PRE CLASS="PROGRAMLISTING">INSERT INTO foo (foo) VALUES (foo);</PRE><P>
<TT CLASS="LITERAL">foo</TT>第一次出现一定在语法上是表名字，所以它不会被取代，即使函数有一个可变名
<TT CLASS="LITERAL">foo</TT>。第二次发生必须是表列名称，所以它也不会被取代。
只有第三次发生是参考函数变量的一个候选。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 9.0之前的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>版本可能尝试所有三种情况中替换变量，导致语法错误。</P></BLOCKQUOTE></DIV><P>
由于变量的名字语法上和表列名字没有什么不同，参考表的语句中有模糊：它是一个给定的名字意味着引用一个表列，或一个变量？
让我们改变以往的例子
</P><PRE CLASS="PROGRAMLISTING">INSERT INTO dest (col) SELECT foo + bar FROM src;</PRE><P>
在这里，<TT CLASS="LITERAL">dest</TT>和<TT CLASS="LITERAL">src</TT>必须是表名，并且
<TT CLASS="LITERAL">col</TT>必须是<TT CLASS="LITERAL">dest</TT>的列，但是<TT CLASS="LITERAL">foo</TT>
和<TT CLASS="LITERAL">bar</TT>可能是函数变量或者<TT CLASS="LITERAL">src</TT>的列。
</P><P> 默认情况下，如果在一个SQL语句中的名字
可以参考一个变量或表列，则<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>将报告错误。
你可以通过重命名变量或列，或限定不明确的引用，或者告诉<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>
说明更喜欢哪个来解决这样的问题。</P><P> 最简单的解决方案是重命名变量或列。一个常见的编码规则是使用
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量的不同命名惯例而不是你使用列名称。
比如，如果你一贯地命名函数变量<TT CLASS="LITERAL">v_<TT CLASS="REPLACEABLE"><I>something</I></TT></TT>，
然而你的列没有以<TT CLASS="LITERAL">v_</TT>开头命名，不会发生冲突。 </P><P>
另外你可以限定含糊的引用以使得它们明确。
在上面的例子中，<TT CLASS="LITERAL">src.foo</TT>将是表列的明确参考。
为了创建明确的引用变量，
在标记块声明它并且使用块标签（参阅<A HREF="plpgsql-structure.html">第 40.2 &#33410;</A>）。比如，
</P><PRE CLASS="PROGRAMLISTING">&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;</PRE><P>
这里<TT CLASS="LITERAL">block.foo</TT>意味着变量，
即使在<TT CLASS="LITERAL">src</TT>中有一列<TT CLASS="LITERAL">foo</TT>。
函数的参数，以及特殊变量如<TT CLASS="LITERAL">FOUND</TT>，可以满足
函数的名字，因为他们在使用函数名标记的外部块中隐式声明。
</P><P> 有时修复在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>编码主体下所有不明确的引用是不切实际的。
在这种情况下，你可以指定<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>应该解决不明确的引用，作为变量
（即兼容<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.0之前的<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>的行为），
或作为表列（与其他一些系统兼容，如<SPAN CLASS="PRODUCTNAME">Oracle</SPAN>）</P><P> 要改变在系统范围基础上的这种行为，设置配置参数<TT CLASS="LITERAL">plpgsql.variable_conflict</TT>为
<TT CLASS="LITERAL">error</TT>, <TT CLASS="LITERAL">use_variable</TT>或者
<TT CLASS="LITERAL">use_column</TT>之一（<TT CLASS="LITERAL">error</TT>是出厂缺省值）。
此参数会影响<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数中语句后续的编译，但不是在当前会话中已编译的语句。
由于更改此设置可以导致<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数行为意想不到的变化，它只能由超级用户改变。</P><P>
你也可以在功能分析的基础上设定行为，通过在函数文本的开始处插入这些特殊的命令之一：
</P><PRE CLASS="PROGRAMLISTING">#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column</PRE><P>
这些命令只影响写入的函数，
并且重写<TT CLASS="LITERAL">plpgsql.variable_conflict</TT>的设置。例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;</PRE><P>
在<TT CLASS="LITERAL">UPDATE</TT>命令中，<TT CLASS="LITERAL">curtime</TT>, <TT CLASS="LITERAL">comment</TT>,
和<TT CLASS="LITERAL">id</TT>将引用函数的变量和<TT CLASS="LITERAL">users</TT>是否具有这些名称列的参数。
请注意我们必须限定到<TT CLASS="LITERAL">WHERE</TT>子句<TT CLASS="LITERAL">users.id</TT>的引用以使得它引用表列。
我们没有必要限定引用到<TT CLASS="LITERAL">comment</TT>作为<TT CLASS="LITERAL">UPDATE</TT>列表中的目标，
因为语法上必定是<TT CLASS="LITERAL">users</TT>的列。
我们可以写不依赖于这种方式的<TT CLASS="LITERAL">variable_conflict</TT>设置的同样函数：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;</PRE><P>
</P><P> 变量代换不会发生在给定<TT CLASS="COMMAND">EXECUTE</TT>或者它的变种之一的命令字符串中。
如果你需要插入一个不同的值到这个命令中，
执行它作为构建字符串值的一部分，
或使用<TT CLASS="LITERAL">USING</TT>，正如
<A HREF="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN">第 40.5.4 &#33410;</A>说明的。</P><P> 变量替换目前只能在<TT CLASS="COMMAND">SELECT</TT>,<TT CLASS="COMMAND">INSERT</TT>, <TT CLASS="COMMAND">UPDATE</TT>和
<TT CLASS="COMMAND">DELETE</TT>命令中运行，因为主要的SQL引擎允许这些命令中的查询参数。
为了使用其他语句类型中非恒定的名称或值
（一般称为实用语句），你必须构建实用语句作为字符串并且<TT CLASS="COMMAND">EXECUTE</TT>它。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-PLAN-CACHING">40.10.2. 计划缓存</A></H2><P> <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>解释器解析函数的源
文本并且第一次函数被调用时（每个会话中）产生一个内部二进制指令树。
指令树充分翻译<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>语句结构，
但个别<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>表达式和在函数中使用的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令不是立即翻译。</P><P>
在函数中首先执行每个表达式和<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令，<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>
解释器解析并且分析命令以创建预备语句，使用<ACRONYM CLASS="ACRONYM">SPI</ACRONYM>管理的
<CODE CLASS="FUNCTION">SPI_prepare</CODE>函数。
随后访问表达式或命令重新使用事先准备好的语句。
因此，带有条件编码路径的函数很少被访问将不会产生分析不在当前会话中执行的命令的开销，
一个缺点是在一个特定的表达或命令中的错误
不能被检测到直到执行达到函数部分
（琐碎的语法错误在初步解析传递期间将被检测到，但是任何更深的东西将不会被检测到直到执行为止。）
</P><P> <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>（或者更准确的说，SPI管理者）可以
尝试与任何特别已准备语句相关的缓存执行计划。
如果没有使用缓存计划，
那么在每次访问语句中产生一个新的执行计划，并且
当前的参数值（即，<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>
变量值）可以用来优化选择方案。
如果语句没有参数，或是执行多次，SPI管理者
将考虑创建<I CLASS="FIRSTTERM">generic</I>计划不依赖于特定的参数值，并且缓存再利用。
只有执行计划对<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量中引用的值不太敏感时，往往会发生。
如果是，每次生成一个计划都是净赢。
参阅<A HREF="sql-prepare.html">PREPARE</A>获得更多有关预备语句行为信息。 </P><P> 因为<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>保存已预备好语句并且有时以这种方式执行计划，
直接出现在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数中的SQL命令必须查阅相同表和每个执行列；
也就是说，你不能使用参数作为SQL命令的表或列的名字。
为了应对这个限制，
你可以使用<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN> <TT CLASS="COMMAND">EXECUTE</TT>
语句构建动态命令；以执行新的解析分析和每个执行上构建新的执行计划为代价。</P><P> 记录变量的可变性质提出连接中的另一个问题。
当在表达式或语句中使用记录变量字段时，
该字段数据类型必须不能从函数的一个调用到下一个改变，
因为当表达式第一个到达时使用目前数据类型分析每个表达式。
<TT CLASS="COMMAND">EXECUTE</TT>必要时可以用于解决这个问题。</P><P> 如果相同函数作为多个表的触发器使用，
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>为了每个表独立地准备并且缓存声明；
即，有一个触发器函数和表组合的高速缓存，而不只是为每个函数。
这解决了一些数据类型不同的问题；例如，一个触发器函数可以使用命名<TT CLASS="LITERAL">key</TT>的列
成功运行，即使发生不同的表中有不同的类型。</P><P> 同样，具有多态性参数类型的函数
有一个他们被调用的实际参数类型的每个组合的单独声明缓存，
所以该数据类型差异不会导致意外失败。</P><P>
语句缓存有时会对时间敏感值的解释有令人惊讶的影响。
例如在这两个函数要做的内容之间有区别：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;</PRE><P>
和
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;</PRE><P>
</P><P> 在<CODE CLASS="FUNCTION">logfunc1</CODE>的情况下，该
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>主解析器知道当
分析<TT CLASS="COMMAND">INSERT</TT>时
字符串<TT CLASS="LITERAL">'now'</TT>应解释为<TT CLASS="TYPE">时间戳</TT>，
因为<CODE CLASS="CLASSNAME">logtable</CODE>目标列是那种类型。
因此，当分析<TT CLASS="COMMAND">INSERT</TT>时，
<TT CLASS="LITERAL">'now'</TT>将被转换为<TT CLASS="TYPE">timestamp</TT>常量，
然后在会话的整个生命周期中用于<CODE CLASS="FUNCTION">logfunc1</CODE>的所有调用。
不用说，这不是程序员希望的。
一个更好的办法是使用<TT CLASS="LITERAL">now()</TT>或者<TT CLASS="LITERAL">current_timestamp</TT>函数。</P><P> 在<CODE CLASS="FUNCTION">logfunc2</CODE>的情况下，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>主解析器并不知道
<TT CLASS="LITERAL">'now'</TT>应该成为什么类型，因此它返回包含字符串<TT CLASS="LITERAL">now</TT>
类型<TT CLASS="TYPE">text</TT>的数据值。
随后分配给局部变量<TT CLASS="VARNAME">curtime</TT>期间，
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>解析器通过调用<CODE CLASS="FUNCTION">text_out</CODE>和
<CODE CLASS="FUNCTION">timestamp_in</CODE>转换函数将这个字符串转换为<TT CLASS="TYPE">timestamp</TT>类型，
因此，作为编程期望每次执行时更新计算时间戳。
尽管这正如预期的那样发生，这不是非常有效的，
所以<TT CLASS="LITERAL">now()</TT>函数的使用仍然会是一个更好的主意。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="plpgsql-trigger.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="plpgsql-development-tips.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">触发器过程</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">开发<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>的一些提示</TD></TR></TABLE></DIV></BODY></HTML>
