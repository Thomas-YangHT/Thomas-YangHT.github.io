<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pg_dump</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PostgreSQL 客户端应用程序" HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html"><LINK REL="PREVIOUS" TITLE="pg_config" HREF="app-pgconfig.html"><LINK REL="NEXT" TITLE="pg_dumpall" HREF="app-pg-dumpall.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/pg_dump.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_config" HREF="app-pgconfig.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="pg_dumpall" HREF="app-pg-dumpall.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="APP-PGDUMP"></A>pg_dump</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN84326"></A><H2>&#21517;&#31216;</H2>pg_dump&nbsp;--&nbsp; 将一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>数据库转储到一个脚本文件或者其它归档文件中
</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN84332"></A><H2>&#22823;&#32434;</H2><P><TT CLASS="COMMAND">pg_dump</TT> [<TT CLASS="REPLACEABLE"><I>connection-option</I></TT>...] [<TT CLASS="REPLACEABLE"><I>option</I></TT>...] [<TT CLASS="REPLACEABLE"><I>dbname</I></TT>]</P></DIV><DIV CLASS="REFSECT1"><A NAME="PG-DUMP-DESCRIPTION"></A><H2> 描述
</H2><P><SPAN CLASS="APPLICATION">pg_dump</SPAN>是一个用于备份<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
数据库的工具。它甚至可以在数据库正在使用的时候进行完整一致的备份。
<SPAN CLASS="APPLICATION">pg_dump</SPAN>并不阻塞其它用户对数据库的访问(读或者写)。</P><P>转储格式可以是一个脚本或者归档文件。脚本转储的格式是纯文本，它包含许多 SQL 命令，
这些 SQL 命令可以用于重建该数据库并将之恢复到保存成脚本的时候的状态。
使用<A HREF="app-psql.html"><SPAN CLASS="APPLICATION">psql</SPAN></A>从这样的脚本中恢复。
它们甚至可以用于在其它机器甚至是其它硬件体系的机器上重建该数据库，
通过对脚本进行一些修改，甚至可以在其它 SQL 数据库产品上重建该数据库。</P><P>归档文件格式必须和<A HREF="app-pgrestore.html">pg_restore</A>一起使用重建数据库。
它们允许<SPAN CLASS="APPLICATION">pg_restore</SPAN>对恢复什么东西进行选择，
或者甚至是在恢复之前对需要恢复的条目进行重新排序。归档文件也是设计成可以跨平台移植的。</P><P>如果一种候选文件格式和<SPAN CLASS="APPLICATION">pg_restore</SPAN>结合，
那么<SPAN CLASS="APPLICATION">pg_dump</SPAN>就能提供一种灵活的归档和传输机制。
<SPAN CLASS="APPLICATION">pg_dump</SPAN>可以用于备份整个数据库，然后就可以使用
<SPAN CLASS="APPLICATION">pg_restore</SPAN>检查这个归档和/或选择要恢复的数据库部分。
最灵活的输出文件格式是<SPAN CLASS="QUOTE">"custom"</SPAN>(自定义)格式(<TT CLASS="OPTION">-Fc</TT>)和
<SPAN CLASS="QUOTE">"directory"</SPAN>（目录）格式(<TT CLASS="OPTION">-Fd</TT>)。
它们允许对归档元素进行选取和重新排列，支持并行恢复并且缺省时是压缩的。
<SPAN CLASS="QUOTE">"directory"</SPAN>格式是唯一支持并行转储的格式。</P><P>在运行<SPAN CLASS="APPLICATION">pg_dump</SPAN>的时候，应该检查输出，
看看是否有任何警告存在(在标准错误上打印)，特别是下面列出的限制。</P></DIV><DIV CLASS="REFSECT1"><A NAME="PG-DUMP-OPTIONS"></A><H2>选项</H2><P>下面的命令行参数控制输出的内容和格式。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>dbname</I></TT></DT><DD><P>将要转储的数据库名。如果没有声明这个参数，那么使用环境变量<TT CLASS="ENVAR">PGDATABASE</TT>。
如果那个环境变量也没声明，那么使用发起连接的用户名。</P></DD><DT><TT CLASS="OPTION">-a</TT><BR><TT CLASS="OPTION">--data-only</TT></DT><DD><P>只输出数据，不输出模式(数据定义)。转储表数据、大对象和序列值。</P><P>这个选项类似于声明<TT CLASS="OPTION">--section=data</TT>，但是只是因为历史原因存在并不完全相同。</P></DD><DT><TT CLASS="OPTION">-b</TT><BR><TT CLASS="OPTION">--blobs</TT></DT><DD><P>在转储中包含大对象。除非指定了<TT CLASS="OPTION">--schema</TT>, <TT CLASS="OPTION">--table</TT>,
<TT CLASS="OPTION">--schema-only</TT>开关，否则这是默认行为。因此<TT CLASS="OPTION">-b</TT>
开关仅用于在选择性转储的时候添加大对象。</P></DD><DT><TT CLASS="OPTION">-c</TT><BR><TT CLASS="OPTION">--clean</TT></DT><DD><P>输出命令在输出创建数据库命令之前先清理(drop)该数据库对象。
（如果任何对象在目标数据库中不存在，则转储可能生成一些无害的错误信息。）</P><P>这个选项只是对纯文本格式有意义。对于归档格式，可以在调用<TT CLASS="COMMAND">pg_restore</TT>的时候声明该选项。</P></DD><DT><TT CLASS="OPTION">-C</TT><BR><TT CLASS="OPTION">--create</TT></DT><DD><P>以一条创建该数据库本身并且与这个数据库连接命令开头进行输出。如果是这种形式的脚本，
那么你在运行脚本之前和目的安装中的哪个数据库连接就不重要了。如果也声明了
<TT CLASS="OPTION">--clean</TT>，那么脚本在重新连接到数据库之前删除并重新创建目标数据库。</P><P>这个选项只对纯文本格式有意义。对于归档格式，可以在调用<TT CLASS="COMMAND">pg_restore</TT>
的时候声明该选项。</P></DD><DT><TT CLASS="OPTION">-E <TT CLASS="REPLACEABLE"><I>encoding</I></TT></TT><BR><TT CLASS="OPTION">--encoding=<TT CLASS="REPLACEABLE"><I>encoding</I></TT></TT></DT><DD><P>以指定的字符集编码创建转储。缺省时，转储是按照数据库编码创建的。
另外一个获取同样结果的方法是将<TT CLASS="ENVAR">PGCLIENTENCODING</TT>环境变量设置为期望的转储编码。</P></DD><DT><TT CLASS="OPTION">-f <TT CLASS="REPLACEABLE"><I>file</I></TT></TT><BR><TT CLASS="OPTION">--file=<TT CLASS="REPLACEABLE"><I>file</I></TT></TT></DT><DD><P>把输出发往指定的文件。文件基础输出格式时可以省略这个参数，这种情况下使用标准输出。
但是，在声明目标目录而不是文件时必须给出目录输出格式。在这种情况下，
目录通过<TT CLASS="COMMAND">pg_dump</TT>创建并且必须之前不存在。</P></DD><DT><TT CLASS="OPTION">-F <TT CLASS="REPLACEABLE"><I>format</I></TT></TT><BR><TT CLASS="OPTION">--format=<TT CLASS="REPLACEABLE"><I>format</I></TT></TT></DT><DD><P>选择输出的格式。<TT CLASS="REPLACEABLE"><I>format</I></TT>可以是下列之一：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">p</TT><BR><TT CLASS="LITERAL">plain</TT></DT><DD><P>纯文本<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>脚本文件(缺省)。</P></DD><DT><TT CLASS="LITERAL">c</TT><BR><TT CLASS="LITERAL">custom</TT></DT><DD><P>适合输入到<SPAN CLASS="APPLICATION">pg_restore</SPAN>里的自定义格式归档。
加上目录输出格式，这是最灵活的格式，它允许在转储期间对已归档的条目进行手动选择和重新排列。
这个格式缺省的时候是压缩的。</P></DD><DT><TT CLASS="LITERAL">d</TT><BR><TT CLASS="LITERAL">directory</TT></DT><DD><P>适合输入到<SPAN CLASS="APPLICATION">pg_restore</SPAN>里的目录格式归档。这将创建一个目录，
该目录包含一个为每个被转储的表和二进制大对象的文件，加上一个号称目录的文件，
该文件以<SPAN CLASS="APPLICATION">pg_restore</SPAN>可读的机器可读格式描述转储的对象。
目录格式归档可以用标准Unix工具操作；例如，在非压缩归档中的文件可以用
<SPAN CLASS="APPLICATION">gzip</SPAN>工具压缩。这个格式缺省的时候是压缩的，
并且也支持并行转储。</P></DD><DT><TT CLASS="LITERAL">t</TT><BR><TT CLASS="LITERAL">tar</TT></DT><DD><P>适合输入到<SPAN CLASS="APPLICATION">pg_restore</SPAN>里的<TT CLASS="COMMAND">tar</TT>归档文件。
tar格式兼容目录格式；提取tar格式归档产生一个有效的目录格式归档。不过，
tar格式不支持压缩并且限制单独的表为8 GB。还有，表数据条目的相关顺序在转储期间不能更改。</P></DD></DL></DIV><P></P></DD><DT><TT CLASS="OPTION">-i</TT><BR><TT CLASS="OPTION">--ignore-version</TT></DT><DD><P>一个现在已经不用了的废弃选项。</P></DD><DT><TT CLASS="OPTION">-j <TT CLASS="REPLACEABLE"><I>njobs</I></TT></TT><BR><TT CLASS="OPTION">--jobs=<TT CLASS="REPLACEABLE"><I>njobs</I></TT></TT></DT><DD><P>通过同时转储<TT CLASS="REPLACEABLE"><I>njobs</I></TT>表并行运行转储。
该选项减少了转储的时间，但是也增加了数据库服务器的负载。可以只将这个选项用于目录输出格式，
因为这是多进程可以同时写它们的数据的唯一的输出格式。</P><P><SPAN CLASS="APPLICATION">pg_dump</SPAN>将打开<TT CLASS="REPLACEABLE"><I>njobs</I></TT> + 1个到数据库的连接，
所以确保你的<A HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</A>设置足够高以适应所有的连接。</P><P>运行并行转储时在数据库对象上请求排他锁会导致转储失败。原因是<SPAN CLASS="APPLICATION">pg_dump</SPAN>
主进程在工作进程稍后转储的对象上请求共享锁，这样做是为了确保在转储运行时没有人删除它们或移走它们。
如果另一个客户端然后在一个表上请求一个排他锁，该锁将不被授予，但是将会排队等候主进程的共享锁释放。
因此，任意其他访问表的请求也将不被授予，并且会在排他锁请求后排队。
这包含工作进程尝试转储这个表。没有防范措施这将是一个经典的死锁情况。为了检测这个冲突，
<SPAN CLASS="APPLICATION">pg_dump</SPAN>工作进程请求使用<TT CLASS="LITERAL">NOWAIT</TT>选项请求另外一个共享锁。
如果没有授予工作进程这个共享锁，那么肯定是另外一个人在此期间请求了一个排他锁，
并且没有办法继续进行转储了，所以<SPAN CLASS="APPLICATION">pg_dump</SPAN>只能退出转储。</P><P>对于一个一致的备份，数据库服务器需要支持同步快照，这是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.2
引入的一个特性。有了这个特性，数据库客户端可以保证他们看到相同的数据设置，即使它们使用不同的连接。
<TT CLASS="COMMAND">pg_dump -j</TT>使用多个数据库连接；它与主进程连接到数据库一次，然后再次连接到每个worker工作。
没有同步快照特性，不同的worker工作将不会保证在每个连接中看到相同的数据，这将导致一个不一致的备份。</P><P>如果你想在一个9.2之前的服务器上运行并行转储，那么你需要保证在主进程到最后一个worker工作连接到数据库之间，
数据库内容不会改变。最简单的方法是在开始备份之前叫停所有数据修改进程（DDL和DML）访问数据库。
你也需要在9.2之前的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器上运行<TT CLASS="COMMAND">pg_dump -j</TT>
时，声明<TT CLASS="OPTION">--no-synchronized-snapshots</TT>参数。</P></DD><DT><TT CLASS="OPTION">-n <TT CLASS="REPLACEABLE"><I>schema</I></TT></TT><BR><TT CLASS="OPTION">--schema=<TT CLASS="REPLACEABLE"><I>schema</I></TT></TT></DT><DD><P>只转储匹配<TT CLASS="REPLACEABLE"><I>schema</I></TT>的模式内容，
包括模式本身以及其中包含的对象。如果没有声明这个选项，
所有目标数据库中的非系统模式都会被转储出来。可以使用多个<TT CLASS="OPTION">-n</TT>选项指定多个模式。
同样，<TT CLASS="REPLACEABLE"><I>schema</I></TT>参数将按照<SPAN CLASS="APPLICATION">psql</SPAN>
的<TT CLASS="LITERAL">\d</TT>命令的规则(参见<A HREF="app-psql.html#APP-PSQL-PATTERNS"><I>匹配模式</I></A>)
被解释为匹配模式，因此可以使用通配符匹配多个模式。在使用通配符的时候，最好用引号进行界定，
以防止 shell 将通配符进行扩展。参阅<A HREF="app-pgdump.html#PG-DUMP-EXAMPLES"><I>例子</I></A>。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>如果指定了<TT CLASS="OPTION">-n</TT>，那么<SPAN CLASS="APPLICATION">pg_dump</SPAN>
将不会转储那些模式所依赖的其他数据库对象。因此，
无法保证转储出来的内容一定能够在另一个干净的数据库中恢复成功。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>非模式对象(比如大对象)不会在指定<TT CLASS="OPTION">-n</TT>的时候被转储出来。
你可以使用<TT CLASS="OPTION">--blobs</TT>明确要求转储大对象。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="OPTION">-N <TT CLASS="REPLACEABLE"><I>schema</I></TT></TT><BR><TT CLASS="OPTION">--exclude-schema=<TT CLASS="REPLACEABLE"><I>schema</I></TT></TT></DT><DD><P>不转储任何匹配<TT CLASS="REPLACEABLE"><I>schema</I></TT>的模式内容。
模式匹配规则与<TT CLASS="OPTION">-n</TT>完全相同。可以指定多个<TT CLASS="OPTION">-N</TT>以排除多种匹配的模式。</P><P>如果同时指定了<TT CLASS="OPTION">-n</TT>和<TT CLASS="OPTION">-N</TT>，那么将只转储匹配<TT CLASS="OPTION">-n</TT>
但不匹配<TT CLASS="OPTION">-N</TT>的模式。如果出现<TT CLASS="OPTION">-N</TT>但是不出现<TT CLASS="OPTION">-n</TT>，
那么匹配<TT CLASS="OPTION">-N</TT>的模式将不会被转储。</P></DD><DT><TT CLASS="OPTION">-o</TT><BR><TT CLASS="OPTION">--oids</TT></DT><DD><P>作为数据的一部分，为每个表都输出对象标识(<ACRONYM CLASS="ACRONYM">OID</ACRONYM>s)。
如果你的应用需要<ACRONYM CLASS="ACRONYM">OID</ACRONYM>字段的话(比如在外键约束中用到)，那么使用这个选项。
否则，不应该使用这个选项。</P></DD><DT><TT CLASS="OPTION">-O</TT><BR><TT CLASS="OPTION">--no-owner</TT></DT><DD><P>不把对象的所有权设置为对应源数据库。<SPAN CLASS="APPLICATION">pg_dump</SPAN>默认发出
<TT CLASS="COMMAND">ALTER OWNER</TT>或<TT CLASS="COMMAND">SET SESSION AUTHORIZATION</TT>
语句以设置创建的数据库对象的所有权。如果这些脚本将来没有被超级用户
(或者拥有脚本中全部对象的用户)运行的话将会失败。<TT CLASS="OPTION">-O</TT>
选项就是为了让该脚本可以被任何用户恢复并且将脚本中对象的所有权赋予该选项指定的用户。</P><P>这个选项只是对纯文本格式有意义。对于归档格式，在调用<TT CLASS="COMMAND">pg_restore</TT>
的时候可以声明该选项。</P></DD><DT><TT CLASS="OPTION">-R</TT><BR><TT CLASS="OPTION">--no-reconnect</TT></DT><DD><P>这个选项已经过时，但是出于向下兼容的考虑，仍然接受这个选项。</P></DD><DT><TT CLASS="OPTION">-s</TT><BR><TT CLASS="OPTION">--schema-only</TT></DT><DD><P>只输出对象定义(模式)，不输出数据。</P><P>这个选项与<TT CLASS="OPTION">--data-only</TT>相反。类似于，但是由于历史原因不等于声明
<TT CLASS="OPTION">--section=pre-data --section=post-data</TT>。</P><P>不要与<TT CLASS="OPTION">--schema</TT>选项混淆，<TT CLASS="OPTION">--schema</TT>使用不同含义的<SPAN CLASS="QUOTE">"schema"</SPAN>。</P><P>排除表数据只是数据库中表的一个子集，参阅<TT CLASS="OPTION">--exclude-table-data</TT>。</P></DD><DT><TT CLASS="OPTION">-S <TT CLASS="REPLACEABLE"><I>username</I></TT></TT><BR><TT CLASS="OPTION">--superuser=<TT CLASS="REPLACEABLE"><I>username</I></TT></TT></DT><DD><P>指定关闭触发器时需要用到的超级用户名。它只有使用了<TT CLASS="OPTION">--disable-triggers</TT>
的时候才有影响。一般情况下最好不要输入这个参数，而是用超级用户启动生成的脚本。</P></DD><DT><TT CLASS="OPTION">-t <TT CLASS="REPLACEABLE"><I>table</I></TT></TT><BR><TT CLASS="OPTION">--table=<TT CLASS="REPLACEABLE"><I>table</I></TT></TT></DT><DD><P>只转储出匹配<TT CLASS="REPLACEABLE"><I>table</I></TT>的表（或视图、序列、外表）。
可以使用多个<TT CLASS="OPTION">-t</TT>选项匹配多个表。同样，<TT CLASS="REPLACEABLE"><I>table</I></TT>
参数将按照<SPAN CLASS="APPLICATION">psql</SPAN>的<TT CLASS="LITERAL">\d</TT>命令的规则(参见
<A HREF="app-psql.html#APP-PSQL-PATTERNS"><I>匹配模式</I></A>)被解释为匹配模式，
因此可以使用通配符匹配多个模式。在使用通配符的时候，最好用引号进行界定，
以防止 shell 将通配符进行扩展。参阅<A HREF="app-pgdump.html#PG-DUMP-EXAMPLES"><I>例子</I></A>。</P><P>使用了<TT CLASS="OPTION">-t</TT>之后，<TT CLASS="OPTION">-n</TT>和<TT CLASS="OPTION">-N</TT>选项就失效了。因为被<TT CLASS="OPTION">-t</TT>
选中的表将无视<TT CLASS="OPTION">-n</TT>和<TT CLASS="OPTION">-N</TT>选项而被转储，同时除了表之外的其他对象不会被转储。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>如果指定了<TT CLASS="OPTION">-t</TT>，那么<SPAN CLASS="APPLICATION">pg_dump</SPAN>
将不会转储任何选中的表依赖的其它数据库对象。因此，
无法保证转储出来的表能在一个干净的数据库中成功恢复。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><TT CLASS="OPTION">-t</TT>选项与<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.2 之前的版本不兼容。
之前的<TT CLASS="LITERAL">-t tab</TT>将转储所有名为<TT CLASS="LITERAL">tab</TT>的表，
但是现在只转储在默认搜索路径中可见的表。写成<TT CLASS="LITERAL">-t '*.tab'</TT>将等价于老版本的行为。
同样，你必须用<TT CLASS="LITERAL">-t sch.tab</TT>而不是老版本的<TT CLASS="LITERAL">-n sch -t tab</TT>选择特定模式中的表。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="OPTION">-T <TT CLASS="REPLACEABLE"><I>table</I></TT></TT><BR><TT CLASS="OPTION">--exclude-table=<TT CLASS="REPLACEABLE"><I>table</I></TT></TT></DT><DD><P>不要转储任何匹配<TT CLASS="REPLACEABLE"><I>table</I></TT>模式的表。
模式匹配规则与<TT CLASS="OPTION">-t</TT>完全相同。可以指定多个<TT CLASS="OPTION">-T</TT>以排除多种匹配的表。</P><P>如果同时指定了<TT CLASS="OPTION">-t</TT>和<TT CLASS="OPTION">-T</TT>，那么将只转储匹配<TT CLASS="OPTION">-t</TT>
但不匹配<TT CLASS="OPTION">-T</TT>的表。如果出现<TT CLASS="OPTION">-T</TT>但是不出现<TT CLASS="OPTION">-t</TT>，
那么匹配 <TT CLASS="OPTION">-T</TT>的表将不会被转储。</P></DD><DT><TT CLASS="OPTION">-v</TT><BR><TT CLASS="OPTION">--verbose</TT></DT><DD><P>指定冗余模式。这样将令<SPAN CLASS="APPLICATION">pg_dump</SPAN>
输出详细的对象评注以及转储文件的启停时间和进度信息到标准错误上。</P></DD><DT><TT CLASS="OPTION">-V</TT><BR><TT CLASS="OPTION">--version</TT></DT><DD><P>打印<SPAN CLASS="APPLICATION">pg_dump</SPAN>版本然后退出。</P></DD><DT><TT CLASS="OPTION">-x</TT><BR><TT CLASS="OPTION">--no-privileges</TT><BR><TT CLASS="OPTION">--no-acl</TT></DT><DD><P>禁止转储访问权限(grant/revoke 命令)。</P></DD><DT><TT CLASS="OPTION">-Z <TT CLASS="REPLACEABLE"><I>0..9</I></TT></TT><BR><TT CLASS="OPTION">--compress=<TT CLASS="REPLACEABLE"><I>0..9</I></TT></TT></DT><DD><P>指定要使用的压缩级别。0表示不压缩。对于自定义归档格式，指定单个表数据段的压缩，
并且缺省是中等水平的压缩。对于纯文本输出，设置非零压缩级别会压缩整个输出文件，
就像通过<SPAN CLASS="APPLICATION">gzip</SPAN>反馈回来一样；但是缺省是不压缩的。
tar归档模式当前不支持压缩。</P></DD><DT><TT CLASS="OPTION">--binary-upgrade</TT></DT><DD><P>此选项用于在线升级工具。不建议也不支持用于其他目的。该选项的行为可能会在将来的版本中改变。</P></DD><DT><TT CLASS="OPTION">--column-inserts</TT><BR><TT CLASS="OPTION">--attribute-inserts</TT></DT><DD><P>把数据转储为带有明确字段名的<TT CLASS="COMMAND">INSERT</TT>命令
(<TT CLASS="LITERAL">INSERT INTO <TT CLASS="REPLACEABLE"><I>table</I></TT> (<TT CLASS="REPLACEABLE"><I>column</I></TT>, ...)
VALUES ...</TT>)。这样会导致恢复非常缓慢，它主要用于制作那种可以用于其它非
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>数据库的转储。由于这个选项为每条记录都生成一条命令，
因此如果其中某一行命令出错，那么将仅有该行数据丢失，而不是整个表的数据丢失。</P></DD><DT><TT CLASS="OPTION">--disable-dollar-quoting</TT></DT><DD><P>这个选项关闭使用美元符界定函数体。强制它们用 SQL 标准的字符串语法的引号包围。</P></DD><DT><TT CLASS="OPTION">--disable-triggers</TT></DT><DD><P>这个选项只是和创建仅有数据的转储相关。它告诉<SPAN CLASS="APPLICATION">pg_dump</SPAN>
包含在恢复数据时临时关闭目标表上触发器的命令。如果在表上有参照完整性检查或者其它触发器，
而恢复数据的时候不想重载他们，那么就应该使用这个选项。</P><P>目前，为<TT CLASS="OPTION">--disable-triggers</TT>发出的命令必须以超级用户来执行。因此，
你应该同时用<TT CLASS="OPTION">-S</TT>声明一个超级用户名，
或者最好是用一个超级用户的身份来启动这个生成的脚本。</P><P>这个选项只对纯文本格式有意义。对于归档格式，可以在调用<TT CLASS="COMMAND">pg_restore</TT>
的时候声明这个选项。</P></DD><DT><TT CLASS="OPTION">--exclude-table-data=<TT CLASS="REPLACEABLE"><I>table</I></TT></TT></DT><DD><P>不要转储任何匹配<TT CLASS="REPLACEABLE"><I>table</I></TT>模式的表。
模式匹配规则与<TT CLASS="OPTION">-t</TT>完全相同。可以给出多个<TT CLASS="OPTION">--exclude-table-data</TT>
以排除多个匹配的表。当你需要指定表的定义时该选项是有用的，即使你不需要表里面的数据。</P><P>要排除数据库中所有表的数据，参阅<TT CLASS="OPTION">--schema-only</TT>。</P></DD><DT><TT CLASS="OPTION">--inserts</TT></DT><DD><P>将数据输出为的<TT CLASS="COMMAND">INSERT</TT>命令(而不是<TT CLASS="COMMAND">COPY</TT>)。
这样会导致恢复非常缓慢。这个选项主要用于制作那种可以用于其它非
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>数据库的转储。由于这个选项为每条记录都生成一条命令，
因此如果其中某一行命令出错，那么将仅有该行数据丢失，而不是整个表的数据丢失。
请注意，如果你重新排列了字段顺序，那么恢复可能会完全失败。
<TT CLASS="OPTION">--column-inserts</TT>更安全，但是也更慢。</P></DD><DT><TT CLASS="OPTION">--lock-wait-timeout=<TT CLASS="REPLACEABLE"><I>timeout</I></TT></TT></DT><DD><P>在转储开始的时候不要等待请求一个共享表锁。相反，如果无法在指定的
<TT CLASS="REPLACEABLE"><I>timeout</I></TT>内锁住表则失败。
timeout可以用任意<TT CLASS="COMMAND">SET statement_timeout</TT>接受的格式声明。
（允许的值依赖于你转储的服务器版本，但是自7.3以来，所有的版本都接受毫秒的整数值。
当从7.3以前的版本服务器中转储时，省略该选项。）</P></DD><DT><TT CLASS="OPTION">--no-security-labels</TT></DT><DD><P>不转储安全标签。</P></DD><DT><TT CLASS="OPTION">--no-synchronized-snapshots</TT></DT><DD><P>该选项允许在9.2以前的服务器上运行<TT CLASS="COMMAND">pg_dump -j</TT>，参阅<TT CLASS="OPTION">-j</TT>
参数的文档获取更多信息。</P></DD><DT><TT CLASS="OPTION">--no-tablespaces</TT></DT><DD><P>不要输出选择表空间的命令。有了该选项，所有对象在转储期间都将在缺省的表空间中创建。</P><P>这个选项只是对纯文本格式有意义。对于归档格式，在调用<TT CLASS="COMMAND">pg_restore</TT>
的时候可以声明该选项。</P></DD><DT><TT CLASS="OPTION">--no-unlogged-table-data</TT></DT><DD><P>不要转储未记录表的内容。该选项对于表定义（模式）是否转储没有影响；
它只阻止转储表的数据。当从备用服务器转储时，未记录表中的数据总是排除。</P></DD><DT><TT CLASS="OPTION">--quote-all-identifiers</TT></DT><DD><P>强制给所有标识符加上引号。这在转储一个数据库到一个可能引入了额外关键字的新版本中时可能是有用的。</P></DD><DT><TT CLASS="OPTION">--section=<TT CLASS="REPLACEABLE"><I>sectionname</I></TT></TT></DT><DD><P>只转储命名的章节。该章节名可以是<TT CLASS="OPTION">pre-data</TT>, <TT CLASS="OPTION">data</TT>, 或
<TT CLASS="OPTION">post-data</TT>。可以多次声明这个选项以选择多个章节。
缺省是转储所有章节。</P><P>数据章节包含实际的表数据、大对象内容和序列值。原始数据项包含索引、触发器、
规则和约束（除了验证检查约束）的定义。之前的数据项包含所有其他数据定义项。</P></DD><DT><TT CLASS="OPTION">--serializable-deferrable</TT></DT><DD><P>为转储使用一个<TT CLASS="LITERAL">可串行化</TT>的事务，以保证使用的快照和稍后的数据库状态一致；
做这些是通过等待事务流中的一个点，该点没有异常会出现，所以不会有转储失败或导致其他事务
<TT CLASS="LITERAL">serialization_failure</TT>而回滚的风险。参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/mvcc.html">第 13 &#31456;</A>
获取关于事务隔离和并发控制的更多信息。</P><P>这个选项对于只打算灾难恢复的转储没有益处。对于原始数据库仍然在更新时，
加载一个数据库的拷贝作为报告或其他只读加载共享的转储是有帮助的。
没有这个选项，转储会反应一个与任何事务最终提交的序列化执行不一致的状态。
例如，如果使用了批处理技术，可能会在转储中显示一部分，而不是批处理中的所有条目。</P><P>在pg_dump开始时，如果没有读写事务在活动，则这个选项没有什么影响。
如果有读写事务在活动，那么转储开始时可能会延迟一段不确定的时间。
一旦运行，有没有开关的性能是一样的。</P></DD><DT><TT CLASS="OPTION">--use-set-session-authorization</TT></DT><DD><P>输出符合 SQL 标准的<TT CLASS="COMMAND">SET SESSION AUTHORIZATION</TT>命令而不是<TT CLASS="COMMAND">ALTER OWNER</TT>
命令来确定对象所有权。这样令转储更加符合标准，但是如果转储文件中的对象的历史有些问题，
那么可能不能正确恢复。并且，使用<TT CLASS="COMMAND">SET SESSION AUTHORIZATION</TT>
的转储需要数据库超级用户的权限才能转储成功，而<TT CLASS="COMMAND">ALTER OWNER</TT>需要的权限则低得多。</P></DD><DT><TT CLASS="OPTION">-?</TT><BR><TT CLASS="OPTION">--help</TT></DT><DD><P>显示关于<SPAN CLASS="APPLICATION">pg_dump</SPAN>命令行参数的帮助然后退出。</P></DD></DL></DIV><P>
</P><P> 下面的命令行参数控制数据库的连接参数。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-d <TT CLASS="REPLACEABLE"><I>dbname</I></TT></TT><BR><TT CLASS="OPTION">--dbname=<TT CLASS="REPLACEABLE"><I>dbname</I></TT></TT></DT><DD><P>声明要连接的数据库名称。相当于在命令行中声明<TT CLASS="REPLACEABLE"><I>dbname</I></TT>
作为第一个非选项参数。</P><P>如果这个参数包含一个<TT CLASS="SYMBOL">=</TT>符号或以一个有效的<ACRONYM CLASS="ACRONYM">URI</ACRONYM>前缀
(<TT CLASS="LITERAL">postgresql://</TT>或<TT CLASS="LITERAL">postgres://</TT>)开始，
那么将其看做一个<TT CLASS="PARAMETER">conninfo</TT>字符串。参阅<A HREF="libpq-connect.html">第 31.1 &#33410;</A>
获取更多信息。</P></DD><DT><TT CLASS="OPTION">-h <TT CLASS="REPLACEABLE"><I>host</I></TT></TT><BR><TT CLASS="OPTION">--host=<TT CLASS="REPLACEABLE"><I>host</I></TT></TT></DT><DD><P>指定运行服务器的主机名。如果数值以斜杠开头，则被用作到 Unix 域套接字的路径。
缺省从<TT CLASS="ENVAR">PGHOST</TT>环境变量中获取(如果设置了的话)，否则，尝试一个 Unix 域套接字连接。</P></DD><DT><TT CLASS="OPTION">-p <TT CLASS="REPLACEABLE"><I>port</I></TT></TT><BR><TT CLASS="OPTION">--port=<TT CLASS="REPLACEABLE"><I>port</I></TT></TT></DT><DD><P>指定服务器正在侦听的 TCP 端口或本地 Unix 域套接字文件的扩展(描述符)。
缺省使用<TT CLASS="ENVAR">PGPORT</TT>环境变量(如果设置了的话)，否则，编译时的缺省值。</P></DD><DT><TT CLASS="OPTION">-U <TT CLASS="REPLACEABLE"><I>username</I></TT></TT><BR><TT CLASS="OPTION">--username=<TT CLASS="REPLACEABLE"><I>username</I></TT></TT></DT><DD><P>连接的用户名。</P></DD><DT><TT CLASS="OPTION">-w</TT><BR><TT CLASS="OPTION">--no-password</TT></DT><DD><P>从不发出密码提示问题。如果服务器要求密码认证并且密码不可用于其他意思如
<TT CLASS="FILENAME">.pgpass</TT>文件，则连接尝试将会失败。
该选项在批量工作和不存在用户输入密码的脚本中很有帮助。</P></DD><DT><TT CLASS="OPTION">-W</TT><BR><TT CLASS="OPTION">--password</TT></DT><DD><P>强制<SPAN CLASS="APPLICATION">pg_dump</SPAN>在连接到数据库之前提示一个密码。</P><P>这个选项从来不是至关重要的，因为如果服务器需求密码认证，则<SPAN CLASS="APPLICATION">pg_dump</SPAN>
自动提示一个密码。不过，<SPAN CLASS="APPLICATION">pg_dump</SPAN>
将在找出服务器想要一个密码上浪费一个连接尝试。在某些情况下，值得输入<TT CLASS="OPTION">-W</TT>
以避免额外的连接尝试。</P></DD><DT><TT CLASS="OPTION">--role=<TT CLASS="REPLACEABLE"><I>rolename</I></TT></TT></DT><DD><P>指定创建转储的角色名。这个选项导致连接到数据库之后<SPAN CLASS="APPLICATION">pg_dump</SPAN>
发出一个<TT CLASS="COMMAND">SET ROLE</TT> <TT CLASS="REPLACEABLE"><I>rolename</I></TT>命令。
当认证的用户（通过<TT CLASS="OPTION">-U</TT>指定）缺乏<SPAN CLASS="APPLICATION">pg_dump</SPAN>所需的权限时是很有用的，
可以转变成有所需权限的角色。一些安装有反对作为超级用户直接登录的政策，
使用这个选项允许转储不违反该政策。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN84908"></A><H2>环境变量</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="ENVAR">PGDATABASE</TT><BR><TT CLASS="ENVAR">PGHOST</TT><BR><TT CLASS="ENVAR">PGOPTIONS</TT><BR><TT CLASS="ENVAR">PGPORT</TT><BR><TT CLASS="ENVAR">PGUSER</TT></DT><DD><P>缺省连接参数。</P></DD></DL></DIV><P>这个功用，类似大多数其他<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>实用工具，
也使用由<SPAN CLASS="APPLICATION">libpq</SPAN>支持的环境变量（参阅<A HREF="libpq-envars.html">第 31.14 &#33410;</A>）。</P></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PGDUMP-DIAGNOSTICS"></A><H2>诊断</H2><P><SPAN CLASS="APPLICATION">pg_dump</SPAN>在内部使用<TT CLASS="COMMAND">SELECT</TT>语句。
如果你运行<SPAN CLASS="APPLICATION">pg_dump</SPAN>时碰到问题，确认你能够使用像
<A HREF="app-psql.html"><SPAN CLASS="APPLICATION">psql</SPAN></A>这样的程序从数据库选取信息。还有，要申请
任何<SPAN CLASS="APPLICATION">libpq</SPAN>前端库要使用的缺省连接设置和环境变量。</P><P><SPAN CLASS="APPLICATION">pg_dump</SPAN>的数据库活动通常由统计收集器收集。
如果不需要，你可以通过<TT CLASS="ENVAR">PGOPTIONS</TT> 或 <TT CLASS="LITERAL">ALTER
USER</TT>命令设置参数<TT CLASS="VARNAME">track_counts</TT>为假。</P></DIV><DIV CLASS="REFSECT1"><A NAME="PG-DUMP-NOTES"></A><H2>注意</H2><P>如果你的数据库给<TT CLASS="LITERAL">template1</TT>数据库增加了任何你自己的东西，
那么请注意把<SPAN CLASS="APPLICATION">pg_dump</SPAN>的输出恢复到一个真正空的数据库中；
否则你可能会收到因为重复定义所追加的对象而造成的错误信息。
要制作一个没有任何本地附属物的数据库，可以从<TT CLASS="LITERAL">template0</TT>
而不是<TT CLASS="LITERAL">template1</TT>拷贝，比如：
</P><PRE CLASS="PROGRAMLISTING">CREATE DATABASE foo WITH TEMPLATE template0;</PRE><P></P><P>在进行纯数据转储并且使用了选项<TT CLASS="OPTION">--disable-triggers</TT>的时候，
<SPAN CLASS="APPLICATION">pg_dump</SPAN>发出一些查询先关闭用户表上的触发器，
然后插入数据，插入完成后再打开触发器。如果恢复动作在中间停止，
那么系统表可能就会处于一种错误状态。</P><P>tar 归档的成员的大小限制于 8 GB 。这是 tar 文件格式的固有限制。
因此这个格式无法用于任何大小超过这个尺寸的表。
tar 归档和任何其它输出格式的总大小是不受限制的，只是可能会有操作系统的限制。</P><P><SPAN CLASS="APPLICATION">pg_dump</SPAN>生成的转储文件并不包含优化器用于查询规划决策的统计信息。
因此，恢复完之后，建议在每个已恢复的对象上运行<TT CLASS="COMMAND">ANALYZE</TT>，
以保证最佳的性能；参阅<A HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS">第 23.1.3 &#33410;</A>和<A HREF="routine-vacuuming.html#AUTOVACUUM">第 23.1.6 &#33410;</A>
获取更多信息。转储文件也不包含任何<TT CLASS="COMMAND">ALTER DATABASE ... SET</TT>命令；
这些设置通过<A HREF="app-pg-dumpall.html"><SPAN CLASS="APPLICATION">pg_dumpall</SPAN></A>转储，连同数据库用户和其他安装范围的设置。</P><P>因为<SPAN CLASS="APPLICATION">pg_dump</SPAN>常用于向新版本的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
中传递数据，所以<SPAN CLASS="APPLICATION">pg_dump</SPAN>的输出预计可以加载到比
<SPAN CLASS="APPLICATION">pg_dump</SPAN>的版本更新的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
服务器版本中。<SPAN CLASS="APPLICATION">pg_dump</SPAN>还可以从比它自身版本老的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
服务器中转储。（当前，支持后退到版本7.0的服务器。）不过，<SPAN CLASS="APPLICATION">pg_dump</SPAN>
不能从比它自身主版本新的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器中转储；它会拒绝尝试，
而不是冒险制作一个不可用的转储。另外，它不保证<SPAN CLASS="APPLICATION">pg_dump</SPAN>
的输出可以加载到一个旧的主版本的服务器中，即使该转储是从那个版本的服务器中而来。
加载转储文件到一个旧的服务器可能需要手动编辑转储文件，以删除不被旧版本理解的语法。</P></DIV><DIV CLASS="REFSECT1"><A NAME="PG-DUMP-EXAMPLES"></A><H2>例子</H2><P>将<TT CLASS="LITERAL">mydb</TT>数据库转储到一个 SQL 脚本文件：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump mydb &gt; db.sql</KBD
></PRE><P></P><P>将上述脚本导入一个(新建的)数据库<TT CLASS="LITERAL">newdb</TT>：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -d newdb -f db.sql</KBD
></PRE><P></P><P>将数据库转储为自定义格式的归档文件
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -Fc mydb &gt; db.dump</KBD
></PRE><P></P><P>将数据库转储为目录格式归档：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -Fd mydb -f dumpdir</KBD
></PRE><P></P><P>将数据库转储为目录格式归档，并行5个worker工作：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -Fd mydb -j 5 -f dumpdir</KBD
></PRE><P></P><P>将归档文件导入一个(新建的)数据库<TT CLASS="LITERAL">newdb</TT>：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_restore -d newdb db.dump</KBD
></PRE><P></P><P>转储一个名为<TT CLASS="LITERAL">mytab</TT>的表：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -t mytab mydb &gt; db.sql</KBD
></PRE><P></P><P>转储<TT CLASS="LITERAL">detroit</TT>模式中所有以<TT CLASS="LITERAL">emp</TT>开头的表，
但是不包括<TT CLASS="LITERAL">employee_log</TT>表：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -t 'detroit.emp*' -T detroit.employee_log mydb &gt; db.sql</KBD
></PRE><P></P><P>转储所有以<TT CLASS="LITERAL">east</TT>或<TT CLASS="LITERAL">west</TT>开头并以<TT CLASS="LITERAL">gsm</TT>结尾的模式，
但是不包括名字中含有<TT CLASS="LITERAL">test</TT>模式：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -n 'east*gsm' -n 'west*gsm' -N '*test*' mydb &gt; db.sql</KBD
></PRE><P></P><P>同上，不过这一次使用正则表达式的方法：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -n '(east|west)*gsm' -N '*test*' mydb &gt; db.sql</KBD
></PRE><P></P><P>转储所有数据库对象，但是不包括名字以<TT CLASS="LITERAL">ts_</TT>开头的表：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -T 'ts_*' mydb &gt; db.sql</KBD
></PRE><P></P><P>在<TT CLASS="OPTION">-t</TT>等选项中指定大写字母或大小写混合的名字必须用双引号界定，
否则将被自动转换为小写(参见<A HREF="app-psql.html#APP-PSQL-PATTERNS"><I>匹配模式</I></A>)。
但是因为双引号在 shell 中有特殊含义，所以必须将双引号再放进单引号中。
这样一来，要转储一个大小写混合的表名，你就需要像下面这样：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -t "\"MixedCaseName\"" mydb &gt; mytab.sql</KBD
></PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN85035"></A><H2>又见</H2><A HREF="app-pg-dumpall.html"><SPAN CLASS="APPLICATION">pg_dumpall</SPAN></A>, <A HREF="app-pgrestore.html">pg_restore</A>, <A HREF="app-psql.html"><SPAN CLASS="APPLICATION">psql</SPAN></A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="app-pgconfig.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="app-pg-dumpall.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">pg_config</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><SPAN CLASS="APPLICATION">pg_dumpall</SPAN></TD></TR></TABLE></DIV></BODY></HTML>
