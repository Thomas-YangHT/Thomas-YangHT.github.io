<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>ltree</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="lo" HREF="lo.html"><LINK REL="NEXT" TITLE="pageinspect" HREF="pageinspect.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ltree.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="lo" HREF="lo.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="pageinspect" HREF="pageinspect.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LTREE">F.21. ltree</A></H1><P>这个模块实现了数据类型<TT CLASS="TYPE">ltree</TT>，该类型表示存储在分层的树形结构里的数据的标签。
提供大量的工具搜索标签树。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN147242">F.21.1. 定义</A></H2><P><I CLASS="FIRSTTERM">label</I>是一个字母数字字符和下划线的序列（例如，在C语言环境，
字符<TT CLASS="LITERAL">A-Za-z0-9_</TT>是允许的）。标签长度必须少于256字节。</P><P>示例：<TT CLASS="LITERAL">42</TT>, <TT CLASS="LITERAL">Personal_Services</TT></P><P><I CLASS="FIRSTTERM">label path</I>是零个或多个由点分隔的标签序列，例如<TT CLASS="LITERAL">L1.L2.L3</TT>，
表示由树状结构的根节点到具体节点的路径。标签路径的长度必须少于65Kb，
但是保持在2Kb以下是最好的。实际上，这不是主要限制；例如，
在DMOZ目录中的最长标签路径(<A HREF="http://www.dmoz.org" TARGET="_top">http://www.dmoz.org</A>)大约240字节。</P><P>示例：<TT CLASS="LITERAL">Top.Countries.Europe.Russia</TT></P><P><TT CLASS="FILENAME">ltree</TT>模块提供几种数据类型：</P><P></P><UL><LI><P><TT CLASS="TYPE">ltree</TT>存储标签路径。</P></LI><LI><P><TT CLASS="TYPE">lquery</TT>表示一个正规表达式类似的模式以匹配<TT CLASS="TYPE">ltree</TT>值。
在一个路径中一个单词匹配那个标签。星号(<TT CLASS="LITERAL">*</TT>)匹配零个或多个标签。例如：
</P><PRE CLASS="SYNOPSIS">foo         <I
CLASS="LINEANNOTATION"
>准确匹配标签路径 <TT
CLASS="LITERAL"
>foo</TT
></I
>
*.foo.*     <I
CLASS="LINEANNOTATION"
>匹配任何包含标签 <TT
CLASS="LITERAL"
>foo</TT
> 的标签路径</I
>
*.foo       <I
CLASS="LINEANNOTATION"
>匹配任何以 <TT
CLASS="LITERAL"
>foo</TT
> 结束的标签路径</I
></PRE><P>
</P><P>可以量化星号来限制可以匹配多少个标签：
</P><PRE CLASS="SYNOPSIS">*{<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>}        <I
CLASS="LINEANNOTATION"
>准确匹配 <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> 个标签</I
>
*{<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>,}       <I
CLASS="LINEANNOTATION"
>至少匹配 <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> 个标签</I
>
*{<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>,<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
>}      <I
CLASS="LINEANNOTATION"
>至少匹配 <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> 个但不超过 <TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
> 个标签</I
>
*{,<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
>}       <I
CLASS="LINEANNOTATION"
>最多匹配 <TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
> 个标签 &mdash; 和 </I
> *{0,<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
> 相同}</PRE><P></P><P>有几个修饰符可以放在<TT CLASS="TYPE">lquery</TT>中非星号标签的后面，使其不只是匹配正好的那个：
</P><PRE CLASS="SYNOPSIS">@           <I
CLASS="LINEANNOTATION"
>匹配大小写无关，例如 <TT
CLASS="LITERAL"
>a@</TT
> 匹配 <TT
CLASS="LITERAL"
>A</TT
></I
>
*           <I
CLASS="LINEANNOTATION"
>匹配任何带有这个前缀的标签，例如 <TT
CLASS="LITERAL"
>foo*</TT
> 匹配 <TT
CLASS="LITERAL"
>foobar</TT
></I
>
%           <I
CLASS="LINEANNOTATION"
>匹配字首下划线分开的单词</I
></PRE><P>
<TT CLASS="LITERAL">%</TT>的行为稍微有点复杂。它试图匹配单词而不是整个标签。例如<TT CLASS="LITERAL">foo_bar%</TT> 匹配
<TT CLASS="LITERAL">foo_bar_baz</TT>而不是<TT CLASS="LITERAL">foo_barbaz</TT>。如果与<TT CLASS="LITERAL">*</TT>结合，
前缀匹配分别应用到每个单词，例如<TT CLASS="LITERAL">foo_bar%*</TT>匹配<TT CLASS="LITERAL">foo1_bar2_baz</TT>
而不是not <TT CLASS="LITERAL">foo1_br2_baz</TT>。</P><P>还有，可以写几个由<TT CLASS="LITERAL">|</TT> (OR)分开的标签以匹配任意这些标签，
并且可以在开始放置<TT CLASS="LITERAL">!</TT> (NOT)以匹配任何不匹配任何可选标签的标签。</P><P>这是一个带有评注的<TT CLASS="TYPE">lquery</TT>的例子：
</P><PRE CLASS="PROGRAMLISTING">Top.*{0,2}.sport*@.!football|tennis.Russ*|Spain
a.  b.     c.      d.               e.</PRE><P>
这个查询将匹配任何标签路径：</P><P></P><OL TYPE="a"><LI><P>以标签<TT CLASS="LITERAL">Top</TT>开始</P></LI><LI><P>然后有0到2个标签</P></LI><LI><P>然后是一个带有大小写不敏感前缀<TT CLASS="LITERAL">sport</TT>的标签</P></LI><LI><P>然后是一个既不匹配<TT CLASS="LITERAL">football</TT>也不匹配<TT CLASS="LITERAL">tennis</TT>的标签</P></LI><LI><P>然后以一个带有<TT CLASS="LITERAL">Russ</TT>或准确匹配<TT CLASS="LITERAL">Spain</TT>开头的标签作为结束。</P></LI></OL></LI><LI><P><TT CLASS="TYPE">ltxtquery</TT>表示一个匹配<TT CLASS="TYPE">ltree</TT>值的全文本搜索风格模式。
<TT CLASS="TYPE">ltxtquery</TT>值包含单词，可能在结尾带有修饰词<TT CLASS="LITERAL">@</TT>, <TT CLASS="LITERAL">*</TT>, <TT CLASS="LITERAL">%</TT>，
这些修饰词的含义和在<TT CLASS="TYPE">lquery</TT>中的含义相同。单词可以与<TT CLASS="LITERAL">&amp;</TT> (AND),
<TT CLASS="LITERAL">|</TT> (OR), <TT CLASS="LITERAL">!</TT> (NOT) 和圆括号结合。与<TT CLASS="TYPE">lquery</TT>
主要的不同是<TT CLASS="TYPE">ltxtquery</TT>匹配单词时不考虑单词在标签路径中的位置。</P><P>这是一个<TT CLASS="TYPE">ltxtquery</TT>的例子：
</P><PRE CLASS="PROGRAMLISTING">Europe &amp; Russia*@ &amp; !Transportation</PRE><P>
这将匹配包含<TT CLASS="LITERAL">Europe</TT>标签和以<TT CLASS="LITERAL">Russia</TT>
（大小写不敏感）开始的标签的路径，但是不匹配包含<TT CLASS="LITERAL">Transportation</TT>
标签的路径。这些单词在路径中的位置并不重要。还有，当使用了<TT CLASS="LITERAL">%</TT>时，
该单词能匹配标签中任何用下划线分隔单词，不管位置在哪。</P></LI></UL><P>注意：<TT CLASS="TYPE">ltxtquery</TT>允许符号之间有空格，但是<TT CLASS="TYPE">ltree</TT> 和
<TT CLASS="TYPE">lquery</TT>不允许这样做。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN147357">F.21.2. 操作符和函数</A></H2><P>类型<TT CLASS="TYPE">ltree</TT>有平常的比较操作符<TT CLASS="LITERAL">=</TT>, <TT CLASS="LITERAL">&lt;&gt;</TT>,
<TT CLASS="LITERAL">&lt;</TT>, <TT CLASS="LITERAL">&gt;</TT>, <TT CLASS="LITERAL">&lt;=</TT>, <TT CLASS="LITERAL">&gt;=</TT>。
比较的优先级以树遍历的顺序，节点的子节点以标签文本排序。另外，
在<A HREF="ltree.html#LTREE-OP-TABLE">&#34920; F-12</A>中显示的专业的操作符是可用的。</P><DIV CLASS="TABLE"><A NAME="LTREE-OP-TABLE"></A><P><B>&#34920; F-12. <TT CLASS="TYPE">ltree</TT> 操作符</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>操作符</TH><TH>返回</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">@&gt;</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>左边参数是右边参数的上代 (或相等)?</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">&lt;@</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>左边参数是右边参数的后代 (或相等)?</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">~</TT> <TT CLASS="TYPE">lquery</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 匹配 <TT CLASS="TYPE">lquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">lquery</TT> <TT CLASS="LITERAL">~</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 匹配 <TT CLASS="TYPE">lquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">?</TT> <TT CLASS="TYPE">lquery[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 匹配数组中的任意 <TT CLASS="TYPE">lquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">lquery[]</TT> <TT CLASS="LITERAL">?</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 匹配数组中的任意 <TT CLASS="TYPE">lquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">@</TT> <TT CLASS="TYPE">ltxtquery</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 匹配 <TT CLASS="TYPE">ltxtquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">ltxtquery</TT> <TT CLASS="LITERAL">@</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 匹配 <TT CLASS="TYPE">ltxtquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">||</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>连接 <TT CLASS="TYPE">ltree</TT> 路径</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">||</TT> <TT CLASS="TYPE">text</TT></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>将文本转化成 <TT CLASS="TYPE">ltree</TT> 并连接</TD></TR><TR><TD><TT CLASS="TYPE">text</TT> <TT CLASS="LITERAL">||</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>将文本转化成 <TT CLASS="TYPE">ltree</TT> 并连接</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">@&gt;</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数组包含 <TT CLASS="TYPE">ltree</TT> 的祖先?</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">&lt;@</TT> <TT CLASS="TYPE">ltree[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数组包含 <TT CLASS="TYPE">ltree</TT> 的祖先?</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">&lt;@</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数组包含 <TT CLASS="TYPE">ltree</TT> 的后代?</TD></TR><TR><TD><TT CLASS="TYPE">ltree</TT> <TT CLASS="LITERAL">@&gt;</TT> <TT CLASS="TYPE">ltree[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数组包含 <TT CLASS="TYPE">ltree</TT> 的后代?</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">~</TT> <TT CLASS="TYPE">lquery</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数据包含任何匹配 <TT CLASS="TYPE">lquery</TT> 的路径?</TD></TR><TR><TD><TT CLASS="TYPE">lquery</TT> <TT CLASS="LITERAL">~</TT> <TT CLASS="TYPE">ltree[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数据包含任何匹配 <TT CLASS="TYPE">lquery</TT> 的路径?</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">?</TT> <TT CLASS="TYPE">lquery[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 数组包含任意路径匹配任意 <TT CLASS="TYPE">lquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">lquery[]</TT> <TT CLASS="LITERAL">?</TT> <TT CLASS="TYPE">ltree[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 数组包含任意路径匹配任意 <TT CLASS="TYPE">lquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">@</TT> <TT CLASS="TYPE">ltxtquery</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数据包含任意路径匹配 <TT CLASS="TYPE">ltxtquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">ltxtquery</TT> <TT CLASS="LITERAL">@</TT> <TT CLASS="TYPE">ltree[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>数组包含任意路径匹配 <TT CLASS="TYPE">ltxtquery</TT>?</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">?@&gt;</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>第一个数组条目是 <TT CLASS="TYPE">ltree</TT> 的祖先？; 如果不是则为 NULL</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">?&lt;@</TT> <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>第一个数组条目是 <TT CLASS="TYPE">ltree</TT> 的后代？; 如果不是则为 NULL</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">?~</TT> <TT CLASS="TYPE">lquery</TT></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>第一个数组条目匹配 <TT CLASS="TYPE">lquery</TT> ？; 如果不是则为 NULL</TD></TR><TR><TD><TT CLASS="TYPE">ltree[]</TT> <TT CLASS="LITERAL">?@</TT> <TT CLASS="TYPE">ltxtquery</TT></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>第一个数组条目匹配 <TT CLASS="TYPE">ltxtquery</TT> ？; 如果不是则为 NULL</TD></TR></TBODY></TABLE></DIV><P>操作符 <TT CLASS="LITERAL">&lt;@</TT>, <TT CLASS="LITERAL">@&gt;</TT>,
<TT CLASS="LITERAL">@</TT> 和 <TT CLASS="LITERAL">~</TT> 类似
<TT CLASS="LITERAL">^&lt;@</TT>, <TT CLASS="LITERAL">^@&gt;</TT>, <TT CLASS="LITERAL">^@</TT>,
<TT CLASS="LITERAL">^~</TT>，除了不用索引之外都相同。这些只是对于测试目的有用。</P><P>可用的函数显示在 <A HREF="ltree.html#LTREE-FUNC-TABLE">&#34920; F-13</A> 中。</P><DIV CLASS="TABLE"><A NAME="LTREE-FUNC-TABLE"></A><P><B>&#34920; F-13. <TT CLASS="TYPE">ltree</TT> 函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回类型</TH><TH>描述</TH><TH>示例</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD><CODE CLASS="FUNCTION">subltree(ltree, int start, int end)</CODE></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">ltree</TT>的子路径，从位置 <TT CLASS="PARAMETER">start</TT> 到位置
<TT CLASS="PARAMETER">end</TT>-1 (从0开始计算)</TD><TD><TT CLASS="LITERAL">subltree('Top.Child1.Child2',1,2)</TT></TD><TD><TT CLASS="LITERAL">Child1</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">subpath(ltree, int offset, int len)</CODE></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 的子路径，从位置 <TT CLASS="PARAMETER">offset</TT> 开始，长度为 <TT CLASS="PARAMETER">len</TT>。
如果 <TT CLASS="PARAMETER">offset</TT> 为负值，子路径从路径的结尾开始。如果 <TT CLASS="PARAMETER">len</TT> 是负值，
那么距离路径的结尾多少个标签。</TD><TD><TT CLASS="LITERAL">subpath('Top.Child1.Child2',0,2)</TT></TD><TD><TT CLASS="LITERAL">Top.Child1</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">subpath(ltree, int offset)</CODE></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="TYPE">ltree</TT> 的子路径，从位置 <TT CLASS="PARAMETER">offset</TT> 开始，一直到路径的结束。
如果 <TT CLASS="PARAMETER">offset</TT> 为负值，那么子路径从路径的结尾开始。</TD><TD><TT CLASS="LITERAL">subpath('Top.Child1.Child2',1)</TT></TD><TD><TT CLASS="LITERAL">Child1.Child2</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">nlevel(ltree)</CODE></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>路径中的标签的个数</TD><TD><TT CLASS="LITERAL">nlevel('Top.Child1.Child2')</TT></TD><TD><TT CLASS="LITERAL">3</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">index(ltree a, ltree b)</CODE></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD><TT CLASS="PARAMETER">b</TT> 在 <TT CLASS="PARAMETER">a</TT> 中第一次出现的位置；如果没有发现则为 -1</TD><TD><TT CLASS="LITERAL">index('0.1.2.3.5.4.5.6.8.5.6.8','5.6')</TT></TD><TD><TT CLASS="LITERAL">6</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">index(ltree a, ltree b, int offset)</CODE></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD><TT CLASS="PARAMETER">b</TT> 在 <TT CLASS="PARAMETER">a</TT> 中第一次出现的位置，从 <TT CLASS="PARAMETER">offset</TT>
开始搜索；负的 <TT CLASS="PARAMETER">offset</TT> 意味从路径结尾开始 <TT CLASS="PARAMETER">-offset</TT> 个标签</TD><TD><TT CLASS="LITERAL">index('0.1.2.3.5.4.5.6.8.5.6.8','5.6',-4)</TT></TD><TD><TT CLASS="LITERAL">9</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">text2ltree(text)</CODE></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>将 <TT CLASS="TYPE">text</TT> 转换为 <TT CLASS="TYPE">ltree</TT></TD><TD><TT CLASS="LITERAL"></TT></TD><TD><TT CLASS="LITERAL"></TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">ltree2text(ltree)</CODE></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>将 <TT CLASS="TYPE">ltree</TT> 转换为 <TT CLASS="TYPE">text</TT></TD><TD><TT CLASS="LITERAL"></TT></TD><TD><TT CLASS="LITERAL"></TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">lca(ltree, ltree, ...)</CODE></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>最低的公共祖先，也就是，路径的最长公共前缀（支持多达 8 个参数）</TD><TD><TT CLASS="LITERAL">lca('1.2.2.3','1.2.3.4.5.6')</TT></TD><TD><TT CLASS="LITERAL">1.2</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">lca(ltree[])</CODE></TD><TD><TT CLASS="TYPE">ltree</TT></TD><TD>最低的公共祖先，也就是，路径的最长公共前缀</TD><TD><TT CLASS="LITERAL">lca(array['1.2.2.3'::ltree,'1.2.3'])</TT></TD><TD><TT CLASS="LITERAL">1.2</TT></TD></TR></TBODY></TABLE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN147768">F.21.3. 索引</A></H2><P><TT CLASS="FILENAME">ltree</TT> 支持索引的几个类型，可以加速指出的操作符：</P><P></P><UL><LI><P><TT CLASS="TYPE">ltree</TT> 上的 B-tree 索引：
<TT CLASS="LITERAL">&lt;</TT>, <TT CLASS="LITERAL">&lt;=</TT>, <TT CLASS="LITERAL">=</TT>,
<TT CLASS="LITERAL">&gt;=</TT>, <TT CLASS="LITERAL">&gt;</TT></P></LI><LI><P><TT CLASS="TYPE">ltree</TT> 上的 GiST 索引：
<TT CLASS="LITERAL">&lt;</TT>, <TT CLASS="LITERAL">&lt;=</TT>, <TT CLASS="LITERAL">=</TT>,
<TT CLASS="LITERAL">&gt;=</TT>, <TT CLASS="LITERAL">&gt;</TT>,
<TT CLASS="LITERAL">@&gt;</TT>, <TT CLASS="LITERAL">&lt;@</TT>,
<TT CLASS="LITERAL">@</TT>, <TT CLASS="LITERAL">~</TT>, <TT CLASS="LITERAL">?</TT></P><P>创建这样一个索引的列子：</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX path_gist_idx ON test USING GIST (path);</PRE></LI><LI><P><TT CLASS="TYPE">ltree[]</TT> 上的 GiST 索引：
<TT CLASS="LITERAL">ltree[] &lt;@ ltree</TT>, <TT CLASS="LITERAL">ltree @&gt; ltree[]</TT>,
<TT CLASS="LITERAL">@</TT>, <TT CLASS="LITERAL">~</TT>, <TT CLASS="LITERAL">?</TT></P><P>创建这样一个索引的例子：</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX path_gist_idx ON test USING GIST (array_path);</PRE><P>注意：这种索引类型损耗很大。</P></LI></UL></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN147807">F.21.4. 示例</A></H2><P>这个示例使用下列的数据（在源代码发布中的<TT CLASS="FILENAME">contrib/ltree/ltreetest.sql</TT>文件中也可用）：</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE test (path ltree);
INSERT INTO test VALUES ('Top');
INSERT INTO test VALUES ('Top.Science');
INSERT INTO test VALUES ('Top.Science.Astronomy');
INSERT INTO test VALUES ('Top.Science.Astronomy.Astrophysics');
INSERT INTO test VALUES ('Top.Science.Astronomy.Cosmology');
INSERT INTO test VALUES ('Top.Hobbies');
INSERT INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');
INSERT INTO test VALUES ('Top.Collections');
INSERT INTO test VALUES ('Top.Collections.Pictures');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');
CREATE INDEX path_gist_idx ON test USING gist(path);
CREATE INDEX path_idx ON test USING btree(path);</PRE><P>现在，我们有一个表<TT CLASS="STRUCTNAME">test</TT>，由下面显示的数据描述层级构成：</P><PRE CLASS="LITERALLAYOUT">                        Top
                     /   |  \
             Science Hobbies Collections
                 /       |              \
        Astronomy   Amateurs_Astronomy Pictures
           /  \                            |
Astrophysics  Cosmology                Astronomy
                                        /  |    \
                                 Galaxies Stars Astronauts</PRE><P>
现在我们可以做继承：
</P><PRE CLASS="SCREEN">ltreetest=&gt; SELECT path FROM test WHERE path &lt;@ 'Top.Science';
                path
------------------------------------
 Top.Science
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(4 rows)</PRE><P>
</P><P>
这里是一些路径匹配的例子：
</P><PRE CLASS="SCREEN">ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.Astronomy.*';
                     path
-----------------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Collections.Pictures.Astronomy
 Top.Collections.Pictures.Astronomy.Stars
 Top.Collections.Pictures.Astronomy.Galaxies
 Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)

ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.!pictures@.*.Astronomy.*';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)</PRE><P>
</P><P>
这里是一些全文本搜索的例子：
</P><PRE CLASS="SCREEN">ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro*% &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Hobbies.Amateurs_Astronomy
(4 rows)

ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro* &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)</PRE><P>
</P><P>
路径建造使用函数：
</P><PRE CLASS="SCREEN">ltreetest=&gt; SELECT subpath(path,0,2)||'Space'||subpath(path,2) FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                 ?column?
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)</PRE><P>
</P><P>
我们可以通过创建一个SQL函数来简化，该函数在路径中的指定位置插入一个标签：
</P><PRE CLASS="SCREEN">CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
    AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
    LANGUAGE SQL IMMUTABLE;

ltreetest=&gt; SELECT ins_label(path,2,'Space') FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                ins_label
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN147825">F.21.5. 作者</A></H2><P>所有工作都是 Teodor Sigaev (<CODE CLASS="EMAIL">&#60;<A HREF="mailto:teodor@stack.net">teodor@stack.net</A>&#62;</CODE>) 和
Oleg Bartunov (<CODE CLASS="EMAIL">&#60;<A HREF="mailto:oleg@sai.msu.su">oleg@sai.msu.su</A>&#62;</CODE>)做的。参阅
<A HREF="http://www.sai.msu.su/~megera/postgres/gist/" TARGET="_top">http://www.sai.msu.su/~megera/postgres/gist/</A>获取额外的信息。
作者感谢 Eugeny Rodichev 的有帮助的讨论。欢迎评论和报告bug。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="lo.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="pageinspect.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">lo</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">pageinspect</TD></TR></TABLE></DIV></BODY></HTML>
