<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>命令执行函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="连接状态函数" HREF="libpq-status.html"><LINK REL="NEXT" TITLE="异步命令处理" HREF="libpq-async.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="连接状态函数" HREF="libpq-status.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="异步命令处理" HREF="libpq-async.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-EXEC">31.3. 命令执行函数</A></H1><P>一旦与数据库服务器的连接成功建立，便可以使用这里描述的函数执行SQL查询和命令。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EXEC-MAIN">31.3.1. 主函数</A></H2><P> <P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQEXEC"></A><CODE CLASS="FUNCTION">PQexec</CODE>
</DT><DD><P>给服务器提交一条命令并且等待结果。
</P><PRE CLASS="SYNOPSIS">PGresult *PQexec(PGconn *conn, const char *command);</PRE><P>
</P><P>返回一个<TT CLASS="STRUCTNAME">PGresult</TT>指针或者也可能是一个空指针。
通常返回一个非空指针，除非耗尽内存或发生了像不能把命令发送到服务器这样的严重错误。
应该调用<CODE CLASS="FUNCTION">PQresultStatus</CODE>函数来检查任何错误的返回值
（包括空指针的值，在这种情况下它将返回<TT CLASS="SYMBOL">PGRES_FATAL_ERROR</TT>）。
使用<CODE CLASS="FUNCTION">PQerrorMessage</CODE>获取有关错误的更多信息。</P></DD></DL></DIV><P>
命令字符串可以包括多个SQL命令（用分号分隔）。在一个<CODE CLASS="FUNCTION">PQexec</CODE>
调用中发送的多个查询是在一个事务里处理的，除非在查询字符串里有明确的
<TT CLASS="COMMAND">BEGIN</TT>/<TT CLASS="COMMAND">COMMIT</TT>命令把整个字符串分隔成多个事务。
请注意，返回的<TT CLASS="STRUCTNAME">PGresult</TT>结构只描述字符串里执行的最后一条命令的结果。
如果有一个命令失败，那么字符串处理的过程就会停止，并且返回的<TT CLASS="STRUCTNAME">PGresult</TT>
会描述错误条件。
</P><P> <P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQEXECPARAMS"></A><CODE CLASS="FUNCTION">PQexecParams</CODE>
</DT><DD><P>向服务器提交一条命令并且等待结果，还有独立于SQL命令文本传递参数的能力。
</P><PRE CLASS="SYNOPSIS">PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQexecParams</CODE>类似<CODE CLASS="FUNCTION">PQexec</CODE>，但是提供了额外的功能：
参数值可以独立于命令字符串进行声明，并且可以要求查询结果的格式是文本或二进制的。
<CODE CLASS="FUNCTION">PQexecParams</CODE>只是在协议3.0及以后的版本中支持；在使用协议2.0的时候会失败。</P><P>函数的参数是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="PARAMETER">conn</TT></DT><DD><P>连接对象通过它发送命令。</P></DD><DT><TT CLASS="PARAMETER">command</TT></DT><DD><P>要执行的SQL命令字符串。如果使用参数，它们在命令字符串中被叫做<TT CLASS="LITERAL">$1</TT>、
<TT CLASS="LITERAL">$2</TT>等等。</P></DD><DT><TT CLASS="PARAMETER">nParams</TT></DT><DD><P>提供的参数数目；它是<TT CLASS="PARAMETER">paramTypes[]</TT>、<TT CLASS="PARAMETER">paramValues[]</TT>、
<TT CLASS="PARAMETER">paramLengths[]</TT>和<TT CLASS="PARAMETER">paramFormats[]</TT>数组的长度。
（当<TT CLASS="PARAMETER">nParams</TT>是0时，数组指针可以是<TT CLASS="SYMBOL">NULL</TT>。）</P></DD><DT><TT CLASS="PARAMETER">paramTypes[]</TT></DT><DD><P>通过OID，将声明数据类型指定到参数标记。如果<TT CLASS="PARAMETER">paramTypes</TT>
是<TT CLASS="SYMBOL">NULL</TT>，或数组中任何的特定参数是0，服务器为参数标记推断数据类型，
采用的方式与一个未定义类型的文本字符串相同。</P></DD><DT><TT CLASS="PARAMETER">paramValues[]</TT></DT><DD><P>声明参数的实际值。在这个数组中的一个空指针表示相应的参数是空；
否则指针指向一个以零结尾的文本字符串（文本格式）或者服务器希望的格式的二进制数据
（二进制格式）。</P></DD><DT><TT CLASS="PARAMETER">paramLengths[]</TT></DT><DD><P>为二进制格式的参数声明实际数据长度。该设置忽略空参数或文本格式的参数。
如果没有二进制参数，那么数组指针可以为空。</P></DD><DT><TT CLASS="PARAMETER">paramFormats[]</TT></DT><DD><P>声明参数为文本（为相应参数在数组条目中放置一个0）还是二进制格式
（为相应参数在数组条目中放置一个1）。如果数组指针是空，那么所有参数被看做是文本字符串。</P><P>以二进制格式传递的值需要能够被后台识别的内部表示。例如，整数必须以网络字节顺序来传递。
传递<TT CLASS="TYPE">numeric</TT>值需要服务器存储格式的识别，如在
<TT CLASS="FILENAME">src/backend/utils/adt/numeric.c::numeric_send()</TT>和
<TT CLASS="FILENAME">src/backend/utils/adt/numeric.c::numeric_recv()</TT>中那样。</P></DD><DT><TT CLASS="PARAMETER">resultFormat</TT></DT><DD><P>声明0用于以文本格式获得结果，或1用于以二进制格式获得结果。
（目前没有规定以不同的格式来获取不同的结果列，即使底层协议中可能实现。）</P></DD></DL></DIV><P>
</P></DD></DL></DIV><P>
</P><P><CODE CLASS="FUNCTION">PQexecParams</CODE>相比<CODE CLASS="FUNCTION">PQexec</CODE>的主要优势是参数值可以从命令字符串中分离出来，
因此避免了繁琐和容易出错的引用和转义的需要。</P><P>和<CODE CLASS="FUNCTION">PQexec</CODE>不同的是，<CODE CLASS="FUNCTION">PQexecParams</CODE>在一个给出的字符串里最多允许一个SQL命令。
（里面可以有分号，但是不得超过一个非空的命令。）这是下层协议的一个限制，
但是也有些好处，比如作为对SQL注入攻击的额外防御。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>通过OID声明参数类型是非常繁琐的，尤其是你不希望在你的程序里写死特定的OID值的时候。
不过，你可以避免这么做，即使在服务器自己无法判断参数类型，
或者是选择了一种与你预期不同的参数类型的时候也一样。在SQL命令文本里，
给参数符号附加一个明确的类型转换，显示你准备发送的数据类型。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM mytable WHERE x = $1::bigint;</PRE><P>
这样强制参数<TT CLASS="LITERAL">$1</TT>当作<TT CLASS="TYPE">bigint</TT>看待，即使缺省情况下它会被赋予和
<TT CLASS="LITERAL">x</TT>一样的类型。在以二进制格式发送参数值的时候，
我们强烈建议通过这种方法或者是声明数字类型OID的方法强制类型判断，
因为二进制格式比文本格式少一些冗余，因此服务器就会少一些机会捕捉类型的错误匹配。
</P></BLOCKQUOTE></DIV><P> <P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQPREPARE"></A><CODE CLASS="FUNCTION">PQprepare</CODE>
</DT><DD><P>用给定的参数提交请求，创建一个预备语句，然后等待结束。
</P><PRE CLASS="SYNOPSIS">PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQprepare</CODE>创建一个为后面<CODE CLASS="FUNCTION">PQexecPrepared</CODE>执行用的预备语句。
这个特性允许那些重复使用的语句只分析和规划一次，而不是每次执行都分析规划。
只是在协议3.0和以后的连接里支持<CODE CLASS="FUNCTION">PQprepare</CODE>；在使用2.0协议的时候，它会失败。</P><P>这个函数从<TT CLASS="PARAMETER">query</TT>字串里创建一个叫<TT CLASS="PARAMETER">stmtName</TT>的预备语句，
<TT CLASS="PARAMETER">query</TT>必须只包含一个 SQL 命令。<TT CLASS="PARAMETER">stmtName</TT>可以是<TT CLASS="LITERAL">""</TT>，
这样就创建一个无名的语句，这种情况下，任何前面存在的无名语句都会自动被代替；
否则，如果语句名已经在当前会话里定义，那就是一个错误。如果使用了参数，
那么在查询里它们引用成<TT CLASS="LITERAL">$1</TT>，<TT CLASS="LITERAL">$2</TT>等等。<TT CLASS="PARAMETER">nParams</TT>
是参数的个数，参数的类型在数组<TT CLASS="PARAMETER">paramTypes[]</TT>里事先声明好了。
（如果<TT CLASS="PARAMETER">nParams</TT>是零，那么这个数组指针可以是<TT CLASS="SYMBOL">NULL</TT>。）
<TT CLASS="PARAMETER">paramTypes[]</TT>用 OID 的方式声明与参数符号关联的数据类型。
如果<TT CLASS="PARAMETER">paramTypes</TT>为<TT CLASS="SYMBOL">NULL</TT>，或者数组中某个特定元素是零，
那么服务器将用处理无类型文本同样的方法给这个参数符号赋予数据类型。还有，
查询可以使用比<TT CLASS="PARAMETER">nParams</TT>数值更大的参数符号编号；
也为这些符号推断数据类型。（参阅<CODE CLASS="FUNCTION">PQdescribePrepared</CODE>
作为一个找出推断的什么类型的手段。）</P><P>和<CODE CLASS="FUNCTION">PQexec</CODE>相似，结果通常是一个<TT CLASS="STRUCTNAME">PGresult</TT>对象，
其内容表明服务器端是成功还是失败。空的结果表示内存耗尽或者完全不能发送命令。
使用<CODE CLASS="FUNCTION">PQerrorMessage</CODE>获取有关这类错误的更多信息。</P></DD></DL></DIV><P>
用于<CODE CLASS="FUNCTION">PQexecPrepared</CODE>的预备语句也可以通过执行SQL <A HREF="sql-prepare.html">PREPARE</A>语句来创建。
还有，尽管没有<SPAN CLASS="APPLICATION">libpq</SPAN>函数可以删除一个预备语句，
SQL <A HREF="sql-deallocate.html">DEALLOCATE</A>语句却可以删除。
</P><P> <P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQEXECPREPARED"></A><CODE CLASS="FUNCTION">PQexecPrepared</CODE>
</DT><DD><P>发送一个请求，执行一个带有给出参数的预备语句，并且等待结果。
</P><PRE CLASS="SYNOPSIS">PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQexecPrepared</CODE>和<CODE CLASS="FUNCTION">PQexecParams</CODE>类似，
但是要执行的命令是通过命名一个前面准备好的语句声明的，而不是给出一个查询字串。
这个特性允许那些要重复使用的命令只进行一次分析和规划，而不是每次执行都来一遍。
这个语句必须在当前会话的前面已经准备好。<CODE CLASS="FUNCTION">PQexecPrepared</CODE>
只在协议 3.0 和以后的版本里支持；在使用 2.0 版本的协议的时候，它们会失败。</P><P>参数和<CODE CLASS="FUNCTION">PQexecParams</CODE>一样，只是给出的是一个预备语句的名字，而不是一个查询字串，
并且没有<TT CLASS="PARAMETER">paramTypes[]</TT>参数（没必要，因为预备语句的参数类型是在创建的时候确定的）。</P></DD><DT><A NAME="LIBPQ-PQDESCRIBEPREPARED"></A><CODE CLASS="FUNCTION">PQdescribePrepared</CODE>
</DT><DD><P>提交请求以获取有关指定的预备语句的信息，并等待完成。
</P><PRE CLASS="SYNOPSIS">PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQdescribePrepared</CODE>允许应用程序获取有关先前准备的语句的信息。
<CODE CLASS="FUNCTION">PQdescribePrepared</CODE>只在协议 3.0 和以后的版本里支持；
在使用 2.0 版本的协议的时候，它们会失败。</P><P><TT CLASS="PARAMETER">stmtName</TT>可以是<TT CLASS="LITERAL">""</TT>或<TT CLASS="SYMBOL">NULL</TT>以指向未命名声明，
要么必须与现有的预备语句同名。成功时，会返回一个带有<TT CLASS="LITERAL">PGRES_COMMAND_OK</TT>
的<TT CLASS="STRUCTNAME">PGresult</TT>。可以在这个<TT CLASS="STRUCTNAME">PGresult</TT>中使用
<CODE CLASS="FUNCTION">PQnparams</CODE>和<CODE CLASS="FUNCTION">PQparamtype</CODE>
函数以获得预备语句的参数信息，同时<CODE CLASS="FUNCTION">PQnfields</CODE>，
<CODE CLASS="FUNCTION">PQfname</CODE>，<CODE CLASS="FUNCTION">PQftype</CODE>等函数提供声明的结果列（如果有）的信息。</P></DD><DT><A NAME="LIBPQ-PQDESCRIBEPORTAL"></A><CODE CLASS="FUNCTION">PQdescribePortal</CODE>
</DT><DD><P>提交请求以获取有关指定的端口的信息，并等待完成。
</P><PRE CLASS="SYNOPSIS">PGresult *PQdescribePortal(PGconn *conn, const char *portalName);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQdescribePortal</CODE>允许应用程序获得关于之前创建的端口的信息。
（<SPAN CLASS="APPLICATION">libpq</SPAN>不提供与端口的直接连接，但可以使用这个函数来检查
<TT CLASS="COMMAND">DECLARE CURSOR</TT>命令创建的游标的属性）。<CODE CLASS="FUNCTION">PQdescribePortal</CODE>
只支持3.0及其之后的连接协议；当使用协议2.0时会失败。</P><P><TT CLASS="PARAMETER">portalName</TT>可以是<TT CLASS="LITERAL">""</TT>或<TT CLASS="SYMBOL">NULL</TT>以指向未命名声明，
要么必须与现有的预备语句同名。成功时，会返回一个带有<TT CLASS="LITERAL">PGRES_COMMAND_OK</TT>
的<TT CLASS="STRUCTNAME">PGresult</TT>。可以在<TT CLASS="STRUCTNAME">PGresult</TT>中使用
<CODE CLASS="FUNCTION">PQnfields</CODE>，<CODE CLASS="FUNCTION">PQfname</CODE>，
<CODE CLASS="FUNCTION">PQftype</CODE>等函数获取端口的结果列（如果有）的信息。</P></DD></DL></DIV><P>
</P><P><TT CLASS="STRUCTNAME">PGresult</TT>
结构封装了服务器返回的结果。<SPAN CLASS="APPLICATION">libpq</SPAN>应该小心维护
<TT CLASS="STRUCTNAME">PGresult</TT>的抽象。使用下面的访问函数获取
<TT CLASS="STRUCTNAME">PGresult</TT>的内容。避免直接引用<TT CLASS="STRUCTNAME">PGresult</TT>
里面的字段，因为它们在未来版本里可能会被修改。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQRESULTSTATUS"></A><CODE CLASS="FUNCTION">PQresultStatus</CODE>
</DT><DD><P>
返回命令的结果状态。
</P><PRE CLASS="SYNOPSIS">ExecStatusType PQresultStatus(const PGresult *res);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQresultStatus</CODE>可以返回下面数值之一：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PGRES-EMPTY-QUERY"></A><TT CLASS="LITERAL">PGRES_EMPTY_QUERY</TT></DT><DD><P>发送给服务器的字串是空的。</P></DD><DT><A NAME="LIBPQ-PGRES-COMMAND-OK"></A><TT CLASS="LITERAL">PGRES_COMMAND_OK</TT></DT><DD><P>成功完成一个不返回数据的命令。</P></DD><DT><A NAME="LIBPQ-PGRES-TUPLES-OK"></A><TT CLASS="LITERAL">PGRES_TUPLES_OK</TT></DT><DD><P>成功执行一个返回数据的查询（比如<TT CLASS="COMMAND">SELECT</TT>或者<TT CLASS="COMMAND">SHOW</TT>）。</P></DD><DT><A NAME="LIBPQ-PGRES-COPY-OUT"></A><TT CLASS="LITERAL">PGRES_COPY_OUT</TT></DT><DD><P>（从服务器）Copy Out （拷贝出）数据传输开始。</P></DD><DT><A NAME="LIBPQ-PGRES-COPY-IN"></A><TT CLASS="LITERAL">PGRES_COPY_IN</TT></DT><DD><P>Copy In（拷贝入）（到服务器）数据传输开始。</P></DD><DT><A NAME="LIBPQ-PGRES-BAD-RESPONSE"></A><TT CLASS="LITERAL">PGRES_BAD_RESPONSE</TT></DT><DD><P>服务器的响应无法理解。</P></DD><DT><A NAME="LIBPQ-PGRES-NONFATAL-ERROR"></A><TT CLASS="LITERAL">PGRES_NONFATAL_ERROR</TT></DT><DD><P>发生了一个非致命错误（通知或者警告）。</P></DD><DT><A NAME="LIBPQ-PGRES-FATAL-ERROR"></A><TT CLASS="LITERAL">PGRES_FATAL_ERROR</TT></DT><DD><P>发生了一个致命错误。</P></DD><DT><A NAME="LIBPQ-PGRES-COPY-BOTH"></A><TT CLASS="LITERAL">PGRES_COPY_BOTH</TT></DT><DD><P>拷贝入/出（到和从服务器）数据传输开始。这个特性当前只用于流复制，
所以这个状态不会在普通应用中发生。</P></DD><DT><A NAME="LIBPQ-PGRES-SINGLE-TUPLE"></A><TT CLASS="LITERAL">PGRES_SINGLE_TUPLE</TT></DT><DD><P><TT CLASS="STRUCTNAME">PGresult</TT>包含一个来自当前命令的结果元组。
这个状态只在查询选择了单行模式时发生（参阅<A HREF="libpq-single-row-mode.html">第 31.5 &#33410;</A>）。</P></DD></DL></DIV><P>
如果结果状态是<TT CLASS="LITERAL">PGRES_TUPLES_OK</TT>或<TT CLASS="LITERAL">PGRES_SINGLE_TUPLE</TT>，
那么可以用下面的函数从查询的返回中抽取元组信息。注意一个碰巧检索了零条元组的
<TT CLASS="COMMAND">SELECT</TT>仍然显示<TT CLASS="LITERAL">PGRES_TUPLES_OK</TT>。
<TT CLASS="LITERAL">PGRES_COMMAND_OK</TT>用于不返回元组的命令（没有<TT CLASS="LITERAL">RETURNING</TT>
子句的<TT CLASS="COMMAND">INSERT</TT>，<TT CLASS="COMMAND">UPDATE</TT>等）。
返回<TT CLASS="LITERAL">PGRES_EMPTY_QUERY</TT>的响应通常意味着暴露了客户端软件里面的Bug。
</P><P>状态为<TT CLASS="SYMBOL">PGRES_NONFATAL_ERROR</TT>的结果永远不会直接由<CODE CLASS="FUNCTION">PQexec</CODE>
或者其它查询执行函数返回；这类的结果会被传递给通知处理器
（参阅<A HREF="libpq-notice-processing.html">第 31.12 &#33410;</A>）。</P></DD><DT><A NAME="LIBPQ-PQRESSTATUS"></A><CODE CLASS="FUNCTION">PQresStatus</CODE>
</DT><DD><P>把<CODE CLASS="FUNCTION">PQresultStatus</CODE>返回的枚举类型转换成一个描述状态码的字符串常量。
调用者不应该释放结果。
</P><PRE CLASS="SYNOPSIS">char *PQresStatus(ExecStatusType status);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQRESULTERRORMESSAGE"></A><CODE CLASS="FUNCTION">PQresultErrorMessage</CODE>
</DT><DD><P>返回与查询关联的错误信息，或在没有错误时返回一个空字符串。
</P><PRE CLASS="SYNOPSIS">char *PQresultErrorMessage(const PGresult *res);</PRE><P>
如果有错误，那么返回的字串将包括一个结尾的新行。调用者不应该直接释放结果。
在相关的<TT CLASS="STRUCTNAME">PGresult</TT>句柄传递给<CODE CLASS="FUNCTION">PQclear</CODE>之后，它会自动释放。
</P><P>紧跟在一个<CODE CLASS="FUNCTION">PQexec</CODE>或<CODE CLASS="FUNCTION">PQgetResult</CODE>调用后面，
<CODE CLASS="FUNCTION">PQerrorMessage</CODE>（对连接）将返回与<CODE CLASS="FUNCTION">PQresultErrorMessage</CODE>
(对结果)一样的字符串。不过，一个<TT CLASS="STRUCTNAME">PGresult</TT>将保有其错误信息直到被删除，
而连接的错误信息将在后续的操作完成时被改变。当你想知道与某个<TT CLASS="STRUCTNAME">PGresult</TT>
相关联的状态时用<CODE CLASS="FUNCTION">PQresultErrorMessage</CODE>；
当你想知道与连接的最近一个操作相关联的状态时用<CODE CLASS="FUNCTION">PQerrorMessage</CODE>。</P></DD><DT><A NAME="LIBPQ-PQRESULTERRORFIELD"></A><CODE CLASS="FUNCTION">PQresultErrorField</CODE></DT><DD><P>返回一个独立的错误报告字段。
</P><PRE CLASS="SYNOPSIS">char *PQresultErrorField(const PGresult *res, int fieldcode);</PRE><P>
<TT CLASS="PARAMETER">fieldcode</TT>是一个错误字段标识符；参阅下面列出的符号。
如果<TT CLASS="STRUCTNAME">PGresult</TT>不是错误或者警告结果或者不包括指定的字段，
那么返回<TT CLASS="SYMBOL">NULL</TT>。字段值通常将不包括结尾的新行。调用者不应该直接释放结果。
在相关联的<TT CLASS="STRUCTNAME">PGresult</TT>句柄传递给<CODE CLASS="FUNCTION">PQclear</CODE>之后，它将被自动释放。
</P><P>下列代码是可用的：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PG-DIAG-SEVERITY"></A><TT CLASS="SYMBOL">PG_DIAG_SEVERITY</TT></DT><DD><P>严重程度，这个字段的内容是<TT CLASS="LITERAL">ERROR</TT>，<TT CLASS="LITERAL">FATAL</TT>或者<TT CLASS="LITERAL">PANIC</TT>
（在错误信息里），或者<TT CLASS="LITERAL">WARNING</TT>，<TT CLASS="LITERAL">NOTICE</TT>，<TT CLASS="LITERAL">DEBUG</TT>，
<TT CLASS="LITERAL">INFO</TT>或<TT CLASS="LITERAL">LOG</TT>（在注意信息里），或者是这些东西的一个本地化翻译。总是出现。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-SQLSTATE"></A><TT CLASS="SYMBOL">PG_DIAG_SQLSTATE</TT></DT><DD><P>这个错误的SQLSTATE代码。SQLSTATE代码表示所发生的错误的类型；
可以由前端应用用于对特定的数据库错误执行特定的操作（比如错误处理）。
可能的SQLSTATE代码的列表，请查看<A HREF="http://school.yunwei.edu/manual/PostgreSQL/errcodes-appendix.html">&#38468;&#24405; A</A>。
这个字段是不能区域化的，并且总是出现。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-MESSAGE-PRIMARY"></A><TT CLASS="SYMBOL">PG_DIAG_MESSAGE_PRIMARY</TT></DT><DD><P>主要的人类可读错误的信息（通常一行）。总是出现。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-MESSAGE-DETAIL"></A><TT CLASS="SYMBOL">PG_DIAG_MESSAGE_DETAIL</TT></DT><DD><P>细节：一个可选的从属错误信息，里面有更多有关该问题的细节。可能有多行。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-MESSAGE-HINT"></A><TT CLASS="SYMBOL">PG_DIAG_MESSAGE_HINT</TT></DT><DD><P>提示：一个可选的有关如何处理该问题的建议。它和细节的区别是它提供了建议
（可能不太合适）而不光是事实。可能有好几行。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-STATEMENT-POSITION"></A><TT CLASS="SYMBOL">PG_DIAG_STATEMENT_POSITION</TT></DT><DD><P>一个包含十进制整数的字串，表明错误游标的位置，作为一个索引指向最初的语句字符串。
第一个字符的索引是 1，并且这个位置是用字符计，而不是用字节计。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-INTERNAL-POSITION"></A><TT CLASS="SYMBOL">PG_DIAG_INTERNAL_POSITION</TT></DT><DD><P>这个和<TT CLASS="SYMBOL">PG_DIAG_STATEMENT_POSITION</TT>字段定义是一样的，
区别是它在游标位置指向内部生成的命令时使用，而不是客户端提交的命令。如果出现了这个字段，
那么<TT CLASS="SYMBOL">PG_DIAG_INTERNAL_QUERY</TT>字段也总是出现。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-INTERNAL-QUERY"></A><TT CLASS="SYMBOL">PG_DIAG_INTERNAL_QUERY</TT></DT><DD><P>一个失败的内部生成的命令的文本。比如，这个可能是一个 PL/pgSQL 函数发出的 SQL 查询。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-CONTEXT"></A><TT CLASS="SYMBOL">PG_DIAG_CONTEXT</TT></DT><DD><P>一个指示器，表明错误发生的环境。目前这个包括活跃的过程语言函数和内部生成的查询的调用堆栈跟踪。
跟踪是每行一条，最近的在上面。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-SCHEMA-NAME"></A><TT CLASS="SYMBOL">PG_DIAG_SCHEMA_NAME</TT></DT><DD><P>如果错误与特定的数据库对象相关，那么是包含该对象的模式名（如果有）。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-TABLE-NAME"></A><TT CLASS="SYMBOL">PG_DIAG_TABLE_NAME</TT></DT><DD><P>如果错误与特定的表相关，那么是该表的名字。（参考模式名字段获取表的模式的名字。）</P></DD><DT><A NAME="LIBPQ-PG-DIAG-COLUMN-NAME"></A><TT CLASS="SYMBOL">PG_DIAG_COLUMN_NAME</TT></DT><DD><P>如果错误与特定的表字段相关，那么是该字段的名字。（参考模式和表名字段识别该表。）</P></DD><DT><A NAME="LIBPQ-PG-DIAG-DATATYPE-NAME"></A><TT CLASS="SYMBOL">PG_DIAG_DATATYPE_NAME</TT></DT><DD><P>如果错误与特定的数据类型相关，那么是该数据类型的名字。（参考模式名字段获取数据类型的模式的名字。）</P></DD><DT><A NAME="LIBPQ-PG-DIAG-CONSTRAINT-NAME"></A><TT CLASS="SYMBOL">PG_DIAG_CONSTRAINT_NAME</TT></DT><DD><P>如果错误与特定的约束相关，那么是该约束的名字。参考上面列出的字段获取相关的表或域。
（为了这个目的，索引被看做是约束，即使它们是用约束语法创建的。）</P></DD><DT><A NAME="LIBPQ-PG-DIAG-SOURCE-FILE"></A><TT CLASS="SYMBOL">PG_DIAG_SOURCE_FILE</TT></DT><DD><P>报告错误的源代码所在的文件名。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-SOURCE-LINE"></A><TT CLASS="SYMBOL">PG_DIAG_SOURCE_LINE</TT></DT><DD><P>报告错误的源代码所在的行号。</P></DD><DT><A NAME="LIBPQ-PG-DIAG-SOURCE-FUNCTION"></A><TT CLASS="SYMBOL">PG_DIAG_SOURCE_FUNCTION</TT></DT><DD><P>报告错误的源代码函数的名字。</P></DD></DL></DIV><P>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>只为有限的错误类型提供模式名、表名、字段名、数据类型名和约束名字段；
参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/errcodes-appendix.html">&#38468;&#24405; A</A>。不要假设这些字段的出现会保证其他字段的出现。
核心错误来源观察以上提到的相互关系，但是用户定义的函数可以以其他方式使用这些字段。
同样的，不要假设这些字段表示当前数据库中的同时期对象。</P></BLOCKQUOTE></DIV><P>按照自身的要求格式化显示信息是客户端的责任；特别是根据需要对长行进行折行。
在错误信息字段里出现的新行字符应该当作分段符号，而不是换行。</P><P><SPAN CLASS="APPLICATION">libpq</SPAN>生成的错误将会有严重性和主信息，但是通常没有其它字段。
3.0 协议之前返回的错误将包含严重性和主信息，有时候还有详细信息，但是没有其它字段。</P><P>请注意这些错误字段只能从<TT CLASS="STRUCTNAME">PGresult</TT>对象里获得，
而不是<TT CLASS="STRUCTNAME">PGconn</TT>对象；没有<CODE CLASS="FUNCTION">PQerrorField</CODE>函数。</P></DD><DT><A NAME="LIBPQ-PQCLEAR"></A><CODE CLASS="FUNCTION">PQclear</CODE></DT><DD><P>释放与<TT CLASS="STRUCTNAME">PGresult</TT>相关联的存储空间。
任何不再需要的查询结果都应该用<CODE CLASS="FUNCTION">PQclear</CODE>释放掉。
</P><PRE CLASS="SYNOPSIS">void PQclear(PGresult *res);</PRE><P>
</P><P>只要你需要，你可以保留<TT CLASS="STRUCTNAME">PGresult</TT>对象任意长的时间；
当你提交新的查询时它并不消失，甚至你断开连接后也是这样。要删除它，
你必须调用<CODE CLASS="FUNCTION">PQclear</CODE>。不这么做将导致你应用中的内存泄漏。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EXEC-SELECT-INFO">31.3.2. 检索查询结果信息</A></H2><P>这些函数用于从一个代表着成功查询结果（也就是说，状态为<TT CLASS="LITERAL">PGRES_TUPLES_OK</TT>或
<TT CLASS="LITERAL">PGRES_SINGLE_TUPLE</TT>的查询）的<TT CLASS="STRUCTNAME">PGresult</TT>对象中抽取信息。
它们也可以用于从一个成功描述操作中抽取信息：
一个描述的结果和实际查询的执行将要提供的结果有所有相同的字段信息，但是它有零行。
对于其它状态值的对象，他们的行为会好像他们有零行和零列一样。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQNTUPLES"></A><CODE CLASS="FUNCTION">PQntuples</CODE>
</DT><DD><P>返回查询结果里的行（元组）个数。因为它返回一个整数的结果，在32位操作系统上大型结果集可能溢出返回值。
</P><PRE CLASS="SYNOPSIS">int PQntuples(const PGresult *res);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQNFIELDS"></A><CODE CLASS="FUNCTION">PQnfields</CODE>
</DT><DD><P>返回查询结果里数据行的列（字段）的个数。
</P><PRE CLASS="SYNOPSIS">int PQnfields(const PGresult *res);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQFNAME"></A><CODE CLASS="FUNCTION">PQfname</CODE>
</DT><DD><P>返回与给出的字段编号相关联的字段名。字段编号从 0 开始。调用者不应该直接释放结果。
在相关联的<TT CLASS="STRUCTNAME">PGresult</TT>句柄传递给<CODE CLASS="FUNCTION">PQclear</CODE>之后，结果会被自动释放。
</P><PRE CLASS="SYNOPSIS">char *PQfname(const PGresult *res,
              int column_number);</PRE><P>
</P><P>如果字段编号超出范围，那么返回<TT CLASS="SYMBOL">NULL</TT>。</P></DD><DT><A NAME="LIBPQ-PQFNUMBER"></A><CODE CLASS="FUNCTION">PQfnumber</CODE>
</DT><DD><P>返回与给出的字段名相关的字段编号。
</P><PRE CLASS="SYNOPSIS">int PQfnumber(const PGresult *res,
              const char *column_name);</PRE><P>
</P><P>如果给出的名字不匹配任何字段，返回-1。</P><P>给出的名字是当作 SQL 命令里的一个标识符看待的，也就是说，如果没有加双引号，
那么会转换为小写。比如，如果我们有一个从 SQL 命令里生成的查询结果：
</P><PRE CLASS="PROGRAMLISTING">SELECT 1 AS FOO, 2 AS "BAR";</PRE><P>
那么我们会有下面的结果：
</P><PRE CLASS="PROGRAMLISTING">PQfname(res, 0)              <I
CLASS="LINEANNOTATION"
>foo</I
>
PQfname(res, 1)              <I
CLASS="LINEANNOTATION"
>BAR</I
>
PQfnumber(res, "FOO")        <I
CLASS="LINEANNOTATION"
>0</I
>
PQfnumber(res, "foo")        <I
CLASS="LINEANNOTATION"
>0</I
>
PQfnumber(res, "BAR")        <I
CLASS="LINEANNOTATION"
>-1</I
>
PQfnumber(res, "\"BAR\"")    <I
CLASS="LINEANNOTATION"
>1</I
></PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQFTABLE"></A><CODE CLASS="FUNCTION">PQftable</CODE>
</DT><DD><P>返回我们抓取的字段所在的表的 OID。字段编号从 0 开始。
</P><PRE CLASS="SYNOPSIS">Oid PQftable(const PGresult *res,
             int column_number);</PRE><P>
</P><P>如果字段编号超出了范围，或者声明的字段不是一个指向某个表的字段的简单引用，
或者使用了 3.0 版本之前的协议，那么就会返回<TT CLASS="LITERAL">InvalidOid</TT>。
你可以查询系统表<TT CLASS="LITERAL">pg_class</TT>来判断究竟引用了哪个表。</P><P>在你包含<SPAN CLASS="APPLICATION">libpq</SPAN>头文件的时候，就会定义类型<TT CLASS="TYPE">Oid</TT>
和常量<TT CLASS="LITERAL">InvalidOid</TT>。他们都是相同的整数类型。</P></DD><DT><A NAME="LIBPQ-PQFTABLECOL"></A><CODE CLASS="FUNCTION">PQftablecol</CODE>
</DT><DD><P>返回组成声明的查询结果字段的字段号（在它的表内部）。查询结果字段编号从 0 开始，
但是表字段编号不会是 0。
</P><PRE CLASS="SYNOPSIS">int PQftablecol(const PGresult *res,
                int column_number);</PRE><P>
</P><P>如果字段编号超出范围，或者声明的字段并不是一个表字段的简单引用，
或者使用的是 3.0 之前的协议，那么返回零。</P></DD><DT><A NAME="LIBPQ-PQFFORMAT"></A><CODE CLASS="FUNCTION">PQfformat</CODE>
</DT><DD><P>返回说明给出字段的格式的格式代码。字段编号从 0 开始。
</P><PRE CLASS="SYNOPSIS">int PQfformat(const PGresult *res,
              int column_number);</PRE><P>
</P><P>格式码为 0 表示文本数据，而格式码是一表示二进制数据。（其它编码保留给将来定义。）</P></DD><DT><A NAME="LIBPQ-PQFTYPE"></A><CODE CLASS="FUNCTION">PQftype</CODE>
</DT><DD><P>返回与给定字段编号关联的数据类型。返回的整数是一个该类型的内部 OID 号。字段编号从0 开始。
</P><PRE CLASS="SYNOPSIS">Oid PQftype(const PGresult *res,
            int column_number);</PRE><P>
</P><P>你可以查询系统表<TT CLASS="LITERAL">pg_type</TT>以获取各种数据类型的名称和属性。
内建的数据类型的<ACRONYM CLASS="ACRONYM">OID</ACRONYM>在源码树的
<TT CLASS="FILENAME">src/include/catalog/pg_type.h</TT>文件里定义。</P></DD><DT><A NAME="LIBPQ-PQFMOD"></A><CODE CLASS="FUNCTION">PQfmod</CODE>
</DT><DD><P>返回与给定字段编号相关联的字段的类型修饰符。字段编号从 0 开始。
</P><PRE CLASS="SYNOPSIS">int PQfmod(const PGresult *res,
           int column_number);</PRE><P>
</P><P>类型修饰符的值是类型相关的；他们通常包括精度或者尺寸限制。
数值 -1 用于表示<SPAN CLASS="QUOTE">"没有可用信息"</SPAN>。大多数数据类型不用修饰词，这种情况下该值总是-1。</P></DD><DT><A NAME="LIBPQ-PQFSIZE"></A><CODE CLASS="FUNCTION">PQfsize</CODE>
</DT><DD><P>返回与给定字段编号关联的字段以字节计的大小。字段编号从0 开始。
</P><PRE CLASS="SYNOPSIS">int PQfsize(const PGresult *res,
            int column_number);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQfsize</CODE>返回在数据库行里面给该数据字段分配的空间，
换句话说就是该数据类型在服务器的内部表现形式的大小（尺寸）。（因此，
这个对客户端没有什么用。） 负值表示该数据类型是可变长度。</P></DD><DT><A NAME="LIBPQ-PQBINARYTUPLES"></A><CODE CLASS="FUNCTION">PQbinaryTuples</CODE>
</DT><DD><P>如果<TT CLASS="STRUCTNAME">PGresult</TT>包含二进制数据时返回 1，如果包含文本数据返回 0。
</P><PRE CLASS="SYNOPSIS">int PQbinaryTuples(const PGresult *res);</PRE><P>
</P><P>这个函数已经废弃了（除了还用于与<TT CLASS="COMMAND">COPY</TT>连接之外），
因为我们可能在一个<TT CLASS="STRUCTNAME">PGresult</TT>的某些字段里包含文本数据，
而另外一些字段包含二进制数据。更好的是使用<CODE CLASS="FUNCTION">PQfformat</CODE>。
<CODE CLASS="FUNCTION">PQbinaryTuples</CODE>只有在结果中的所有字段都是二进制（格式 1）的时候才返回 1。</P></DD><DT><A NAME="LIBPQ-PQGETVALUE"></A><CODE CLASS="FUNCTION">PQgetvalue</CODE>
</DT><DD><P>返回一个<TT CLASS="STRUCTNAME">PGresult</TT>里面一行的单独的一个字段的值。
行和字段编号从 0 开始。调用者不应该直接释放结果。在把<TT CLASS="STRUCTNAME">PGresult</TT>
句柄传递给<CODE CLASS="FUNCTION">PQclear</CODE>之后，结果会被自动释放。
</P><PRE CLASS="SYNOPSIS">char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);</PRE><P>
</P><P>对于文本格式的数据，<CODE CLASS="FUNCTION">PQgetvalue</CODE>返回的值是一个表示字段值的空（NULL）
结尾的字符串。对于二进制格式，返回的值就是由该数据类型的<CODE CLASS="FUNCTION">typsend</CODE>
和<CODE CLASS="FUNCTION">typreceive</CODE>决定的二进制表现形式。（在这种情况下，
数值实际上也跟着一个字节零，但是通常这个字节没什么用处，因为数值本身很可能包含内嵌的空。）</P><P>如果字段值是空，则返回一个空字串。参阅<CODE CLASS="FUNCTION">PQgetisnull</CODE>来区别空值和空字串值。</P><P><CODE CLASS="FUNCTION">PQgetvalue</CODE>返回的指针指向一个本身是<TT CLASS="STRUCTNAME">PGresult</TT>
结构的一部分的存储区域。我们不能更改它，并且如果我们要在<TT CLASS="STRUCTNAME">PGresult</TT>
结构的生存期后还要使用它的话，我们必须明确地把该数值拷贝到其他存储器中。</P></DD><DT><A NAME="LIBPQ-PQGETISNULL"></A><CODE CLASS="FUNCTION">PQgetisnull</CODE>
</DT><DD><P>测试一个字段是否为空（NULL）。行和字段编号从 0 开始。
</P><PRE CLASS="SYNOPSIS">int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);</PRE><P>
</P><P>如果该域包含 NULL，函数返回 1，如果包含非空（non-null ）值，返回 0。
（注意，对一个 NULL 字段，<CODE CLASS="FUNCTION">PQgetvalue</CODE>将返回一个空字符串，不是一个空指针。）</P></DD><DT><A NAME="LIBPQ-PQGETLENGTH"></A><CODE CLASS="FUNCTION">PQgetlength</CODE>
</DT><DD><P>返回以字节计的字段的长度。行和字段编号从 0 开始。
</P><PRE CLASS="SYNOPSIS">int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);</PRE><P>
</P><P>这是特定数值的实际数据长度，也就是说，<CODE CLASS="FUNCTION">PQgetvalue</CODE>指向的对象的大小。
对于文本数据格式，它和<CODE CLASS="FUNCTION">strlen()</CODE>相同。对于二进制格式，这是基本信息。
请注意我们<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不</I></SPAN>应该依靠<CODE CLASS="FUNCTION">PQfsize</CODE> 获取实际数据长度。</P></DD><DT><A NAME="LIBPQ-PQNPARAMS"></A><CODE CLASS="FUNCTION">PQnparams</CODE>
</DT><DD><P>返回一个预备语句中的参数的数目。
</P><PRE CLASS="SYNOPSIS">int PQnparams(const PGresult *res);</PRE><P>
</P><P>只有在检查<CODE CLASS="FUNCTION">PQdescribePrepared</CODE>的结果时，这个函数是有用的。
对于其他类型的查询将返回零。</P></DD><DT><A NAME="LIBPQ-PQPARAMTYPE"></A><CODE CLASS="FUNCTION">PQparamtype</CODE>
</DT><DD><P>返回指示语句中的参数的数据类型。参数编号从0开始。
</P><PRE CLASS="SYNOPSIS">Oid PQparamtype(const PGresult *res, int param_number);</PRE><P>
</P><P>只有在检查<CODE CLASS="FUNCTION">PQdescribePrepared</CODE>的结果时，这个函数是有用的。
对于其他类型的查询将返回零。</P></DD><DT><A NAME="LIBPQ-PQPRINT"></A><CODE CLASS="FUNCTION">PQprint</CODE>
</DT><DD><P>向指定的输出流打印所有的行和（可选的）字段名称。
</P><PRE CLASS="SYNOPSIS">void PQprint(FILE *fout,      /* 输出流 */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* 打印输出字段头和行计数 */
    pqbool  align;       /* 填充对齐字段 */
    pqbool  standard;    /* 旧的格式 */
    pqbool  html3;       /* 输出HTML表 */
    pqbool  expanded;    /* 扩展表 */
    pqbool  pager;       /* 必要时在输出中使用分页器 */
    char    *fieldSep;   /* 字段分隔符 */
    char    *tableOpt;   /* HTML表格元素的属性 */
    char    *caption;    /* HTML表标题 */
    char    **fieldName; /* 替换字段名组成的空结尾的数组 */
} PQprintOpt;</PRE><P>
</P><P>这个函数以前被<SPAN CLASS="APPLICATION">psql</SPAN>用于打印查询结果，但是现在已经不用这个函数了。
请注意它假设所有的数据都是文本格式。</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EXEC-NONSELECT">31.3.3. 检索其它命令的结果信息</A></H2><P>这些函数用于从<TT CLASS="STRUCTNAME">PGresult</TT>对象里检索其他信息。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQCMDSTATUS"></A><CODE CLASS="FUNCTION">PQcmdStatus</CODE>
</DT><DD><P>返回产生<TT CLASS="STRUCTNAME">PGresult</TT>的 SQL 命令的命令状态标签。
</P><PRE CLASS="SYNOPSIS">char *PQcmdStatus(PGresult *res);</PRE><P>
</P><P>通常这只是命令的名字，但是它可能包括额外的数据，比如处理过的行数。调用者不应该直接释放结果。
结果会在把<TT CLASS="STRUCTNAME">PGresult</TT>句柄传递给<CODE CLASS="FUNCTION">PQclear</CODE>的时候释放。</P></DD><DT><A NAME="LIBPQ-PQCMDTUPLES"></A><CODE CLASS="FUNCTION">PQcmdTuples</CODE>
</DT><DD><P>返回被 SQL 命令影响的行的数量。
</P><PRE CLASS="SYNOPSIS">char *PQcmdTuples(PGresult *res);</PRE><P>
</P><P>这个函数返回一个字符串，包含<TT CLASS="STRUCTNAME">PGresult</TT>产生的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>语句影响的行数。
这个函数只能用于下列的执行：<TT CLASS="COMMAND">SELECT</TT>，<TT CLASS="COMMAND">CREATE TABLE AS</TT>，<TT CLASS="COMMAND">INSERT</TT>，
<TT CLASS="COMMAND">UPDATE</TT>，<TT CLASS="COMMAND">DELETE</TT>，<TT CLASS="COMMAND">MOVE</TT>，<TT CLASS="COMMAND">FETCH</TT>，或者
<TT CLASS="COMMAND">COPY</TT>语句，或者是一个包含<TT CLASS="COMMAND">INSERT</TT>，<TT CLASS="COMMAND">UPDATE</TT>或<TT CLASS="COMMAND">DELETE</TT>
语句的预备查询的<TT CLASS="COMMAND">EXECUTE</TT>。如果生成这个<TT CLASS="STRUCTNAME">PGresult</TT>的命令是其他的东西，
那么<CODE CLASS="FUNCTION">PQcmdTuples</CODE>返回一个空字串。调用者不应该直接释放返回的数值。
在相关联的<TT CLASS="STRUCTNAME">PGresult</TT>被传递给<CODE CLASS="FUNCTION">PQclear</CODE>之后，它会被自动释放。</P></DD><DT><A NAME="LIBPQ-PQOIDVALUE"></A><CODE CLASS="FUNCTION">PQoidValue</CODE>
</DT><DD><P>返回插入的行的OID，
如果<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令是<TT CLASS="COMMAND">INSERT</TT>，插入了正好一行到有OID的表格，
或者是一个包含合适<TT CLASS="COMMAND">INSERT</TT>语句的预备查询<TT CLASS="COMMAND">EXECUTE</TT>的时候。
否则，函数返回<TT CLASS="LITERAL">InvalidOid</TT>。如果受<TT CLASS="COMMAND">INSERT</TT>
影响的表不包含 OID，也返回<TT CLASS="LITERAL">InvalidOid</TT>。
</P><PRE CLASS="SYNOPSIS">Oid PQoidValue(const PGresult *res);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQOIDSTATUS"></A><CODE CLASS="FUNCTION">PQoidStatus</CODE>
</DT><DD><P>为了支持<CODE CLASS="FUNCTION">PQoidValue</CODE>，这个函数已经废弃了，并且不是线程安全的。
它返回插入行的带有OID的字符串，而<CODE CLASS="FUNCTION">PQoidValue</CODE>返回OID值。
</P><PRE CLASS="SYNOPSIS">char *PQoidStatus(const PGresult *res);</PRE><P>
</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EXEC-ESCAPE-STRING">31.3.4. 转义包含在SQL命令中的字符串</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQESCAPELITERAL"></A><CODE CLASS="FUNCTION">PQescapeLiteral</CODE>
</DT><DD><P></P><PRE CLASS="SYNOPSIS">char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQescapeLiteral</CODE>为在 SQL 命令中使用字串而对之进行转义处理。
在我们向 SQL 命令里把数据值当作文本常量插入的时候很有用。有些字符
（比如单引号和反斜杠）必须被转义，以避免他们被 SQL 分析器作为特殊字符解析。
<CODE CLASS="FUNCTION">PQescapeLiteral</CODE>执行这个操作。</P><P><CODE CLASS="FUNCTION">PQescapeLiteral</CODE>返回一个内存中分配有<CODE CLASS="FUNCTION">malloc()</CODE>的
<TT CLASS="PARAMETER">str</TT>参数的转义版本。当结果不再需要时，需要通过<CODE CLASS="FUNCTION">PQfreemem()</CODE>
来释放这块内存。不需要一个0字节结束，并且不应以<TT CLASS="PARAMETER">length</TT>计数。
（如果在处理<TT CLASS="PARAMETER">length</TT>字节之前出现0字节的结束，<CODE CLASS="FUNCTION">PQescapeLiteral</CODE>
在此处结束；这个行为有点像<CODE CLASS="FUNCTION">strncpy</CODE>）。返回的字符串中所有特殊字符都替换掉了，
因此可以很好的被<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>字符串文本解析器处理，同样，
允许增加一个0字节结尾。必须在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
字符串文本两边的单引号包含在结果字符串中。</P><P>一旦错误，<CODE CLASS="FUNCTION">PQescapeLiteral</CODE>返回<TT CLASS="SYMBOL">NULL</TT>并在<TT CLASS="PARAMETER">conn</TT>对象中存储合适的信息。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>处理从不可信来源收到的字符串时必须进行合适的转义，否则存在一定的安全风险：
容易受到<SPAN CLASS="QUOTE">"SQL 注入"</SPAN>攻击，数据库中会被写入未知的SQL命令。</P></BLOCKQUOTE></DIV><P>需要注意的是，当一个数据以<CODE CLASS="FUNCTION">PQexecParams</CODE>或它的兄弟格式，
作为一个单独的参数传递时，做转义是不必要，也是不正确的。</P></DD><DT><A NAME="LIBPQ-PQESCAPEIDENTIFIER"></A><CODE CLASS="FUNCTION">PQescapeIdentifier</CODE>
</DT><DD><P></P><PRE CLASS="SYNOPSIS">char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQescapeIdentifier</CODE>转义一个字符串作为一个SQL标识符使用，
如一个表，列，或函数名。当一个用户自定义标识符需要包含特殊的字符，
否则将不能被SQL解析器解析为标识符的一部分时，或者当标识符需要包含大写字母，
且这种情况必须保留时，这样做是很有用的。</P><P><CODE CLASS="FUNCTION">PQescapeIdentifier</CODE>返回<TT CLASS="PARAMETER">str</TT>参数转义为一个内存中分配有
<CODE CLASS="FUNCTION">malloc()</CODE>的SQL标识符的版本。当结果不再需要时，这块内存必须使用
<CODE CLASS="FUNCTION">PQfreemem()</CODE>来释放。不需要一个0字节结束，并且不应以<TT CLASS="PARAMETER">length</TT>计数。
（如果在处理<TT CLASS="PARAMETER">length</TT>字节之前出现0字节的结束，<CODE CLASS="FUNCTION">PQescapeIdentifier</CODE>
在此处结束；这个行为比较像<CODE CLASS="FUNCTION">strncpy</CODE>）。返回的字符串中所有特殊字符都替换掉了，
因此可以很好的作为SQL标识符被处理。也可以添加一个结尾的0字节。返回字符串也是被双引号环绕。</P><P>出错时，<CODE CLASS="FUNCTION">PQescapeIdentifier</CODE>返回<TT CLASS="SYMBOL">NULL</TT>，并且在<TT CLASS="PARAMETER">conn</TT>对象中存贮合适的信息。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>由于带有字符串常量，为阻止SQL注入攻击，当从一个不可信任资源获得时，SQL标识符必须转义。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="LIBPQ-PQESCAPESTRINGCONN"></A><CODE CLASS="FUNCTION">PQescapeStringConn</CODE>
</DT><DD><P></P><PRE CLASS="SYNOPSIS">size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);</PRE><P>
</P><P><CODE CLASS="FUNCTION">PQescapeStringConn</CODE>转义字符串常量，比较像<CODE CLASS="FUNCTION">PQescapeLiteral</CODE>。
不同于<CODE CLASS="FUNCTION">PQescapeLiteral</CODE>，请求应该提供一个适当大小的缓冲区。更重要的是，
<CODE CLASS="FUNCTION">PQescapeStringConn</CODE>不会生成一个必须在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
字符串常量两端的单引号；SQL命令中应该提供，这样结果中会被插入。<TT CLASS="PARAMETER">from</TT>
参数指向字符串的第一个字符（用以转义），<TT CLASS="PARAMETER">length</TT>参数指出了在这个字符串中的字节数。
不需要一个0字节结束，并且不应以<TT CLASS="PARAMETER">length</TT>计数。
（如果在处理<TT CLASS="PARAMETER">length</TT>字节之前出现0字节的结束，<CODE CLASS="FUNCTION">PQescapeStringConn</CODE>
在此处结束；这个行为比较像<CODE CLASS="FUNCTION">strncpy</CODE>）。<TT CLASS="PARAMETER">to</TT>应该指向一个包含至少多于两倍
<TT CLASS="PARAMETER">length</TT>大小的缓冲区，要么就不会定义该行为。如果<TT CLASS="PARAMETER">to</TT>和<TT CLASS="PARAMETER">from</TT>
字符串交叠，那么也不会定义该行为。</P><P><TT CLASS="PARAMETER">error</TT>参数非<TT CLASS="SYMBOL">NULL</TT>，那么在成功的时候<TT CLASS="LITERAL">*error</TT>会被设置为零，
失败的时候设置为非0。目前唯一可能的错误条件涉及在源字符串中无效的多字节编码。
输出字符串同样产生错误，但服务器可以视其为异常以拒绝。一旦发生错误，
一条合适的信息会存储在<TT CLASS="PARAMETER">conn</TT>对象中，无论<TT CLASS="PARAMETER">error</TT>是否为<TT CLASS="SYMBOL">NULL</TT>。</P><P><CODE CLASS="FUNCTION">PQescapeStringConn</CODE>返回写到<TT CLASS="PARAMETER">to</TT>的字节数，不包含0字节终止。</P></DD><DT><A NAME="LIBPQ-PQESCAPESTRING"></A><CODE CLASS="FUNCTION">PQescapeString</CODE>
</DT><DD><P><CODE CLASS="FUNCTION">PQescapeString</CODE>是一个老的，已经被<CODE CLASS="FUNCTION">PQescapeStringConn</CODE>弃用了的版本。
</P><PRE CLASS="SYNOPSIS">size_t PQescapeString (char *to, const char *from, size_t length);</PRE><P>
</P><P>与<CODE CLASS="FUNCTION">PQescapeStringConn</CODE>唯一的不同是，<CODE CLASS="FUNCTION">PQescapeString</CODE>
不使用<TT CLASS="STRUCTNAME">PGconn</TT>或<TT CLASS="PARAMETER">error</TT>参数。因此，不能够根据连接属性
（如字符编码）来调整其行为，因此<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">可能会给出错误的结果</I></SPAN>，同样，不会报告错误条件。</P><P><CODE CLASS="FUNCTION">PQescapeString</CODE>可以在客户端编程（一次只有一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>连接）
中安全的使用。在这种情况下，它可以找到<SPAN CLASS="QUOTE">"在屏幕背后"</SPAN>想要知道的。在其他情况下，
这是一个安全隐患，使用<CODE CLASS="FUNCTION">PQescapeStringConn</CODE>时应该避免。</P></DD><DT><A NAME="LIBPQ-PQESCAPEBYTEACONN"></A><CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>
</DT><DD><P>转义那些在 SQL 命令中使用的用<TT CLASS="TYPE">bytea</TT>表示的二进制数据。
和<CODE CLASS="FUNCTION">PQescapeStringConn</CODE>一样，这个函数只有在直接向 SQL 字串插入数据的时候使用。
</P><PRE CLASS="SYNOPSIS">unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);</PRE><P>
</P><P>在<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>语句中用做<TT CLASS="TYPE">bytea</TT>字串文本的一部分的时候，
有些字节值必需转义。<CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>转义字节使用十六进制编码或反斜杠转义。
参阅<A HREF="datatype-binary.html">第 8.4 &#33410;</A>获取更多信息。</P><P><TT CLASS="PARAMETER">from</TT>参数指向需要转义的字串的第一个字节，<TT CLASS="PARAMETER">from_length</TT>
参数反映在这个二进制字串（结尾的字节零既不必要也不计算在内）里字节的个数。
<TT CLASS="PARAMETER">to_length</TT>参数指向一个变量，它保存转义后字符串长度的结果。
结果字串长度包括结果结尾的零字节。</P><P><CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>在内存中返回一个<TT CLASS="PARAMETER">from</TT>
参数的二进制字串的转义后的版本，这片内存是用<CODE CLASS="FUNCTION">malloc()</CODE>分配的
在不再需要结果的时候，必须用<CODE CLASS="FUNCTION">PQfreemem()</CODE>释放内存。
返回的字串已经把所有特殊的字符替换掉了，这样他们就可以由<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
的字串文本分析器以及<TT CLASS="TYPE">bytea</TT>的输入函数正确地处理。同时还追加了一个结尾的字节零。
那些必需包围在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>字串文本周围的单引号并非结果字串的一部分。</P><P>当出错时，返回一个空指针，一个合适的错误信息会被储存在<TT CLASS="PARAMETER">conn</TT>对象中，
当前唯一可能的错误是结果字符串的内存不足。</P></DD><DT><A NAME="LIBPQ-PQESCAPEBYTEA"></A><CODE CLASS="FUNCTION">PQescapeBytea</CODE>
</DT><DD><P><CODE CLASS="FUNCTION">PQescapeBytea</CODE>是<CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>的一个旧的，过时的版本。
</P><PRE CLASS="SYNOPSIS">unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);</PRE><P>
</P><P>与<CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>唯一的不同之处在于，<CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>
不使用<TT CLASS="STRUCTNAME">PGconn</TT>参数，因此，<CODE CLASS="FUNCTION">PQescapeBytea</CODE>可以在客户端编程
（一次只有一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>连接）中安全的使用。在这种情况下，
它可以找到<SPAN CLASS="QUOTE">"在屏幕背后"</SPAN>想要知道的。如果在编程中使用多个数据库连接
（在这种情况下使用<CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>），那么<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">可能会给出错误结果</I></SPAN>。</P></DD><DT><A NAME="LIBPQ-PQUNESCAPEBYTEA"></A><CODE CLASS="FUNCTION">PQunescapeBytea</CODE>
</DT><DD><P>把一个二进制数据的字符串表现形式转换成二进制数据&mdash;
<CODE CLASS="FUNCTION">PQescapeBytea</CODE>的反作用。在以文本格式抽取<TT CLASS="TYPE">bytea</TT>
数据的时候是必须的，但是在以二进制格式抽取的时候是不必要的。
</P><PRE CLASS="SYNOPSIS">unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);</PRE><P>
</P><P><TT CLASS="PARAMETER">from</TT>参数指向一个字符串，比如应用到<TT CLASS="TYPE">bytea</TT>字段时，
<CODE CLASS="FUNCTION">PQgetvalue</CODE>返回的。<CODE CLASS="FUNCTION">PQunescapeBytea</CODE>
把它的字串表现形式转换成二进制形式，它返回一个用<CODE CLASS="FUNCTION">malloc()</CODE>
分配的指向该缓冲区的指针，或者是出错时返回<TT CLASS="SYMBOL">NULL</TT>，缓冲区的尺寸放在
<TT CLASS="PARAMETER">to_length</TT>里。在不再需要这个结果之后，
这片内存必须用<CODE CLASS="FUNCTION">PQfreemem</CODE>释放。</P><P>这个转换不正好是<CODE CLASS="FUNCTION">PQescapeBytea</CODE>逆转换，因为，当从
<CODE CLASS="FUNCTION">PQgetvalue</CODE>接收时，字符串不希望被<SPAN CLASS="QUOTE">"转义"</SPAN>。尤其是，这意味着，
不需要考虑字符串引用，并且不需要<TT CLASS="STRUCTNAME">PGconn</TT>参数。</P></DD></DL></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-status.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-async.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">连接状态函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">异步命令处理</TD></TR></TABLE></DIV></BODY></HTML>
