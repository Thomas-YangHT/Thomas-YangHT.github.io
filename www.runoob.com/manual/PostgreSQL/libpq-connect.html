<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>数据库连接控制函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="NEXT" TITLE="连接状态函数" HREF="libpq-status.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="连接状态函数" HREF="libpq-status.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-CONNECT">31.1. 数据库连接控制函数</A></H1><P>
下面的函数处理与<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器联接的事情。
一个应用程序一次可以与多个服务器建立联接。
（这么做的原因之一是访问多于一个数据库。） 每个连接都是用一个从函数
<CODE CLASS="FUNCTION">PQconnectdb</CODE>、<CODE CLASS="FUNCTION">PQconnectdbParams</CODE>或<CODE CLASS="FUNCTION">PQsetdbLogin</CODE>
获得的<TT CLASS="STRUCTNAME">PGconn</TT>对象表示。
注意，这些函数总是返回一个非空的对象指针，除非存储器少得连个
<TT CLASS="STRUCTNAME">PGconn</TT>对象都分配不出来。在把查询发送给连接对象之前，
可以调用<CODE CLASS="FUNCTION">PQstatus</CODE>函数来检查一下返回值看看连接是否成功。
<DIV CLASS="WARNING"><P></P><TABLE CLASS="WARNING" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#35686;&#21578;</B></TD></TR><TR><TD ALIGN="LEFT"><P>在Unix上，用打开的libpq连接分支化一个过程会导致不可预知的结果，
因为父进程和子进程共享同一个套接字和操作系统资源。因为这个原因，
不建议这样的使用，尽管从子进程中执行<CODE CLASS="FUNCTION">exec</CODE>
加载一个新的可执行文件是安全的。</P></TD></TR></TABLE></DIV>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>在Windows上，如果一个数据库连接重复的启动和关闭，有一个方式提高性能。
内部的，libpq为连接启动和关闭分别调用<CODE CLASS="FUNCTION">WSAStartup()</CODE>和<CODE CLASS="FUNCTION">WSACleanup()</CODE>。
<CODE CLASS="FUNCTION">WSAStartup()</CODE>增加一个内部Windows库引用计数，而<CODE CLASS="FUNCTION">WSACleanup()</CODE>
减少一个。当引用计数是一时，调用<CODE CLASS="FUNCTION">WSACleanup()</CODE>释放所有资源和所有DLL是空载的。
这是一个昂贵的操作。为了避免它，一个应用可以手动调用<CODE CLASS="FUNCTION">WSACleanup()</CODE>，
这样在最后一个数据库连接关闭时，资源将不会被释放。</P></BLOCKQUOTE></DIV><P>
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQCONNECTDBPARAMS"></A><CODE CLASS="FUNCTION">PQconnectdbParams</CODE></DT><DD><P>与数据库服务器建立一个新的连接。
</P><PRE CLASS="SYNOPSIS">PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);</PRE><P>
</P><P>这个函数用从两个<TT CLASS="SYMBOL">NULL</TT>结束的数组中来的参数打开一个新的数据库连接。
第一个，<TT CLASS="LITERAL">keywords</TT>，定义为一个字符串的数组，每个都成为一个关键字。
第二个，<TT CLASS="LITERAL">values</TT>，给每个关键字一个值。与下面的<CODE CLASS="FUNCTION">PQsetdbLogin</CODE>
不同的是，我们可以不必更换函数签名（名字）就可以扩展参数集，
所以我们建议应用程序中使用这个函数（或者它的类似的非阻塞变种
<CODE CLASS="FUNCTION">PQconnectStartParams</CODE>和<CODE CLASS="FUNCTION">PQconnectPoll</CODE>）。</P><P>目前公认的参数关键字在<A HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS">第 31.1.2 &#33410;</A>中列出。</P><P>当<TT CLASS="LITERAL">expand_dbname</TT>是非零的时，允许将<TT CLASS="PARAMETER">dbname</TT>
的关键字值看做一个连接字符串。可能的格式的更详细信息在<A HREF="libpq-connect.html#LIBPQ-CONNSTRING">第 31.1.1 &#33410;</A>
中显示。</P><P>传入的参数可以为空，表明使用所有缺省的参数，或者可以包含一个或更多个参数设置。
它们的长度应该匹配。处理将会在<TT CLASS="LITERAL">keywords</TT>数组的最后一个非
<TT CLASS="SYMBOL">NULL</TT>元素停止。</P><P>如果没有指定任何参数，则使用对应的环境变量（参阅<A HREF="libpq-envars.html">第 31.14 &#33410;</A>）。
如果环境变量也没有设置，则使用表示的内建缺省。</P><P>通常，关键字是从这些数组的开始以索引的顺序处理的。这样的影响是，当关键字重复时，
获得最后处理的值。因此，通过小心的放置<TT CLASS="PARAMETER">dbname</TT>关键字，
有可能决定哪个被<TT CLASS="PARAMETER">conninfo</TT>字符串覆盖，哪个不被覆盖。</P></DD><DT><A NAME="LIBPQ-PQCONNECTDB"></A><CODE CLASS="FUNCTION">PQconnectdb</CODE></DT><DD><P>与数据库服务器建立一个新的连接。
</P><PRE CLASS="SYNOPSIS">PGconn *PQconnectdb(const char *conninfo);</PRE><P>
</P><P>这个函数用从一个字符串<TT CLASS="LITERAL">conninfo</TT>来的参数与数据库打开一个新的联接。</P><P>传入的参数可以为空，表明使用所有缺省的参数，或者可以包含一个或更多个用空白间隔的参数设置，
或者它可以包含一个<ACRONYM CLASS="ACRONYM">URI</ACRONYM>。参阅<A HREF="libpq-connect.html#LIBPQ-CONNSTRING">第 31.1.1 &#33410;</A>获取细节。</P></DD><DT><A NAME="LIBPQ-PQSETDBLOGIN"></A><CODE CLASS="FUNCTION">PQsetdbLogin</CODE></DT><DD><P> 与数据库服务器建立一个新的连接。
</P><PRE CLASS="SYNOPSIS">PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);</PRE><P>
</P><P>这个函数是<CODE CLASS="FUNCTION">PQconnectdb</CODE>前身，它有固定个数的参数。它有相同的功能，
只是在调用中那些它缺少的参数总是用缺省值。如果要给任意的固定参数设置缺省值，
那么写一个<TT CLASS="SYMBOL">NULL</TT>或者一个空字串给它们。</P><P>如果<TT CLASS="PARAMETER">dbName</TT>包含一个<TT CLASS="SYMBOL">=</TT>符或者有一个有效的连接
<ACRONYM CLASS="ACRONYM">URI</ACRONYM>前缀，它被看做一个<TT CLASS="PARAMETER">conninfo</TT>字符串，
就和它已经被传递到<CODE CLASS="FUNCTION">PQconnectdb</CODE>中完全一样，
然后剩余的参数就像为<CODE CLASS="FUNCTION">PQconnectdbParams</CODE>指定的那样应用。</P></DD><DT><A NAME="LIBPQ-PQSETDB"></A><CODE CLASS="FUNCTION">PQsetdb</CODE></DT><DD><P> 与数据库服务器建立一个新的连接。
</P><PRE CLASS="SYNOPSIS">PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);</PRE><P>
</P><P>这是一个调用<CODE CLASS="FUNCTION">PQsetdbLogin</CODE>的宏，只是<TT CLASS="PARAMETER">login</TT>和<TT CLASS="PARAMETER">pwd</TT>
参数是空指针。提供这个函数是为了与非常老版本的程序兼容。</P></DD><DT><A NAME="LIBPQ-PQCONNECTSTARTPARAMS"></A><CODE CLASS="FUNCTION">PQconnectStartParams</CODE><BR><CODE CLASS="FUNCTION">PQconnectStart</CODE><BR><CODE CLASS="FUNCTION">PQconnectPoll</CODE></DT><DD><P>&#13;与数据库服务器建立一次非阻塞的联接。
</P><PRE CLASS="SYNOPSIS">PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);</PRE><P>
</P><P>这三个函数用于打开一个与数据库服务器之间的非阻塞的联接：
你的应用的执行线程在执行它的时候不会因远端的 I/O 而阻塞。
这个方法的要点是等待 I/O 结束可以发生在应用的主循环里，
而不是在<CODE CLASS="FUNCTION">PQconnectdbParams</CODE>或<CODE CLASS="FUNCTION">PQconnectdb</CODE>里，
这样应用可以把这件事与其它操作并发起来一起执行。</P><P>对于<CODE CLASS="FUNCTION">PQconnectStartParams</CODE>，数据库联接是用从<TT CLASS="LITERAL">keywords</TT>
和<TT CLASS="LITERAL">values</TT>数组中取得的参数进行的，并且是使用<TT CLASS="LITERAL">expand_dbname</TT>
控制的，就像上面<CODE CLASS="FUNCTION">PQconnectdbParams</CODE>里描述的一样。</P><P>对于<CODE CLASS="FUNCTION">PQconnectStart</CODE>，数据库联接是用从<TT CLASS="LITERAL">conninfo</TT>
字符串里取得的参数进行的，这个字符串的格式与上面<CODE CLASS="FUNCTION">PQconnectdb</CODE>
里描述的一样。</P><P><CODE CLASS="FUNCTION">PQconnectStartParams</CODE>、<CODE CLASS="FUNCTION">PQconnectStart</CODE>
和<CODE CLASS="FUNCTION">PQconnectPoll</CODE>都不会阻塞（进程），不过有一些条件：
<P></P></P><UL><LI><P>必须正确提供<TT CLASS="LITERAL">hostaddr</TT>和<TT CLASS="LITERAL">host</TT>参数以确保不会发生正向或者反向的名字查找。
参阅<A HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS">第 31.1.2 &#33410;</A>里的这些参数的文档获取细节。</P></LI><LI><P>如果你调用了<CODE CLASS="FUNCTION">PQtrace</CODE>，确保你跟踪进入的流对象不会阻塞。</P></LI><LI><P>你必须在调用<CODE CLASS="FUNCTION">PQconnectPoll</CODE>之前确保 socket 处于正确的状态，
像下面描述的那样。</P></LI></UL><P>
</P><P>注意：<CODE CLASS="FUNCTION">PQconnectStartParams</CODE>的使用类似于下面显示的<CODE CLASS="FUNCTION">PQconnectStart</CODE>。</P><P>要开始一次非阻塞连接请求，调用<TT CLASS="LITERAL">conn = PQconnectStart("<TT CLASS="REPLACEABLE"><I>connection_info_string</I></TT>")</TT>。
如果<TT CLASS="VARNAME">conn</TT>是空，表明<SPAN CLASS="APPLICATION">libpq</SPAN>无法分配一个新的<TT CLASS="STRUCTNAME">PGconn</TT>结构。
否则，返回一个有效的<TT CLASS="STRUCTNAME">PGconn</TT>指针（尽管还不一定代表一个与数据库有效联接）。
<CODE CLASS="FUNCTION">PQconnectStart</CODE>一返回，调用<TT CLASS="LITERAL">status = PQstatus(conn)</TT>。
如果<TT CLASS="VARNAME">status</TT>等于<TT CLASS="SYMBOL">CONNECTION_BAD</TT>，<CODE CLASS="FUNCTION">PQconnectStart</CODE>失败。</P><P>如果<CODE CLASS="FUNCTION">PQconnectStart</CODE>成功了，下一个阶段是轮询<SPAN CLASS="APPLICATION">libpq</SPAN>，
这样它就可以继续连接序列动作。使用<CODE CLASS="FUNCTION">PQsocket(conn)</CODE>
获取数据库链接下层的套接字描述符。像这样循环：如果<CODE CLASS="FUNCTION">PQconnectPoll(conn)</CODE>
的最后一个返回是<TT CLASS="SYMBOL">PGRES_POLLING_READING</TT>，那么就等到套接字准备好被读取了的时候
（就像系统函数<CODE CLASS="FUNCTION">select()</CODE>，<CODE CLASS="FUNCTION">poll()</CODE>，或者类似的系统调用声明的那样）。
然后再次调用<CODE CLASS="FUNCTION">PQconnectPoll(conn)</CODE>。反过来，如果<CODE CLASS="FUNCTION">PQconnectPoll(conn)</CODE>
最后返回<TT CLASS="SYMBOL">PGRES_POLLING_WRITING</TT>，那么就等到套接字准备好可以写了，
然后再次调用<CODE CLASS="FUNCTION">PQconnectPoll(conn)</CODE>。如果你还没调用<CODE CLASS="FUNCTION">PQconnectPoll</CODE>，
比如，刚刚调用完<CODE CLASS="FUNCTION">PQconnectStart</CODE>，那么按照它刚返回<TT CLASS="SYMBOL">PGRES_POLLING_WRITING</TT>
的原则行动。继续这个循环直到<CODE CLASS="FUNCTION">PQconnectPoll(conn)</CODE>返回<TT CLASS="SYMBOL">PGRES_POLLING_FAILED</TT>，
表明连接过程失败，或者<TT CLASS="SYMBOL">PGRES_POLLING_OK</TT>，表明连接成功建立。</P><P>在连接的任意时刻，我们都可以通过调用<CODE CLASS="FUNCTION">PQstatus</CODE>来检查联接的状态。
如果这是<TT CLASS="SYMBOL">CONNECTION_BAD</TT>，那么联接过程失败；如果是<CODE CLASS="FUNCTION">CONNECTION_OK</CODE>，
那么联接已经做好。这两种状态同样也可以从上面的<CODE CLASS="FUNCTION">PQconnectPoll</CODE>的返回值里检测到。
其他状态可能（也只能）在一次异步联接过程中发生。这些标识连接过程的当前状态，
因而可能对给用户提供反馈有帮助。这些状态可能包括：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-CONNECTION-STARTED"></A><TT CLASS="SYMBOL">CONNECTION_STARTED</TT></DT><DD><P>等待进行连接。</P></DD><DT><A NAME="LIBPQ-CONNECTION-MADE"></A><TT CLASS="SYMBOL">CONNECTION_MADE</TT></DT><DD><P>连接成功；等待发送。</P></DD><DT><A NAME="LIBPQ-CONNECTION-AWAITING-RESPONSE"></A><TT CLASS="SYMBOL">CONNECTION_AWAITING_RESPONSE</TT></DT><DD><P>等待来自服务器的响应。</P></DD><DT><A NAME="LIBPQ-CONNECTION-AUTH-OK"></A><TT CLASS="SYMBOL">CONNECTION_AUTH_OK</TT></DT><DD><P>已收到认证；等待后端启动结束。</P></DD><DT><A NAME="LIBPQ-CONNECTION-SSL-STARTUP"></A><TT CLASS="SYMBOL">CONNECTION_SSL_STARTUP</TT></DT><DD><P>协商 SSL 加密。</P></DD><DT><A NAME="LIBPQ-CONNECTION-SETENV"></A><TT CLASS="SYMBOL">CONNECTION_SETENV</TT></DT><DD><P>协商环境驱动的参数设置。</P></DD></DL></DIV><P>
注意，尽管这些常量将保持下去（为了维持兼容性），应用决不应该依赖于这些常量以某种特定顺序出现，
或者是根本不应依赖于这些常量，或者是不应该依赖于这些状态总是某个文档声明的值。
一个应用可能像下面这样：
</P><PRE CLASS="PROGRAMLISTING">switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}</PRE><P>
</P><P>在使用<CODE CLASS="FUNCTION">PQconnectPoll</CODE>的时候，连接参数<TT CLASS="LITERAL">connect_timeout</TT>
将被忽略；判断是否超时是应用的责任。否则，后面跟着一个<CODE CLASS="FUNCTION">PQconnectPoll</CODE>
循环的<CODE CLASS="FUNCTION">PQconnectStart</CODE>等效于<CODE CLASS="FUNCTION">PQconnectdb</CODE>。</P><P>要注意如果<CODE CLASS="FUNCTION">PQconnectStart</CODE>返回一个非空的指针，你必须在使用完它（指针）
之后调用<CODE CLASS="FUNCTION">PQfinish</CODE>，以处理那些结构和所有相关的存储块。
甚至是在连接尝试失败或放弃时也要这样处理。</P></DD><DT><A NAME="LIBPQ-PQCONNDEFAULTS"></A><CODE CLASS="FUNCTION">PQconndefaults</CODE></DT><DD><P>返回缺省的联接选项。
</P><PRE CLASS="SYNOPSIS">PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* 选项的键字 */
    char   *envvar;    /* 退守的环境变量名 */
    char   *compiled;  /*  退守的编译时缺省值*/
    char   *val;       /* 选项的当前值，或者 NULL */
    char   *label;     /* 连接对话里字段的标识 */
    char   *dispchar;  /* 在连接对话里为此字段显示的字符。
                          数值有：
                          ""        原样现实输入的数值
                          "*"       口令字段 － 隐藏数值
                          "D"       调试选项 － 缺省的时候不显示 */
    int     dispsize;  /*  对话中字段的以字符计的大小 */
} PQconninfoOption;</PRE><P>
</P><P>返回一个连接选项数组。可以用于获取所有可能的<CODE CLASS="FUNCTION">PQconnectdb</CODE>
选项和它们的当前缺省值。返回值指向一个<TT CLASS="STRUCTNAME">PQconninfoOption</TT>
结构的数组，该数组以一个有 NULL <TT CLASS="STRUCTFIELD">keyword</TT>指针的条目结束。
如果无法分配内存，则返回空指针。注意当前缺省值（<TT CLASS="STRUCTFIELD">val</TT>域）
将依赖于环境变量和其他环境。调用者必须把连接选项当作只读对待。</P><P>在处理完选项数组后，把数组交给<CODE CLASS="FUNCTION">PQconninfoFree</CODE>释放。
如果没有这么做，每次调用<CODE CLASS="FUNCTION">PQconndefaults</CODE>都会有一小部分内存泄漏。</P></DD><DT><A NAME="LIBPQ-PQCONNINFO"></A><CODE CLASS="FUNCTION">PQconninfo</CODE></DT><DD><P>返回活的连接使用的连接选项。
</P><PRE CLASS="SYNOPSIS">PQconninfoOption *PQconninfo(PGconn *conn);</PRE><P>
</P><P>返回一个连接选项数组。可以用于获取所有可能的<CODE CLASS="FUNCTION">PQconnectdb</CODE>
选项和用于连接到服务器的值。返回值指向一个<TT CLASS="STRUCTNAME">PQconninfoOption</TT>
结构的数组，该数组以一个有 NULL <TT CLASS="STRUCTFIELD">keyword</TT>指针的条目结束。
以上所有<CODE CLASS="FUNCTION">PQconndefaults</CODE>的注意事项也应用到<CODE CLASS="FUNCTION">PQconninfo</CODE>
的结果。</P></DD><DT><A NAME="LIBPQ-PQCONNINFOPARSE"></A><CODE CLASS="FUNCTION">PQconninfoParse</CODE></DT><DD><P>从提供的连接字符串中返回解析的连接选项。
</P><PRE CLASS="SYNOPSIS">PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);</PRE><P>
</P><P>解析连接字符串并作为数组返回结果选项；或者如果连接字符串有问题返回<TT CLASS="SYMBOL">NULL</TT>。
这个函数可以用来在提供的连接字符串中提取<CODE CLASS="FUNCTION">PQconnectdb</CODE>选项。
返回值指向一个<TT CLASS="STRUCTNAME">PQconninfoOption</TT>结构的数组，
该数组以一个有 NULL <TT CLASS="STRUCTFIELD">keyword</TT>指针的条目结束。</P><P>所有合法选项将在结果数组中显示，但是<TT CLASS="LITERAL">PQconninfoOption</TT>
的任何没有在连接字符串中出现的选项将把<TT CLASS="LITERAL">val</TT>设置为<TT CLASS="LITERAL">NULL</TT>；
缺省值不插入。</P><P>如果<TT CLASS="LITERAL">errmsg</TT>是非<TT CLASS="SYMBOL">NULL</TT>的，那么<TT CLASS="LITERAL">*errmsg</TT>在成功时设置为<TT CLASS="SYMBOL">NULL</TT>，
否则是<CODE CLASS="FUNCTION">malloc</CODE>的解释问题的错误字符串。（<TT CLASS="LITERAL">*errmsg</TT>设置为<TT CLASS="SYMBOL">NULL</TT>
并且函数返回<TT CLASS="SYMBOL">NULL</TT>是可能的；这表示一个内存溢出条件。）</P><P>在处理完选项数组后，把数组交给<CODE CLASS="FUNCTION">PQconninfoFree</CODE>释放。
如果没有这么做，每次调用<CODE CLASS="FUNCTION">PQconndefaults</CODE>都会有一小部分内存泄漏。
相反的，如果错误发生了并且<TT CLASS="LITERAL">errmsg</TT>非<TT CLASS="SYMBOL">NULL</TT>，
确保使用<CODE CLASS="FUNCTION">PQfreemem</CODE>释放错误字符串。</P></DD><DT><A NAME="LIBPQ-PQFINISH"></A><CODE CLASS="FUNCTION">PQfinish</CODE></DT><DD><P>关闭与服务器的连接。同时释放被<TT CLASS="STRUCTNAME">PGconn</TT>对象使用的存储器。
</P><PRE CLASS="SYNOPSIS">void PQfinish(PGconn *conn);</PRE><P>
</P><P>注意，即使与服务器的连接尝试失败（可由<CODE CLASS="FUNCTION">PQstatus</CODE>判断），
应用也要调用<CODE CLASS="FUNCTION">PQfinish</CODE>释放被<TT CLASS="STRUCTNAME">PGconn</TT>
对象使用的存储器。不应该在调用<CODE CLASS="FUNCTION">PQfinish</CODE>后再使用<TT CLASS="STRUCTNAME">PGconn</TT>指针。</P></DD><DT><A NAME="LIBPQ-PQRESET"></A><CODE CLASS="FUNCTION">PQreset</CODE></DT><DD><P>重置与服务器的通讯端口。
</P><PRE CLASS="SYNOPSIS">void PQreset(PGconn *conn);</PRE><P>
</P><P>此函数将关闭与服务器的连接并且试图与同一个服务器重建新的连接，
使用所有前面使用过的参数。这在失去工作连接后进行故障恢复时很有用。</P></DD><DT><A NAME="LIBPQ-PQRESETSTART"></A><CODE CLASS="FUNCTION">PQresetStart</CODE><BR><CODE CLASS="FUNCTION">PQresetPoll</CODE></DT><DD><P>以非阻塞模式重置与服务器的通讯端口。
</P><PRE CLASS="SYNOPSIS">int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);</PRE><P>
</P><P>此函数将关闭与服务器的连接并且试图与同一个服务器重建新的连接，使用所有前面使用过的参数。
这在失去工作连接后进行故障恢复时很有用。它们和上面的<CODE CLASS="FUNCTION">PQreset</CODE>
的区别是它们工作在非阻塞模式。这些函数的使用有与上面<CODE CLASS="FUNCTION">PQconnectStartParams</CODE>、
<CODE CLASS="FUNCTION">PQconnectStart</CODE>和<CODE CLASS="FUNCTION">PQconnectPoll</CODE>一样的限制。</P><P>要发起一次连接重置，调用<CODE CLASS="FUNCTION">PQresetStart</CODE>。如果它返回 0，
那么重置失败。如果返回 1，用与使用<CODE CLASS="FUNCTION">PQresetPoll</CODE>
建立连接的同样的方法使用<CODE CLASS="FUNCTION">PQresetPoll</CODE>重置连接。</P></DD><DT><A NAME="LIBPQ-PQPINGPARAMS"></A><CODE CLASS="FUNCTION">PQpingParams</CODE></DT><DD><P><CODE CLASS="FUNCTION">PQpingParams</CODE>报告服务器的状态。它接受和<CODE CLASS="FUNCTION">PQconnectdbParams</CODE>
一样的连接参数，在下面描述。不需要应用正确的用户名、密码或数据库名的值获取服务器状态；
不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。
</P><PRE CLASS="SYNOPSIS">PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);</PRE><P>
该函数返回下列的值之一：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQPINGPARAMS-PQPING-OK"></A><TT CLASS="LITERAL">PQPING_OK</TT></DT><DD><P>服务器正在运行并且似乎接受了连接。</P></DD><DT><A NAME="LIBPQ-PQPINGPARAMS-PQPING-REJECT"></A><TT CLASS="LITERAL">PQPING_REJECT</TT></DT><DD><P>服务器正在运行，但是在一个不允许连接的状态（启动、关闭或崩溃恢复）。</P></DD><DT><A NAME="LIBPQ-PQPINGPARAMS-PQPING-NO-RESPONSE"></A><TT CLASS="LITERAL">PQPING_NO_RESPONSE</TT></DT><DD><P>联系不上服务器。这可能表明服务器没有运行，或者给出的连接参数有什么错误
（例如，错误的端口号），或者网络连接有问题（例如，防火墙阻塞连接请求）。</P></DD><DT><A NAME="LIBPQ-PQPINGPARAMS-PQPING-NO-ATTEMPT"></A><TT CLASS="LITERAL">PQPING_NO_ATTEMPT</TT></DT><DD><P>没有尝试连接到服务器，因为提供的参数明显的不正确或者有一些客户端侧的问题（例如，内存溢出）。</P></DD></DL></DIV><P>
</P></DD><DT><A NAME="LIBPQ-PQPING"></A><CODE CLASS="FUNCTION">PQping</CODE></DT><DD><P>
<CODE CLASS="FUNCTION">PQping</CODE>报告服务器的状态。它接受和<CODE CLASS="FUNCTION">PQconnectdb</CODE>
一样的连接参数，在下面描述。不需要应用正确的用户名、密码或数据库名的值获取服务器状态；
不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。
</P><PRE CLASS="SYNOPSIS">PGPing PQping(const char *conninfo);</PRE><P>
</P><P>返回值和<CODE CLASS="FUNCTION">PQpingParams</CODE>的相同。</P></DD></DL></DIV><P>
</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-CONNSTRING">31.1.1. 连接字符串</A></H2><P>几个<SPAN CLASS="APPLICATION">libpq</SPAN>函数分析用户指定的字符串以获取连接参数。
这些字符串有两个可接受的格式：纯<TT CLASS="LITERAL">keyword = value</TT>字符串和
<A HREF="http://www.ietf.org/rfc/rfc3986.txt" TARGET="_top">RFC 3986</A> URIs。</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN38811">31.1.1.1. 关键字/值连接字符串</A></H3><P>在第一中格式中，每个参数以<TT CLASS="LITERAL">keyword = value</TT>的形式设置。
等号周围的空白是可选的。要写一个空值或者一个包含空白的值，你可以用一对单引号包围它们，
例如，<TT CLASS="LITERAL">keyword = 'a value'</TT>。数值内部的单引号和反斜杠必须用一个反斜杠转义，
比如，<TT CLASS="LITERAL">\'</TT>或<TT CLASS="LITERAL">\\</TT>。</P><P>示例：
</P><PRE CLASS="PROGRAMLISTING">host=localhost port=5432 dbname=mydb connect_timeout=10</PRE><P></P><P>可识别的参数关键字在<A HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS">第 31.1.2 &#33410;</A>中列出。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN38822">31.1.1.2. 连接URI</A></H3><P>连接<ACRONYM CLASS="ACRONYM">URI</ACRONYM>的通用格式是：
</P><PRE CLASS="SYNOPSIS">postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&amp;...]</PRE><P>
</P><P><ACRONYM CLASS="ACRONYM">URI</ACRONYM>模式标识符可以是<TT CLASS="LITERAL">postgresql://</TT>或
<TT CLASS="LITERAL">postgres://</TT>。<ACRONYM CLASS="ACRONYM">URI</ACRONYM>的每个部分都是可选的。
下列示例举例说明了有效的<ACRONYM CLASS="ACRONYM">URI</ACRONYM>语法使用：
</P><PRE CLASS="PROGRAMLISTING">postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp</PRE><P>
<ACRONYM CLASS="ACRONYM">URI</ACRONYM>的层次部分的组件也可以作为参数给出。例如：
</P><PRE CLASS="PROGRAMLISTING">postgresql:///mydb?host=localhost&amp;port=5433</PRE><P>
</P><P>百分号可以用在<ACRONYM CLASS="ACRONYM">URI</ACRONYM>的任何部分来包含特殊含义的符号。</P><P>忽略任何不对应于在<A HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS">第 31.1.2 &#33410;</A>列出的关键字的连接参数，
并将关于它们的警告消息发送到<TT CLASS="FILENAME">stderr</TT>。</P><P>为了提高JDBC连接<ACRONYM CLASS="ACRONYM">URI</ACRONYM>的兼容性，参数<TT CLASS="LITERAL">ssl=true</TT>
的实例被翻译成<TT CLASS="LITERAL">sslmode=require</TT>。</P><P>主机部分是主机名或者IP地址。要指定一个IPv6主机地址，将它包含在方括号中：
</P><PRE CLASS="SYNOPSIS">postgresql://[2001:db8::1234]/database</PRE><P>
</P><P>主机部分解释为参数<A HREF="libpq-connect.html#LIBPQ-CONNECT-HOST">host</A>的描述。特别的，
如果主机部分为空或者以斜线开头，那么选择一个Unix域套接字连接，否则初始化一个TCP/IP连接。
不过要注意，斜线是URI分层部分的一个保留字符。所以，要指定一个非标准Unix域套接字路径，
要么在URI中省略主机声明并指定主机为一个参数，要么在URI的主机部分添加百分号：
</P><PRE CLASS="PROGRAMLISTING">postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname</PRE><P>
</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-PARAMKEYWORDS">31.1.2. 参数关键字</A></H2><P>目前可识别的参数键字是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-CONNECT-HOST"></A><TT CLASS="LITERAL">host</TT></DT><DD><P>要联接的主机名。如果主机名以斜杠开头，
则它声明使用 Unix 域套接字通讯而不是 TCP/IP 通讯；该值就是套接字文件所存储的目录。
如果没有声明<TT CLASS="LITERAL">host</TT>，那么缺省时是与位于<TT CLASS="FILENAME">/tmp</TT>目录
（或者制作<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的时候声明的套接字目录）里面的 Unix-域套接字连接。
在没有 Unix 域套接字的机器上，缺省是与<TT CLASS="LITERAL">localhost</TT>连接。</P></DD><DT><A NAME="LIBPQ-CONNECT-HOSTADDR"></A><TT CLASS="LITERAL">hostaddr</TT></DT><DD><P>与之连接的主机的 IP 地址。这个应该是标准的IPv4 地址格式，比如，<TT CLASS="LITERAL">172.28.40.9</TT>。
如果你的机器支持 IPv6，那么你也可以使用 IPv6 的地址。如果声明了一个非空的字符串，
那么使用 TCP/IP 通讯机制。</P><P>使用<TT CLASS="LITERAL">hostaddr</TT>取代<TT CLASS="LITERAL">host</TT>可以让应用避免一次主机名查找，
这一点对于那些有时间约束的应用来说可能是非常重要的。不过，Kerberos、GSSAPI
或SSPI认证方法和<TT CLASS="LITERAL">verify-full</TT> SSL证书验证要求主机（host）名。
因此，应用下面的规则：
<P></P></P><UL><LI><P>如果声明了不带<TT CLASS="LITERAL">hostaddr</TT>的<TT CLASS="LITERAL">host</TT>那么就强制进行主机名查找。</P></LI><LI><P>如果声明中没有<TT CLASS="LITERAL">host</TT>，<TT CLASS="LITERAL">hostaddr</TT>的值给出服务器网络地址；
如果认证方法要求主机名，那么连接尝试将失败。</P></LI><LI><P>如果同时声明了<TT CLASS="LITERAL">host</TT>和<TT CLASS="LITERAL">hostaddr</TT>，那么<TT CLASS="LITERAL">hostaddr</TT>
的值作为服务器网络地址。<TT CLASS="LITERAL">host</TT>的值将被忽略，除非认证方法需要它，
在这种情况下它将被用作主机名。</P></LI></UL><P>
要注意如果<TT CLASS="LITERAL">host</TT>不是网络地址<TT CLASS="LITERAL">hostaddr</TT>处的服务器名，
那么认证很有可能失败。同样，在<TT CLASS="FILENAME">~/.pgpass</TT>（参阅<A HREF="libpq-pgpass.html">第 31.15 &#33410;</A>）
中是使用<TT CLASS="LITERAL">host</TT>而不是<TT CLASS="LITERAL">hostaddr</TT>来标识连接。
</P><P>如果主机名（host）和主机地址都没有，那么<SPAN CLASS="APPLICATION">libpq</SPAN>
将使用一个本地的 Unix 域套接字进行连接；或者是在没有 Unix 域套接字的机器上，
它将尝试与<TT CLASS="LITERAL">localhost</TT>连接。</P></DD><DT><A NAME="LIBPQ-CONNECT-PORT"></A><TT CLASS="LITERAL">port</TT></DT><DD><P>主机服务器的端口号，或者在 Unix 域套接字联接时的套接字扩展文件名。</P></DD><DT><A NAME="LIBPQ-CONNECT-DBNAME"></A><TT CLASS="LITERAL">dbname</TT></DT><DD><P>数据库名。缺省和用户名相同。在某些情况下，为扩展的格式检查值；
参阅<A HREF="libpq-connect.html#LIBPQ-CONNSTRING">第 31.1.1 &#33410;</A>获取更多信息。</P></DD><DT><A NAME="LIBPQ-CONNECT-USER"></A><TT CLASS="LITERAL">user</TT></DT><DD><P>要连接的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>用户名。
缺省是与运行该应用的用户操作系统名同名的用户。</P></DD><DT><A NAME="LIBPQ-CONNECT-PASSWORD"></A><TT CLASS="LITERAL">password</TT></DT><DD><P>如果服务器要求口令认证，所用的口令。</P></DD><DT><A NAME="LIBPQ-CONNECT-CONNECT-TIMEOUT"></A><TT CLASS="LITERAL">connect_timeout</TT></DT><DD><P>连接的最大等待时间，以秒计（用十进制整数字串书写）。零或者不声明表示无穷。
我们不建议把连接超时的值设置得小于 2 秒。</P></DD><DT><A NAME="LIBPQ-CONNECT-CLIENT-ENCODING"></A><TT CLASS="LITERAL">client_encoding</TT></DT><DD><P>为这个连接设置<TT CLASS="VARNAME">client_encoding</TT>配置参数。
除了对应的服务器选项接受的值，你可以使用<TT CLASS="LITERAL">auto</TT>
从客户端中的当前环境中确定正确的编码（Unix系统上是
<TT CLASS="ENVAR">LC_CTYPE</TT>环境变量）。</P></DD><DT><A NAME="LIBPQ-CONNECT-OPTIONS"></A><TT CLASS="LITERAL">options</TT></DT><DD><P>添加命令行选项以在运行时发送到服务器。例如，设置为<TT CLASS="LITERAL">-c geqo=off</TT>
设置<TT CLASS="VARNAME">geqo</TT>参数的会话的值为<TT CLASS="LITERAL">off</TT>。关于可用选项的详细讨论，
请查阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html">第 18 &#31456;</A>。</P></DD><DT><A NAME="LIBPQ-CONNECT-APPLICATION-NAME"></A><TT CLASS="LITERAL">application_name</TT></DT><DD><P>为<A HREF="runtime-config-logging.html#GUC-APPLICATION-NAME">application_name</A>配置参数指定一个值。</P></DD><DT><A NAME="LIBPQ-CONNECT-FALLBACK-APPLICATION-NAME"></A><TT CLASS="LITERAL">fallback_application_name</TT></DT><DD><P>为<A HREF="runtime-config-logging.html#GUC-APPLICATION-NAME">application_name</A>配置参数指定一个回退值。
如果没有通过连接参数或<TT CLASS="ENVAR">PGAPPNAME</TT>环境变量给定
<TT CLASS="LITERAL">application_name</TT>值，那么将使用这个值。
在想要设置缺省应用名但是允许用户重写的通用实用程序中指定一个回退名是有用的。</P></DD><DT><A NAME="LIBPQ-KEEPALIVES"></A><TT CLASS="LITERAL">keepalives</TT></DT><DD><P>控制客户端侧的TCP保持激活是否使用。缺省值是1，意思为打开，但是如果不想要保持激活，
你可以更改为0，意思为关闭。通过Unix域套接字做的连接忽略这个参数。</P></DD><DT><A NAME="LIBPQ-KEEPALIVES-IDLE"></A><TT CLASS="LITERAL">keepalives_idle</TT></DT><DD><P>在TCP应该发送一个保持激活的信息给服务器之后，控制不活动的秒数。
0值表示使用系统缺省。通过Unix域套接字做的连接或者如果禁用了保持激活则忽略这个参数。
只有在<TT CLASS="SYMBOL">TCP_KEEPIDLE</TT>和<TT CLASS="SYMBOL">TCP_KEEPALIVE</TT>套接字选项可用的系统上支持这个参数，
在Windows上还是在其他系统上是没什么影响的。</P></DD><DT><A NAME="LIBPQ-KEEPALIVES-INTERVAL"></A><TT CLASS="LITERAL">keepalives_interval</TT></DT><DD><P>在TCP保持激活信息没有被应该传播的服务器承认之后，控制秒数。0值表示使用系统缺省。
通过Unix域套接字做的连接或者如果禁用了保持激活则忽略这个参数。
只有在<TT CLASS="SYMBOL">TCP_KEEPINTVL</TT>套接字选项可用的系统上支持这个参数，
在Windows上还是在其他系统上是没什么影响的。</P></DD><DT><A NAME="LIBPQ-KEEPALIVES-COUNT"></A><TT CLASS="LITERAL">keepalives_count</TT></DT><DD><P>在认为客户端到服务器的连接死亡之前，控制可以丢失的TCP保持激活的数量。0值表示使用系统缺省。
通过Unix域套接字做的连接或者如果禁用了保持激活则忽略这个参数。
只有在<TT CLASS="SYMBOL">TCP_KEEPINTVL</TT>套接字选项可用的系统上支持这个参数，
在Windows上还是在其他系统上是没什么影响的。</P></DD><DT><A NAME="LIBPQ-CONNECT-TTY"></A><TT CLASS="LITERAL">tty</TT></DT><DD><P>忽略（以前，这个选项声明服务器日志的输出方向）。</P></DD><DT><A NAME="LIBPQ-CONNECT-SSLMODE"></A><TT CLASS="LITERAL">sslmode</TT></DT><DD><P>这个选项决定是否需要和服务器协商一个<ACRONYM CLASS="ACRONYM">SSL</ACRONYM> TCP/IP连接，
以及以什么样的安全优先级与服务器进行<ACRONYM CLASS="ACRONYM">SSL</ACRONYM> TCP/IP连接。
这里有六个模式：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">disable</TT></DT><DD><P>只进行一个非<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接</P></DD><DT><TT CLASS="LITERAL">allow</TT></DT><DD><P>首先尝试一个非<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接；如果失败，尝试一个<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接</P></DD><DT><TT CLASS="LITERAL">prefer</TT> (default)</DT><DD><P>首先尝试<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接；如果失败，尝试一个非<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接</P></DD><DT><TT CLASS="LITERAL">require</TT></DT><DD><P>尝试一个<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接。如果有根CA文件，则按照指定了<TT CLASS="LITERAL">verify-ca</TT>
的相同方式验证该证书</P></DD><DT><TT CLASS="LITERAL">verify-ca</TT></DT><DD><P>只尝试一个<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接，并核实服务器证书是由一个受信任的认证中心(<ACRONYM CLASS="ACRONYM">CA</ACRONYM>)发布的</P></DD><DT><TT CLASS="LITERAL">verify-full</TT></DT><DD><P>只尝试一个<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接，核实服务器证书是由受信任的<ACRONYM CLASS="ACRONYM">CA</ACRONYM>发布的，
并且该服务器主机名匹配证书中的服务器主机名。</P></DD></DL></DIV><P>
参阅<A HREF="libpq-ssl.html">第 31.18 &#33410;</A>获取这些选项工作的详细描述。
</P><P>Unix域套接字通信忽略<TT CLASS="LITERAL">sslmode</TT>。如果<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
编译时没有打开 SSL 支持，那么使用选项<TT CLASS="LITERAL">require</TT>、<TT CLASS="LITERAL">verify-ca</TT>或
<TT CLASS="LITERAL">verify-full</TT>将导致一个错误，而选项<TT CLASS="LITERAL">allow</TT>和<TT CLASS="LITERAL">prefer</TT>
将被接受，但是<SPAN CLASS="APPLICATION">libpq</SPAN>实际上不会企图进行<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>连接。&#13;</P></DD><DT><A NAME="LIBPQ-CONNECT-REQUIRESSL"></A><TT CLASS="LITERAL">requiressl</TT></DT><DD><P>这个选项因为有了<TT CLASS="LITERAL">sslmode</TT>设置之后已经废弃了。</P><P>如果设为1，则要求与服务器进行<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>联接（等效于<TT CLASS="LITERAL">sslmode</TT>
<TT CLASS="LITERAL">require</TT>）。如果服务器不支持<ACRONYM CLASS="ACRONYM">SSL</ACRONYM>，那么<SPAN CLASS="APPLICATION">libpq</SPAN>
将马上拒绝联接。设置为0（缺省），与服务器进行协商连接类型（等效于<TT CLASS="LITERAL">sslmode</TT>
<TT CLASS="LITERAL">prefer</TT>）。这个选项只有在编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时打开了 SSL 支持才有效。</P></DD><DT><A NAME="LIBPQ-CONNECT-SSLCOMPRESSION"></A><TT CLASS="LITERAL">sslcompression</TT></DT><DD><P>如果设置为1（缺省），通过SSL连接进行的数据发送将被压缩（这要求<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN>
版本0.9.8或更高）。如果设置为0，将禁用压缩（这需要<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN> 1.0.0或更高）。
如果连接没有通过SSL进行，或者如果使用的<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN>版本不支持它，则忽略该参数。</P><P>压缩使用CPU时间，但是如果网络是瓶颈，那么可以提高吞吐量。
如果CPU性能是限制因素，那么禁用压缩可以提高响应时间和吞吐量。</P></DD><DT><A NAME="LIBPQ-CONNECT-SSLCERT"></A><TT CLASS="LITERAL">sslcert</TT></DT><DD><P>这个参数指定客户端SSL认证的文件名，替换缺省的<TT CLASS="FILENAME">~/.postgresql/postgresql.crt</TT>。
如果没有做SSL连接，则忽略这个参数。</P></DD><DT><A NAME="LIBPQ-CONNECT-SSLKEY"></A><TT CLASS="LITERAL">sslkey</TT></DT><DD><P>这个参数指定客户端使用的秘钥的位置。也可以指定一个用来替换缺省
<TT CLASS="FILENAME">~/.postgresql/postgresql.key</TT>的文件名，或者指定一个从外部
<SPAN CLASS="QUOTE">"引擎"</SPAN>获取的键（引擎是<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN>可加载模块）。
一个外部引擎声明应该包括一个由冒号分隔的引擎名字和特定于引擎的键标识符。
如果没有做SSL连接则忽略这个参数。</P></DD><DT><A NAME="LIBPQ-CONNECT-SSLROOTCERT"></A><TT CLASS="LITERAL">sslrootcert</TT></DT><DD><P>这个参数声明一个包含SSL认证授权(<ACRONYM CLASS="ACRONYM">CA</ACRONYM>)证书的文件名。
如果该文件存在，那么将要验证的服务器的证书将由这些授权之一签署。
缺省是<TT CLASS="FILENAME">~/.postgresql/root.crt</TT>。</P></DD><DT><A NAME="LIBPQ-CONNECT-SSLCRL"></A><TT CLASS="LITERAL">sslcrl</TT></DT><DD><P>这个参数声明SSL证书撤销列表(CRL)的文件名。在这个文件中列出的证书，
如果该文件存在，将在尝试认证服务器的证书时被拒绝。缺省是
<TT CLASS="FILENAME">~/.postgresql/root.crl</TT>。</P></DD><DT><A NAME="LIBPQ-CONNECT-REQUIREPEER"></A><TT CLASS="LITERAL">requirepeer</TT></DT><DD><P>这个参数声明服务器的操作系统用户名，例如<TT CLASS="LITERAL">requirepeer=postgres</TT>。
当制作一个Unix域套接字连接时，如果设置了该参数，那么在连接的开始，
客户端检查服务器进程是否运行在指定的用户名之下；如果不是，则连接带有错误退出。
这个参数可以用来提供服务器认证，类似于在TCP/IP连接上可用SSL证书。
（请注意，如果Unix域套接字在<TT CLASS="FILENAME">/tmp</TT>中或另一个公开可写位置，
那么任意用户都可以在这里启动一个服务器监听。
使用这个参数确保你连接到一个受信任的用户运行的服务器。）
这个选项只有在实现了<TT CLASS="LITERAL">peer</TT>认证方法的平台上支持；参阅
<A HREF="auth-methods.html#AUTH-PEER">第 19.3.7 &#33410;</A>。</P></DD><DT><A NAME="LIBPQ-CONNECT-KRBSRVNAME"></A><TT CLASS="LITERAL">krbsrvname</TT></DT><DD><P>使用Kerberos 5或GSSAPI认证时使用的Kerberos服务名。
这个名字必须和服务器给Kerberos认证配置的服务名相同，才能认证成功。
（又见<A HREF="auth-methods.html#KERBEROS-AUTH">第 19.3.5 &#33410;</A>和<A HREF="auth-methods.html#GSSAPI-AUTH">第 19.3.3 &#33410;</A>。）</P></DD><DT><A NAME="LIBPQ-CONNECT-GSSLIB"></A><TT CLASS="LITERAL">gsslib</TT></DT><DD><P>为GSSAPI认证使用的GSS库。只在Windows上使用。设置为<TT CLASS="LITERAL">gssapi</TT>
强迫libpq为认证使用GSSAPI库而不是缺省的SSPI。</P></DD><DT><A NAME="LIBPQ-CONNECT-SERVICE"></A><TT CLASS="LITERAL">service</TT></DT><DD><P>用于额外参数的服务名。它在<TT CLASS="FILENAME">pg_service.conf</TT>里面声明一个服务名，
这个配置文件保存额外的连接参数。这样就允许应用只声明一个服务名，
而连接参数就可以在一个地方维护了。参阅<A HREF="libpq-pgservice.html">第 31.16 &#33410;</A>。</P></DD></DL></DIV><P>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-status.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">连接状态函数</TD></TR></TABLE></DIV></BODY></HTML>
