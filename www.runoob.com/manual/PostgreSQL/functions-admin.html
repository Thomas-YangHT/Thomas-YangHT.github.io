<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>系统管理函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="函数和操作符" HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html"><LINK REL="PREVIOUS" TITLE="系统信息函数" HREF="functions-info.html"><LINK REL="NEXT" TITLE="触发器函数" HREF="functions-trigger.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/func.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="系统信息函数" HREF="functions-info.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 9. 函数和操作符</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="触发器函数" HREF="functions-trigger.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FUNCTIONS-ADMIN">9.26. 系统管理函数</A></H1><P>这节描述的函数用来控制和监视<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>安装。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-ADMIN-SET">9.26.1. 配置设置函数</A></H2><P><A HREF="functions-admin.html#FUNCTIONS-ADMIN-SET-TABLE">&#34920; 9-58</A>显示了用于查询和修改运行时配置参数的函数。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-ADMIN-SET-TABLE"></A><P><B>&#34920; 9-58. 配置设置函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_setting(<TT CLASS="PARAMETER">setting_name</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取当前的设置值</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">set_config(<TT CLASS="PARAMETER">setting_name</TT>,
<TT CLASS="PARAMETER">new_value</TT>,
<TT CLASS="PARAMETER">is_local</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>设置参数并返回新值</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">current_setting</CODE>用于以查询形式获取<TT CLASS="PARAMETER">setting_name</TT>
设置的当前值。它和<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令<TT CLASS="COMMAND">SHOW</TT>是等效的。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)</PRE><P>
</P><P><CODE CLASS="FUNCTION">set_config</CODE>将参数<TT CLASS="PARAMETER">setting_name</TT>
设置为<TT CLASS="PARAMETER">new_value</TT>。如果<TT CLASS="PARAMETER">is_local</TT>
为<TT CLASS="LITERAL">true</TT>，那么新值将只应用于当前事务。
如果你希望新值应用于当前会话，那么应该使用<TT CLASS="LITERAL">false</TT>。
它等效于 SQL 命令<TT CLASS="COMMAND">SET</TT>。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-ADMIN-SIGNAL">9.26.2. 服务器信号函数</A></H2><P> <A HREF="functions-admin.html#FUNCTIONS-ADMIN-SIGNAL-TABLE">&#34920; 9-59</A>里的函数向其他服务器进程发送控制信号。
通常这些函数的使用限制为超级用户，除了提到的例外。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-ADMIN-SIGNAL-TABLE"></A><P><B>&#34920; 9-59. 服务器信号函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_cancel_backend(<TT CLASS="PARAMETER">pid</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>取消一个后端的当前查询。您可以对另一个后端执行这个函数，
这个后端有和调用这个函数的用户相同的角色。在所有其他情况下，您必须是超级用户。
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_reload_conf()</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>导致所有服务器进程重新装载它们的配置文件</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_rotate_logfile()</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>滚动服务器的日志文件</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_terminate_backend(<TT CLASS="PARAMETER">pid</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>终止一个后端。您可以对另一个后端执行这个函数，
这个后端有和调用这个函数的用户相同的角色。在所有其他情况下，您必须是超级用户。
</TD></TR></TBODY></TABLE></DIV><P>如果成功，这些函数返回<TT CLASS="LITERAL">true</TT>，否则返回<TT CLASS="LITERAL">false</TT>。</P><P><CODE CLASS="FUNCTION">pg_cancel_backend</CODE>和<CODE CLASS="FUNCTION">pg_terminate_backend</CODE>
向由 pid 标识的后端进程发送一个信号（分别是<SPAN CLASS="SYSTEMITEM">SIGINT</SPAN>或<SPAN CLASS="SYSTEMITEM">SIGTERM</SPAN>）。
一个活动的后端进程的 PID 可以从<TT CLASS="STRUCTNAME">pg_stat_activity</TT>视图的
<TT CLASS="STRUCTFIELD">pid</TT>字段找到，或者在服务器上列出<TT CLASS="COMMAND">postgres</TT>进程
（在Unix上使用<SPAN CLASS="APPLICATION">ps</SPAN>或在<SPAN CLASS="PRODUCTNAME">Windows</SPAN>上使用<SPAN CLASS="APPLICATION">Task Manager</SPAN>）。
一个活动的后端角色可以从<TT CLASS="STRUCTNAME">pg_stat_activity</TT>视图的
<TT CLASS="STRUCTFIELD">usename</TT>字段找到。</P><P><CODE CLASS="FUNCTION">pg_reload_conf</CODE>给服务器发送一个<SPAN CLASS="SYSTEMITEM">SIGHUP</SPAN>信号，
导致所有服务器进程重新装载配置文件。</P><P><CODE CLASS="FUNCTION">pg_rotate_logfile</CODE>给日志文件管理器发送信号，告诉它立即切换到一个新的输出文件。
这个函数只有在内建的日志收集器运行的时候才有用，否则根本不存在日志文件管理器子进程。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-ADMIN-BACKUP">9.26.3. 备份控制函数</A></H2><P><A HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE">&#34920; 9-60</A>里的函数帮助我们进行在线备份。
这些函数不能在恢复时执行（除了<CODE CLASS="FUNCTION">pg_is_in_backup</CODE>,
<CODE CLASS="FUNCTION">pg_backup_start_time</CODE>和<CODE CLASS="FUNCTION">pg_xlog_location_diff</CODE>）</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-ADMIN-BACKUP-TABLE"></A><P><B>&#34920; 9-60. 备份控制函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_create_restore_point(<TT CLASS="PARAMETER">name</TT> <TT CLASS="TYPE">text</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为执行恢复创建一个命名点 (限制为超级用户)</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_current_xlog_insert_location()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取当前事务日志的插入位置</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_current_xlog_location()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取当前事务日志的写入位置</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_start_backup(<TT CLASS="PARAMETER">label</TT> <TT CLASS="TYPE">text</TT> [<SPAN CLASS="OPTIONAL">, <TT CLASS="PARAMETER">fast</TT> <TT CLASS="TYPE">boolean</TT> </SPAN>])</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>准备执行在线备份(限制为超级用户或复制的角色)</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stop_backup()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>完成执行在线备份 (限制为超级用户或复制的角色)</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_is_in_backup()</CODE></TT>
</TD><TD><TT CLASS="TYPE">bool</TT></TD><TD>如果在线专属备份仍在进行中则为真。</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_backup_start_time()</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>获取进行中的在线专属备份的开始时间。</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_switch_xlog()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>强制转向一个新的事务日志文件(限制为超级用户)</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_xlogfile_name(<TT CLASS="PARAMETER">location</TT> <TT CLASS="TYPE">text</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>将事务日志的位置字符串转换为文件名</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_xlogfile_name_offset(<TT CLASS="PARAMETER">location</TT> <TT CLASS="TYPE">text</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT>, <TT CLASS="TYPE">integer</TT></TD><TD>将事务日志的位置字符串转换为文件名并返回在文件中的字节偏移量</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_xlog_location_diff(<TT CLASS="PARAMETER">location</TT> <TT CLASS="TYPE">text</TT>, <TT CLASS="PARAMETER">location</TT> <TT CLASS="TYPE">text</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">numeric</TT></TD><TD>计算两个事务日志位置之间的区别</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">pg_start_backup</CODE>接受一个用户定义的备份标签(通常这是备份转储文件存放地点的名字)。
这个函数向数据库集群的数据目录写入一个备份标签文件(<TT CLASS="FILENAME">backup_label</TT>)，执行一次检查点，
然后以文本方式返回备份的事务日志起始位置。用户可以忽略这个返回值，提供它只是为了万一需要的场合。
</P><PRE CLASS="PROGRAMLISTING">postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)</PRE><P>
这个函数有第二个可选的类型为<TT CLASS="TYPE">boolean</TT>的参数。如果为<TT CLASS="LITERAL">true</TT>，
那么指定尽可能快的执行<CODE CLASS="FUNCTION">pg_start_backup</CODE>。这强制一个立即的检查点，
将导致I/O操作有一个尖峰，减缓任何当前执行的查询。
</P><P><CODE CLASS="FUNCTION">pg_stop_backup</CODE>删除<CODE CLASS="FUNCTION">pg_start_backup</CODE>创建的标签文件，
并且在事务日志归档区里创建一个备份历史文件。这个历史文件包含给予<CODE CLASS="FUNCTION">pg_start_backup</CODE>
的标签、备份的事务日志起始与终止位置、备份的起始和终止时间。
返回值是备份的事务日志终止位置(同样也可以忽略)。计算出终止位置后，
当前事务日志的插入点将自动前进到下一个事务日志文件，这样，
结束的事务日志文件可以被立即归档从而完成备份。</P><P><CODE CLASS="FUNCTION">pg_switch_xlog</CODE>移动到下一个事务日志文件，以允许将当前日志文件归档
(假定你使用连续归档)。返回值是刚刚完成的事务日志文件的事务日志结束位置 + 1。
如果自从最后一次事务日志切换以来没有活动的事务日志，那么<CODE CLASS="FUNCTION">pg_switch_xlog</CODE>
什么事也不做，直接返回当前使用的事务日志文件的开始位置。</P><P><CODE CLASS="FUNCTION">pg_create_restore_point</CODE>创建一个可以用作恢复目标的命名的事务日志记录，
并返回相应的事务日志位置。给定的名字可以被<A HREF="recovery-target-settings.html#RECOVERY-TARGET-NAME">recovery_target_name</A>
使用以指定恢复将进行到的点。避免使用相同的名字创建多个恢复点，
因为恢复将在第一个名字匹配恢复目标的位置停止。</P><P><CODE CLASS="FUNCTION">pg_current_xlog_location</CODE>使用与前面那些函数相同的格式显示当前事务日志的写入位置。
类似的，<CODE CLASS="FUNCTION">pg_current_xlog_insert_location</CODE>显示当前事务日志的插入位置。
插入点是事务日志在某个瞬间的<SPAN CLASS="QUOTE">"逻辑终点"</SPAN>，
而实际的写入位置则是从服务器内部缓冲区写出时的终点。写入位置是可以从服务器外部检测到的终点，
如果想归档部分完成的事务日志文件，那么这个通常就是你想要的结果。插入点主要用于服务器调试目的。
上述两个函数既是只读操作也不需要超级用户权限。</P><P>可以使用<CODE CLASS="FUNCTION">pg_xlogfile_name_offset</CODE>
从前述函数的返回结果中抽取相应的事务日志文件名称和字节偏移量。例如：
</P><PRE CLASS="PROGRAMLISTING">postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)</PRE><P>
类似的，<CODE CLASS="FUNCTION">pg_xlogfile_name</CODE>仅仅抽取事务日志文件名称。
如果给定的事务日志位置恰好位于事务日志文件的交界上，这两个函数都返回前一个事务日志文件的名字。
这对于管理事务日志归档来说通常是期望的行为，因为前一个文件是当前最后一个需要归档的文件。
</P><P><CODE CLASS="FUNCTION">pg_xlog_location_diff</CODE>计算两个事务日志位置之间在字节上的不同。
它可以和<TT CLASS="STRUCTNAME">pg_stat_replication</TT>或<A HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE">&#34920; 9-60</A>
里面的一些函数一起使用以获取复制滞后。</P><P>有关正确使用这些函数的细节，参阅<A HREF="continuous-archiving.html">第 24.3 &#33410;</A>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-RECOVERY-CONTROL">9.26.4. 恢复控制函数</A></H2><P><A HREF="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE">&#34920; 9-61</A>里显示的函数提供了当前备机状态的信息。
这些函数可能在恢复期间或正常运行中执行。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-RECOVERY-INFO-TABLE"></A><P><B>&#34920; 9-61. 恢复信息函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_is_in_recovery()</CODE></TT>
</TD><TD><TT CLASS="TYPE">bool</TT></TD><TD>如果恢复仍然在进行中则返回true。
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_last_xlog_receive_location()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取最后一个事务日志接收并通过流媒体复制同步到磁盘的位置。
如果流复制仍在进行，这将单调增加。如果恢复已完成，
那么这个值将保持静止在恢复期间最后接收和同步到磁盘的WAL记录值。
如果不能用流复制，或还没有开始，这个函数返回NULL。
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_last_xlog_replay_location()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取最后一个事物日志在恢复时重放的位置。如果恢复仍在进行，这将单调增加。
如果恢复已经完成，那么这个值将保持静止在恢复期间最后应用的WAL记录值。
当服务已经没有恢复的正常启动时，这个函数返回NULL。
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_last_xact_replay_timestamp()</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>获取最后一个事物在恢复时重放的时间戳。这是为在主节点上生成的事务提交或终止WAL记录的时间。
如果没有事务在恢复时重放，那么这个函数返回NULL。否则，如果恢复仍在进行，
那么这将单调增加。如果恢复已经完成，那么这个值将保持静止在恢复时最后事务应用的值。
当服务已经没有恢复的正常启动时，这个函数返回NULL。
</TD></TR></TBODY></TABLE></DIV><P><A HREF="functions-admin.html#FUNCTIONS-RECOVERY-CONTROL-TABLE">&#34920; 9-62</A>里的函数控制恢复的进程。
这些函数可能只在恢复时被执行。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-RECOVERY-CONTROL-TABLE"></A><P><B>&#34920; 9-62. 恢复控制函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_is_xlog_replay_paused()</CODE></TT>
</TD><TD><TT CLASS="TYPE">bool</TT></TD><TD>如果恢复暂停则返回true。
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_xlog_replay_pause()</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>立即暂停恢复。
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_xlog_replay_resume()</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>如果恢复暂停了那么重新启动。
</TD></TR></TBODY></TABLE></DIV><P>当恢复暂停时，没有进一步的数据库更改。如果是在热备里，所有新的查询将看到相同一致的数据库快照，
并且不会有进一步的查询冲突产生，直到恢复继续。</P><P>如果不能使用流复制，那么暂停状态将没有问题的无限的延续。
当流复制正在进行时，将连续接收WAL记录，这将最终填满可用磁盘空间，取决于暂停的持续时间，
WAL生成的速度和可用的磁盘空间。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-SNAPSHOT-SYNCHRONIZATION">9.26.5. 快照同步函数</A></H2><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许数据库会话同步他们的快照。<I CLASS="FIRSTTERM">snapshot</I>
决定哪个数据对于使用这个快照的事务是可见的。当两个或更多会话需要查看数据库中相同的内容时，
快照同步是必须的。如果两个会话只是单独的启动它们的事务，仍然可能有某些事务在这两个
<TT CLASS="COMMAND">START TRANSACTION</TT>命令执行之间提交，所以一个会话看到了那个事务的影响而另外一个没有看到。</P><P>要解决这些问题，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许一个事务<I CLASS="FIRSTTERM">export</I>
它正在使用的快照。只要导出事务保持打开，其他事务可以<I CLASS="FIRSTTERM">import</I>
它的快照，因此来保证他们看到的是与第一个事务看到的完全相同的数据库视图。
但是要注意的是，由任一这些事务做出的任何数据库更改对其他事务保持不可见，
对由未提交的事务做出的更改同样适用。所以事务是与已经存在的数据同步的，
但是对它们自己做的更改正常动作。</P><P>快照是由<CODE CLASS="FUNCTION">pg_export_snapshot</CODE>函数输出的，在<A HREF="functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE">&#34920; 9-63</A>
里面显示，并且是由<A HREF="sql-set-transaction.html">SET TRANSACTION</A>命令输入的。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE"></A><P><B>&#34920; 9-63. 快照同步函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_export_snapshot()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>保存当前的快照并返回它的标识符</TD></TR></TBODY></TABLE></DIV><P>函数<CODE CLASS="FUNCTION">pg_export_snapshot</CODE>保存当前的快照并返回一个<TT CLASS="TYPE">text</TT>字符串标识这个快照。
这个字符串必须传递（在数据库外面）给想要导入快照的客户端。这个快照只在事务结束输出它之前是可以导入的。
如果需要的话，一个事务可以输出多个快照。请注意，这样做只在<TT CLASS="LITERAL">READ COMMITTED</TT>事务中有用，
因为在<TT CLASS="LITERAL">REPEATABLE READ</TT>和更高的隔离级别，事务在他们的生存周期中使用相同的快照。
一旦一个事务已经输出了任何的快照，它就不能使用<A HREF="sql-prepare-transaction.html">PREPARE TRANSACTION</A>做好准备了。</P><P>参阅<A HREF="sql-set-transaction.html">SET TRANSACTION</A>获取如何使用一个输出的快照的信息。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-ADMIN-DBOBJECT">9.26.6. 数据库对象管理函数</A></H2><P><A HREF="functions-admin.html#FUNCTIONS-ADMIN-DBSIZE">&#34920; 9-64</A>里显示的函数计算数据库对象使用的磁盘空间。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-ADMIN-DBSIZE"></A><P><B>&#34920; 9-64. 数据库对象尺寸函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_column_size(<TT CLASS="TYPE">any</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">int</TT></TD><TD>存储一个指定的数值需要的字节数(可能压缩过)</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_database_size(<TT CLASS="TYPE">oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>指定 OID 代表的数据库使用的磁盘空间</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_database_size(<TT CLASS="TYPE">name</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>指定名称的数据库使用的磁盘空间</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_indexes_size(<TT CLASS="TYPE">regclass</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD> 附加到指定表的索引使用的总磁盘空间
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_relation_size(<TT CLASS="PARAMETER">relation</TT> <TT CLASS="TYPE">regclass</TT>, <TT CLASS="PARAMETER">fork</TT> <TT CLASS="TYPE">text</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD> 指定表或索引的指定分叉树(<TT CLASS="LITERAL">'main'</TT>, <TT CLASS="LITERAL">'fsm'</TT> 或 <TT CLASS="LITERAL">'vm'</TT>)
使用的磁盘空间
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_relation_size(<TT CLASS="PARAMETER">relation</TT> <TT CLASS="TYPE">regclass</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD> <TT CLASS="LITERAL">pg_relation_size(..., 'main')的简写</TT>
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_size_pretty(<TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD> 把用64位整数表示的字节计算的尺寸转换成一个人类易读的尺寸
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_size_pretty(<TT CLASS="TYPE">numeric</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD> 把用数值表示的字节计算的尺寸转换成一个人类易读的尺寸
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_table_size(<TT CLASS="TYPE">regclass</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD> 指定的表使用的磁盘空间，不计索引（但是包含TOAST，自由空间映射和可见性映射）
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_tablespace_size(<TT CLASS="TYPE">oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>指定 OID 代表的表空间使用的磁盘空间</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_tablespace_size(<TT CLASS="TYPE">name</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>指定名字的表空间使用的磁盘空间</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_total_relation_size(<TT CLASS="TYPE">regclass</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD> 指定的表使用的总磁盘空间，包括所有的索引和<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>数据
</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">pg_column_size</CODE>显示用于存储某个独立数据值的空间。</P><P><CODE CLASS="FUNCTION">pg_total_relation_size</CODE>接受一个表或压缩表的OID或名字，
并且返回那个表使用的总的在磁盘上的空间，包括所有相关的索引。
这个函数相当于<CODE CLASS="FUNCTION">pg_table_size</CODE>
<TT CLASS="LITERAL">+</TT> <CODE CLASS="FUNCTION">pg_indexes_size</CODE></P><P><CODE CLASS="FUNCTION">pg_table_size</CODE>接受一个表的OID或名字，并且返回那个表需要的磁盘空间，
不包括索引。（包含TOAST空间，自由空间映射和可见性映射）</P><P><CODE CLASS="FUNCTION">pg_indexes_size</CODE>接受一个表的OID或名字，
并且返回所有附加到这个表上的索引使用的总的磁盘空间。</P><P><CODE CLASS="FUNCTION">pg_database_size</CODE>和<CODE CLASS="FUNCTION">pg_tablespace_size</CODE>
接受一个数据库或表空间的OID或名字，并且返回该对象使用的总的磁盘空间。</P><P><CODE CLASS="FUNCTION">pg_relation_size</CODE>接受一个表、索引、压缩表的 OID 或者名字，
然后返回它们以字节计的磁盘大小。指定<TT CLASS="LITERAL">'main'</TT>
或省略第二个参数返回这个关系的主数据支路的大小。指定<TT CLASS="LITERAL">'fsm'</TT>
返回和这个关系有关的自由空间映射（参阅<A HREF="storage-fsm.html">第 58.3 &#33410;</A>）的大小。
指定<TT CLASS="LITERAL">'vm'</TT>返回和这个关系有关的可见性映射
（参阅<A HREF="storage-vm.html">第 58.4 &#33410;</A>）的大小。请注意，这个函数只显示一个支路的大小；
更多的是想更方便的使用高级函数<CODE CLASS="FUNCTION">pg_total_relation_size</CODE>或<CODE CLASS="FUNCTION">pg_table_size</CODE>。</P><P><CODE CLASS="FUNCTION">pg_size_pretty</CODE>用于把其它函数的结果格式化成一种人类易读的格式，
可以根据情况使用KB 、MB 、GB 、TB 。</P><P>以上操作在表或索引上的函数接受一个<TT CLASS="TYPE">regclass</TT>参数，这个参数简单的是表的OID
或<TT CLASS="STRUCTNAME">pg_class</TT>系统目录中的索引。你不需要手动的去查看OID，
因为<TT CLASS="TYPE">regclass</TT>数据类型的输入转换将为你做这件事。只需要写下包含在单引号中的表名，
这样看起来像是一个字符串常量。为了与普通的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>名字的处理兼容，
这个字符串将被转换成小写，除非表名用双引号括起。</P><P>如果一个不代表活动对象的OID传递给以上一个函数的参数，那么返回NULL。</P><P><A HREF="functions-admin.html#FUNCTIONS-ADMIN-DBLOCATION">&#34920; 9-65</A>里显示的函数帮助标识指定的与数据库对象有关的磁盘文件。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-ADMIN-DBLOCATION"></A><P><B>&#34920; 9-65. 数据库对象位置函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_relation_filenode(<TT CLASS="PARAMETER">relation</TT> <TT CLASS="TYPE">regclass</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">oid</TT></TD><TD> 指定关系的文件节点数
</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_relation_filepath(<TT CLASS="PARAMETER">relation</TT> <TT CLASS="TYPE">regclass</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD> 指定关系的文件路径名
</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">pg_relation_filenode</CODE>接受一个表、索引、序列或压缩表的OID或者名字，
并且返回当前分配给它的<SPAN CLASS="QUOTE">"filenode"</SPAN>数。文件节点是关系使用的文件名字的基本组件
（参阅<A HREF="storage-file-layout.html">第 58.1 &#33410;</A>获取更多信息）。对大多数表来说，
结果和<TT CLASS="STRUCTNAME">pg_class</TT>.<TT CLASS="STRUCTFIELD">relfilenode</TT>相同，但对确定的系统目录来说，
<TT CLASS="STRUCTFIELD">relfilenode</TT>为0而且这个函数必须用来获取正确的值。
如果传递一个没有存储的关系，比如一个视图，那么这个函数返回NULL。</P><P><CODE CLASS="FUNCTION">pg_relation_filepath</CODE>类似于<CODE CLASS="FUNCTION">pg_relation_filenode</CODE>，
但是它返回关系的整个文件路径名（相对于数据库集群的数据目录<TT CLASS="VARNAME">PGDATA</TT>）。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-ADMIN-GENFILE">9.26.7. 通用文件访问函数</A></H2><P><A HREF="functions-admin.html#FUNCTIONS-ADMIN-GENFILE-TABLE">&#34920; 9-66</A>
里的函数提供了对数据库服务器所在机器上的文件的本地访问接口。
只有那些在数据库集群目录和<TT CLASS="VARNAME">log_directory</TT>目录里面的文件可以访问。
使用相对路径访问集群目录里面的文件，以及匹配<TT CLASS="VARNAME">log_directory</TT>
配置设置的路径访问日志文件。只有超级用户才能使用这些函数。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-ADMIN-GENFILE-TABLE"></A><P><B>&#34920; 9-66. 通用文件访问函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_ls_dir(<TT CLASS="PARAMETER">dirname</TT> <TT CLASS="TYPE">text</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">setof text</TT></TD><TD>列出目录中的文件</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_read_file(<TT CLASS="PARAMETER">filename</TT> <TT CLASS="TYPE">text</TT> [, <TT CLASS="PARAMETER">offset</TT> <TT CLASS="TYPE">bigint</TT>, <TT CLASS="PARAMETER">length</TT> <TT CLASS="TYPE">bigint</TT>])</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>返回一个文本文件的内容</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_read_binary_file(<TT CLASS="PARAMETER">filename</TT> <TT CLASS="TYPE">text</TT> [, <TT CLASS="PARAMETER">offset</TT> <TT CLASS="TYPE">bigint</TT>, <TT CLASS="PARAMETER">length</TT> <TT CLASS="TYPE">bigint</TT>])</CODE></TT>
</TD><TD><TT CLASS="TYPE">bytea</TT></TD><TD>返回一个文件的内容</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_file(<TT CLASS="PARAMETER">filename</TT> <TT CLASS="TYPE">text</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">record</TT></TD><TD>返回一个文件的信息</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">pg_ls_dir</CODE>返回指定目录里面的除了特殊项<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">.</TT>"</SPAN>
和<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">..</TT>"</SPAN>之外的所有名字。</P><P><CODE CLASS="FUNCTION">pg_read_file</CODE>返回一个文本文件的一部分，从<TT CLASS="PARAMETER">offset</TT>开始，
返回最多<TT CLASS="PARAMETER">length</TT>字节(如果先达到文件结尾，则小于这个数值)。
如果<TT CLASS="PARAMETER">offset</TT>是负数，那么它就是相对于文件结尾回退的长度。
如果省略了<TT CLASS="PARAMETER">offset</TT>和<TT CLASS="PARAMETER">length</TT>，则返回整个文件。
从文件读取到的字节在服务器编码里被解释为一个字符串；
如果它们在那种编码下是不可用的则抛出一个错误。</P><P>
<CODE CLASS="FUNCTION">pg_read_binary_file</CODE>类似于<CODE CLASS="FUNCTION">pg_read_file</CODE>，
除了结果是<TT CLASS="TYPE">bytea</TT>值；因此，不执行编码检查。
与<CODE CLASS="FUNCTION">convert_from</CODE>函数结合，这个函数可以用来读取用指定编码的一个文件。
</P><PRE CLASS="PROGRAMLISTING">SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');</PRE><P>
</P><P>
<CODE CLASS="FUNCTION">pg_stat_file</CODE>返回一个记录，这个记录包含文件大小，
最后访问的时间戳，最后修改的时间戳，最后文件状态改变的时间戳（只在Unix平台上），
文件创建的时间戳（只在Windows），和一个<TT CLASS="TYPE">boolean</TT>表明是否为一个路径。
典型的用法包括：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-ADVISORY-LOCKS">9.26.8. 咨询锁函数</A></H2><P><A HREF="functions-admin.html#FUNCTIONS-ADVISORY-LOCKS-TABLE">&#34920; 9-67</A>中的函数用于管理咨询锁(Advisory Lock)。
有关正确使用这些函数的细节，参阅<A HREF="explicit-locking.html#ADVISORY-LOCKS">第 13.3.4 &#33410;</A>。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-ADVISORY-LOCKS-TABLE"></A><P><B>&#34920; 9-67. 咨询锁函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_lock(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取排他会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_lock(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取排他会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_lock_shared(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取共享会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_lock_shared(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取共享会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_unlock(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>释放一个排他会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_unlock(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>释放一个排他会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_unlock_all()</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>释放所有当前会话持有的会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_unlock_shared(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>释放一个共享会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_unlock_shared(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>释放一个共享会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_xact_lock(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取排他事务级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_xact_lock(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取排他事务级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_xact_lock_shared(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取共享事务级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_advisory_xact_lock_shared(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">void</TT></TD><TD>获取共享事务级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_lock(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取排他会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_lock(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取排他会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_lock_shared(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取共享会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_lock_shared(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取共享会话级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_xact_lock(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取排他事务级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_xact_lock(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取排他事务级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_xact_lock_shared(<TT CLASS="PARAMETER">key</TT> <TT CLASS="TYPE">bigint</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取共享事务级别咨询锁</TD></TR><TR><TD> <TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_try_advisory_xact_lock_shared(<TT CLASS="PARAMETER">key1</TT> <TT CLASS="TYPE">int</TT>, <TT CLASS="PARAMETER">key2</TT> <TT CLASS="TYPE">int</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>尝试获取共享事务级别咨询锁</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">pg_advisory_lock</CODE>锁定一个应用程序定义的资源，
该资源可以用一个 64 位或两个不重叠的 32 位键值标识。如果已经有另外的会话锁定了该资源，
那么该函数将会阻塞到该资源可用为止。这个锁是排它的。多个锁定请求将会被压入栈中，因此，
如果同一个资源被锁定了三次，那么它必须被解锁三次以将资源释放给其它会话使用。</P><P><CODE CLASS="FUNCTION">pg_advisory_lock_shared</CODE>类似于<CODE CLASS="FUNCTION">pg_advisory_lock</CODE>，
不同之处仅在于共享锁可以和其它请求共享锁的会话共享，但排他锁除外。</P><P><CODE CLASS="FUNCTION">pg_try_advisory_lock</CODE>类似于<CODE CLASS="FUNCTION">pg_advisory_lock</CODE>，
不同之处在于该函数不会阻塞以等待资源的释放。它要么立即获得锁并返回<TT CLASS="LITERAL">true</TT>，
要么返回<TT CLASS="LITERAL">false</TT>表示目前不能锁定。</P><P><CODE CLASS="FUNCTION">pg_try_advisory_lock_shared</CODE>类似于<CODE CLASS="FUNCTION">pg_try_advisory_lock</CODE>，
不同之处在于该函数尝试获得一个共享锁而不是一个排它锁。</P><P><CODE CLASS="FUNCTION">pg_advisory_unlock</CODE>释放先前取得的排他会话级别咨询锁。
如果释放成功则返回<TT CLASS="LITERAL">true</TT>。如果指定的锁并未持有，
那么它将返回<TT CLASS="LITERAL">false</TT>并且服务器会报告一条 SQL 警告信息。</P><P><CODE CLASS="FUNCTION">pg_advisory_unlock_shared</CODE>类似于<CODE CLASS="FUNCTION">pg_advisory_unlock</CODE>，
不同之处在于该函数释放的是共享会话级别咨询锁。</P><P><CODE CLASS="FUNCTION">pg_advisory_unlock_all</CODE>将会释放当前会话持有的所有会话级别咨询锁，
该函数在会话结束的时候被隐含调用，即使客户端异常地断开连接也是一样。</P><P><CODE CLASS="FUNCTION">pg_advisory_xact_lock</CODE>类似于<CODE CLASS="FUNCTION">pg_advisory_lock</CODE>，
不同之处在于锁是自动在当前事务的结束释放的，而且不能被显式的释放。</P><P><CODE CLASS="FUNCTION">pg_advisory_xact_lock_shared</CODE>类似于 <CODE CLASS="FUNCTION">pg_advisory_lock_shared</CODE>，
不同之处在于锁是自动在当前事务的结束释放的，而且不能被显式的释放。</P><P><CODE CLASS="FUNCTION">pg_try_advisory_xact_lock</CODE>类似于<CODE CLASS="FUNCTION">pg_try_advisory_lock</CODE>，
不同之处在于锁，如果得到，是自动在当前事务的结束释放的，而且不能被显式的释放。</P><P><CODE CLASS="FUNCTION">pg_try_advisory_xact_lock_shared</CODE>类似于<CODE CLASS="FUNCTION">pg_try_advisory_lock_shared</CODE>，
不同之处在于锁，如果得到，是自动在当前事务的结束释放的，而且不能被显式的释放。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="functions-info.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="functions-trigger.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">系统信息函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">触发器函数</TD></TR></TABLE></DIV></BODY></HTML>
