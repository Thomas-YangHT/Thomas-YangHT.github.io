<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>词法结构</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL语法" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html"><LINK REL="PREVIOUS" TITLE="SQL语法" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html"><LINK REL="NEXT" TITLE="值表达式" HREF="sql-expressions.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/syntax.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="SQL语法" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 4. SQL语法</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="值表达式" HREF="sql-expressions.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="SQL-SYNTAX-LEXICAL">4.1. 词法结构</A></H1><P>SQL 输入由一系列<I CLASS="FIRSTTERM">命令</I>组成。一条命令由一系列<I CLASS="FIRSTTERM">记号</I>
构成，用一个分号(<SPAN CLASS="QUOTE">";"</SPAN>)结尾。输入流的终止也结束一条命令。
哪些记号是合法的取决于特定命令的语法。 </P><P>记号可以是一个<I CLASS="FIRSTTERM">关键字</I>、<I CLASS="FIRSTTERM">标识符</I>、
<I CLASS="FIRSTTERM">引号包围的标识符</I>、<I CLASS="FIRSTTERM">文本</I>(或常量)、
特殊的字符符号。记号通常由空白分隔(空格/tab/换行符)，
但如果不存在混淆的时候也可以不用(通常只是一个特殊字符与一些其它记号类型相连的时候)。</P><P>
比如，下列命令是(语法上)合法的 SQL 输入：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');</PRE><P>
这里是三条命令的序列，每条一行(尽管并不要求这么做；多条命令可以在一行里，
单条命令也可以合理地分裂成多行)。
</P><P>另外，在 SQL 输入里可以有<I CLASS="FIRSTTERM">注释</I>。它们不是记号，它们实际上等效于空白。 </P><P>如果从哪些记号标识命令、哪些是操作数或参数的角度考虑，SQL 语法并不是非常一致。
通常头几个记号是命令名字，因此上面的例子我们通常可以说是一个<SPAN CLASS="QUOTE">"SELECT"</SPAN>、
一个<SPAN CLASS="QUOTE">"UPDATE"</SPAN>、和一个<SPAN CLASS="QUOTE">"INSERT"</SPAN>命令。不过，<TT CLASS="COMMAND">UPDATE</TT>
命令总是要求一个<TT CLASS="TOKEN">SET</TT>在某个位置出现，并且这个特定的<TT CLASS="COMMAND">INSERT</TT>
还要求有一个<TT CLASS="TOKEN">VALUES</TT>才完整。每条命令的准确语法规则都在<A HREF="http://school.yunwei.edu/manual/PostgreSQL/reference.html">第 VI &#37096;&#20998;</A>里描述。 </P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-IDENTIFIERS">4.1.1. 标识符和关键字</A></H2><P>像上面例子里的<TT CLASS="TOKEN">SELECT</TT>，<TT CLASS="TOKEN">UPDATE</TT>或<TT CLASS="TOKEN">VALUES</TT>
这样的记号都是<I CLASS="FIRSTTERM">关键字</I>的例子，也就是那些在 SQL
语言里有固定含义的单词。记号<TT CLASS="TOKEN">MY_TABLE</TT>和<TT CLASS="TOKEN">A</TT>
是<I CLASS="FIRSTTERM">标识符</I>的例子。根据使用它们的命令的不同，
它们标识表、字段、或者其它数据库对象的名字。因此，有时候只是简单地叫它们
<SPAN CLASS="QUOTE">"名字"</SPAN>。关键字和标识符有着同样的词法结构，
意思是我们在没有认识这种语言之前是无法区分一个记号是标识符还是名字。
你可以在<A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-keywords-appendix.html">&#38468;&#24405; C</A>里找到一个关键字的完整列表。</P><P>SQL 标识符和关键字必须以一个字母(<TT CLASS="LITERAL">a</TT>-<TT CLASS="LITERAL">z</TT>
以及带变音符的字母和非拉丁字母)或下划线(<TT CLASS="LITERAL">_</TT>)开头，
随后的字符可以是字母、下划线、数字(<TT CLASS="LITERAL">0</TT>-<TT CLASS="LITERAL">9</TT>)、
美元符号(<TT CLASS="LITERAL">$</TT>)。需要注意的是，根据 SQL 标准，美元符号不允许出现在标识符中，
因此使用美元符号将不易移植。SQL 标准不会定义包含数字或者以下划线开头或结尾的关键字，
因此按照这种格式定义的标识符是安全的，不会和将来标准的扩展特性冲突。</P><P>&#13;系统使用不超过<TT CLASS="SYMBOL">NAMEDATALEN</TT>-1 个字符作为标识符；
你可以在命令中写更长的名字，但它们会被截断。<TT CLASS="SYMBOL">NAMEDATALEN</TT>的缺省值是 64 ，
因此标识符最大长度是 63 字节。如果觉得这个限制有问题，那么你可以在
<TT CLASS="FILENAME">src/include/pg_config_manual.h</TT>里修改<TT CLASS="SYMBOL">NAMEDATALEN</TT>来改变它。 </P><P>
关键字和未被引号包围的标识符都是大小写无关的。因此：
</P><PRE CLASS="PROGRAMLISTING">UPDATE MY_TABLE SET A = 5;</PRE><P>
也可以等效地写成：
</P><PRE CLASS="PROGRAMLISTING">uPDaTE my_TabLE SeT a = 5;</PRE><P>
一种好习惯是把关键字写成大写，而名字等用小写：
</P><PRE CLASS="PROGRAMLISTING">UPDATE my_table SET a = 5;</PRE><P>
</P><P>
还有第二种标识符：<I CLASS="FIRSTTERM">分隔标识符</I>或 <I CLASS="FIRSTTERM">引号包围的标识符</I>。
它是通过在双引号(<TT CLASS="LITERAL">"</TT>)中包围任意字符序列形成的。
分隔标识符总是一个标识符，而不是关键字。因此，你可以用<TT CLASS="LITERAL">"select"</TT>
表示一个字段或者表的名字，而一个没有引号的<TT CLASS="LITERAL">select</TT>
将被当做一条命令的一部分，因此如果把它当做一个表名或者字段名使用的话就会产生一个分析错误。
上面的例子可以用引号包围的标识符这么写：
</P><PRE CLASS="PROGRAMLISTING">UPDATE "my_table" SET "a" = 5;</PRE><P>
</P><P>引号包围的标识符可以包含编码不等于零的任意字符(要包含一个双引号，可以写两个相连的双引号)。
这样我们就可以构造那些原本是不允许的表名或者字段名，比如那些包含空白或与号(&#38;)的名字。
但长度限制依旧。</P><P>
一个带引号的标识符的变形允许带有代码点标记的转义Unicode字符。
该变形以<TT CLASS="LITERAL">U&amp;</TT>开始（大/小写U后跟有&amp;符号）紧跟着打开的双引号，
之间没有空格，例如<TT CLASS="LITERAL">U&amp;"foo"</TT>。（需要注意的是，
这可能产生和操作符<TT CLASS="LITERAL">&amp;</TT>之间的歧义。可以在操作符周围加上空格来避免该问题。）
在引号中，通过写一个后面跟有反斜杠和四位十六进制代码点或跟有反斜杠和加号和六位十六进制代码点，
Unicode字符可以写成转义格式。 例如，<TT CLASS="LITERAL">"data"</TT>可以写成：
</P><PRE CLASS="PROGRAMLISTING">U&amp;"d\0061t\+000061"</PRE><P>
下例以西里尔字母写俄文<SPAN CLASS="QUOTE">"slon"</SPAN>（象）。
</P><PRE CLASS="PROGRAMLISTING">U&amp;"\0441\043B\043E\043D"</PRE><P>
</P><P>
如果需要一个非反斜杠的不同的转义，可以通过在字符串之后使用<TT CLASS="LITERAL">UESCAPE</TT>
语句来进行声明，如：
</P><PRE CLASS="PROGRAMLISTING">U&amp;"d!0061t!+000061" UESCAPE '!'</PRE><P>
转义字符可以是一个十六进制数字以外的任何单个字符，加号，一个单引号，一个双引号，
或一个空白字符。需要注意的是，转义字符是写在单引号中，而不是双引号中。
</P><P>为了将转义字符写到标识符中，可以将它写两次。 </P><P>只有服务器字符集是<TT CLASS="LITERAL">UTF8</TT>时，才会完全使用Unicode转义语法。
当使用其他服务器字符集时，只有在ASCII内的（最多<TT CLASS="LITERAL">\007F</TT>）代码点可以被声明。
4位和6位的数字形式可以被用来将UTF-16代理对声明为大于U+FFFF的带有代码点的字符，
尽管6位数字形式技术的可用性使得这样做没有必要。（代理对不是直接存储的，
首先，它们结合成一个单一的代码点，然后再用UTF-8编码。） </P><P>
把一个标识符用引号包围起来同时也令它大小写相关，而没有引号包围起来的名字总是转成小写。
比如，我们认为标识符<TT CLASS="LITERAL">FOO</TT>，<TT CLASS="LITERAL">foo</TT>和<TT CLASS="LITERAL">"foo"</TT>
是等价的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>名字，但<TT CLASS="LITERAL">"Foo"</TT>和<TT CLASS="LITERAL">"FOO"</TT>
与上面三个以及它们之间都是不同的。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里对未加引号的名子总是转换成小写，
这和 SQL 标准是不兼容的，SQL 标准要求未用引号包围起来的名字总是转成大写。因此根据标准，
<TT CLASS="LITERAL">foo</TT>等于<TT CLASS="LITERAL">"FOO"</TT>但不等于<TT CLASS="LITERAL">"foo"</TT> 。
如果你想编写可移植的程序，那么我们建议你要么就总是用引号包围某个名字，要么就从来不引。 </P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-CONSTANTS">4.1.2. 常量</A></H2><P>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里有三种<I CLASS="FIRSTTERM">隐含类型的常量</I>：
字符串、位串、数值。常量也可以声明为明确的类型，
这样就可以使用更准确的表现形式以及可以被系统更有效地处理。这些将在后面的小节描述。</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SQL-SYNTAX-STRINGS">4.1.2.1. 字符串常量</A></H3><P>
SQL 里的一个文本常量是用单引号(<TT CLASS="LITERAL">'</TT>)包围的任意字符序列，
比如<TT CLASS="LITERAL">'This is a string'</TT> 。
在这种类型的字符串常量里嵌入单引号的标准兼容的做法是敲入两个连续的单引号，
比如<TT CLASS="LITERAL">'Dianne''s horse'</TT>。注意：两个连续的单引号<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不是</I></SPAN>双引号(<TT CLASS="LITERAL">"</TT>)。
</P><P>
两个只是通过<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">至少一个换行符</I></SPAN>的空白分隔的字符串常量会被连接在一起，
并当做它们是写成一个常量处理。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'foo'
'bar';</PRE><P>
等效于：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'foobar';</PRE><P>
但：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'foo'      'bar';</PRE><P>
是非法的语法。这个怪异的行为是<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>声明的，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>遵循标准。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SQL-SYNTAX-STRINGS-ESCAPE">4.1.2.2. C风格的转义字符串常量</A></H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>还允许<SPAN CLASS="QUOTE">"转义"</SPAN>字符串中的内容，
这是一个PostgreSQL对SQL标准的扩展。转义字符串语法是通过在字符串前写字母<TT CLASS="LITERAL">E</TT>
(大写或者小写)的方法声明的。比如<TT CLASS="LITERAL">E'foo'</TT>。（当需要续行包含转义字符的字符串时，
仅需要在第一行的开始引号前写上<TT CLASS="LITERAL">E</TT>就可以了。）在转义字符串中，
通过一个反斜杠(<TT CLASS="LITERAL">\</TT>)开始C风格的<I CLASS="FIRSTTERM">反斜杠转义</I>序列，在该转义中，
反斜杠与其之后字符的组合代表一个特殊的字节值，可参阅<A HREF="sql-syntax-lexical.html#SQL-BACKSLASH-TABLE">&#34920; 4-1</A>。 </P><DIV CLASS="TABLE"><A NAME="SQL-BACKSLASH-TABLE"></A><P><B>&#34920; 4-1. 反斜杠转义序列</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>反斜杠转义序列</TH><TH>解释</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">\b</TT></TD><TD>退格</TD></TR><TR><TD><TT CLASS="LITERAL">\f</TT></TD><TD>进纸</TD></TR><TR><TD><TT CLASS="LITERAL">\n</TT></TD><TD>换行</TD></TR><TR><TD><TT CLASS="LITERAL">\r</TT></TD><TD>回车</TD></TR><TR><TD><TT CLASS="LITERAL">\t</TT></TD><TD>水平制表符</TD></TR><TR><TD> <TT CLASS="LITERAL">\<TT CLASS="REPLACEABLE"><I>o</I></TT></TT>,
<TT CLASS="LITERAL">\<TT CLASS="REPLACEABLE"><I>oo</I></TT></TT>,
<TT CLASS="LITERAL">\<TT CLASS="REPLACEABLE"><I>ooo</I></TT></TT>
(<TT CLASS="REPLACEABLE"><I>o</I></TT> = 0 - 7)
</TD><TD>八进制字节值</TD></TR><TR><TD> <TT CLASS="LITERAL">\x<TT CLASS="REPLACEABLE"><I>h</I></TT></TT>,
<TT CLASS="LITERAL">\x<TT CLASS="REPLACEABLE"><I>hh</I></TT></TT>
(<TT CLASS="REPLACEABLE"><I>h</I></TT> = 0 - 9, A - F)
</TD><TD>十六进制字节值</TD></TR><TR><TD> <TT CLASS="LITERAL">\u<TT CLASS="REPLACEABLE"><I>xxxx</I></TT></TT>,
<TT CLASS="LITERAL">\U<TT CLASS="REPLACEABLE"><I>xxxxxxxx</I></TT></TT>
(<TT CLASS="REPLACEABLE"><I>x</I></TT> = 0 - 9, A - F)
</TD><TD>16或32位十六进制Unicode字符值</TD></TR></TBODY></TABLE></DIV><P>
任何其它跟在反斜杠后面的字符都当做文本看待。因此，要在字符串常量里包含反斜杠，
则写两个反斜杠(<TT CLASS="LITERAL">\\</TT>)。另外，PostgreSQL 允许用一个反斜杠来转义单引号<TT CLASS="LITERAL">\'</TT>，
不过，将来版本 的 PostgreSQL 将不允许这么用。所以最好坚持使用符合标准的<TT CLASS="LITERAL">''</TT>。
</P><P>你有必要为你所创建的字节序列（特别是在使用八进制或十六进制转义时）编写有效的服务器字符集编码字符。
当服务器编码是UTF-8时，应该使用Unicode转义或另一种Unicode转义语法（参阅<A HREF="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE">第 4.1.2.3 &#33410;</A>）。
（后者通过写出字节来处理UTF-8字符集，这样做是很繁琐的）。</P><P>只有服务器字符集是<TT CLASS="LITERAL">UTF8</TT>时，才会完全使用Unicode转义语法。
当使用其他服务器字符集时，只有在ASCII内的（最多<TT CLASS="LITERAL">\u007F</TT>）代码点可以被声明。
4位和8位的数字形式可以被用来将UTF-16代理对声明为大于U+FFFF的带有代码点的字符，
尽管8位数字形式技术的可用性使得这样做没有必要。（当服务器编码是<TT CLASS="LITERAL">UTF8</TT>时使用代理对，
首先，它们结合成一个单一的代码点，然后再用UTF-8编码）</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P>如果配置参数<A HREF="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</A>的值是<TT CLASS="LITERAL">off</TT>，
那么<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将能够识别常规和转义字符串常量中的反斜杠转义。
然而，在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>9.1中，参数值默认为<TT CLASS="LITERAL">on</TT>，这意味着反斜杠转义只能在转义字符串常量中识别。
这个行为更为标准兼容，但是可能会使依赖于历史行为的应用程序崩溃，因为历史行为中反斜杠转义总是能被识别。
作为一个变通方案，你可以设置这个参数为<TT CLASS="LITERAL">off</TT>，但是最好是不使用反斜杠转义。如果你需要使用反斜杠转义来表示特殊的字符，
那么请在字符串常量前加上<TT CLASS="LITERAL">E</TT>。</P><P>除<TT CLASS="VARNAME">standard_conforming_strings</TT>之外，<A HREF="runtime-config-compatible.html#GUC-ESCAPE-STRING-WARNING">escape_string_warning</A>
和<A HREF="runtime-config-compatible.html#GUC-BACKSLASH-QUOTE">backslash_quote</A>配置参数也影响字符串常量中反斜杠的处理。</P></TD></TR></TABLE></DIV><P>编码为零的字符不允许出现在字符串常量中。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SQL-SYNTAX-STRINGS-UESCAPE">4.1.2.3. Unicode转义字符串常量</A></H3><P>
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>也支持其他类型的字符串转义语法，
允许声明任意的带有代码点标记的Unicode字符。一个转义Unicode字符常量以
<TT CLASS="LITERAL">U&amp;</TT>开始（大/小写U后紧跟有&amp;符号）紧跟着打开的单引号，
之间没有空格，例如<TT CLASS="LITERAL">U&amp;'foo'</TT>。（这可能产生和操作符<TT CLASS="LITERAL">&amp;</TT>
之间的歧义。可以在操作符周围加上空格来避免该问题。）在引号中，
通过写一个后面跟有四位十六进制代码点或跟有加号和六位十六进制代码点的反斜杠，
Unicode字符可以写成转义格式。例如，<TT CLASS="LITERAL">'data'</TT>可以写成：
</P><PRE CLASS="PROGRAMLISTING">U&amp;'d\0061t\+000061'</PRE><P>
下例以西里尔字母写俄文<SPAN CLASS="QUOTE">"slon"</SPAN>（象）。
</P><PRE CLASS="PROGRAMLISTING">U&amp;'\0441\043B\043E\043D'</PRE><P>
</P><P>
如果需要一个非反斜杠的不同的转义，可以通过在字符串之后使用
<TT CLASS="LITERAL">UESCAPE</TT>语句来进行声明，如：
</P><PRE CLASS="PROGRAMLISTING">U&amp;'d!0061t!+000061' UESCAPE '!'</PRE><P>
转义字符可以是一个十六进制数字以外的任何单个字符，加号，一个单引号，
一个双引号，或一个空白字符。
</P><P>只有服务器字符集是<TT CLASS="LITERAL">UTF8</TT>时，才会完全使用Unicode转义语法。
当使用其他服务器字符集时，只有在ASCII内的（最多<TT CLASS="LITERAL">\007F</TT>）代码点可以被声明。
4位和6位的数字形式可以被用来将UTF-16代理对声明为大于U+FFFF的带有代码点的字符，
尽管6位数字形式技术的可用性使得这样做没有必要。（当服务器编码是<TT CLASS="LITERAL">UTF8</TT>时使用代理对，
首先，它们结合成一个单一的代码点，然后再用UTF-8编码。） </P><P>同样，字符串常量的Unicode转义语法只有当配置参数<A HREF="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</A>
启用时才能生效。否则，该语法在解析SQL语法时给客户端造成混淆，导致SQL注入或其他安全问题。
如果该参数设为OFF，该语法会带着一条错误消息一起被拒绝。 </P><P>为了将转义字符写到字符串中，可以将它写两次。 </P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SQL-SYNTAX-DOLLAR-QUOTING">4.1.2.4. 美元符引用字符串常量</A></H3><P>
尽管声明字符串常量的标准方法通常都很方便，但是如果字符串中包含很多单引号或者反斜杠，
那么理解字符串的内容可能就会变得很苦涩，因为每个单引号都要加倍。
为了让这种场合下的查询更具可读性，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许另外一种称作
<SPAN CLASS="QUOTE">"美元符引用"</SPAN>的字符串常量书写办法。一个通过美元符引用声明的字符串常量由一个美元符号
(<TT CLASS="LITERAL">$</TT>)、零个或多个字符组成的<SPAN CLASS="QUOTE">"标签"</SPAN>、另一个美元符号、
组成字符串常量的任意字符序列、一个美元符号、与前面相同的标签、一个美元符号组成的。
比如，下面是两个不同的用美元符引用的方法声明<SPAN CLASS="QUOTE">"Dianne's horse"</SPAN>的例子：
</P><PRE CLASS="PROGRAMLISTING">$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$</PRE><P>
请注意，在美元符引用的字符串里，单引号不允许转义。实际上，在一个美元符引用的字符串里，
不允许转义任何字符：字符串内容总是按照字面内容书写。反斜杠不是特殊的、
美元符自己也不是特殊的(除非它们和开标签的一部分匹配)。
</P><P>
我们可以通过在不同嵌套级别使用不同的"标签"来实现嵌套。最常见的是写函数定义的时候。比如：
</P><PRE CLASS="PROGRAMLISTING">$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$</PRE><P>
这里，序列<TT CLASS="LITERAL">$q$[\t\r\n\v\\]$q$</TT>表示一个美元符引用的字符串文本<TT CLASS="LITERAL">[\t\r\n\v\\]</TT>，
在函数体被<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>执行的时候，它将被识别出来。
但是因为这个序列不匹配外层的美元符引用分隔符<TT CLASS="LITERAL">$function$</TT> ，所以只要考虑了外层字符串，
它就只是常量里面的普通字符而已。
</P><P>一个美元符引用字符串的标签(如果有标签的话),遵循和无引号包围的标识符相同的规则，
只是它不能包含美元符。标签是大小写敏感的，因此<TT CLASS="LITERAL">$tag$String content$tag$</TT>
是正确的，而<TT CLASS="LITERAL">$TAG$String content$tag$</TT>则是错误的。</P><P>一个后面紧跟着关键字或者标识符的美元符引用字符串必须用空白与其后的关键字或者标识符隔开；
否则美元符引用分隔符将会被当作标识符的开头部分。</P><P>美元符引用不是 SQL 标准，但是在写复杂的字符串文本的时候，它通常比标准的单引号语法更方便。
尤其是在其它常量里表现字符串常量的时候更有用，比如在过程函数定义里。如果用单引号语法，
每个上面例子里的每个反斜杠都必须写四个，它们在作为字符串文本分析的时候会减少为两个，
然后在函数执行的时候在内层字符串常量里会再次被解析为一个。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SQL-SYNTAX-BIT-STRINGS">4.1.2.5. 位串常量</A></H3><P>位串常量看起来很像在开引号前面有一个<TT CLASS="LITERAL">B</TT>(大写或小写)的普通字符串
(它们之间没有空白)，比如<TT CLASS="LITERAL">B'1001'</TT>。位串常量里可以用的字符只有<TT CLASS="LITERAL">0</TT>
和<TT CLASS="LITERAL">1</TT>。</P><P>另外，位串常量可以用十六进制表示法声明，方法是使用前缀<TT CLASS="LITERAL">X</TT>(大写或者小写)，
比如<TT CLASS="LITERAL">X'1FF'</TT>，其中的每个十六进制位等效于四个二进制位。</P><P>两种形式的位串常量都可以像普通字符串常量那样跨行连续。位串常量不能用美元符引用。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SQL-SYNTAX-CONSTANTS-NUMERIC">4.1.2.6. 数值常量</A></H3><P>
数值常量接受下列通用的形式：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>
<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>.[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>][<SPAN
CLASS="OPTIONAL"
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>]
[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>].<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>[<SPAN
CLASS="OPTIONAL"
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>]
<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>digits</I></TT>是一个或多个十进制数字(0-9)。
如果有小数点，那么至少有一位在小数点前面或后面。
如果出现了指数标记(<TT CLASS="LITERAL">e</TT>)那么至少有一个数字跟在它后面。
在常量里不能有空格或者其它字符。请注意任何前导正号或负号实际上都不认为是常量的一部分；
它是施加于常量的一个操作符。
</P><P>
这里是一些合法的数值常量的例子：
<P CLASS="LITERALLAYOUT">42<br>
3.5<br>
4.<br>
.001<br>
5e2<br>
1.925e-3</P>
</P><P>&#13;
如果一个数值常量既不包含小数点，也不包含指数，
那么如果它的数值可以放在<TT CLASS="TYPE">integer</TT>类型中(32位)，则认为它是<TT CLASS="TYPE">integer</TT>类型；
如果它的数值可以放在<TT CLASS="TYPE">bigint</TT>中(64位)，则认为它是<TT CLASS="TYPE">bigint</TT>，
否则认为它是<TT CLASS="TYPE">numeric</TT>类型。包含小数点和/或指数的常量总是被认为是
<TT CLASS="TYPE">numeric</TT>类型。 </P><P>
给一个数值常量赋予初始数据类型只是类型解析算法的开端。
在大多数情况下该常量会根据环境被自动强制转换成最合适的类型。
必要时，你可以通过强制类型转换把一个数值解析成特定的数据类型。
比如，你可以强制要求把一个数值当作<TT CLASS="TYPE">real</TT> (<TT CLASS="TYPE">float4</TT>)类型来看，方法是这么写：
</P><PRE CLASS="PROGRAMLISTING">REAL '1.23'  -- 字符串风格
1.23::REAL   -- PostgreSQL (历史的) 风格</PRE><P>
这些实际上只是下面讨论的通用转换的特例。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SQL-SYNTAX-CONSTANTS-GENERIC">4.1.2.7. 其它类型的常量</A></H3><P>
<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">任意</I></SPAN>类型的常量都可以用下列表示法中的任何一种来输入：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'
'<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'::<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>
CAST ( '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>' AS <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> )</PRE><P>
其中字符串常量的文本将会被代入到类型<TT CLASS="REPLACEABLE"><I>type</I></TT>的输入转换过程。其结果是一个该类型的常量。
如果不存在该常量所属类型的歧义，那么可以省略明确的类型转换(比如，当你把它直接赋予一个表字段的时候)，
这种情况下它会自动转换。
</P><P>其中的字符串常量可以用普通 SQL 表示法或者美元符引用来书写。</P><P>
我们还可以用函数风格的语法来声明类型转换：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>typename</I
></TT
> ( '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>' )</PRE><P>
不过并非所有类型名都可以这样使用；参阅<A HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS">第 4.2.9 &#33410;</A>获取细节。
</P><P><TT CLASS="LITERAL">::</TT>，<TT CLASS="LITERAL">CAST()</TT>
和函数调用语法也可以用于声明任意表达式的运行时类型转换(如<A HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS">第 4.2.9 &#33410;</A>
中讨论的那样)。为了避免语法歧义，<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>type</I></TT> '<TT CLASS="REPLACEABLE"><I>string</I></TT>'</TT>
的形式只能用于声明一个简单的字面常量的类型。<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>type</I></TT> '<TT CLASS="REPLACEABLE"><I>string</I></TT>'</TT>
的另外一个限制是它不能用于数组类型(要用<TT CLASS="LITERAL">::</TT>或 <TT CLASS="LITERAL">CAST()</TT>
声明一个数组常量的类型)。</P><P><TT CLASS="LITERAL">CAST()</TT>语法遵循 SQL 标准。<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>type</I></TT> '<TT CLASS="REPLACEABLE"><I>string</I></TT>'</TT>
语法是标准的一个推广：SQL 只是给少数几种数据类型声明了这个语法，但<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
允许将其用于所有类型。<TT CLASS="LITERAL">::</TT>和函数调用的语法是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的历史用法。</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-OPERATORS">4.1.3. 操作符</A></H2><P>
一个操作符是最多 <TT CLASS="SYMBOL">NAMEDATALEN</TT>-1 个(缺省63个)下列字符的序列：
<P CLASS="LITERALLAYOUT">+&nbsp;-&nbsp;*&nbsp;/&nbsp;&lt;&nbsp;&gt;&nbsp;=&nbsp;~&nbsp;!&nbsp;@&nbsp;#&nbsp;%&nbsp;^&nbsp;&amp;&nbsp;|&nbsp;`&nbsp;?</P>
不过，有几个限制：
<P></P></P><UL><LI><P><TT CLASS="LITERAL">--</TT> 和 <TT CLASS="LITERAL">/*</TT>不能出现在操作符中的任何地方，
因为它们会被当做注释开始对待。</P></LI><LI><P>
多字符操作符不能以<TT CLASS="LITERAL">+</TT> 或 <TT CLASS="LITERAL">-</TT>结束，除非其中至少还包含下列操作符之一：
<P CLASS="LITERALLAYOUT">~&nbsp;!&nbsp;@&nbsp;#&nbsp;%&nbsp;^&nbsp;&amp;&nbsp;|&nbsp;`&nbsp;?</P>
比如，<TT CLASS="LITERAL">@-</TT>是允许的操作符，但<TT CLASS="LITERAL">*-</TT>不是。
这个限制允许<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>在不要求记号之间有空白的情况下分析 SQL 兼容的查询。
</P></LI></UL><P>
</P><P>当你使用非 SQL 标准的操作符的时候，你通常需要用空白分隔相邻的操作符以避免歧义。
比如，如果你定义了一个叫<TT CLASS="LITERAL">@</TT>的左单目操作符，那么你就不能写成
<TT CLASS="LITERAL">X*@Y</TT>；而是要写成<TT CLASS="LITERAL">X* @Y</TT>以确保<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
把它读成两个操作符，而不是一个。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-SPECIAL-CHARS">4.1.4. 特殊字符</A></H2><P>
有些非字母数字字符有一些特殊含义，因此不能用做操作符。
它们的用法细节可以在相应的描述语法元素的地方找到。
本节只是描述它们的存在和概括一下这些字符的目的。
<P></P></P><UL><LI><P>
美元符号(<TT CLASS="LITERAL">$</TT>)后面跟着数字用于在一个函数体定义或者预备语句中表示参数的位置。
在其它环境里美元符号可能是一个标识符名字或者是一个美元符引用的字符串常量的一部分。 </P></LI><LI><P>圆括弧(<TT CLASS="LITERAL">()</TT>)用于分组和强制优先级的时候含义与平常一样。
有些场合里圆括弧是作为一个特定 SQL 命令的固定语法的一部分要求的。</P></LI><LI><P>方括弧(<TT CLASS="LITERAL">[]</TT>)用于选取数组元素。参阅<A HREF="arrays.html">第 8.15 &#33410;</A>获取更多信息。</P></LI><LI><P>逗号(<TT CLASS="LITERAL">,</TT>)在一些语法构造里用于分隔一个列表的元素。</P></LI><LI><P>分号(<TT CLASS="LITERAL">;</TT>)结束一条 SQL 命令。它不能出现在一条命令里的任何地方，
除了在引号包围的字符串常量或者标识符中。</P></LI><LI><P>冒号(<TT CLASS="LITERAL">:</TT>)用于从数组中选取<SPAN CLASS="QUOTE">"片段"</SPAN>(参阅
<A HREF="arrays.html">第 8.15 &#33410;</A>)。在一些 SQL 方言里(比如嵌入 SQL)，冒号用于前缀变量名。</P></LI><LI><P>星号(<TT CLASS="LITERAL">*</TT>)在某些环境里表示一个表的全部字段或者一个复合类型的值。
在用作聚合函数的参数时还表示该聚合并不需要明确的参数。</P></LI><LI><P>句点(<TT CLASS="LITERAL">.</TT>)用在数字常量里，并用于分隔模式、表、字段名。</P></LI></UL><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-COMMENTS">4.1.5. 注释</A></H2><P>
注释是任意以双划线开头并延伸到行尾的任意字符序列，比如：
</P><PRE CLASS="PROGRAMLISTING">-- 这是标准的 SQL 注释 </PRE><P>
</P><P>
另外，还可以使用C风格的块注释：
</P><PRE CLASS="PROGRAMLISTING">/* 多行注释
 * 可以嵌套: /* 被嵌套的块注释 */
 */</PRE><P>
这里注释以<TT CLASS="LITERAL">/*</TT>开头并扩展到对应的<TT CLASS="LITERAL">*/</TT>。
这些块注释可以嵌套，就像 SQL标准里说的那样(但和 C 不一样)，
因此我们可以注释掉一大块已经包含块注释的代码。
</P><P>注释在进一步的语法分析之前被从输入流中删除并用空白代替。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-PRECEDENCE">4.1.6. 操作符优先级</A></H2><P>
<A HREF="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE">&#34920; 4-2</A>显示了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
里面的操作符的优先级和关联性。大多数操作符都有相同的优先级并且都是左关联的。
操作符的优先级和关联性是硬连接到解析器的。这种情况可能会有不那么直观的行为；
比如，布尔操作符<TT CLASS="LITERAL">&lt;</TT>和<TT CLASS="LITERAL">&gt;</TT>与布尔操作符<TT CLASS="LITERAL">&lt;=</TT>和
<TT CLASS="LITERAL">&gt;=</TT>之间有着不同的优先级。同样，当你把双目和单目操作符组合使用的时候，
有时候也需要加圆括弧。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT 5 ! - 6;</PRE><P>
会被分析成：
</P><PRE CLASS="PROGRAMLISTING">SELECT 5 ! (- 6);</PRE><P>
因为解析器不知道<TT CLASS="TOKEN">!</TT>被定义成了后缀操作符，而不是中缀操作符
(知道的时候只能是太晚了)。要在本例中获得你需要的特性，你要写成：
</P><PRE CLASS="PROGRAMLISTING">SELECT (5 !) - 6;</PRE><P>
这是我们为扩展性付出的代价。
</P><DIV CLASS="TABLE"><A NAME="SQL-PRECEDENCE-TABLE"></A><P><B>&#34920; 4-2. 操作符优先级(递减)</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>操作符/元素</TH><TH>关联性</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="TOKEN">.</TT></TD><TD>左</TD><TD>表/字段名分隔符</TD></TR><TR><TD><TT CLASS="TOKEN">::</TT></TD><TD>左</TD><TD><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>特有的类型转换操作符</TD></TR><TR><TD><TT CLASS="TOKEN">[</TT> <TT CLASS="TOKEN">]</TT></TD><TD>左</TD><TD>数组元素选择</TD></TR><TR><TD><TT CLASS="TOKEN">+</TT> <TT CLASS="TOKEN">-</TT></TD><TD>右</TD><TD>单目正号，单目负号</TD></TR><TR><TD><TT CLASS="TOKEN">^</TT></TD><TD>左</TD><TD>幂</TD></TR><TR><TD><TT CLASS="TOKEN">*</TT> <TT CLASS="TOKEN">/</TT> <TT CLASS="TOKEN">%</TT></TD><TD>左</TD><TD>乘，除，模</TD></TR><TR><TD><TT CLASS="TOKEN">+</TT> <TT CLASS="TOKEN">-</TT></TD><TD>左</TD><TD>加，减</TD></TR><TR><TD><TT CLASS="TOKEN">IS</TT></TD><TD>&nbsp;</TD><TD><TT CLASS="LITERAL">IS TRUE</TT>, <TT CLASS="LITERAL">IS FALSE</TT>, <TT CLASS="LITERAL">IS NULL</TT>, etc</TD></TR><TR><TD><TT CLASS="TOKEN">ISNULL</TT></TD><TD>&nbsp;</TD><TD>测试是否为NULL</TD></TR><TR><TD><TT CLASS="TOKEN">NOTNULL</TT></TD><TD>&nbsp;</TD><TD>测试是否不为NULL</TD></TR><TR><TD>(任何其他的)</TD><TD>左</TD><TD>所有其他的本地和用户定义操作符</TD></TR><TR><TD><TT CLASS="TOKEN">IN</TT></TD><TD>&nbsp;</TD><TD>集合成员</TD></TR><TR><TD><TT CLASS="TOKEN">BETWEEN</TT></TD><TD>&nbsp;</TD><TD>范围包含</TD></TR><TR><TD><TT CLASS="TOKEN">OVERLAPS</TT></TD><TD>&nbsp;</TD><TD>时间间隔重叠</TD></TR><TR><TD><TT CLASS="TOKEN">LIKE</TT> <TT CLASS="TOKEN">ILIKE</TT> <TT CLASS="TOKEN">SIMILAR</TT></TD><TD>&nbsp;</TD><TD>字符串模式匹配</TD></TR><TR><TD><TT CLASS="TOKEN">&lt;</TT> <TT CLASS="TOKEN">&gt;</TT></TD><TD>&nbsp;</TD><TD>小于，大于</TD></TR><TR><TD><TT CLASS="TOKEN">=</TT></TD><TD>右</TD><TD>等于，赋值</TD></TR><TR><TD><TT CLASS="TOKEN">NOT</TT></TD><TD>右</TD><TD>逻辑非</TD></TR><TR><TD><TT CLASS="TOKEN">AND</TT></TD><TD>左</TD><TD>逻辑与</TD></TR><TR><TD><TT CLASS="TOKEN">OR</TT></TD><TD>左</TD><TD>逻辑或</TD></TR></TBODY></TABLE></DIV><P>请注意操作符优先级也适用于和上面提到的内置操作符同名的用户定义操作符。
比如，如果你为一些客户数据类型定义一个<SPAN CLASS="QUOTE">"+"</SPAN>操作符，
那么它和内置的<SPAN CLASS="QUOTE">"+"</SPAN>操作符有同样的优先级，不管用它来干什么。 </P><P>
如果在<TT CLASS="LITERAL">OPERATOR</TT>语法里使用了模式修饰的操作符名，比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT 3 OPERATOR(pg_catalog.+) 4;</PRE><P>
那么<TT CLASS="LITERAL">OPERATOR</TT>构造就会有<A HREF="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE">&#34920; 4-2</A>
里面为<SPAN CLASS="QUOTE">"任何其它的"</SPAN> 操作符显示的缺省优先级。不管什么特定的操作符出现在
<TT CLASS="LITERAL">OPERATOR()</TT>里都是这样。
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-expressions.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">SQL语法</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">值表达式</TD></TR></TABLE></DIV></BODY></HTML>
