<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>条件表达式</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="函数和操作符" HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html"><LINK REL="PREVIOUS" TITLE="序列操作函数" HREF="functions-sequence.html"><LINK REL="NEXT" TITLE="数组函数和操作符" HREF="functions-array.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/func.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="序列操作函数" HREF="functions-sequence.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 9. 函数和操作符</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="数组函数和操作符" HREF="functions-array.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FUNCTIONS-CONDITIONAL">9.17. 条件表达式</A></H1><P>本节描述在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里可用的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>兼容的条件表达式。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>如果你的需求超过这些条件表达式的能力，你可能会希望用一种更富表现力的编程语言写一个存储过程。</P></BLOCKQUOTE></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-CASE">9.17.1. <TT CLASS="LITERAL">CASE</TT></A></H2><P><TT CLASS="TOKEN">CASE</TT>表达式是一种通用的条件表达式，类似于其它编程语言中的 if/else 语句。
</P><PRE CLASS="SYNOPSIS">CASE WHEN <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> THEN <TT
CLASS="REPLACEABLE"
><I
>result</I
></TT
>
     [<SPAN
CLASS="OPTIONAL"
>WHEN ...</SPAN
>]
     [<SPAN
CLASS="OPTIONAL"
>ELSE <TT
CLASS="REPLACEABLE"
><I
>result</I
></TT
></SPAN
>]
END</PRE><P>
<TT CLASS="TOKEN">CASE</TT>子句可以用于任何表达式可以存在的地方。<TT CLASS="REPLACEABLE"><I>condition</I></TT>
是一个返回<TT CLASS="TYPE">boolean</TT>的表达式。如果条件的结果为真，那么<TT CLASS="TOKEN">CASE</TT>
表达式的结果就是符合条件的<TT CLASS="REPLACEABLE"><I>result</I></TT>，并且不再处理剩余的
<TT CLASS="TOKEN">CASE</TT>表达式。如果条件的结果为假，那么以相同方式搜寻任何随后的<TT CLASS="TOKEN">WHEN</TT>
子句。如果没有<TT CLASS="TOKEN">WHEN</TT> <TT CLASS="REPLACEABLE"><I>condition</I></TT>为真，
那么表达式的结果就是在<TT CLASS="TOKEN">ELSE</TT>子句里的<TT CLASS="REPLACEABLE"><I>result</I></TT>。
如果省略了<TT CLASS="TOKEN">ELSE</TT>子句且没有匹配的条件，结果为 NULL 。
</P><P>一个例子：
</P><PRE CLASS="SCREEN">SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other</PRE><P>
</P><P>所有<TT CLASS="REPLACEABLE"><I>result</I></TT>表达式的数据的类型都必须可以转换成单一的输出类型。
参阅<A HREF="typeconv-union-case.html">第 10.5 &#33410;</A>获取更多细节。</P><P>下面这个<SPAN CLASS="QUOTE">"简单的"</SPAN><TT CLASS="TOKEN">CASE</TT>表达式是上面的通用形式的一个特殊的变种：
</P><PRE CLASS="SYNOPSIS">CASE <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>
    WHEN <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> THEN <TT
CLASS="REPLACEABLE"
><I
>result</I
></TT
>
    [<SPAN
CLASS="OPTIONAL"
>WHEN ...</SPAN
>]
    [<SPAN
CLASS="OPTIONAL"
>ELSE <TT
CLASS="REPLACEABLE"
><I
>result</I
></TT
></SPAN
>]
END</PRE><P>
先计算<TT CLASS="REPLACEABLE"><I>expression</I></TT>的值，然后与每个<TT CLASS="TOKEN">WHEN</TT>
子句里声明的<TT CLASS="REPLACEABLE"><I>value</I></TT>表达式对比，直到找到一个相等的。
如果没有找到匹配的，则返回在<TT CLASS="TOKEN">ELSE</TT>子句里的<TT CLASS="REPLACEABLE"><I>result</I></TT>
(或者 NULL)。这个类似于 C 里的<CODE CLASS="FUNCTION">switch</CODE>语句。
</P><P>上面的例子可以用简单<TT CLASS="TOKEN">CASE</TT>语法来写：
</P><PRE CLASS="SCREEN">SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other</PRE><P>
</P><P><TT CLASS="TOKEN">CASE</TT>表达式并不计算任何对于判断结果并不需要的子表达式。比如，
下面是一个可以避免被零除的方法：
</P><PRE CLASS="PROGRAMLISTING">SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;</PRE><P>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>正如在<A HREF="xfunc-volatility.html">第 35.6 &#33410;</A>描述的那样，被<TT CLASS="LITERAL">IMMUTABLE</TT>
标记的函数和操作符在计划查询时评估，而不是在执行时。
这意味着没有在查询执行时评估的子表达式的常量部分可能仍会在查询计划时评估。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-COALESCE-NVL-IFNULL">9.17.2. <TT CLASS="LITERAL">COALESCE</TT></A></H2><PRE CLASS="SYNOPSIS"><CODE
CLASS="FUNCTION"
>COALESCE</CODE
>(<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>])</PRE><P><CODE CLASS="FUNCTION">COALESCE</CODE>返回它的第一个非 NULL 的参数值。如果所有参数都是null那么返回null。
它常用于在显示数据时用缺省值替换 NULL 。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT COALESCE(description, short_description, '(none)') ...</PRE><P>
如果<TT CLASS="VARNAME">description</TT>非空那么返回它，否则如果<TT CLASS="VARNAME">short_description</TT>非空则返回它，
否则返回<TT CLASS="LITERAL">(none)</TT>。
</P><P>和<TT CLASS="TOKEN">CASE</TT>表达式一样，<CODE CLASS="FUNCTION">COALESCE</CODE>只计算需要用来判断结果的参数；
也就是说，在第一个非空参数右边的参数不会被计算。
这个符合 SQL 标准的函数提供了与某些其它数据库系统中的<CODE CLASS="FUNCTION">NVL</CODE>
和<CODE CLASS="FUNCTION">IFNULL</CODE>类似的功能。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-NULLIF">9.17.3. <TT CLASS="LITERAL">NULLIF</TT></A></H2><PRE CLASS="SYNOPSIS"><CODE
CLASS="FUNCTION"
>NULLIF</CODE
>(<TT
CLASS="REPLACEABLE"
><I
>value1</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>value2</I
></TT
>)</PRE><P>当且仅当<TT CLASS="REPLACEABLE"><I>value1</I></TT>等于<TT CLASS="REPLACEABLE"><I>value2</I></TT>时，
<CODE CLASS="FUNCTION">NULLIF</CODE>才返回 null 。否则它返回<TT CLASS="REPLACEABLE"><I>value1</I></TT>。
这些可以用于执行上面给出的<CODE CLASS="FUNCTION">COALESCE</CODE>例子的反例：
</P><PRE CLASS="PROGRAMLISTING">SELECT NULLIF(value, '(none)') ...</PRE><P>
</P><P>在这个例子中，如果<TT CLASS="LITERAL">value</TT>是<TT CLASS="LITERAL">(none)</TT>那么返回 null，否则返回<TT CLASS="LITERAL">value</TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-GREATEST-LEAST">9.17.4. <TT CLASS="LITERAL">GREATEST</TT> and <TT CLASS="LITERAL">LEAST</TT></A></H2><PRE CLASS="SYNOPSIS"><CODE
CLASS="FUNCTION"
>GREATEST</CODE
>(<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>])</PRE><PRE CLASS="SYNOPSIS"><CODE
CLASS="FUNCTION"
>LEAST</CODE
>(<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>])</PRE><P><CODE CLASS="FUNCTION">GREATEST</CODE>和<CODE CLASS="FUNCTION">LEAST</CODE>函数从一个任意数字表达式的列表里选取最大或者最小的数值。
这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型(参阅<A HREF="typeconv-union-case.html">第 10.5 &#33410;</A>
获取细节)。列表中的 NULL 值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL 。</P><P>请注意<CODE CLASS="FUNCTION">GREATEST</CODE>和<CODE CLASS="FUNCTION">LEAST</CODE>都不是 SQL 标准，但却是很常见的扩展。
某些其他的数据库在任意一个参数为NULL时返回NULL，而不是所有参数都是NULL时。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="functions-sequence.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="functions-array.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">序列操作函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">数组函数和操作符</TD></TR></TABLE></DIV></BODY></HTML>
