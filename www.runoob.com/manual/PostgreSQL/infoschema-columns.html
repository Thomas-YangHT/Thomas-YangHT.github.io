<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>columns</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="信息模式" HREF="http://school.yunwei.edu/manual/PostgreSQL/information-schema.html"><LINK REL="PREVIOUS" TITLE="column_udt_usage" HREF="infoschema-column-udt-usage.html"><LINK REL="NEXT" TITLE="constraint_column_usage" HREF="infoschema-constraint-column-usage.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/information_schema.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="column_udt_usage" HREF="infoschema-column-udt-usage.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/information-schema.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 34. 信息模式</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="constraint_column_usage" HREF="infoschema-constraint-column-usage.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="INFOSCHEMA-COLUMNS">34.16. <TT CLASS="LITERAL">columns</TT></A></H1><P>视图<TT CLASS="LITERAL">columns</TT>包含有关数据库中所有表字段（或者视图字段）的信息。
不包括系统字段（比如<TT CLASS="LITERAL">oid</TT>等）。只有那些当前用户有权访问的字段才会显示出来
（要么是所有者，要么是有些权限）。 </P><DIV CLASS="TABLE"><A NAME="AEN47933"></A><P><B>&#34920; 34-14. <TT CLASS="LITERAL">columns</TT> 字段</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>数据类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">table_catalog</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>包含表的数据库的名字（总是当前数据库）</TD></TR><TR><TD><TT CLASS="LITERAL">table_schema</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>包含表的模式的名字</TD></TR><TR><TD><TT CLASS="LITERAL">table_name</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>表的名字</TD></TR><TR><TD><TT CLASS="LITERAL">column_name</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>字段的名字</TD></TR><TR><TD><TT CLASS="LITERAL">ordinal_position</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>字段在表中的位置序号（从 1 开始）</TD></TR><TR><TD><TT CLASS="LITERAL">column_default</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>字段的缺省表达式</TD></TR><TR><TD><TT CLASS="LITERAL">is_nullable</TT></TD><TD><TT CLASS="TYPE">yes_or_no</TT></TD><TD>
如果字段可能为空，则为<TT CLASS="LITERAL">YES</TT>，如果知道它不能为空，则为<TT CLASS="LITERAL">NO</TT>。
非空约束是我们得知字段不能为空的一个手段，但是还可能有其它的。
</TD></TR><TR><TD><TT CLASS="LITERAL">data_type</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>
如果它是一个内置类型，那么为字段的数据类型，如果它是某种数组，
则为<TT CLASS="LITERAL">ARRAY</TT>（在这种情况下，参阅视图<TT CLASS="LITERAL">element_types</TT>），
否则就是<TT CLASS="LITERAL">USER-DEFINED</TT>（这时，类型定义在<TT CLASS="LITERAL">udt_name</TT>和相关的字段上）。
如果字段基于域，这个字段引用底层域类型（而域是在<TT CLASS="LITERAL">domain_name</TT>和相关字段里定义的）。
</TD></TR><TR><TD><TT CLASS="LITERAL">character_maximum_length</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>
如果<TT CLASS="LITERAL">data_type</TT>标识一个字符或者位串类型，那么就是声明的最大长度；
如果是其它类型或者没有定义最大长度，就是空。
</TD></TR><TR><TD><TT CLASS="LITERAL">character_octet_length</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>
如果<TT CLASS="LITERAL">data_type</TT>标识一个字符类型，就是以字节记的最大可能长度；
所有其它类型都是空。最大字节长度取决于声明的字节最大长度（见上文）和服务器编码。
</TD></TR><TR><TD><TT CLASS="LITERAL">numeric_precision</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>
如果<TT CLASS="LITERAL">data_type</TT>标识一个数值类型，这个字段包含
（声明的或隐含的）这个字段的数据类型的精度。精度表示有效小数位的长度。
它可以用十进制或者二进制来表示，这一点在<TT CLASS="LITERAL">numeric_precision_radix</TT>
字段里声明。对于其它数据类型，这个字段是空。
</TD></TR><TR><TD><TT CLASS="LITERAL">numeric_precision_radix</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>
如果<TT CLASS="LITERAL">data_type</TT>标识一个数值类型，这个字段标识字段
<TT CLASS="LITERAL">numeric_precision</TT>和<TT CLASS="LITERAL">numeric_scale</TT>
里的数据是多少进制的。值要么是 2 要么是 10。对于所有其它数据类型，这个字段是空。
</TD></TR><TR><TD><TT CLASS="LITERAL">numeric_scale</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>
如果<TT CLASS="LITERAL">data_type</TT>标识一个精确的数值类型，
那么这个字段包含（声明的或者隐含的）这个字段上这个类型的数值范围。
数值范围表明小数点右边的有效小数位的数目。它可以用十进制（10为基）
或者二进制（二为基）来表示，正如字段<TT CLASS="LITERAL">numeric_precision_radix</TT>
声明的那样。对于所有其它数据类型，这个字段是空。
</TD></TR><TR><TD><TT CLASS="LITERAL">datetime_precision</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>
如果<TT CLASS="LITERAL">data_type</TT>标识一个日期，时间，时间戳，或者间隔类型，
该字段（公开地或隐含地）包含该字段类型的小数秒精度，就是说，
小数位数保持到小数点后面。对于所有其它的数据类型，该字段是null。
</TD></TR><TR><TD><TT CLASS="LITERAL">interval_type</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>
如果<TT CLASS="LITERAL">data_type</TT>标识一个间隔类型，这个字段包含这个字段时间间隔声明，
例如，<TT CLASS="LITERAL">YEAR TO MONTH</TT>, <TT CLASS="LITERAL">DAY TO SECOND</TT>等等。
如果没有指定字段限制（也就是，间隔接受所有字段），或对于所有其他数据类型，这个字段是null。
</TD></TR><TR><TD><TT CLASS="LITERAL">interval_precision</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>
用于一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不可用的特性
（参阅<TT CLASS="LITERAL">datetime_precision</TT>获取间隔类型字段的小数秒精度）
</TD></TR><TR><TD><TT CLASS="LITERAL">character_set_catalog</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">character_set_schema</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">character_set_name</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">collation_catalog</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
包含该字段的排序规则的数据库的名字（总是当前数据库），缺省或者字段的数据类型不可排序时为null。
</TD></TR><TR><TD><TT CLASS="LITERAL">collation_schema</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
包含该字段的排序规则的模式的名字，缺省或者字段的数据类型不可排序时为null。
</TD></TR><TR><TD><TT CLASS="LITERAL">collation_name</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
字段的排序规则的名字，缺省或者字段的数据类型不可排序时为null。
</TD></TR><TR><TD><TT CLASS="LITERAL">domain_catalog</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
如果字段是域类型，就是该域定义所在的数据库的名字（总是当前数据库），否则为null。
</TD></TR><TR><TD><TT CLASS="LITERAL">domain_schema</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
如果字段是域类型，就是域定义所在的模式的名字，否则为null。
</TD></TR><TR><TD><TT CLASS="LITERAL">domain_name</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>如果字段是域类型，就是该域的名字，否则为null。</TD></TR><TR><TD><TT CLASS="LITERAL">udt_catalog</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
这个字段数据类型（如果适用，就是底层域类型）定义所在的数据库的名字（总是当前数据库）。
</TD></TR><TR><TD><TT CLASS="LITERAL">udt_schema</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
这个字段数据类型（如果适用，就是底层域类型）定义所在的模式名字。
</TD></TR><TR><TD><TT CLASS="LITERAL">udt_name</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
这个字段数据类型（如果适用，就是底层域类型）的名字。
</TD></TR><TR><TD><TT CLASS="LITERAL">scope_catalog</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">scope_schema</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">scope_name</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">maximum_cardinality</TT></TD><TD><TT CLASS="TYPE">cardinal_number</TT></TD><TD>总是空，因为在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里数组总是有无限的最大维数 </TD></TR><TR><TD><TT CLASS="LITERAL">dtd_identifier</TT></TD><TD><TT CLASS="TYPE">sql_identifier</TT></TD><TD>
一个该字段的数据类型描述符的标识符，在属于这个表中的所有的数据类型描述符中唯一。
这个字段主要用于和其它这样的标识符实例连接。
（这个标识符的确切格式没有定义并且不保证在将来的版本中保持一样。）
</TD></TR><TR><TD><TT CLASS="LITERAL">is_self_referencing</TT></TD><TD><TT CLASS="TYPE">yes_or_no</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">is_identity</TT></TD><TD><TT CLASS="TYPE">yes_or_no</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">identity_generation</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">identity_start</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">identity_increment</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">identity_maximum</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">identity_minimum</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">identity_cycle</TT></TD><TD><TT CLASS="TYPE">yes_or_no</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">is_generated</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">generation_expression</TT></TD><TD><TT CLASS="TYPE">character_data</TT></TD><TD>用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里一个不可用的特性</TD></TR><TR><TD><TT CLASS="LITERAL">is_updatable</TT></TD><TD><TT CLASS="TYPE">yes_or_no</TT></TD><TD>
如果字段为可更新则为<TT CLASS="LITERAL">YES</TT>，否则为<TT CLASS="LITERAL">NO</TT>
（基表中的字段总是可以更新的，而试图中的字段则不一定）
</TD></TR></TBODY></TABLE></DIV><P>因为数据类型在SQL里可以用多种方法定义，并且<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>包含额外的定义数据类型的方法，
因此他们在信息模式里的表现形式可能不太一样。字段<TT CLASS="LITERAL">data_type</TT>
会被用于标识该字段底层的内置数据类型。在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里，
这意味着类型将定义在系统表模式<TT CLASS="LITERAL">pg_catalog</TT>里。如果应用可以很好地处理那些重要的内置类型
（比如，对数值类型格式化成不同的东西，或者使用在精度字段里的数据），那么这个字段是有用的。
字段<TT CLASS="LITERAL">udt_name</TT>, <TT CLASS="LITERAL">udt_schema</TT>, 和 <TT CLASS="LITERAL">udt_catalog</TT>
总是标识该字段的底层数据类型，即使字段是基于域的也一样。（因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
把内置类型看作和用户定义类型一样，所以，内置类型也在这里出现。这是对SQL标准的一个扩展。）
如果一个应用想根据数据类型的不同而区别处理数据，那么应该使用这些字段，
因为在这种情况下它不会在意这个字段是否真正基于域的。如果这个字段基于一个域，
那么该域的标识保存在字段<TT CLASS="LITERAL">domain_name</TT>, <TT CLASS="LITERAL">domain_schema</TT>,
和<TT CLASS="LITERAL">domain_catalog</TT>里。如果你想把字段和他们相关的数据类型凑成对儿，
并且把域当作不同的类型处理， 你可以这么写<TT CLASS="LITERAL">coalesce(domain_name,udt_name)</TT>等等。 </P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="infoschema-column-udt-usage.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="infoschema-constraint-column-usage.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><TT CLASS="LITERAL">column_udt_usage</TT></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/information-schema.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><TT CLASS="LITERAL">constraint_column_usage</TT></TD></TR></TABLE></DIV></BODY></HTML>
