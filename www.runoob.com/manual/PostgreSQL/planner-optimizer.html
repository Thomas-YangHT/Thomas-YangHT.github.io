<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>规划器/优化器</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PostgreSQL内部概述" HREF="http://school.yunwei.edu/manual/PostgreSQL/overview.html"><LINK REL="PREVIOUS" TITLE="PostgreSQL规则系统" HREF="rule-system.html"><LINK REL="NEXT" TITLE="执行器" HREF="executor.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/arch-dev.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="PostgreSQL规则系统" HREF="rule-system.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/overview.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 46. PostgreSQL内部概述</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="执行器" HREF="executor.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PLANNER-OPTIMIZER">46.5. 规划器/优化器</A></H1><P><I CLASS="FIRSTTERM">规划器/优化器</I>的任务是创建一个最优的执行规划。
一个特定的 SQL 查询(因此也就是一个查询树)实际上可以以多种不同的方式执行，
每种都生成相同的结果集。如果可能，查询优化器将检查每个可能的执行规划，
最终选择认为运行最快的执行规划。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>有些情况下，检查一个查询所有可能的执行方式会花去很多时间和内存空间。
特别是执行的查询涉及大量连接操作的时候。
为了在合理的时间里选择一个合理的(而不是最优的)查询计划。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
当连接操作的数量超过一个阈值(参阅 <A HREF="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</A>)时使用
<I CLASS="FIRSTTERM">基因查询优化器</I>(参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/geqo.html">第 53 &#31456;</A>)。</P></BLOCKQUOTE></DIV><P>规划器的搜索过程实际上是与叫做<I CLASS="FIRSTTERM">paths</I>的数据结构一起结合运转的，
这个数据结构是查询规划的一个精简版本，它只包括规划器用来决策所必须的信息。
在找到代价最小的路径之后，就生成一个完整的<I CLASS="FIRSTTERM">规划树</I>传递给执行器，
它有足够的详细信息，表示需要执行的计划，执行器可以读懂并运行之。在本章剩余部分，
将忽略路径和规划之间的区别。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN90625">46.5.1. 生成可能的规划</A></H2><P>规划器/优化器开始于为查询中出现的每个关系(表)生成规划，这些规划用于对这些关系进行扫描，
每个关系上可能的规划是由其有哪些可用的索引决定的。对一个关系总是可以对其进行顺序扫描，
所以总是会创建只使用顺序扫描的规划。假设一个关系上定义着一个索引(例如 B-tree 索引)，
并且一条查询包含约束<TT CLASS="LITERAL">relation.attribute OPR constant</TT>。
如果<TT CLASS="LITERAL">relation.attribute</TT>碰巧匹配 B-tree 索引的关键字并且<TT CLASS="LITERAL">OPR</TT>
又是索引<I CLASS="FIRSTTERM">操作符类</I>中的一个操作符，
那么将会创建另一个使用 B-tree 索引扫描该关系的规划。如果还有别的索引，
而且查询里面的约束又和那个索引的关键字匹配，则还会生成更多的规划。如果索引的排序与查询的<TT CLASS="LITERAL">ORDER BY</TT>子句（如果有）相匹配，或者排序可能有益于将来进行归并连接（见下），也会生成索引扫描规划。</P><P>如果查询需要连接两个或者更多的关系，在所有的对单一关系的扫描可行的规划被发现后，
连接各个关系的规划就要被考虑了。有三种可能的连接策略：
<P></P></P><UL><LI><P><I CLASS="FIRSTTERM">嵌套循环连接</I>：对左边的关系里面找到的每一行都对右边关系进行一次扫描。
这个策略容易实现，但是可能会很耗费时间。（但是，如果右边的关系可以用索引扫描，
那么这个可能就是个好策略。可以使用左边关系中当前行的值作为对右边关系进行索引扫描的键。）</P></LI><LI><P><I CLASS="FIRSTTERM">归并连接</I>：在连接开始之前，每个关系都对连接字段进行排序。
然后对两个关系并发扫描，匹配的行就组合起来形成连接行。这种连接更有吸引力，
因为每个关系都只用扫描一次。要求的排序步骤可以通过明确的排序步骤，
或者是使用连接键字上的索引按照恰当的顺序对关系进行扫描。</P></LI><LI><P><I CLASS="FIRSTTERM">Hash 连接</I>：首先扫描右边的关系，
并用连接的字段作为散列键字加载进入一个 Hash 表，然后扫描左边的关系，
并将找到的每行用作散列键字来以定位表里匹配的行。</P></LI></UL><P>
</P><P>如果查询中的关系多于两个，最后的结果必须通过一个连接步骤树建立，
每个步骤有两个输入。规划器检查不同的、可能的连接顺序，找出开销最小的。</P><P>如果查询使用少于<A HREF="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</A>的关系，
会使用一个近乎穷举的搜索方法查找最好的连接顺序。规划器优先考虑为存在连接子句的任意两个关系进行连接，
这些连接子句在<TT CLASS="LITERAL">WHERE</TT>约束条件（例如，存在像
<TT CLASS="LITERAL">where rel1.attr1=rel2.attr2</TT>这样的约束）。
没有连接子句的连接对只有在没有别的选择的时候才考虑，也就是说，
一个关系没有和任何其它关系有连接子句可用。规划器为每个连接对生成所有可能的规划，
并且那个（预计是）最经济的规划将被选择。</P><P>当连接数超出<TT CLASS="VARNAME">geqo_threshold</TT>时，连接顺序被认为是由启发式方法决定的，
如<A HREF="http://school.yunwei.edu/manual/PostgreSQL/geqo.html">第 53 &#31456;</A>所描述。否则，流程是相同的。</P><P>最终完成的规划树由三部分内容组成：对基础关系的顺序或索引扫描节点，嵌套循环、归并或Hash连接节点以及一些必须的辅助节点，比如拍苏节点和聚集函数计算节点。
这些规划节点类型中，大多数都可以做<I CLASS="FIRSTTERM">选择</I>
(抛弃那些不符合指定布尔条件的行)和<I CLASS="FIRSTTERM">投影</I> (基于给出的字段数值计算一个派生出的字段集，
也就是在需要时计算标量表达式)。规划器的一个责任是从<TT CLASS="LITERAL">WHERE</TT>
子句中附加选择条件以及为规划树最合适的节点计算所需要的输出表达式。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="rule-system.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="executor.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>规则系统</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/overview.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">执行器</TD></TR></TABLE></DIV></BODY></HTML>
