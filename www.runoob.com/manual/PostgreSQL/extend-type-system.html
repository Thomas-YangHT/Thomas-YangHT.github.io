<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>PostgreSQL类型系统</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="扩展SQL" HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html"><LINK REL="PREVIOUS" TITLE="扩展性是如何实现的" HREF="extend-how.html"><LINK REL="NEXT" TITLE="用户定义的函数" HREF="xfunc.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/extend.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="扩展性是如何实现的" HREF="extend-how.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 35. 扩展<ACRONYM CLASS="ACRONYM">SQL</ACRONYM></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="用户定义的函数" HREF="xfunc.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="EXTEND-TYPE-SYSTEM">35.2. <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>类型系统</A></H1><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>数据类型可以分为基本类型、复合类型、域、伪类型。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN52452">35.2.1. 基本类型</A></H2><P> 基本类型是那些在<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>语言层次更低级别(通常是C语言)上实现的类型(比如<TT CLASS="TYPE">int4</TT>类型)，
它们通常与抽像数据类型对应。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对这些数据类型只能通过用户提供的函数来操作，
并且对这些数据类型行为的理解只限于用户所描述的范围。基本类型进一步分成标量和数组类型。
对于每种标量类型，系统都会自动创建一个对应的数组类型，可以保存该标量类型的变长数组。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN52458">35.2.2. 复合类型</A></H2><P> 复合类型(或者说行类型)是用户创建表时创建的。
也可以用<A HREF="sql-createtype.html">CREATE TYPE</A>创建一个<SPAN CLASS="QUOTE">"独立的"</SPAN>、没有关联表的复合类型。
复合类型只是一个带着相关字段名称的基本类型的列表。
复合类型的数值是一行字段值或者一条字段值组成的记录。
用户可以从<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>查询里访问其字段。
参考<A HREF="rowtypes.html">第 8.16 &#33410;</A>获取更多复合类型的相关信息。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="EXTEND-TYPE-SYSTEM-DOMAINS">35.2.3. 域</A></H2><P> 域基于一种特定的基本类型，从很多角度来看，它们也可以和其对应的基本类型交换。
但是，域可以有约束，把它的有效值限制在其对应的基本类型的有效值范围的一个子集中。</P><P> 域可以使用<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令<A HREF="sql-createdomain.html">CREATE DOMAIN</A>创建。
它们的创建和使用不在本章讨论。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN52471">35.2.4. 伪-类型</A></H2><P> 有一些用于特殊目的<SPAN CLASS="QUOTE">"伪类型"</SPAN>。伪类型不能作为表的字段类型，
也不能作为复合类型的属性，但是它们可以用于声明函数的参数和结果类型。
这样就在类型系统里提供了一个标识特殊类型函数的机制。
<A HREF="datatype-pseudo.html#DATATYPE-PSEUDOTYPES-TABLE">&#34920; 8-24</A>列出了现有的伪类型。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="EXTEND-TYPES-POLYMORPHIC">35.2.5. 多态类型</A></H2><P> <TT CLASS="TYPE">anyelement</TT>,<TT CLASS="TYPE">anyarray</TT>, <TT CLASS="TYPE">anynonarray</TT>, <TT CLASS="TYPE">anyenum</TT>,
和<TT CLASS="TYPE">anyrange</TT>是五种特别有趣的伪类型，它们被称作<I CLASS="FIRSTTERM">多态类型</I>。
任何用这些类型定义的函数就叫做<I CLASS="FIRSTTERM">多态函数</I>。
一种多态函数可以在许多不同的数据类型上操作，
它们根据调用中实际传递进来的数据类型判断具体的类型。</P><P> 多态参数和结果是相互绑定的，并且在分析查询调用的函数时解析成特定的数据类型。
每个声明成<TT CLASS="TYPE">anyelement</TT>的位置(参数或者返回类型)都允许拥有一个特定的实际数据类型，
但是在任何给定的调用过程中，它们都必须是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">同样的</I></SPAN>类型。
每个声明为<TT CLASS="TYPE">anyarray</TT>的位置都可以是任何数组数据类型，类似的，声明为<TT CLASS="TYPE">anyrange</TT>的位置
也必许都是同样的类型。而且，如果有些位置声明为<TT CLASS="TYPE">anyarray</TT>而其它位置声明为<TT CLASS="TYPE">anyelement</TT>，
那么在<TT CLASS="TYPE">anyarray</TT>位置上的类型必须是元素类型与那些出现在<TT CLASS="TYPE">anyelement</TT>位置上的类型相同的数组。
类似的，如果有声明为<TT CLASS="TYPE">anyrange</TT>的位置而且其他的声明为<TT CLASS="TYPE">anyelement</TT>，那么
在<TT CLASS="TYPE">anyrange</TT>位置上的类型必须是子类型与那些出现在<TT CLASS="TYPE">anyelement</TT>位置上类型相同
的范围。<TT CLASS="TYPE">anynonarray</TT>实际上被看做<TT CLASS="TYPE">anyelement</TT>，
但却多一个约束：实际类型必须不能是一个数组类型。
<TT CLASS="TYPE">anyenum</TT>实际上被看做<TT CLASS="TYPE">anyelement</TT>，但却多一个约束：
实际类型必须是一个枚举类型。</P><P> 因此，如果多个参数位置声明为多态类型，其实际效果是只允许某些实际参数类型的组合出现。
比如，一个函数声明为<TT CLASS="LITERAL">equal(anyelement, anyelement)</TT>将接受任何两个输入值，只要它们的数据类型相同。</P><P> 如果一个函数的返回值声明为多态类型，那么至少有一个参数位置也是多态的，
并且提供给参数的类型决定本次调用实际返回的类型。比如，如果没有数组下标机制，
那么我们可以定义一个实现下标的函数<TT CLASS="LITERAL">subscript(anyarray, integer) returns anyelement</TT>。
这个声明约束第一个实际参数是一个数组类型，并且允许分析器从第一个参数的实际类型推导出正确的返回类型。
声明为一个<TT CLASS="LITERAL">f(anyarray) returns anyenum</TT>的函数的另一个例子只接受枚举类型的数组。</P><P> 需要注意的是，<TT CLASS="TYPE">anynonarray</TT>和<TT CLASS="TYPE">anyenum</TT>不代表不同的类型变量；
它们是与<TT CLASS="TYPE">anyelement</TT>相同的类型，只有一个额外的约束。
例如，声明一个函数为<TT CLASS="LITERAL">f(anyelement, anyenum)</TT>
等同于声明它为<TT CLASS="LITERAL">f(anyenum, anyenum)</TT>:
两个实际参数必须是相同的枚举类型。</P><P> 一个可变参数函数（其使用一个可变数目的参数，如<A HREF="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS">第 35.4.5 &#33410;</A>中描述）
可以是多态的：
可以通过声明它的最后一个参数为<TT CLASS="LITERAL">VARIADIC</TT> <TT CLASS="TYPE">anyarray</TT>来实现。
为了实现参数匹配并决定实际结果类型，
这样一个函数的行为等同于将<TT CLASS="TYPE">anynonarray</TT>参数写一个合适的数目。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="extend-how.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="xfunc.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">扩展性是如何实现的</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">用户定义的函数</TD></TR></TABLE></DIV></BODY></HTML>
