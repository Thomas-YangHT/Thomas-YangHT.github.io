<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>表表达式</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="查询" HREF="http://school.yunwei.edu/manual/PostgreSQL/queries.html"><LINK REL="PREVIOUS" TITLE="概述" HREF="queries-overview.html"><LINK REL="NEXT" TITLE="选择列表" HREF="queries-select-lists.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/queries.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="概述" HREF="queries-overview.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/queries.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 7. 查询</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="选择列表" HREF="queries-select-lists.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="QUERIES-TABLE-EXPRESSIONS">7.2. 表表达式</A></H1><P><I CLASS="FIRSTTERM">表表达式</I>计算一个表，它包含一个<TT CLASS="LITERAL">FROM</TT>子句，
该子句可以根据需要选用<TT CLASS="LITERAL">WHERE</TT>, <TT CLASS="LITERAL">GROUP BY</TT>,<TT CLASS="LITERAL">HAVING</TT>
子句。大部分表表达式只是指向磁盘上的一个所谓的基本表，
但是我们可以用更复杂的表达式以各种方法修改或组合基本表。</P><P>表表达式里的<TT CLASS="LITERAL">WHERE</TT>, <TT CLASS="LITERAL">GROUP BY</TT>, <TT CLASS="LITERAL">HAVING</TT>
子句声明一系列对源自<TT CLASS="LITERAL">FROM</TT>子句的表的转换操作。
所有这些转换最后生成一个虚拟表，传递给选择列表计算输出行。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="QUERIES-FROM">7.2.1. <TT CLASS="LITERAL">FROM</TT> 子句</A></H2><P><A HREF="sql-select.html#SQL-FROM"><I><I>FROM</I> 子句</I></A>
从一个逗号分隔的表引用列表中生成一个虚拟表。
</P><PRE CLASS="SYNOPSIS">FROM <TT
CLASS="REPLACEABLE"
><I
>table_reference</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>table_reference</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>]</SPAN
>]</PRE><P>
表引用可以是一个表名字(可能有模式修饰)或者是一个生成的表，
比如子查询、表连接、或这些东西的复杂组合。如果在<TT CLASS="LITERAL">FROM</TT>子句中列出了多于一个表，
那么它们交叉连接(见下文)形成一个派生表，该表可以进行<TT CLASS="LITERAL">WHERE</TT>, <TT CLASS="LITERAL">GROUP BY</TT>,
<TT CLASS="LITERAL">HAVING</TT>子句的转换处理，并最后生成表表达式的结果。</P><P>如果一个表引用是一个简单的父表的名字，那么将包括其所有后代子表的行，
除非你在该表名字前面加<TT CLASS="LITERAL">ONLY</TT>关键字(这样任何子表都会被忽略)。</P><P>除了在表名字前面加<TT CLASS="LITERAL">ONLY</TT>，你可以在表名字后面写<TT CLASS="LITERAL">*</TT>
明确指定包括后代表。写<TT CLASS="LITERAL">*</TT>不是必须的，因为这个行为是默认的
（除非你已经改变了<A HREF="runtime-config-compatible.html#GUC-SQL-INHERITANCE">sql_inheritance</A>配置选项里面的设置）。
然而写<TT CLASS="LITERAL">*</TT>可能对于强调搜索额外的表是有用的。</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="QUERIES-JOIN">7.2.1.1. 连接表</A></H3><P>一个连接表是根据特定的连接规则从两个其它表(真实表或生成表)中派生的表。
我们支持内连接、外连接、交叉连接。</P><P></P><DIV CLASS="VARIABLELIST"><P><B>连接类型</B></P><DL><DT>交叉连接</DT><DD><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>T1</I
></TT
> CROSS JOIN <TT
CLASS="REPLACEABLE"
><I
>T2</I
></TT
></PRE><P>对每个来自<TT CLASS="REPLACEABLE"><I>T1</I></TT>和<TT CLASS="REPLACEABLE"><I>T2</I></TT>
的行进行组合（也就是，一个笛卡尔积），连接成的表将包含这样的行：
所有<TT CLASS="REPLACEABLE"><I>T1</I></TT>里面的字段后面跟着所有<TT CLASS="REPLACEABLE"><I>T2</I></TT>
里面的字段。如果两表分别有 N 和 M 行，连接成的表将有 N*M 行。</P><P><TT CLASS="LITERAL">FROM <TT CLASS="REPLACEABLE"><I>T1</I></TT> CROSS JOIN <TT CLASS="REPLACEABLE"><I>T2</I></TT></TT>
等效于<TT CLASS="LITERAL">FROM <TT CLASS="REPLACEABLE"><I>T1</I></TT>,<TT CLASS="REPLACEABLE"><I>T2</I></TT></TT>。
它还等效于<TT CLASS="LITERAL">FROM <TT CLASS="REPLACEABLE"><I>T1</I></TT> INNER JOIN <TT CLASS="REPLACEABLE"><I>T2</I></TT> ON TRUE</TT>(见下文)。</P></DD><DT>条件连接</DT><DD><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>T1</I
></TT
> { [<SPAN
CLASS="OPTIONAL"
>INNER</SPAN
>] | { LEFT | RIGHT | FULL } [<SPAN
CLASS="OPTIONAL"
>OUTER</SPAN
>] } JOIN <TT
CLASS="REPLACEABLE"
><I
>T2</I
></TT
> ON <TT
CLASS="REPLACEABLE"
><I
>boolean_expression</I
></TT
>
<TT
CLASS="REPLACEABLE"
><I
>T1</I
></TT
> { [<SPAN
CLASS="OPTIONAL"
>INNER</SPAN
>] | { LEFT | RIGHT | FULL } [<SPAN
CLASS="OPTIONAL"
>OUTER</SPAN
>] } JOIN <TT
CLASS="REPLACEABLE"
><I
>T2</I
></TT
> USING ( <TT
CLASS="REPLACEABLE"
><I
>join column list</I
></TT
> )
<TT
CLASS="REPLACEABLE"
><I
>T1</I
></TT
> NATURAL { [<SPAN
CLASS="OPTIONAL"
>INNER</SPAN
>] | { LEFT | RIGHT | FULL } [<SPAN
CLASS="OPTIONAL"
>OUTER</SPAN
>] } JOIN <TT
CLASS="REPLACEABLE"
><I
>T2</I
></TT
></PRE><P><TT CLASS="LITERAL">INNER</TT>和<TT CLASS="LITERAL">OUTER</TT>对所有连接类型都是可选的。
<TT CLASS="LITERAL">INNER</TT>为缺省。<TT CLASS="LITERAL">LEFT</TT>, <TT CLASS="LITERAL">RIGHT</TT>,
和<TT CLASS="LITERAL">FULL</TT>隐含外连接。</P><P><I CLASS="FIRSTTERM">连接条件</I>在<TT CLASS="LITERAL">ON</TT>或<TT CLASS="LITERAL">USING</TT>子句里声明，
或者用关键字<TT CLASS="LITERAL">NATURAL</TT>隐含地声明。
连接条件判断来自两个源表中的那些行是<SPAN CLASS="QUOTE">"匹配"</SPAN>的，这些我们将在下面详细解释。</P><P><TT CLASS="LITERAL">ON</TT>子句是最常见的连接条件的类型：它接收一个和<TT CLASS="LITERAL">WHERE</TT>
子句相同的布尔表达式。如果两个分别来自<TT CLASS="REPLACEABLE"><I>T1</I></TT>和<TT CLASS="REPLACEABLE"><I>T2</I></TT>
的行在<TT CLASS="LITERAL">ON</TT>表达式上运算的结果为真，那么它们就算是匹配的行。</P><P><TT CLASS="LITERAL">USING</TT>是一个连接条件的缩写语法：它接收一个用逗号分隔的字段名列表，
这些字段必须是连接表共有的并且其值必须相同。最后，<TT CLASS="LITERAL">JOIN USING</TT>
会将每一对相等的输入字段输出为一个字段，其后跟着所有其它字段。
因此，<TT CLASS="LITERAL">USING (a, b, c)</TT> 等效于<TT CLASS="LITERAL">ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c)</TT>
只不过是如果使用了<TT CLASS="LITERAL">ON</TT>，那么在结果里<TT CLASS="LITERAL">a</TT>, <TT CLASS="LITERAL">b</TT>和<TT CLASS="LITERAL">c</TT>
字段都会有两个，而用<TT CLASS="LITERAL">USING</TT>的时候就只会有一个（如果使用了<TT CLASS="COMMAND">SELECT *</TT>
的话，他们会优先发生）。</P><P>
最后，<TT CLASS="LITERAL">NATURAL</TT>是<TT CLASS="LITERAL">USING</TT>的缩写形式：
它自动形成一个由两个表中同名的字段组成的<TT CLASS="LITERAL">USING</TT>列表(同名字段只出现一次)。
如果没有同名的字段，<TT CLASS="LITERAL">NATURAL</TT>的行为会像<TT CLASS="LITERAL">CROSS JOIN</TT>。</P><P>
条件连接可能的类型是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">INNER JOIN</TT></DT><DD><P>内连接。对于 T1 中的每一行 R1 ，如果能在 T2 中找到一个或多个满足连接条件的行，
那么这些满足条件的每一行都在连接表中生成一行。</P></DD><DT><TT CLASS="LITERAL">LEFT OUTER JOIN</TT></DT><DD><P>左外连接。首先执行一次内连接。然后为每一个 T1 中无法在 T2 中找到匹配的行生成一行，
该行中对应 T2 的列用 NULL 补齐。因此，生成的连接表里总是包含来自 T1 里的每一行至少一个副本。</P></DD><DT><TT CLASS="LITERAL">RIGHT OUTER JOIN</TT></DT><DD><P>右外连接。首先执行一次内连接。然后为每一个 T2 中无法在 T1 中找到匹配的行生成一行，
该行中对应 T1 的列用 NULL 补齐。因此，生成的连接表里总是包含来自 T2 里的每一行至少一个副本。</P></DD><DT><TT CLASS="LITERAL">FULL OUTER JOIN</TT></DT><DD><P>全连接。首先执行一次内连接。然后为每一个 T1 与 T2 中找不到匹配的行生成一行，
该行中无法匹配的列用 NULL 补齐。因此，生成的连接表里无条件地包含 T1 和 T2 里的每一行至少一个副本。</P></DD></DL></DIV><P>
</P></DD></DL></DIV><P>如果<TT CLASS="REPLACEABLE"><I>T1</I></TT>和<TT CLASS="REPLACEABLE"><I>T2</I></TT>
之一或全部是可以连接的表，那么所有类型的连接都可以串连或嵌套在一起。
你可以在<TT CLASS="LITERAL">JOIN</TT>子句周围使用圆括弧来控制连接顺序，如果没有圆括弧，
那么<TT CLASS="LITERAL">JOIN</TT>子句从左向右嵌套。</P><P>为了解释这些问题，假设我们有一个表<TT CLASS="LITERAL">t1</TT>:
</P><PRE CLASS="PROGRAMLISTING"> num | name
-----+------
   1 | a
   2 | b
   3 | c</PRE><P>
和<TT CLASS="LITERAL">t2</TT>:
</P><PRE CLASS="PROGRAMLISTING"> num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz</PRE><P>
然后我们用不同的连接方式可以获得各种结果：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 CROSS JOIN t2;</KBD
>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</KBD
>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 INNER JOIN t2 USING (num);</KBD
>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 NATURAL INNER JOIN t2;</KBD
>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</KBD
>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 LEFT JOIN t2 USING (num);</KBD
>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</KBD
>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</KBD
>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)</PRE><P>
</P><P>
用<TT CLASS="LITERAL">ON</TT>声明的连接条件也可以包含与连接不直接相关的条件。
这种功能可能对某些查询很有用，但是需要我们仔细想清楚。比如：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</KBD
>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)</PRE><P>
请注意，将限制放在在<TT CLASS="LITERAL">WHERE</TT>子句中将会产生不同的结果：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</KBD
>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)</PRE><P>
这是因为限制放在<TT CLASS="LITERAL">ON</TT>子句中时是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">先于</I></SPAN>连接处理的，
而限制放在<TT CLASS="LITERAL">WHERE</TT>子句中时是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">后于</I></SPAN>连接处理的。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="QUERIES-TABLE-ALIASES">7.2.1.2. 表和列别名</A></H3><P>你可以给表或复杂的表引用起一个临时的<I CLASS="FIRSTTERM">表别名</I>，以便被其余的查询引用。</P><P>
要创建一个表别名，可以这样：
</P><PRE CLASS="SYNOPSIS">FROM <TT
CLASS="REPLACEABLE"
><I
>table_reference</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
></PRE><P>
或：
</P><PRE CLASS="SYNOPSIS">FROM <TT
CLASS="REPLACEABLE"
><I
>table_reference</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
></PRE><P>
<TT CLASS="LITERAL">AS</TT>关键字没啥特别的含义。<TT CLASS="REPLACEABLE"><I>alias</I></TT>可以是任意标识符。
</P><P>
表别名的典型应用是给长表名赋予比较短的标识，好让连接子句更易读一些。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;</PRE><P>
</P><P>
取了别名之后就不允许再用最初的名字了。因此，这是不合法的：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- wrong</PRE><P>
</P><P>
表别名主要是为了方便标记，但对于自连接却是必须的。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;</PRE><P>
另外，要引用子查询的结果也必须使用别名(参见<A HREF="queries-table-expressions.html#QUERIES-SUBQUERIES">第 7.2.1.3 &#33410;</A>)。
</P><P>圆括弧用于解决歧义。下面的第一个语句把别名<TT CLASS="LITERAL">b</TT>赋予第二个<TT CLASS="LITERAL">my_table</TT>表；
而第二个语句则把别名<TT CLASS="LITERAL">b</TT>赋予了连接的结果。
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...</PRE><P>
</P><P>另外一种形式的表别名除了给表赋予别名外，还给该表的字段也赋予了别名：
</P><PRE CLASS="SYNOPSIS">FROM <TT
CLASS="REPLACEABLE"
><I
>table_reference</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>AS</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>column1</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>column2</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>]</SPAN
>] )</PRE><P>
如果声明的字段别名比表里实际的字段少，那么后面的字段就没有别名。
这个语法对于自连接或子查询特别有用。
</P><P> 如果用这些形式中的任何一种给一个<TT CLASS="LITERAL">JOIN</TT>子句的输出结果附加了一个别名，
那么该别名就在<TT CLASS="LITERAL">JOIN</TT>里隐藏了其原始的名字。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...</PRE><P>
是合法 SQL ，但是：
</P><PRE CLASS="PROGRAMLISTING">SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c</PRE><P>
是不合法的：别名<TT CLASS="LITERAL">a</TT>在别名<TT CLASS="LITERAL">c</TT>的外面是看不到的。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="QUERIES-SUBQUERIES">7.2.1.3. 子查询</A></H3><P>子查询的结果(派生表)<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必须</I></SPAN>包围在圆括弧里并且必须赋予一个别名(参阅
<A HREF="queries-table-expressions.html#QUERIES-TABLE-ALIASES">第 7.2.1.2 &#33410;</A>)。比如：
</P><PRE CLASS="PROGRAMLISTING">FROM (SELECT * FROM table1) AS alias_name</PRE><P>
</P><P>这个例子等效于<TT CLASS="LITERAL">FROM table1 AS alias_name</TT>。
更有趣的例子是在子查询里面有分组或聚集的时候，
这个时候子查询不能归纳成一个简单的连接。</P><P>子查询也可以是一个<TT CLASS="COMMAND">VALUES</TT>列表：
</P><PRE CLASS="PROGRAMLISTING">FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)</PRE><P>
这种情况同样也必须要取一个别名。还可以为<TT CLASS="COMMAND">VALUES</TT>列表中的字段取别名，
并且被认为是一个好习惯。更多信息参见<A HREF="queries-values.html">第 7.7 &#33410;</A>。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="QUERIES-TABLEFUNCTIONS">7.2.1.4. 表函数</A></H3><P>表函数是那些生成一个行集合的函数，这个集合可以是由基本数据类型(标量类型)组成，
也可以是由复合数据类型(表的行)组成。他们的用法类似一个表、视图、或 <TT CLASS="LITERAL">FROM</TT>
子句里的子查询。表函数返回的字段可以像一个表、视图、或者子查询字段那样包含在
<TT CLASS="LITERAL">SELECT</TT>,<TT CLASS="LITERAL">JOIN</TT>,<TT CLASS="LITERAL">WHERE</TT>子句里。</P><P>如果表函数返回基本数据类型，那么单一结果字段的名字匹配函数名。
如果表函数返回复合数据类型，那么多个结果字段的名字和该类型的每个属性的名字相同。</P><P>可以在<TT CLASS="LITERAL">FROM</TT>子句中为表函数取一个别名，也可以不取别名。
如果一个函数在<TT CLASS="LITERAL">FROM</TT>子句中没有别名，那么将使用函数名作为结果表的名字。</P><P>
一些例子：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;</PRE><P>
</P><P>有时侯，把一个函数定义成根据不同的调用方法可以返回不同的字段是很有用的。
为了支持这个，表函数可以声明为返回伪类型<TT CLASS="TYPE">record</TT>。如果在查询里使用这样的函数，
那么我们必须在查询中声明预期的行结构，这样系统才知道如何分析和规划该查询。
让我们看看下面的例子：
</P><PRE CLASS="PROGRAMLISTING">SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';</PRE><P>
<A HREF="contrib-dblink-function.html">dblink</A>函数（<A HREF="dblink.html">dblink</A>模块的一部分）
执行一个远程的查询。它声明为返回<TT CLASS="TYPE">record</TT>，因为它可能会被用于任何类型的查询。
实际的字段集必须在调用它的查询中声明，这样分析器才知道类似<TT CLASS="LITERAL">*</TT>
这样的东西应该扩展成什么样子。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="QUERIES-LATERAL">7.2.1.5. <TT CLASS="LITERAL">LATERAL</TT> 子查询</A></H3><P><TT CLASS="LITERAL">FROM</TT>子句中出现的子查询可以放在关键字<TT CLASS="LITERAL">LATERAL</TT>之前。
这样就允许它们引用通过前置<TT CLASS="LITERAL">FROM</TT>条目提供的字段。（如果没有<TT CLASS="LITERAL">LATERAL</TT>，
那么每个子查询都被认为是独立的并且不能交叉引用任何其他的<TT CLASS="LITERAL">FROM</TT>条目。）</P><P><TT CLASS="LITERAL">FROM</TT>中出现的表函数也可以出现在关键字<TT CLASS="LITERAL">LATERAL</TT>之前，
但是对于函数来说，这个关键字是可选的；函数的参数在任何情况下都可以包含通过前置<TT CLASS="LITERAL">FROM</TT>
条目提供的字段。</P><P><TT CLASS="LITERAL">LATERAL</TT>条目可以出现在<TT CLASS="LITERAL">FROM</TT>列表的顶级，或者在<TT CLASS="LITERAL">JOIN</TT>树中。
在后者的情况下，它在<TT CLASS="LITERAL">JOIN</TT>右侧时也可以参考左侧的条目。</P><P>当<TT CLASS="LITERAL">FROM</TT>包含<TT CLASS="LITERAL">LATERAL</TT>交叉引用时，评估收益如下：
<TT CLASS="LITERAL">FROM</TT>条目的每行或多个<TT CLASS="LITERAL">FROM</TT>条目的行组提供交叉引用的字段，
<TT CLASS="LITERAL">LATERAL</TT>条目被评估为使用行或行组的字段值。结果行像平常一样加入他们的计算行。
这些来自字段原表中的行或行组就这样重复。 </P><P>一个<TT CLASS="LITERAL">LATERAL</TT>常见的例子是：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;</PRE><P>
这并不是特别有用的，因为它的结果正好和更传统做法的相同。
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;</PRE><P>
<TT CLASS="LITERAL">LATERAL</TT>当交叉引用字段对于加入的计算行是重要的时是主要有用的。
一个常见的应用是为一个set-returning函数提供一个参数值。例如，假设<CODE CLASS="FUNCTION">vertices(polygon)</CODE>
返回一个多边形的顶点坐标，我们可以识别出多边形的顶点距离近的存储在一个表中：
</P><PRE CLASS="PROGRAMLISTING">SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;</PRE><P>
这条语句也可以写成：
</P><PRE CLASS="PROGRAMLISTING">SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;</PRE><P>
或者几个其他等价的形式。（就像之前提到的，<TT CLASS="LITERAL">LATERAL</TT>关键字在这个例子中不是必须的，
但是我们为了明确而使用它。）
</P><P><TT CLASS="LITERAL">LEFT JOIN</TT>对于<TT CLASS="LITERAL">LATERAL</TT>子查询来说往往是特别有用的，
所以即使<TT CLASS="LITERAL">LATERAL</TT>子查询不产生行，源行也将出现在结果中。例如，
如果<CODE CLASS="FUNCTION">get_product_names()</CODE>返回一个制造商制造的产品名字，
但是一些在我们表中的制造商当前没有生产任何产品，我们可以像下面这样找出这些制造商：
</P><PRE CLASS="PROGRAMLISTING">SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;</PRE><P>
</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="QUERIES-WHERE">7.2.2. <TT CLASS="LITERAL">WHERE</TT>子句</A></H2><P><A HREF="sql-select.html#SQL-WHERE"><I><I>WHERE</I> 子句</I></A>子句的语法是：
</P><PRE CLASS="SYNOPSIS">WHERE <TT
CLASS="REPLACEABLE"
><I
>search_condition</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>search_condition</I></TT>是一个返回类型为 <TT CLASS="TYPE">boolean</TT>
的值表达式(参阅<A HREF="sql-expressions.html">第 4.2 &#33410;</A>)。
</P><P>在完成对<TT CLASS="LITERAL">FROM</TT>子句的处理之后，生成的每一行都会按照搜索条件进行检查。
如果结果是真，那么该行保留在输出表中，否则(也就是结果是假或NULL)就把它抛弃。
搜索条件通常至少要引用一列在<TT CLASS="LITERAL">FROM</TT>子句里生成的列，这不是必须的，
但如果不这样的话，<TT CLASS="LITERAL">WHERE</TT>子句就没什么意义了。 </P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>
内连接的连接条件既可以写在<TT CLASS="LITERAL">WHERE</TT>子句里也可以写在<TT CLASS="LITERAL">JOIN</TT>子句里。
比如，下面的表表达式是等效的：
</P><PRE CLASS="PROGRAMLISTING">FROM a, b WHERE a.id = b.id AND b.val &gt; 5</PRE><P>
和：
</P><PRE CLASS="PROGRAMLISTING">FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5</PRE><P>
或者可能还有：
</P><PRE CLASS="PROGRAMLISTING">FROM a NATURAL JOIN b WHERE b.val &gt; 5</PRE><P>
你想用哪个只是风格问题。<TT CLASS="LITERAL">FROM</TT>子句里的<TT CLASS="LITERAL">JOIN</TT>
语法可能不那么容易移植到其它产品中。即使它是在SQL标准。对于外连接而言，
我们没有选择：连接条件必须在<TT CLASS="LITERAL">FROM</TT>子句中完成。
外连接的<TT CLASS="LITERAL">ON</TT>或<TT CLASS="LITERAL">USING</TT>子句<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不</I></SPAN>等于<TT CLASS="LITERAL">WHERE</TT>条件，
因为它导致最终结果中行的增(那些不匹配的输入行)和删。
</P></BLOCKQUOTE></DIV><P>这里是一些<TT CLASS="LITERAL">WHERE</TT>子句的例子：
</P><PRE CLASS="PROGRAMLISTING">SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)</PRE><P>
在上面的例子里，<TT CLASS="LITERAL">fdt</TT>是从<TT CLASS="LITERAL">FROM</TT>子句中派生的表。
那些不符合<TT CLASS="LITERAL">WHERE</TT>子句的搜索条件的行将从<TT CLASS="LITERAL">fdt</TT>中删除。
请注意我们把标量子查询当做一个值表达式来用。就像其它查询一样，
子查询里也可以使用复杂的表表达式。同时还请注意子查询
是如何引用<TT CLASS="LITERAL">fdt</TT>的。把<TT CLASS="LITERAL">c1</TT>修饰成<TT CLASS="LITERAL">fdt.c1</TT>
只有在<TT CLASS="LITERAL">c1</TT>是该子查询生成的列名字时才是必须的，
但修饰列名字可以增加语句的准确性(即使有时不是必须的)。
这个例子就演示了字段名字范围如何从外层查询扩展到它的内层查询。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="QUERIES-GROUP">7.2.3. <TT CLASS="LITERAL">GROUP BY</TT>和<TT CLASS="LITERAL">HAVING</TT>子句</A></H2><P>在通过了<TT CLASS="LITERAL">WHERE</TT>过滤器之后，生成的输入表可以继续用<TT CLASS="LITERAL">GROUP BY</TT>
子句进行分组，然后用<TT CLASS="LITERAL">HAVING</TT>子句选取一些分组行。 </P><PRE CLASS="SYNOPSIS">SELECT <TT
CLASS="REPLACEABLE"
><I
>select_list</I
></TT
>
    FROM ...
    [<SPAN
CLASS="OPTIONAL"
>WHERE ...</SPAN
>]
    GROUP BY <TT
CLASS="REPLACEABLE"
><I
>grouping_column_reference</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>grouping_column_reference</I
></TT
></SPAN
>]...</PRE><P><A HREF="sql-select.html#SQL-GROUPBY"><I><I>GROUP BY</I> 子句</I></A>子句用于把那些所有列出的
grouping_column_reference值都相同的行聚集在一起，缩减为一行，
这样就可以删除输出里的重复和/或计算应用于这些组的聚集。这些字段的列出顺序无关紧要。
比如：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT * FROM test1;</KBD
>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT x FROM test1 GROUP BY x;</KBD
>
 x
---
 a
 b
 c
(3 rows)</PRE><P>
</P><P>在第二个查询里，我们不能写成<TT CLASS="LITERAL">SELECT * FROM test1 GROUP BY x</TT>，
因为字段<TT CLASS="LITERAL">y</TT>里没有哪个值可以和每个组关联起来。
被分组的字段可以在选择列表中引用是因为它们每个组都有单一的数值。</P><P>通常，如果一个表被分了组，不在<TT CLASS="LITERAL">GROUP BY</TT>中列出的字段只能在总表达式中被引用。
一个带聚集表达式的例子是：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT x, sum(y) FROM test1 GROUP BY x;</KBD
>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)</PRE><P>
这里的<TT CLASS="LITERAL">sum</TT>是一个聚集函数，它在组上计算总和。
有关可用的聚集函数的更多信息可以在<A HREF="functions-aggregate.html">第 9.20 &#33410;</A>中找到。
</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>没有有效的聚合表达式分组可以计算一列中不同值的设置。
这个可以通过<TT CLASS="LITERAL">DISTINCT</TT>子句来实现(参考<A HREF="queries-select-lists.html#QUERIES-DISTINCT">第 7.3.3 &#33410;</A>). </P></BLOCKQUOTE></DIV><P>这里是另外一个例子：它计算每种产品的总销售额(而不是所有产品的总销售额)。
</P><PRE CLASS="PROGRAMLISTING">SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;</PRE><P>
在这个例子里，字段<TT CLASS="LITERAL">product_id</TT>，<TT CLASS="LITERAL">p.name</TT>
和<TT CLASS="LITERAL">p.price</TT>必须在<TT CLASS="LITERAL">GROUP BY</TT>子句里，
因为它们都在查询选择列表里被引用了（但见下文）。<TT CLASS="LITERAL">s.units</TT>字段不必在
<TT CLASS="LITERAL">GROUP BY</TT>列表里，因为它只是在一个聚集表达式(<TT CLASS="LITERAL">sum(...)</TT>)里使用，
它代表一组产品的销售总额。对于每种产品，这个查询都返回一个该产品的总销售额。
</P><P>如果产品表是这样设置的，就说<TT CLASS="LITERAL">product_id</TT>是主键，
那么它足够在上面的例子中对<TT CLASS="LITERAL">product_id</TT>分组，
因为名字和价格将会<I CLASS="FIRSTTERM">函数依赖</I>于产品ID，
这样将不会在返回每个产品ID组时有名字和价格的分歧。</P><P>在严格的SQL里，<TT CLASS="LITERAL">GROUP BY</TT>只能对源表的列进行分组，但<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
把这个扩展为也允许<TT CLASS="LITERAL">GROUP BY</TT>对选择列表中的字段进行分组。
也允许对值表达式进行分组，而不仅仅是简单的字段。</P><P>如果一个表已经用<TT CLASS="LITERAL">GROUP BY</TT>分了组，
然后你又只对其中的某些组感兴趣，那么就可以用<TT CLASS="LITERAL">HAVING</TT>子句筛选分组。
必须像<TT CLASS="LITERAL">WHERE</TT>子句，从结果中消除组，语法是：
</P><PRE CLASS="SYNOPSIS">SELECT <TT
CLASS="REPLACEABLE"
><I
>select_list</I
></TT
> FROM ... [<SPAN
CLASS="OPTIONAL"
>WHERE ...</SPAN
>] GROUP BY ... HAVING <TT
CLASS="REPLACEABLE"
><I
>boolean_expression</I
></TT
></PRE><P>
在<TT CLASS="LITERAL">HAVING</TT>子句中的表达式可以引用分组的表达式和未分组的表达式
(后者必须涉及一个聚集函数)。
</P><P>例子：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</KBD
>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<SAMP
CLASS="PROMPT"
>=&gt;</SAMP
> <KBD
CLASS="USERINPUT"
>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</KBD
>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)</PRE><P>
</P><P>然后是一个更现实的例子：
</P><PRE CLASS="PROGRAMLISTING">SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;</PRE><P>
在上面的例子里，<TT CLASS="LITERAL">WHERE</TT>子句根据未分组的字段选择数据行
(表达式只是对那些最近四周发生的销售为真)。而<TT CLASS="LITERAL">HAVING</TT>
子句在分组之后选择那些销售总额超过5000的组。
请注意聚集表达式不需要在查询中的所有地方都一样。
</P><P>如果一个查询调用了聚合函数，但没有<TT CLASS="LITERAL">GROUP BY</TT>子句，分组仍然发生：
结果是单一组行（或者如果单一行被<TT CLASS="LITERAL">HAVING</TT>所淘汰，那么也许没有行）。
同样，它包含一个<TT CLASS="LITERAL">HAVING</TT>子句，甚至没有任何聚合函数的调用或<TT CLASS="LITERAL">GROUP BY</TT>子句。 </P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="QUERIES-WINDOW">7.2.4. 窗口函数处理</A></H2><P>如果查询包含窗口函数(参考<A HREF="tutorial-window.html">第 3.5 &#33410;</A>，<A HREF="functions-window.html">第 9.21 &#33410;</A>
和<A HREF="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS">第 4.2.8 &#33410;</A>)，这些函数在执行了分组、聚合和<TT CLASS="LITERAL">HAVING</TT>
过滤之后被评估。也就是说，如果查询使用任何的聚合、<TT CLASS="LITERAL">GROUP BY</TT>或<TT CLASS="LITERAL">HAVING</TT>，
那么由窗口函数发现的行是该组行而不是从<TT CLASS="LITERAL">FROM</TT>/<TT CLASS="LITERAL">WHERE</TT>得到的原始表行。 </P><P>当多个窗口函数被使用的时候，所有在它们的窗口定义里依照语法地等效于
<TT CLASS="LITERAL">PARTITION BY</TT>和<TT CLASS="LITERAL">ORDER BY</TT>子句的窗口函数保证在同一个过去的数据里被评估。
因此它们将看到同样的排序，
即使<TT CLASS="LITERAL">ORDER BY</TT>不唯一确定一个排序。然而，不确保所做出的关于评价的功能有不同的
<TT CLASS="LITERAL">PARTITION BY</TT>或<TT CLASS="LITERAL">ORDER BY</TT>规范。（在这种情况下，
一个排序步骤通常需要在窗口函数评估之间传递，并且不保证行的排序看似跟<TT CLASS="LITERAL">ORDER BY</TT>等效。） </P><P>目前，窗口函数总是需要分类数据，所以查询输出将按照一个或另一个窗口函数的
<TT CLASS="LITERAL">PARTITION BY</TT>/<TT CLASS="LITERAL">ORDER BY</TT>子句。它不是说依赖于此。
如果你想要确保结果是按特定的方式分类那么使用显式的顶级ORDER BY子句。 </P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="queries-overview.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="queries-select-lists.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">概述</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/queries.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">选择列表</TD></TR></TABLE></DIV></BODY></HTML>
