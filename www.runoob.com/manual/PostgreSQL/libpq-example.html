<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>例子程序</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="制作libpq程序" HREF="libpq-build.html"><LINK REL="NEXT" TITLE="大对象" HREF="http://school.yunwei.edu/manual/PostgreSQL/largeobjects.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="制作libpq程序" HREF="libpq-build.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="大对象" HREF="http://school.yunwei.edu/manual/PostgreSQL/largeobjects.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-EXAMPLE">31.21. 例子程序</A></H1><P>这些例子和其他的可以在字典<TT CLASS="FILENAME">src/test/examples</TT>的源代码分布中找到。</P><DIV CLASS="EXAMPLE"><A NAME="LIBPQ-EXAMPLE-1"></A><P><B>&#20363; 31-1. <SPAN CLASS="APPLICATION">libpq</SPAN> 例子程序 1</B></P><PRE CLASS="PROGRAMLISTING">/*
 * testlibpq.c
 *
 *      &#60;!-- Test the C version of libpq, the PostgreSQL frontend library. --&#62;测试libpq的C版本，PostgreSQL前端库。
 */
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;libpq-fe.h&#62;

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     &#60;!-- 
 * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters. 
 --&#62;
 * 如果用户在命令行上提供了一个参数，则拿它当作 conninfo 字串使用；
 * 否则缺省为 dbname=postgres 并且使用环境变量或者所有其它连接参数
 * 都使用缺省值。
     */
    if (argc &#62; 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* &#60;!-- Make a connection to the database --&#62;连接数据库 */
    conn = PQconnectdb(conninfo);

    /* &#60;!-- Check to see that the backend connection was successfully made --&#62;检查后端连接成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     &#60;!-- 
 * Our test case here involves using a cursor, for which we must be inside
     * a transaction block.  We could do the whole thing with a single
     * PQexec() of "select * from pg_database", but that's too trivial to make
     * a good example. 
 --&#62;
 * 我们的测试实例涉及游标的使用，这个时候我们必须使用事务块。
 * 我们可以把全部事情放在一个  "select * from pg_database"
 * PQexec() 里，不过那样太简单了，不是个好例子。
     */

    /* &#60;!-- Start a transaction block --&#62;开始一个事务块 */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     &#60;!-- 
 * Should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks 
 --&#62;
 * 应该在结果不需要的时候 PQclear PGresult，以避免内存泄漏
     */
    PQclear(res);

    /*
     &#60;!-- Fetch rows from pg_database, the system catalog of databases --&#62; 
 * 从系统表 pg_database（数据库的系统目录）里抓取数据
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* &#60;!-- first, print out the attribute names --&#62;首先，打印属性名称 */
    nFields = PQnfields(res);
    for (i = 0; i &#60; nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* &#60;!-- next, print out the rows --&#62;然后打印行 */
    for (i = 0; i &#60; PQntuples(res); i++)
    {
        for (j = 0; j &#60; nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* &#60;!-- close the portal ... we don't bother to check for errors ... --&#62;关闭入口 ... 我们不用检查错误 ... */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* &#60;!-- end the transaction --&#62;结束事务 */
    res = PQexec(conn, "END");
    PQclear(res);

    /* &#60;!-- close the connection to the database and cleanup --&#62;关闭数据库连接并清理 */
    PQfinish(conn);

    return 0;
}</PRE></DIV><DIV CLASS="EXAMPLE"><A NAME="LIBPQ-EXAMPLE-2"></A><P><B>&#20363; 31-2. <SPAN CLASS="APPLICATION">libpq</SPAN> 例子程序 2</B></P><PRE CLASS="PROGRAMLISTING">/*
 * testlibpq2.c
 *      &#60;!-- Test of the asynchronous notification interface --&#62;测试异步通知接口
 *
 * &#60;!-- Start this program, then from psql in another window do --&#62;运行此程序，然后从另外一个窗口的 psql 里运行
 *   NOTIFY TBL2;
 * &#60;!-- Repeat four times to get this program to exit. --&#62;重复四次，直到程序退出
 *
 &#60;!--
 * Or, if you want to get fancy, try this:
 * populate a database with the following commands
 * (provided in src/test/examples/testlibpq2.sql):
 --&#62;
 * 或者，如果你想好玩一点，用下面命令填充数据库：
 * （在 src/test/examples/testlibpq2.sql 里提供）：
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * &#60;!-- and do this four times: --&#62;然后做四次：
 *
 *   INSERT INTO TBL1 VALUES (10);
 */
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;errno.h&#62;
#include &#60;sys/time.h&#62;
#include &#60;libpq-fe.h&#62;

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     &#60;!--
 * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
 --&#62;
 * 如果用户在命令行上提供了参数，
     * 那么拿它当作 conninfo 字串；否则缺省设置是 dbname=postgres
     * 并且对其它连接使用环境变量或者缺省值。
     */
    if (argc &#62; 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* &#60;!-- Make a connection to the database --&#62;和数据库建立连接 */
    conn = PQconnectdb(conninfo);

    /* &#60;!-- Check to see that the backend connection was successfully made --&#62;检查一下与服务器的连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     &#60;!--
 * Issue LISTEN command to enable notifications from the rule's NOTIFY.
 --&#62;
 * 发出 LISTEN 命令打开来自规则 NOTIFY 的通知
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     &#60;!--
 * should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
 --&#62;
 * 如果不再需要了，我们应该 PQclear PGresult ，以避免内存泄漏
     */
    PQclear(res);

    /* &#60;!-- Quit after four notifies are received. --&#62;收到四次通知之后退出。 */
    nnotifies = 0;
    while (nnotifies &#60; 4)
    {
        /*
         &#60;!--
 * Sleep until something happens on the connection.  We use select(2)
         * to wait for input, but you could also use poll() or similar
         * facilities.
 --&#62;
 * 睡眠，直到某些事件发生。我们使用 select(2) 等待输入，
         * 但是也可以用 poll() 或者类似的设施。
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock &#60; 0)
            break;              /* &#60;!-- shouldn't happen --&#62;不应该发生 */

        FD_ZERO(&#38;input_mask);
        FD_SET(sock, &#38;input_mask);

        if (select(sock + 1, &#38;input_mask, NULL, NULL, NULL) &#60; 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* &#60;!-- Now check for input --&#62;现在检查输入 */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify-&#62;relname, notify-&#62;be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

    /* &#60;!-- close the connection to the database and cleanup --&#62;关闭数据连接并清理 */
    PQfinish(conn);

    return 0;
}</PRE></DIV><DIV CLASS="EXAMPLE"><A NAME="LIBPQ-EXAMPLE-3"></A><P><B>&#20363; 31-3. <SPAN CLASS="APPLICATION">libpq</SPAN> 例子程序 3</B></P><PRE CLASS="PROGRAMLISTING">/*
 * testlibpq3.c
 *      &#60;!-- Test out-of-line parameters and binary I/O. --&#62;测试外联参数和二进制I/O。
 *
&#60;!--
  * Before running this, populate a database with the following commands
 * (provided in src/test/examples/testlibpq3.sql):
 --&#62;
  * 在运行这个例子之前，用下面的命令填充一个数据库
 * （在 src/test/examples/testlibpq3.sql 里提供）：
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * &#60;!-- The expected output is: --&#62;期望的输出是：
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;sys/types.h&#62;
#include &#60;libpq-fe.h&#62;

/* for ntohl/htonl */
#include &#60;netinet/in.h&#62;
#include &#60;arpa/inet.h&#62;


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
&#60;!--
  * This function prints a query result that is a binary-format fetch from
 * a table defined as in the comment above.  We split it out because the
 * main() function uses it twice.
 --&#62;
 * 这个函数打印查询结果，这些结果是二进制格式，从上面的
 * 注释里面创建的表中抓取出来的。我们把这个函数单独拆出来
 * 是因为 main() 函数用了它两次。
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* &#60;!-- Use PQfnumber to avoid assumptions about field order in result --&#62;使用 PQfnumber 来避免对结果中的字段顺序进行假设 */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i &#60; PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* &#60;!-- Get the field values (we ignore possibility they are null!) --&#62;获取字段值（我们忽略了它们可能为空的这个可能！） */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         &#60;!--
 * The binary representation of INT4 is in network byte order, which
         * we'd better coerce to the local byte order.
 --&#62;
 * INT4 的二进制表现形式是网络字节序，
         * 我们最好转换成本地字节序。
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         &#60;!--
 * The binary representation of TEXT is, well, text, and since libpq
         * was nice enough to append a zero byte to it, it'll work just fine
         * as a C string.
         *
         * The binary representation of BYTEA is a bunch of bytes, which could
         * include embedded nulls so we have to pay attention to field length.
 --&#62;
 * TEXT 的二进制表现形式是，嗯，文本，因此 libpq 足够给它附加一个字节零，
         * 因此把它看做 C 字串就挺好。
         *
         * BYTEA 的二进制表现形式是一堆字节，里面可能包含嵌入的空值，
         * 因此我们必须注意字段长度。
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j &#60; blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     &#60;!-- 
 * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
 --&#62;
 * 如果用户在命令行上提供了参数，
     * 那么拿它当作 conninfo 字串；否则缺省设置是 dbname=postgres
     * 并且对其它连接参数使用环境变量或者缺省值。
     */
    if (argc &#62; 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* &#60;!-- Make a connection to the database --&#62;和数据库建立连接 */
    conn = PQconnectdb(conninfo);

    /* &#60;!-- Check to see that the backend connection was successfully made --&#62;检查一下与服务器的连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     &#60;!-- 
 * The point of this program is to illustrate use of PQexecParams() with
     * out-of-line parameters, as well as binary transmission of data.
     *
     * This first example transmits the parameters as text, but receives the
     * results in binary format.  By using out-of-line parameters we can
     * avoid a lot of tedious mucking about with quoting and escaping, even
     * though the data is text.  Notice how we don't have to do anything
     * special with the quote mark in the parameter value.
 --&#62;
 * 这个程序是用来演示使用外联参数的 PQexecParams()，
     * 以及数据的二进制传输。第一个例子使用文本传输参数，
     * 但是用二进制格式接收结果。通过使用外联参数，我们可以避免大量
     * 枯燥的字串的引用和转义，即使数据是文本。请注意我们这里不需要对参数值里的引号
     * 做任何特殊的处理。
     */

    /* &#60;!-- Here is our out-of-line parameter value  --&#62;这里是我们的外联参数值*/
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* &#60;!-- one param --&#62;一个参数 */
                       NULL,    /* &#60;!-- let the backend deduce param type --&#62;让后端推出参数类型 */
                       paramValues,
                       NULL,    /* &#60;!-- don't need param lengths since text --&#62;因为是文本，所以必须要参数长度 */
                       NULL,    /* &#60;!-- default to all text params --&#62;缺省是全部文本参数 */
                       1);      /* &#60;!-- ask for binary results --&#62;要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     &#60;!--
 * In this second example we transmit an integer parameter in binary
     * form, and again retrieve the results in binary form.
     *
     * Although we tell PQexecParams we are letting the backend deduce
     * parameter type, we really force the decision by casting the parameter
     * symbol in the query text.  This is a good safety measure when sending
     * binary parameters.
 --&#62;
 * 在这个第二个例子里，我们以二进制格式传输一个整数参数，
     * 然后还是以二进制格式检索结果。
     *
     * 尽管我们告诉 PQexecParams，我们让后端推导参数类型，
     * 实际上我们通过在查询字串里转换参数符号的方法强制了决定的做出。
     * 在发送二进制参数的时候，这是一个很好的安全检查。
     */

    /* &#60;!-- Convert integer value "2" to network byte order --&#62;把整数值 "2" 转换成网络字节序 */
    binaryIntVal = htonl((uint32_t) 2);

    /* &#60;!-- Set up parameter arrays for PQexecParams --&#62;为 PQexecParams 设置参数数组 */
    paramValues[0] = (char *) &#38;binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* &#60;!-- binary --&#62;二进制 */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* &#60;!-- one param --&#62;一个参数 */
                       NULL,    /* &#60;!-- let the backend deduce param type --&#62;让后端推导参数类型 */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* &#60;!-- ask for binary results --&#62;要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* &#60;!-- close the connection to the database and cleanup --&#62;关闭与数据库的连接并清理 */
    PQfinish(conn);

    return 0;
}</PRE></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-build.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/largeobjects.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">制作<SPAN CLASS="APPLICATION">libpq</SPAN>程序</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">大对象</TD></TR></TABLE></DIV></BODY></HTML>
