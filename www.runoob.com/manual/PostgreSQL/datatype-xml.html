<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>XML 类型</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="数据类型" HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html"><LINK REL="PREVIOUS" TITLE="UUID 类型" HREF="datatype-uuid.html"><LINK REL="NEXT" TITLE="JSON 类型" HREF="datatype-json.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/datatype.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="UUID 类型" HREF="datatype-uuid.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 8. 数据类型</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="JSON 类型" HREF="datatype-json.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="DATATYPE-XML">8.13. <ACRONYM CLASS="ACRONYM">XML</ACRONYM> 类型</A></H1><P><TT CLASS="TYPE">xml</TT>数据类型可以用于存储XML数据。
将XML数据存到<TT CLASS="TYPE">text</TT>类型中的优势在于它能够为结构良好性来检查输入值，
并且还支持函数对其进行类型安全性检查，可参阅<A HREF="functions-xml.html">第 9.14 &#33410;</A>。
要使用这个数据类型，编译时必须使用<TT CLASS="COMMAND">configure --with-libxml</TT>。</P><P><TT CLASS="TYPE">xml</TT>可以存储由XML标准定义的格式良好的<SPAN CLASS="QUOTE">"文档"</SPAN>，
以及由XML标准中的<TT CLASS="LITERAL">XMLDecl? content</TT>定义的<SPAN CLASS="QUOTE">"内容"</SPAN>片段，
大致上，这意味着内容片段可以有多个顶级元素或字符节点。
<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>xmlvalue</I></TT> IS DOCUMENT</TT>
表达式可以用来判断一个特定的<TT CLASS="TYPE">xml</TT>值是一个完整的文件还是内容片段。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN7032">8.13.1. 创建XML值</A></H2><P>
使用函数<CODE CLASS="FUNCTION">xmlparse</CODE>:
来从字符数据产生<TT CLASS="TYPE">xml</TT>类型的值：
</P><PRE CLASS="SYNOPSIS">XMLPARSE ( { DOCUMENT | CONTENT } <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>)</PRE><P>
例子：
</P><PRE CLASS="PROGRAMLISTING">XMLPARSE (DOCUMENT '&#60;?xml version="1.0"?&#62;&#60;book&#62;&#60;title&#62;Manual&#60;/title&#62;&#60;chapter&#62;...&#60;/chapter&#62;&#60;/book&#62;')
XMLPARSE (CONTENT 'abc&#60;foo&#62;bar&#60;/foo&#62;&#60;bar&#62;foo&#60;/bar&#62;')</PRE><P>
然而根据SQL标准，这是唯一的用于将字符串转换成XML值的方式，PostgreSQL特有的语法也可以使用：
</P><PRE CLASS="PROGRAMLISTING">xml '&#60;foo&#62;bar&#60;/foo&#62;'
'&#60;foo&#62;bar&#60;/foo&#62;'::xml</PRE><P>
</P><P><TT CLASS="TYPE">xml</TT>类型对一个文档类型声明（DTD）不会验证输入值，
即使输入值声明了一个DTD。目前没有内置支持用于对其他XML架构语言（如XML Schema）验证。 </P><P>使用函数<CODE CLASS="FUNCTION">xmlserialize</CODE>:
来从<TT CLASS="TYPE">xml</TT>产生一个字符串。
</P><PRE CLASS="SYNOPSIS">XMLSERIALIZE ( { DOCUMENT | CONTENT } <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> )</PRE><P>
<TT CLASS="REPLACEABLE"><I>type</I></TT>可以是<TT CLASS="TYPE">character</TT>，<TT CLASS="TYPE">character varying</TT>
或<TT CLASS="TYPE">text</TT>(或其中某个的变种)。同时，根据SQL标准，
这是<TT CLASS="TYPE">xml</TT>和字符类型之间的唯一的转换方式，但PostgreSQL仍支持简单的值转换。
</P><P>当一个字符串值在没有通过<TT CLASS="TYPE">XMLPARSE</TT>或<TT CLASS="TYPE">XMLSERIALIZE</TT>的情况下，
与<TT CLASS="TYPE">xml</TT>类型进行转换时，分别的，选择<TT CLASS="LITERAL">DOCUMENT</TT>与<TT CLASS="LITERAL">CONTENT</TT>
是由<SPAN CLASS="QUOTE">"XML option"</SPAN>
会话配置参数决定，这个配置参数可以由标准命令来设置：
</P><PRE CLASS="SYNOPSIS">SET XML OPTION { DOCUMENT | CONTENT };</PRE><P>
或更多类似的PostgreSQL语法：
</P><PRE CLASS="SYNOPSIS">SET xmloption TO { DOCUMENT | CONTENT };</PRE><P>
默认是<TT CLASS="LITERAL">CONTENT</TT>，因此所有的XML数据格式都能支持。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>随着默认XML选项的设置，如果字符串中包含一个文档类型声明，
那么你不能直接将其转换成<TT CLASS="TYPE">xml</TT>类型，因为XML内容片断的定义不支持。
如果非得需要这么做，要么使用<TT CLASS="LITERAL">XMLPARSE</TT>，要么更改XML选项。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN7076">8.13.2. 编码处理</A></H2><P>在对客户端和服务器端进行多字符编码，以及在通过它们传递XML数据时需要格外注意。
当使用文本模式（正常模式）在服务器端和客户端之间传递查询和查询结果时，
PostgreSQL在各自终端对所有传递的字符数据和字符编码进行相互转换，参阅<A HREF="multibyte.html">第 22.3 &#33410;</A>。
这包括XML值的字符串表示形式，如上面的例子。这通常意味着XML数据中的编码声明，
在客户端和服务器之间传递时，可以成为无效字符数据转换为其他编码。
这是因为枚举编码声明没有改变。为了应对该问题，
提交输入到<TT CLASS="TYPE">xml</TT> 类型的字符串中的编码声明会被<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">ignored</I></SPAN>，
同时，内容会被认为是在当前服务器编码中。所以，对正确的处理来说，
XML数据的字符串必须从在当前客户端编码中的客户端发送。客户端有责任，
要么在传递到服务器之前将文档转换成当前客户端编码，要么适当的调整客户端编码。
输出时，<TT CLASS="TYPE">xml</TT>类型的值不会有编码声明，
同时客户端会认为所有的数据都是在当前客户端编码之中的。</P><P>当使用二进制模式在服务器和客户端之间传递查询参数和查询结果，没有执行字符集转换，
因此解决方法是不同的。在这种情况下，将会遵守XML数据中的编码声明，
并且如果声明不存在，数据会被假定为UTF-8格式(如同XML标准要求那样，
但需要注意的是PostgreSQL不支持UTF-16)。输出时，会对数据进行编码声明以指定客户端编码，
除非客户端编码格式是UTF-8。</P><P>不用说，如果XML数据编码格式，客户端编码格式，以及服务器编码格式都一样，
那么用PostgreSQL处理XML数据将会减少错误，并且效率会很高。在内部，
XML数据是用UTF-8编码格式处理的，因此，如果服务器端编码也是UTF-8时，计算性能会很高。</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P>当服务器编码非UTF-8格式时，一些XML相关的函数可能完全不支持非ASCII数据，
特别是<CODE CLASS="FUNCTION">xpath()</CODE> 函数。</P></TD></TR></TABLE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN7088">8.13.3. 访问XML值</A></H2><P><TT CLASS="TYPE">xml</TT>数据类型有些特殊，因为它不提供比较运算符。这是因为对XML数据，
没有很好的定义和通用的比较运算符。这样做的一个后果是，
不能通过<TT CLASS="TYPE">xml</TT>与检索值的比较来检索行。因此XML值必须带有一个单独的关键值，
如一个ID。另一个解决比较XML值的方法是，先将它们转换成字符串，
但需要注意的是字符串比较与一个有用的XML比较方法无关。</P><P>因为没有针对<TT CLASS="TYPE">xml</TT>数据类型的比较运算符，因此不能在这种类型的字段上直接创建索引。
如果需要对XML数据进行快速搜索，可能的解决方法包括将表达式转换成一个字符串类型，
然后对它进行索引，或索引一个XPath表达式。当然，实际查询是不得不进行调整，
以使用一个索引表达式进行检索。</P><P>PostgreSQL中的文本检索功能也可用于加快XML数据的全文搜索。
但必要的预处理支持在PostgreSQL中还不能获得。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="datatype-uuid.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="datatype-json.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><ACRONYM CLASS="ACRONYM">UUID</ACRONYM> 类型</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><ACRONYM CLASS="ACRONYM">JSON</ACRONYM> 类型</TD></TR></TABLE></DIV></BODY></HTML>
