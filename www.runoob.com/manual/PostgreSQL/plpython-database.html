<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>数据库访问</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PL/Python - Python 过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/plpython.html"><LINK REL="PREVIOUS" TITLE="触发器函数" HREF="plpython-trigger.html"><LINK REL="NEXT" TITLE="明确的子事务" HREF="plpython-subtransaction.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/plpython.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="触发器函数" HREF="plpython-trigger.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpython.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 43. PL/Python - Python 过程语言</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="明确的子事务" HREF="plpython-subtransaction.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PLPYTHON-DATABASE">43.7. 数据库访问</A></H1><P>PL/Python语言模块自动输入一个叫<TT CLASS="LITERAL">plpy</TT>的Python模块。
在这个模块里的函数和常量可以在Python代码里以
<TT CLASS="LITERAL">plpy.<TT CLASS="REPLACEABLE"><I>foo</I></TT></TT>的名字获得。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN60958">43.7.1. 数据库访问函数</A></H2><P><TT CLASS="LITERAL">plpy</TT>模块提供几个函数执行数据库命令：</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">plpy.<CODE CLASS="FUNCTION">execute</CODE>(<TT CLASS="REPLACEABLE"><I>query</I></TT> [, <TT CLASS="REPLACEABLE"><I>max-rows</I></TT>])</TT></DT><DD><P>拿一个查询字符串和一个可选的行限制参数调用<CODE CLASS="FUNCTION">plpy.execute</CODE>可以运行该查询，
并且结果返回到一个结果对象里。</P><P>结果对象仿真一个列表或者是字典对象。结果对象通过行号和字段名来访问。例如：
</P><PRE CLASS="PROGRAMLISTING">rv = plpy.execute("SELECT * FROM my_table", 5)</PRE><P>
返回来自<TT CLASS="LITERAL">my_table</TT>的最多5行。如果<TT CLASS="LITERAL">my_table</TT>
有一个<TT CLASS="LITERAL">my_column</TT>字段，那么你可以用下面的方法访问它：
</P><PRE CLASS="PROGRAMLISTING">foo = rv[i]["my_column"]</PRE><P>
返回的行数可以使用内建<CODE CLASS="FUNCTION">len</CODE>函数获得。
</P><P>
结果对象有下面这些额外的方法：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">nrows</CODE>()</TT></DT><DD><P>返回该命令处理的行数。请注意，这与返回的行数不一定相同。例如，<TT CLASS="COMMAND">UPDATE</TT>
命令将设置这个值，但是不会返回任何行（除非使用了<TT CLASS="LITERAL">RETURNING</TT>）。</P></DD><DT><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">status</CODE>()</TT></DT><DD><P><CODE CLASS="FUNCTION">SPI_execute()</CODE>的返回值。</P></DD><DT><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">colnames</CODE>()</TT><BR><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">coltypes</CODE>()</TT><BR><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">coltypmods</CODE>()</TT></DT><DD><P>分别返回一个字段名的列表、字段类型OID的列表和该字段的特定于类型的类型修饰符的列表。</P><P>这些方式在从一个不产生结果集命令的结果对象上调用时产生一个意外，比如，
不带有<TT CLASS="LITERAL">RETURNING</TT>的<TT CLASS="COMMAND">UPDATE</TT>，或<TT CLASS="COMMAND">DROP TABLE</TT>。
但是在一个包含零行的结果集上使用这些方法是可以的。</P></DD><DT><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">__str__</CODE>()</TT></DT><DD><P>定义了标准的<TT CLASS="LITERAL">__str__</TT>方法，所以有可能，比如，
使用<TT CLASS="LITERAL">plpy.debug(rv)</TT>调试查询执行结果。</P></DD></DL></DIV><P>
</P><P>结果对象可以被修改。</P><P>请注意，调用<TT CLASS="LITERAL">plpy.execute</TT>将导致读取整个结果集到内存中。
只有在你确定结果集将相对较小的情况下使用这个函数。
如果你不希望在抓取大的结果集时承担过度使用内存的风险，
那么使用<TT CLASS="LITERAL">plpy.cursor</TT>而不是<TT CLASS="LITERAL">plpy.execute</TT>。</P></DD><DT><TT CLASS="LITERAL">plpy.<CODE CLASS="FUNCTION">prepare</CODE>(<TT CLASS="REPLACEABLE"><I>query</I></TT> [, <TT CLASS="REPLACEABLE"><I>argtypes</I></TT>])</TT><BR><TT CLASS="LITERAL">plpy.<CODE CLASS="FUNCTION">execute</CODE>(<TT CLASS="REPLACEABLE"><I>plan</I></TT> [, <TT CLASS="REPLACEABLE"><I>arguments</I></TT> [, <TT CLASS="REPLACEABLE"><I>max-rows</I></TT>]])</TT></DT><DD><P>&#13;<CODE CLASS="FUNCTION">plpy.prepare</CODE>为查询准备执行规划。
它用一个查询字符串和一个参数类型列表调用，如果在查询中你有参数引用。比如：
</P><PRE CLASS="PROGRAMLISTING">plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])</PRE><P>
<TT CLASS="LITERAL">text</TT>是将作为<TT CLASS="LITERAL">$1</TT>传递的变量类型。
如果你不想传递任何参数到查询，那么第二个参数是可选的。
</P><P>在准备一个语句之后，你用函数<CODE CLASS="FUNCTION">plpy.execute</CODE>的一个变量运行它：
</P><PRE CLASS="PROGRAMLISTING">rv = plpy.execute(plan, ["name"], 5)</PRE><P>
传递的规划作为第一个参数（而不是查询字符串），一个值的列表代入查询中作为第二个参数。
如果查询不希望有任何参数则第二个参数是可选的。第三个参数和以前一样，是可选的，行数限制。
</P><P>查询参数和结果行字段在PostgreSQL和<A HREF="plpython-data.html">第 43.3 &#33410;</A>描述的Python数据类型之间进行转换。
例外是目前不支持复合类型：当在查询结果中出现时，将拒绝他们作为查询参数，并且转换成字符串。
对于后者问题的解决方法，查询有时可以被改写，这样复合类型的结果作为一个结果行出现而不是一个结果行字段。
可选的，结果字符串可以手动的单独解析，但是不建议使用这个方法，因为它会过时。</P><P>在你用PL/Python模块准备一个计划的时候，该计划是自动保存的。请阅读 SPI 文档(<A HREF="http://school.yunwei.edu/manual/PostgreSQL/spi.html">第 44 &#31456;</A>)
获取这句话的含义。为了能有效的使用这个跨函数调用，需要使用永久存储字典
<TT CLASS="LITERAL">SD</TT>或<TT CLASS="LITERAL">GD</TT>之一(参阅<A HREF="plpython-sharing.html">第 43.4 &#33410;</A>)。比如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    plan = SD.setdefault("plan", plpy.prepare("SELECT 1"))
    # rest of function
$$ LANGUAGE plpythonu;</PRE><P>
</P></DD><DT><TT CLASS="LITERAL">plpy.<CODE CLASS="FUNCTION">cursor</CODE>(<TT CLASS="REPLACEABLE"><I>query</I></TT>)</TT><BR><TT CLASS="LITERAL">plpy.<CODE CLASS="FUNCTION">cursor</CODE>(<TT CLASS="REPLACEABLE"><I>plan</I></TT> [, <TT CLASS="REPLACEABLE"><I>arguments</I></TT>])</TT></DT><DD><P><TT CLASS="LITERAL">plpy.cursor</TT>函数接受和<TT CLASS="LITERAL">plpy.execute</TT>一样的参数
（除了行限制），并返回一个游标对象，它允许你在一个小的语块中处理大的结果集。
和<TT CLASS="LITERAL">plpy.execute</TT>一样，可以使用一个查询字符串或者一个带有参数列表的规划对象。</P><P>该游标对象提供一个<TT CLASS="LITERAL">fetch</TT>方法，接受一个整型参数并返回一个结果对象。
每次你调用<TT CLASS="LITERAL">fetch</TT>，返回的对象将包含下一批行，从不大于参数值。
一旦所有行都获得了，<TT CLASS="LITERAL">fetch</TT>开始返回一个空的结果对象。
游标对象也提供一个<A HREF="http://docs.python.org/library/stdtypes.html#iterator-types" TARGET="_top">迭代器接口</A>，
一次生成一行直到所有行都获得。这种方式获取的数据不作为结果对象返回，而是作为字典，
每个字典对应于一个结果行。</P><P>两种方式处理大表中数据的例子是：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))

return len(rows)
$$ LANGUAGE plpythonu;</PRE><P>
</P><P>游标会自动处理。但是如果你希望明确的释放游标持有的所有资源，使用<TT CLASS="LITERAL">close</TT>方法。
一旦关闭了，游标不再能够获取。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>不要混淆<TT CLASS="LITERAL">plpy.cursor</TT>创建的对象和
<A HREF="http://www.python.org/dev/peps/pep-0249/" TARGET="_top">Python数据库API说明</A>定义的DB-API游标。
它们除了名字相同外没有什么相同的。</P></BLOCKQUOTE></DIV></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPYTHON-TRAPPING">43.7.2. 捕获错误</A></H2><P>访问数据库的函数可能会遇到错误，导致它们退出并引发异常。<CODE CLASS="FUNCTION">plpy.execute</CODE>
和<CODE CLASS="FUNCTION">plpy.prepare</CODE>都会一起一个<TT CLASS="LITERAL">plpy.SPIError</TT>
的子类的实例，缺省将终止函数。这个错误可以像任何其他Python异常那样处理，
通过使用<TT CLASS="LITERAL">try/except</TT>构造。例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        return "something went wrong"
    else:
        return "Joe added"
$$ LANGUAGE plpythonu;</PRE><P>
</P><P>引发的异常的实际类对应于导致该错误的特定条件。查阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/errcodes-appendix.html#ERRCODES-TABLE">&#34920; A-1</A>获取可能的条件的列表。
模块<TT CLASS="LITERAL">plpy.spiexceptions</TT>为每个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
条件定义一个异常类，从条件名中派生它们的名字。例如，<TT CLASS="LITERAL">division_by_zero</TT>
成为<TT CLASS="LITERAL">DivisionByZero</TT>，<TT CLASS="LITERAL">unique_violation</TT>成为
<TT CLASS="LITERAL">UniqueViolation</TT>，<TT CLASS="LITERAL">fdw_error</TT>成为<TT CLASS="LITERAL">FdwError</TT>等等。
每个异常类都从<TT CLASS="LITERAL">SPIError</TT>中继承。这个分离使得它更容易处理特定的错误，例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError, e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpythonu;</PRE><P>
请注意，因为所有来自<TT CLASS="LITERAL">plpy.spiexceptions</TT>模块的异常都从
<TT CLASS="LITERAL">SPIError</TT>继承，所以<TT CLASS="LITERAL">except</TT>子句处理它将捕获任何数据库访问错误。
</P><P>作为处理不同错误条件的一个替换方式，你可以捕获<TT CLASS="LITERAL">SPIError</TT>异常。
然后在<TT CLASS="LITERAL">except</TT>块中通过查看异常对象的<TT CLASS="LITERAL">sqlstate</TT>
属性确定特定的错误条件。这个属性是一个包含<SPAN CLASS="QUOTE">"SQLSTATE"</SPAN>错误代码的字符串值。
这个方法提供了差不多相同的功能。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="plpython-trigger.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="plpython-subtransaction.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">触发器函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpython.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">明确的子事务</TD></TR></TABLE></DIV></BODY></HTML>
