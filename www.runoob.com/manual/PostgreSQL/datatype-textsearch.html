<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>文本搜索类型</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="数据类型" HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html"><LINK REL="PREVIOUS" TITLE="位串类型" HREF="datatype-bit.html"><LINK REL="NEXT" TITLE="UUID 类型" HREF="datatype-uuid.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/datatype.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="位串类型" HREF="datatype-bit.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 8. 数据类型</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="UUID 类型" HREF="datatype-uuid.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="DATATYPE-TEXTSEARCH">8.11. 文本搜索类型</A></H1><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>提供了两种数据类型用于支持全文检索，
即通过自然语言<I CLASS="FIRSTTERM">documents</I>的集合来找到那些匹配一个<I CLASS="FIRSTTERM">query</I>
的检索。<TT CLASS="TYPE">tsvector</TT>类型产生一个文档（以优化了全文检索的形式），
<TT CLASS="TYPE">tsquery</TT>类型用于代表查询。<A HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html">第 12 &#31456;</A>
中说明了这两个类型，同时<A HREF="functions-textsearch.html">第 9.13 &#33410;</A>
总结了相关的函数和操作符。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DATATYPE-TSVECTOR">8.11.1. <TT CLASS="TYPE">tsvector</TT></A></H2><P><TT CLASS="TYPE">tsvector</TT>的值是一个无重复值的<I CLASS="FIRSTTERM">lexemes</I>排序列表，
即一些同一个词的不同变种的<I CLASS="FIRSTTERM">标准化</I> （可参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html">第 12 &#31456;</A>）。
在输入的同时会自动排序和消除重复，如：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'</PRE><P>
为了包含空格或标点符号，可以用引号标记：
</P><PRE CLASS="PROGRAMLISTING">SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector                  
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'</PRE><P>
（在这个例子中，我们使用了双引号美元字符串文本，
下一个例子是为了避免文本中双引号的混淆。）枚举的引号和反斜杠必须双倍：
</P><PRE CLASS="PROGRAMLISTING">SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector                    
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'</PRE><P>
可选的，整型<I CLASS="FIRSTTERM">positions</I>也可以放到词汇中：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4</PRE><P>
位置通常表示文档中的源字的位置。位置信息可以用于<I CLASS="FIRSTTERM">proximity ranking</I>。
位置值的范围是1到16383，最大值默认是16383。相同词的重复位会被忽略掉。
</P><P>拥有位置的词汇甚至可以用一个<I CLASS="FIRSTTERM">权</I>来标记，这个权可以是<TT CLASS="LITERAL">A</TT>，
<TT CLASS="LITERAL">B</TT>，<TT CLASS="LITERAL">C</TT>或<TT CLASS="LITERAL">D</TT>。
默认的是<TT CLASS="LITERAL">D</TT>，因此输出中不会出现：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector          
----------------------------
 'a':1A 'cat':5 'fat':2B,4C</PRE><P>
权可以用来反映文档结构，如：标记标题以与主体相区别。
全文检索排序函数可以为不同的权标记来分配不同的优先级。
</P><P>充分理解<TT CLASS="TYPE">tsvector</TT>类型不能自己标准化这一点是很重要的，
它假设传递给它的单词对应用程序来说是恰当的标准化了的，如：
</P><PRE CLASS="PROGRAMLISTING">select 'The Fat Rats'::tsvector;
      tsvector      
--------------------
 'Fat' 'Rats' 'The'</PRE><P>
对大多数的英文全文检索应用来说，上面的单词会被认为非规范化的，
但<TT CLASS="TYPE">tsvector</TT>并不关心这些。原始文件中的文字应该通过<CODE CLASS="FUNCTION">to_tsvector</CODE>
来为检索恰当的规范化这些单词:
</P><PRE CLASS="PROGRAMLISTING">SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector   
-----------------
 'fat':2 'rat':3</PRE><P>
详细信息可参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html">第 12 &#31456;</A>。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DATATYPE-TSQUERY">8.11.2. <TT CLASS="TYPE">tsquery</TT></A></H2><P><TT CLASS="TYPE">tsquery</TT>存储用于检索的词汇，并且使用布尔操作符
<TT CLASS="LITERAL">&amp;</TT>(AND)，<TT CLASS="LITERAL">|</TT>(OR)和<TT CLASS="LITERAL">!</TT>(NOT)
来组合它们。括号用来强调操作符的分组：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'fat &amp; rat'::tsquery;
    tsquery    
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery          
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery         
------------------------
 'fat' &amp; 'rat' &amp; !'cat'</PRE><P>
在没有括号的情况下，<TT CLASS="LITERAL">!</TT>(NOT)结合的最紧密，
而<TT CLASS="LITERAL">&amp;</TT>(AND)结合的比<TT CLASS="LITERAL">|</TT>(OR)紧密。
</P><P>
可选的，<TT CLASS="TYPE">tsquery</TT>中的词汇可以被一个或多个权字母来标记，
这些权字母用来限制它们只能与带有匹配权的<TT CLASS="TYPE">tsvector</TT>词汇进行匹配。
</P><PRE CLASS="PROGRAMLISTING">SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'</PRE><P>
</P><P>同样，<TT CLASS="TYPE">tsquery</TT>中的词汇可以用<TT CLASS="LITERAL">*</TT>进行标记来指定前缀匹配：
</P><PRE CLASS="PROGRAMLISTING">SELECT 'super:*'::tsquery;
  tsquery  
-----------
 'super':*</PRE><P>
这个查询可以匹配<TT CLASS="TYPE">tsvector</TT>中以<SPAN CLASS="QUOTE">"super"</SPAN>开始的任意单词。
请注意，前缀首先被文本搜索配置处理，这也就意味着下面的结果为真：
</P><PRE CLASS="PROGRAMLISTING">SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column? 
----------
 t
(1 row)</PRE><P>
因为<TT CLASS="LITERAL">postgres</TT>去掉后面后得到<TT CLASS="LITERAL">postgr</TT>:
</P><PRE CLASS="PROGRAMLISTING">SELECT to_tsquery('postgres:*');
 to_tsquery 
------------
 'postgr':*
(1 row)</PRE><P>
这样就匹配<TT CLASS="LITERAL">postgraduate</TT>了。
</P><P>词汇的引用规则与之前<TT CLASS="TYPE">tsvector</TT>中词汇的描述一样；并且，
与<TT CLASS="TYPE">tsvector</TT>一样，任何单词必须在转换为<TT CLASS="TYPE">tsquery</TT>类型前规范化。
<CODE CLASS="FUNCTION">to_tsquery</CODE>函数可以方便的用来执行规范化。
</P><PRE CLASS="PROGRAMLISTING">SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery    
------------------
 'fat':AB &amp; 'cat'</PRE><P>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="datatype-bit.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="datatype-uuid.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">位串类型</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><ACRONYM CLASS="ACRONYM">UUID</ACRONYM> 类型</TD></TR></TABLE></DIV></BODY></HTML>
