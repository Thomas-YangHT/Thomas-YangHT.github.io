<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>外数据封装查询规划</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="写一个外数据包" HREF="http://school.yunwei.edu/manual/PostgreSQL/fdwhandler.html"><LINK REL="PREVIOUS" TITLE="外数据封装辅助函数" HREF="fdw-helpers.html"><LINK REL="NEXT" TITLE="基因查询优化器" HREF="http://school.yunwei.edu/manual/PostgreSQL/geqo.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/fdwhandler.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="外数据封装辅助函数" HREF="fdw-helpers.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/fdwhandler.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 52. 写一个外数据包</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="基因查询优化器" HREF="http://school.yunwei.edu/manual/PostgreSQL/geqo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FDW-PLANNING">52.4. 外数据封装查询规划</A></H1><P> FDW回调函数<CODE CLASS="FUNCTION">GetForeignRelSize</CODE>,
<CODE CLASS="FUNCTION">GetForeignPaths</CODE>, <CODE CLASS="FUNCTION">GetForeignPlan</CODE>和
<CODE CLASS="FUNCTION">PlanForeignModify</CODE>必须适合<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>规划器的工作。
这有一些他们必须做的说明。</P><P> 在<TT CLASS="LITERAL">root</TT>和<TT CLASS="LITERAL">baserel</TT>中的信息可以用于减少从外表中（因此降低成本）读取的信息量。
<TT CLASS="LITERAL">baserel-&gt;baserestrictinfo</TT>特别有趣，正如它包含应该用于过滤读取的行的限制资格测试(<TT CLASS="LITERAL">WHERE</TT> clauses)。
（FDW本身不需要执行这些测试，正如核心执行者反而可以检查它们。）
<TT CLASS="LITERAL">baserel-&gt;reltargetlist</TT>可以用于决定需要抓取哪个列；但是注意它仅仅列出通过
<TT CLASS="STRUCTNAME">ForeignScan</TT>规划节点发出的列，不是在质量评估中使用的列也不是查询输出列。
</P><P> 各种私有字段可用于FDW规划函数保持信息。一般来说，无论在FDW私有字段存储什么
应该是palloc，所以它将在规划结束后被回收。</P><P> <TT CLASS="LITERAL">baserel-&gt;fdw_private</TT>是<TT CLASS="TYPE">空</TT>指针，可用于FDW规划函数存储与特定外表相关的
信息。当创建<TT CLASS="LITERAL">baserel</TT>结点时，核心规划器并不接触它除了初始化为NULL外。
从<CODE CLASS="FUNCTION">GetForeignRelSize</CODE>到<CODE CLASS="FUNCTION">GetForeignPaths</CODE>和/或者
<CODE CLASS="FUNCTION">GetForeignPaths</CODE>到<CODE CLASS="FUNCTION">GetForeignPlan</CODE>传递信息是非常有用的，
从而避免重复计算。
</P><P> <CODE CLASS="FUNCTION">GetForeignPaths</CODE>可以通过在<TT CLASS="STRUCTNAME">ForeignPath</TT>节点的
<TT CLASS="STRUCTFIELD">fdw_private</TT>字段存储私有信息标识不同访问路径的含义。
作为<TT CLASS="TYPE">List</TT>指针声明<TT CLASS="STRUCTFIELD">fdw_private</TT>，但是实际上可以包含任何由于
核心规划器没有接触的东西。然而，最好办法是通过<CODE CLASS="FUNCTION">nodeToString</CODE>可倾式表示形式，
用于调试后端可用支持。</P><P> <CODE CLASS="FUNCTION">GetForeignPlan</CODE>可以检查所选的<TT CLASS="STRUCTNAME">ForeignPath</TT>节点的
<TT CLASS="STRUCTFIELD">fdw_private</TT>字段，并且可以产生放在<TT CLASS="STRUCTNAME">ForeignScan</TT>
规划节点中的<TT CLASS="STRUCTFIELD">fdw_exprs</TT>和<TT CLASS="STRUCTFIELD">fdw_private</TT>列表，
在执行时间他们可用。这些列表必须在<CODE CLASS="FUNCTION">copyObject</CODE>知道如何拷贝的形式中被表示。
<TT CLASS="STRUCTFIELD">fdw_private</TT>列表没有其他限制，并且不能通过任何方式的核心后端进行解释。
<TT CLASS="STRUCTFIELD">fdw_exprs</TT>列表如果不是零，那么希望包含在运行时执行的表达式树。
这些树将通过规划器使得它们完全可执行进行后处理。
&#13;</P><P> 在<CODE CLASS="FUNCTION">GetForeignPlan</CODE>中，往往目标列表可以拷贝到规划节点中。
已通过的scan_clauses列表包含和<TT CLASS="LITERAL">baserel-&gt;baserestrictinfo</TT>相同分句，
但是为了更好的执行效率可能重新排序。
在简单情况下FDW可以从scan_clauses列表（使用<CODE CLASS="FUNCTION">extract_actual_clauses</CODE>）中删除<TT CLASS="STRUCTNAME">RestrictInfo</TT>节点，
并且将所有分句放入规划节点的资格列表中，这意味着在运行期间通过执行器将检查所有分句。
更多复杂的FDW可能检查一些内部分句，在这种情况下那些分句可以从规划节点的列表中删除，以便执行器
不会浪费复查它们的时间。
</P><P> 作为一个例子，FDW可能标识一些来自<TT CLASS="REPLACEABLE"><I>foreign_variable</I></TT> <TT CLASS="LITERAL">=</TT>
<TT CLASS="REPLACEABLE"><I>sub_expression</I></TT>的限制分句，它决定了在给定<TT CLASS="REPLACEABLE"><I>sub_expression</I></TT>的本地评估值的
远程服务器上被执行。在<CODE CLASS="FUNCTION">GetForeignPaths</CODE>期间产生了该分句的实际标识，
因为它会影响路径的成本估算。路径的<TT CLASS="STRUCTFIELD">fdw_private</TT>字段可能包含一个指向
已标识分句的<TT CLASS="STRUCTNAME">RestrictInfo</TT>节点的指针。然后<CODE CLASS="FUNCTION">GetForeignPlan</CODE>从scan_clauses中
删除该分句，但是增加<TT CLASS="REPLACEABLE"><I>sub_expression</I></TT>到<TT CLASS="STRUCTFIELD">fdw_exprs</TT>以确保
它获得可执行形式。它也可能将控制信息放到规划节点的<TT CLASS="STRUCTFIELD">fdw_private</TT>
字段以告知执行函数在运行时间执行什么。传送到远程服务器的查询可能涉及到像<TT CLASS="LITERAL">WHERE <TT CLASS="REPLACEABLE"><I>foreign_variable</I></TT> =
$1</TT>的一些内容，使用从<TT CLASS="STRUCTFIELD">fdw_exprs</TT>表达式树评估中获得的参数值。
</P><P> FDW应该总是构建至少一个仅仅依赖于表的限制分句的路径，在连接查询中，它也可能选择构建依赖于连接分句的路径，
比如 <TT CLASS="REPLACEABLE"><I>foreign_variable</I></TT> <TT CLASS="LITERAL">=</TT>
<TT CLASS="REPLACEABLE"><I>local_variable</I></TT>。该分句没有在<TT CLASS="LITERAL">baserel-&gt;baserestrictinfo</TT>中找到，
但是必须在关系的连接列表中寻找。
使用分句的路径被称为<SPAN CLASS="QUOTE">"参数化路径"</SPAN>。
它必须标识用于使用<TT CLASS="LITERAL">param_info</TT>合适值的已选择连接分句的其他关系；
使用<CODE CLASS="FUNCTION">get_baserel_parampathinfo</CODE>计算该值。在<CODE CLASS="FUNCTION">GetForeignPlan</CODE>中，
连接分句的<TT CLASS="REPLACEABLE"><I>local_variable</I></TT>部分将被添加到<TT CLASS="STRUCTFIELD">fdw_exprs</TT>中，
然后运行时该情况与普通限制分句一样运行。
</P><P> 当规划一个<TT CLASS="COMMAND">UPDATE</TT>或者<TT CLASS="COMMAND">DELETE</TT>的时候，
<CODE CLASS="FUNCTION">PlanForeignModify</CODE>可以查找外表的<TT CLASS="STRUCTNAME">RelOptInfo</TT>结构，
并且充分使用通过扫描规划函数预先创建的<TT CLASS="LITERAL">baserel-&gt;fdw_private</TT>数据。
然而，在<TT CLASS="COMMAND">INSERT</TT>中不扫描目标表，所以没有<TT CLASS="STRUCTNAME">RelOptInfo</TT>。
通过<CODE CLASS="FUNCTION">PlanForeignModify</CODE>返回的<TT CLASS="STRUCTNAME">List</TT>与<TT CLASS="STRUCTNAME">ForeignScan</TT>规划节点
的<TT CLASS="STRUCTFIELD">fdw_private</TT>列表有相同的限制，
即它必须包含<CODE CLASS="FUNCTION">copyObject</CODE>知道如何拷贝的结构。
</P><P> <TT CLASS="COMMAND">UPDATE</TT>或者<TT CLASS="COMMAND">DELETE</TT>反对外部数据源支持并发更新，推荐
<TT CLASS="LITERAL">ForeignScan</TT>操作锁定抓取的行，也许通过<TT CLASS="COMMAND">SELECT FOR UPDATE</TT>的等价物。
当在<TT CLASS="COMMAND">SELECT FOR UPDATE/SHARE</TT>引用外表时，FDW可能也会在抓取时选择锁定行。
如果没有做，就有关外表来说，
那么<TT CLASS="LITERAL">FOR UPDATE</TT>或者<TT CLASS="LITERAL">FOR SHARE</TT>选项本质上是无操作的。
这种操作可能会产生本地表操作上轻微的语义差异，行锁定通常尽可能的延迟：
远程行可能获得锁定即使他们随后没有本地应用限制或者连接条件。
然而，匹配局部语义确实需要每行的额外远程访问，并且不可能依赖于
外部数据源提供的锁定语义内容。
&#13;</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="fdw-helpers.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/geqo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">外数据封装辅助函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/fdwhandler.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">基因查询优化器</TD></TR></TABLE></DIV></BODY></HTML>
