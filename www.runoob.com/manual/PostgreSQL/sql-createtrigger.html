<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>CREATE TRIGGER</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="CREATE TEXT SEARCH TEMPLATE" HREF="sql-createtstemplate.html"><LINK REL="NEXT" TITLE="CREATE TYPE" HREF="sql-createtype.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/create_trigger.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="CREATE TEXT SEARCH TEMPLATE" HREF="sql-createtstemplate.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="CREATE TYPE" HREF="sql-createtype.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-CREATETRIGGER"></A>CREATE TRIGGER</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN73592"></A><H2>&#21517;&#31216;</H2>CREATE TRIGGER&nbsp;--&nbsp;定义一个新触发器</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN73597"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">CREATE [ CONSTRAINT ] TRIGGER <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> { BEFORE | AFTER | INSTEAD OF } { <TT
CLASS="REPLACEABLE"
><I
>event</I
></TT
> [ OR ... ] }
    ON <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>
    [ FROM <TT
CLASS="REPLACEABLE"
><I
>referenced_table_name</I
></TT
> ]
    { NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> ) ]
    EXECUTE PROCEDURE <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>arguments</I
></TT
> )

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>where <TT
CLASS="REPLACEABLE"
><I
>event</I
></TT
> can be one of:</SPAN
></SPAN
>

    INSERT
    UPDATE [ OF <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ... ] ]
    DELETE
    TRUNCATE</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73609"></A><H2>描述</H2><P><TT CLASS="COMMAND">CREATE TRIGGER</TT>创建一个新的触发器。
触发器将与指定表或视图关联并且将在特定事件发生时执行声明的
<TT CLASS="REPLACEABLE"><I>function_name</I></TT>函数。</P><P>触发器可以声明为在对记录进行操作之前(在检查约束之前和<TT CLASS="COMMAND">INSERT</TT>、
<TT CLASS="COMMAND">UPDATE</TT>、<TT CLASS="COMMAND">DELETE</TT>执行前)；
或操作完成之后(在检查约束之后和完成<TT CLASS="COMMAND">INSERT</TT>、
<TT CLASS="COMMAND">UPDATE</TT>、<TT CLASS="COMMAND">UPDATE</TT>操作)；或取代操作
（在视图上插入、更新或删除）触发。如果触发器在事件之前或者取代事件，
触发器可能略过当前记录的操作或改变被插入的记录(只对<TT CLASS="COMMAND">UPDATE</TT>
和<TT CLASS="COMMAND">UPDATE</TT>操作有效)。如果触发器在事件之后，
所有更改，包括其他触发器的影响，对触发器都是<SPAN CLASS="QUOTE">"可见"</SPAN>的。</P><P>一个被标记为<TT CLASS="LITERAL">FOR EACH ROW</TT>的触发器为操作修改的每一行都调用一次。
比如，一个影响 10 行的<TT CLASS="COMMAND">DELETE</TT>将导致任何在目标关系上的
<TT CLASS="LITERAL">ON DELETE</TT>触发器独立调用 10 次，每个被删除的行调用一次。
相比之下，一个被标记为<TT CLASS="LITERAL">FOR EACH STATEMENT</TT>的触发器只执行一次，
而不管有多少行被修改。（特别是，一个修改零行的操作仍然会导致合适的
<TT CLASS="LITERAL">FOR EACH STATEMENT</TT>触发器被执行。</P><P>指定为触发<TT CLASS="LITERAL">INSTEAD OF</TT>触发器事件的触发器必须被标记为
<TT CLASS="LITERAL">FOR EACH ROW</TT>，并且只能在视图上定义。视图上的<TT CLASS="LITERAL">BEFORE</TT>
和<TT CLASS="LITERAL">AFTER</TT>触发器必须被标记为<TT CLASS="LITERAL">FOR EACH STATEMENT</TT>。</P><P>另外，触发器可能被定义为为<TT CLASS="COMMAND">TRUNCATE</TT>触发，
尽管只有<TT CLASS="LITERAL">FOR EACH STATEMENT</TT>。</P><P>下面表总结中的触发器类型可能被用在表和视图上：</P><DIV CLASS="INFORMALTABLE"><P></P><A NAME="SUPPORTED-TRIGGER-TYPES"></A><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>何时</TH><TH>事件</TH><TH>行级别</TH><TH>语句级别</TH></TR></THEAD><TBODY><TR><TD ROWSPAN="2" ALIGN="CENTER"><TT CLASS="LITERAL">BEFORE</TT></TD><TD ALIGN="CENTER"><TT CLASS="COMMAND">INSERT</TT>/<TT CLASS="COMMAND">UPDATE</TT>/<TT CLASS="COMMAND">DELETE</TT></TD><TD ALIGN="CENTER">表</TD><TD ALIGN="CENTER">表和视图</TD></TR><TR><TD ALIGN="CENTER"><TT CLASS="COMMAND">TRUNCATE</TT></TD><TD ALIGN="CENTER">&mdash;</TD><TD ALIGN="CENTER">表</TD></TR><TR><TD ROWSPAN="2" ALIGN="CENTER"><TT CLASS="LITERAL">AFTER</TT></TD><TD ALIGN="CENTER"><TT CLASS="COMMAND">INSERT</TT>/<TT CLASS="COMMAND">UPDATE</TT>/<TT CLASS="COMMAND">DELETE</TT></TD><TD ALIGN="CENTER">表</TD><TD ALIGN="CENTER">表和视图</TD></TR><TR><TD ALIGN="CENTER"><TT CLASS="COMMAND">TRUNCATE</TT></TD><TD ALIGN="CENTER">&mdash;</TD><TD ALIGN="CENTER">表</TD></TR><TR><TD ROWSPAN="2" ALIGN="CENTER"><TT CLASS="LITERAL">INSTEAD OF</TT></TD><TD ALIGN="CENTER"><TT CLASS="COMMAND">INSERT</TT>/<TT CLASS="COMMAND">UPDATE</TT>/<TT CLASS="COMMAND">DELETE</TT></TD><TD ALIGN="CENTER">视图</TD><TD ALIGN="CENTER">&mdash;</TD></TR><TR><TD ALIGN="CENTER"><TT CLASS="COMMAND">TRUNCATE</TT></TD><TD ALIGN="CENTER">&mdash;</TD><TD ALIGN="CENTER">&mdash;</TD></TR></TBODY></TABLE><P></P></DIV><P>还有，触发器定义可以声明一个布尔<TT CLASS="LITERAL">WHEN</TT>条件，用来测试触发器是否应该被触发。
在行级别触发器中，<TT CLASS="LITERAL">WHEN</TT>条件可以检测该行的字段的旧的和/或新值。
语句级别的触发器也可以拥有<TT CLASS="LITERAL">WHEN</TT>条件，尽管该特性对于它们来说不太有用，
因为该条件不能引用表中的任何值。</P><P>如果多个同类型的触发器为同一事件做了定义，那么它们将按照字母顺序被触发。</P><P>当声明了<TT CLASS="LITERAL">CONSTRAINT</TT>选项时，这个命令创建一个<I CLASS="FIRSTTERM">约束触发器</I>。
作为正规触发器也是相同的，除了触发器触发的时间可以使用<A HREF="sql-set-constraints.html">SET CONSTRAINTS</A>
调整。约束触发器必须是<TT CLASS="LITERAL">AFTER ROW</TT>触发器。
它们可以在导致触发事件的语句的结束触发，也可以在包含的事务的结束触发；
在后面一种情况下，它们被称为<I CLASS="FIRSTTERM">延迟的</I>。
一个等待延迟的触发器触发也可以通过使用<TT CLASS="COMMAND">SET CONSTRAINTS</TT>强制立即发生。
当它们实现的约束非法时，约束触发器预计会引发一个异常。</P><P><TT CLASS="COMMAND">SELECT</TT>并不更改任何行，因此你不能创建
<TT CLASS="COMMAND">SELECT</TT>触发器。这种场合下规则和视图更合适些。</P><P>请参考<A HREF="http://school.yunwei.edu/manual/PostgreSQL/triggers.html">第 36 &#31456;</A>获取更多触发器信息。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73708"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>name</I></TT></DT><DD><P>赋予新触发器的名称。它必需和任何作用于同一表的触发器不同。
该名字不能是模式修饰的&mdash;触发器继承它的表的模式。
对于约束触发器，当使用<TT CLASS="COMMAND">SET CONSTRAINTS</TT>修改触发器的行为时，
这也是要使用的名字。</P></DD><DT><TT CLASS="LITERAL">BEFORE</TT><BR><TT CLASS="LITERAL">AFTER</TT><BR><TT CLASS="LITERAL">INSTEAD OF</TT></DT><DD><P>决定该函数是在事件之前、之后还是取代事件时调用。
约束触发器只能被声明为<TT CLASS="LITERAL">AFTER</TT>。</P></DD><DT><TT CLASS="REPLACEABLE"><I>event</I></TT></DT><DD><P><TT CLASS="LITERAL">INSERT</TT>、<TT CLASS="LITERAL">UPDATE</TT>、<TT CLASS="LITERAL">DELETE</TT>
或<TT CLASS="LITERAL">TRUNCATE</TT>之一。它声明激发触发器的事件。
多个事件可以用<TT CLASS="LITERAL">OR</TT>声明。</P><P>对于<TT CLASS="LITERAL">UPDATE</TT>事件，使用这个语法声明一个字段列表是可能的：
</P><PRE CLASS="SYNOPSIS">UPDATE OF <TT
CLASS="REPLACEABLE"
><I
>column_name1</I
></TT
> [, <TT
CLASS="REPLACEABLE"
><I
>column_name2</I
></TT
> ... ]</PRE><P>
该触发器将只在至少一个列表中的字段在<TT CLASS="COMMAND">UPDATE</TT>命令的目标中提及时触发。</P><P><TT CLASS="LITERAL">INSTEAD OF UPDATE</TT>事件不支持字段的列表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>table_name</I></TT></DT><DD><P>触发器作用的表或视图的名称(可以有模式修饰)</P></DD><DT><TT CLASS="REPLACEABLE"><I>referenced_table_name</I></TT></DT><DD><P>约束引用的另外一个表的名字（可以有模式修饰）。这个选项用于外键约束，
不推荐用于一般用途。只能为约束触发器指定。</P></DD><DT><TT CLASS="LITERAL">DEFERRABLE</TT><BR><TT CLASS="LITERAL">NOT DEFERRABLE</TT><BR><TT CLASS="LITERAL">INITIALLY IMMEDIATE</TT><BR><TT CLASS="LITERAL">INITIALLY DEFERRED</TT></DT><DD><P>触发器的默认时机。参阅<A HREF="sql-createtable.html">CREATE TABLE</A>文档获取这些约束选项的详细信息。
只能为约束触发器指定。</P></DD><DT><TT CLASS="LITERAL">FOR EACH ROW</TT><BR><TT CLASS="LITERAL">FOR EACH STATEMENT</TT></DT><DD><P>这些选项声明触发器过程是否为触发器事件影响的每个行触发一次，
还是只为每条 SQL 语句触发一次。如果都没有声明，
那么<TT CLASS="LITERAL">FOR EACH STATEMENT</TT>将是缺省。
约束触发器只能声明为<TT CLASS="LITERAL">FOR EACH ROW</TT>。</P></DD><DT><TT CLASS="REPLACEABLE"><I>condition</I></TT></DT><DD><P>一个决定触发器函数实际上是否执行的布尔表达式。如果声明了<TT CLASS="LITERAL">WHEN</TT>，
那么该函数只有<TT CLASS="REPLACEABLE"><I>condition</I></TT>
返回<TT CLASS="LITERAL">true</TT>时被调用。在<TT CLASS="LITERAL">FOR EACH ROW</TT>触发器中，
<TT CLASS="LITERAL">WHEN</TT>条件可以通过分别写<TT CLASS="LITERAL">OLD.<TT CLASS="REPLACEABLE"><I>column_name</I></TT></TT>或<TT CLASS="LITERAL">NEW.<TT CLASS="REPLACEABLE"><I>column_name</I></TT></TT>参考字段的旧的和/或新的行值。
当然，<TT CLASS="LITERAL">INSERT</TT>触发器不能参考<TT CLASS="LITERAL">OLD</TT>，
<TT CLASS="LITERAL">OLD</TT>触发器不能参考<TT CLASS="LITERAL">NEW</TT>。</P><P><TT CLASS="LITERAL">INSTEAD OF</TT>触发器不支持<TT CLASS="LITERAL">WHEN</TT>条件。</P><P>目前，<TT CLASS="LITERAL">WHEN</TT>表达式不能包含子查询。</P><P>请注意，对于约束触发器，<TT CLASS="LITERAL">WHEN</TT>条件的计算是不延迟的，
只是在行更新操作执行之后立即发生。如果该条件计算不为真，
那么触发器就不排队延迟执行。</P></DD><DT><TT CLASS="REPLACEABLE"><I>function_name</I></TT></DT><DD><P>一个用户提供的函数，它声明为不接受参数并且返回<TT CLASS="LITERAL">trigger</TT>类型，
该函数将在触发器被触发时调用。</P></DD><DT><TT CLASS="REPLACEABLE"><I>arguments</I></TT></DT><DD><P>一个可选的用逗号分隔的参数列表，它将在触发器执行的时候提供给函数。
这些参数是文本字符串常量。也可以在这里写简单的名字和数值常量，
但是它们会被转换成字符串。请检查该触发器函数的实现语言的描述，
找出如何在该函数中访问这些参数；这些参数可能和普通的函数参数不同。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="SQL-CREATETRIGGER-NOTES"></A><H2>注意</H2><P>要在表上创建一个触发器，用户必需在该表上有<TT CLASS="LITERAL">TRIGGER</TT>权限。
用户也必须在触发器函数上有<TT CLASS="LITERAL">EXECUTE</TT>权限。</P><P>使用<A HREF="sql-droptrigger.html">DROP TRIGGER</A>删除触发器。</P><P>字段特有的触发器（使用<TT CLASS="LITERAL">UPDATE OF <TT CLASS="REPLACEABLE"><I>column_name</I></TT></TT>
定义的）将在它的任意字段作为目标列出在<TT CLASS="COMMAND">UPDATE</TT>命令的<TT CLASS="LITERAL">SET</TT>
列表中时触发。当触发器没有触发时，字段的值也是有可能改变的，因为通过
<TT CLASS="LITERAL">BEFORE UPDATE</TT>触发器做的行内容的改变是不考虑的。相反的，
命令如<TT CLASS="LITERAL">UPDATE ... SET x = x ...</TT>将触发在字段<TT CLASS="LITERAL">x</TT>
上的触发器，尽管字段的值没有改变。</P><P>在<TT CLASS="LITERAL">BEFORE</TT>触发器中，<TT CLASS="LITERAL">WHEN</TT>条件只在函数被或将被执行之前计算，
所以使用<TT CLASS="LITERAL">WHEN</TT>与在触发器函数的开始测试相同的条件并无实质区别。
要特别的注意，条件看到的<TT CLASS="LITERAL">NEW</TT>行是当前的值，可能被早些的触发器修改了。
另外，<TT CLASS="LITERAL">BEFORE</TT>触发器的<TT CLASS="LITERAL">WHEN</TT>条件不允许检测<TT CLASS="LITERAL">NEW</TT>
行的系统字段(比如<TT CLASS="LITERAL">oid</TT>)，因为那些目前还没有设置。</P><P>在<TT CLASS="LITERAL">AFTER</TT>触发器中，<TT CLASS="LITERAL">WHEN</TT>条件只在行更新发生之后计算，
并且它决定一个事件是否在语句的最后排队触发该触发器。所以当<TT CLASS="LITERAL">AFTER</TT>
触发器的<TT CLASS="LITERAL">WHEN</TT>条件没有返回真时，不需要排队一个事件，
也不需要在语句的最后重新抓取行。如果触发器只需要为少量的行触发，
这会导致修改许多行的语句明显的加速。</P><P>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 7.3以前，
必须把触发器函数声明为返回<TT CLASS="TYPE">opaque</TT>占位类型，而不是<TT CLASS="TYPE">trigger</TT>类型。
为了支持加载老的转储文件，<TT CLASS="COMMAND">CREATE TRIGGER</TT>将接受一个声明为返回
<TT CLASS="TYPE">opaque</TT>的函数，但是它将发出一条 NOTICE 并且把函数声明的返回类型改成
<TT CLASS="TYPE">trigger</TT>。</P></DIV><DIV CLASS="REFSECT1"><A NAME="SQL-CREATETRIGGER-EXAMPLES"></A><H2>例子</H2><P>当表<TT CLASS="LITERAL">accounts</TT>的一行要被更新时，执行函数
<CODE CLASS="FUNCTION">check_account_update</CODE> ：
</P><PRE CLASS="PROGRAMLISTING">CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();</PRE><P>
同样的，但是只在字段<TT CLASS="LITERAL">balance</TT>在<TT CLASS="COMMAND">UPDATE</TT>
命令的目标中指定时执行该函数：
</P><PRE CLASS="PROGRAMLISTING">CREATE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();</PRE><P>
这种形式只在字段<TT CLASS="LITERAL">balance</TT>实际上改变了值时执行该函数：
</P><PRE CLASS="PROGRAMLISTING">CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE PROCEDURE check_account_update();</PRE><P>
只在改变了什么东西时，调用函数记录<TT CLASS="LITERAL">accounts</TT>的更新：
</P><PRE CLASS="PROGRAMLISTING">CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE PROCEDURE log_account_update();</PRE><P>
为每一行执行函数<CODE CLASS="FUNCTION">view_insert_row</CODE>以在一个视图下插入行到表：
</P><PRE CLASS="PROGRAMLISTING">CREATE TRIGGER view_insert
    INSTEAD OF INSERT ON my_view
    FOR EACH ROW
    EXECUTE PROCEDURE view_insert_row();</PRE><P>
</P><P><A HREF="trigger-example.html">第 36.4 &#33410;</A>包含一个完整的用C写的触发器函数的例子。</P></DIV><DIV CLASS="REFSECT1"><A NAME="SQL-CREATETRIGGER-COMPATIBILITY"></A><H2>兼容性</H2><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里的<TT CLASS="COMMAND">CREATE TRIGGER</TT>
语句实现了一个<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准的子集。目前仍然缺少下面的功能：
<P></P></P><UL><LI><P>SQL 允许你为<SPAN CLASS="QUOTE">"old"</SPAN>和<SPAN CLASS="QUOTE">"new"</SPAN>行或者表定义别名，
用于定义触发器的动作(也就是<TT CLASS="LITERAL">CREATE TRIGGER ... ON tablename
REFERENCING OLD ROW AS somename NEW ROW AS othername ...</TT>)。
因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
允许触发器过程以任意数量的用户定义语言进行书写，
所以访问数据的工作是用和语言相关的方法实现的。</P></LI><LI><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不允许旧的和新的表在语句级别的触发器中引用，
也就是，包含所有旧的和/或新的行的表，在<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准中被<TT CLASS="LITERAL">OLD TABLE</TT>
和<TT CLASS="LITERAL">NEW TABLE</TT>子句提及。</P></LI><LI><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>只允许为触发的动作执行用户定义的函数。
SQL 标准允许执行一些其它的命令，比如拿<TT CLASS="COMMAND">CREATE TABLE</TT>
作为触发器动作。这个限止并不难绕开，只要创建一个执行这些命令的用户定义的函数即可。</P></LI></UL><P>
</P><P>SQL 要求多个触发器应该以创建的时间顺序执行。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>采用的是按照名字顺序，并认为这样更加方便。</P><P>SQL 要求必须在级联<TT CLASS="LITERAL">DELETE</TT>完成<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">之后</I></SPAN>再触发级联删除上的
<TT CLASS="LITERAL">BEFORE DELETE</TT>触发器。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
的行为是<TT CLASS="LITERAL">BEFORE DELETE</TT>将永远在删除动作之前触发，
即使对于级联删除也是如此，我们认为这样更一致。如果<TT CLASS="LITERAL">BEFORE</TT>
触发器在由引用操作引起的更新期间修改行或阻止更新，仍然存在不标准的行为。
这将导致违反约束或者存储不符合参照完整性的数据。</P><P>用<TT CLASS="LITERAL">OR</TT>给一个触发器声明多个动作是
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对SQL标准的扩展。</P><P>触发触发器<TT CLASS="COMMAND">TRUNCATE</TT>的能力是一个
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对SQL标准的扩展，就像在视图上定义语句级别触发器的能力。</P><P><TT CLASS="COMMAND">CREATE CONSTRAINT TRIGGER</TT>是一个
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准的扩展。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73907"></A><H2>又见</H2><A HREF="sql-altertrigger.html">ALTER TRIGGER</A>, <A HREF="sql-droptrigger.html">DROP TRIGGER</A>, <A HREF="sql-createfunction.html">CREATE FUNCTION</A>, <A HREF="sql-set-constraints.html">SET CONSTRAINTS</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-createtstemplate.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-createtype.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">CREATE TEXT SEARCH TEMPLATE</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">CREATE TYPE</TD></TR></TABLE></DIV></BODY></HTML>
