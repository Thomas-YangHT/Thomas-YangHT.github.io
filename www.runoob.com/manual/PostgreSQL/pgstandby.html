<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pg_standby</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="服务器端应用程序" HREF="contrib-prog-server.html"><LINK REL="PREVIOUS" TITLE="pg_archivecleanup" HREF="pgarchivecleanup.html"><LINK REL="NEXT" TITLE="pg_test_fsync" HREF="pgtestfsync.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/pgstandby.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_archivecleanup" HREF="pgarchivecleanup.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="contrib-prog-server.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="pg_test_fsync" HREF="pgtestfsync.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="PGSTANDBY"></A><SPAN CLASS="APPLICATION">pg_standby</SPAN></H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN152089"></A><H2>&#21517;&#31216;</H2>pg_standby&nbsp;--&nbsp;支持<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>热备份服务器的创建</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN152095"></A><H2>&#22823;&#32434;</H2><P><TT CLASS="COMMAND">pg_standby</TT> [<TT CLASS="REPLACEABLE"><I>option</I></TT>...] <TT CLASS="REPLACEABLE"><I>archivelocation</I></TT> <TT CLASS="REPLACEABLE"><I>nextwalfile</I></TT> <TT CLASS="REPLACEABLE"><I>xlogfilepath</I></TT> [<TT CLASS="REPLACEABLE"><I>restartwalfile</I></TT>]</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152108"></A><H2>描述</H2><P><SPAN CLASS="APPLICATION">pg_standby</SPAN>支持<SPAN CLASS="QUOTE">"热备份"</SPAN>数据库服务器的创建。
它设计为一个生产就绪程序，还有一个可定制的模板，定制你需要的特定修改。</P><P><SPAN CLASS="APPLICATION">pg_standby</SPAN>设计为一个等待的<TT CLASS="VARNAME">restore_command</TT>，
需要将标准归档恢复返回到一个热备份操作。也需要其他配置，
所有这些都在主要服务器手册(参阅<A HREF="warm-standby.html">第 25.2 &#33410;</A>)中描述。</P><P>使用<SPAN CLASS="APPLICATION">pg_standby</SPAN>配置一个备用服务器，
将其放入<TT CLASS="FILENAME">recovery.conf</TT>配置文件中：
</P><PRE CLASS="PROGRAMLISTING">restore_command = 'pg_standby <TT
CLASS="REPLACEABLE"
><I
>archiveDir</I
></TT
> %f %p %r'</PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>archiveDir</I></TT>是恢复WAL段文件的目录。</P><P>如果声明了<TT CLASS="REPLACEABLE"><I>restartwalfile</I></TT>，通常通过使用<TT CLASS="LITERAL">%r</TT>宏，
然后所有逻辑上在这个文件之前的WAL文件都将从<TT CLASS="REPLACEABLE"><I>archivelocation</I></TT>
中删除。这最小化了保存崩溃重启能力时需要保留的文件数量。
如果<TT CLASS="REPLACEABLE"><I>archivelocation</I></TT>对于这个备用服务器来说是瞬态暂存区域，
则使用这个参数是合适的，但在打算将<TT CLASS="REPLACEABLE"><I>archivelocation</I></TT>
当做长期WAL归档区域时，这是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不</I></SPAN>合适的。</P><P><SPAN CLASS="APPLICATION">pg_standby</SPAN>假设<TT CLASS="REPLACEABLE"><I>archivelocation</I></TT>
是拥有服务器的用户可读取的目录。如果声明了
<TT CLASS="REPLACEABLE"><I>restartwalfile</I></TT> (或 <TT CLASS="LITERAL">-k</TT>)，
那么<TT CLASS="REPLACEABLE"><I>archivelocation</I></TT>目录也必须是可写的。</P><P>当主服务器故障时，有两种方法故障切换到<SPAN CLASS="QUOTE">"热备用"</SPAN>数据库服务器：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT>智能故障切换</DT><DD><P>在智能故障切换下，在归档中应用所有WAL文件可用后启用备用服务器。
这样就会零数据丢失，即使备用服务器稍后失败，但是如果有大量未能应用的WAL，
那么在备用服务器准备好之前可能需要大量时间。要触发智能故障切换，
创建一个包含单词<TT CLASS="LITERAL">smart</TT>的触发器文件，或者只是创建它而不写内容。</P></DD><DT>快速故障切换</DT><DD><P>在快速故障切换下，备用服务器立即启用。归档中任何未应用的WAL文件都将被忽略，
并且所有在这些文件中的事务都丢失。要触发快速故障切换，创建一个触发器文件，
并写入单词<TT CLASS="LITERAL">fast</TT>。如果没有新的WAL文件出现在定义的间隔中，
则<SPAN CLASS="APPLICATION">pg_standby</SPAN>也可以配置为自动执行快速故障切换。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152150"></A><H2>选项</H2><P>
<SPAN CLASS="APPLICATION">pg_standby</SPAN>接受下列的命令行参数：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-c</TT></DT><DD><P>使用<TT CLASS="LITERAL">cp</TT>或<TT CLASS="LITERAL">copy</TT>命令从归档中恢复WAL文件。
这是唯一支持的行为，所以这个选项没什么用处。</P></DD><DT><TT CLASS="OPTION">-d</TT></DT><DD><P>在<TT CLASS="FILENAME">stderr</TT>上打印大量调试日志输出。</P></DD><DT><TT CLASS="OPTION">-k</TT></DT><DD><P>从<TT CLASS="REPLACEABLE"><I>archivelocation</I></TT>中删除文件，
这样在归档中保存的当前文件之前不超过这么多WAL文件。
0（缺省）意味着不从<TT CLASS="REPLACEABLE"><I>archivelocation</I></TT>中删除任何文件。
如果声明了<TT CLASS="REPLACEABLE"><I>restartwalfile</I></TT>，则忽略这个参数，
因为该声明方法更精确的决定了正确的归档截止点。
这个参数的使用到了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.3就<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">废弃了</I></SPAN>；
声明一个<TT CLASS="REPLACEABLE"><I>restartwalfile</I></TT>参数更安全也更有效。
太小的设置可能导致删除备用服务器重启仍然需要的文件，
而太大的设置会浪费归档空间。</P></DD><DT><TT CLASS="OPTION">-r</TT> <TT CLASS="REPLACEABLE"><I>maxretries</I></TT></DT><DD><P>设置拷贝命令失败时重试的最大次数（缺省是3）。在每次失败之后，
我们等待<TT CLASS="REPLACEABLE"><I>sleeptime</I></TT> * <TT CLASS="REPLACEABLE"><I>num_retries</I></TT>，
所以等待时间逐渐增加。因此，默认的，在将失败报告给备用服务器之前，
我们将等待5秒、10秒、然后15秒。这将被解释为结束恢复，并且结果是备用服务器完全启动。</P></DD><DT><TT CLASS="OPTION">-s</TT> <TT CLASS="REPLACEABLE"><I>sleeptime</I></TT></DT><DD><P>设置测试之间睡眠的秒数（最高60，缺省15），以查看要恢复的WAL文件在归档中是否已经可用。
不一定推荐缺省设置；查阅<A HREF="warm-standby.html">第 25.2 &#33410;</A>获取讨论。</P></DD><DT><TT CLASS="OPTION">-t</TT> <TT CLASS="REPLACEABLE"><I>triggerfile</I></TT></DT><DD><P>声明一个触发器文件，它的存在会引起故障切换。建议使用结构化的文件名，
以避免多个服务器存在于同一个系统上时，混淆要触发的是哪个服务器；
例如<TT CLASS="FILENAME">/tmp/pgsql.trigger.5432</TT>。</P></DD><DT><TT CLASS="OPTION">-V</TT><BR><TT CLASS="OPTION">--version</TT></DT><DD><P>打印<SPAN CLASS="APPLICATION">pg_standby</SPAN>的版本并退出。</P></DD><DT><TT CLASS="OPTION">-w</TT> <TT CLASS="REPLACEABLE"><I>maxwaittime</I></TT></DT><DD><P>设置执行了快速故障切换之后，等待下一个WAL文件的最大秒数。
设置为0（缺省）意味着永远等待。不一定推荐缺省设置；
查阅<A HREF="warm-standby.html">第 25.2 &#33410;</A>获取讨论。</P></DD><DT><TT CLASS="OPTION">-?</TT><BR><TT CLASS="OPTION">--help</TT></DT><DD><P>显示关于<SPAN CLASS="APPLICATION">pg_standby</SPAN>命令行参数的帮助，然后退出。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152224"></A><H2>注意</H2><P><SPAN CLASS="APPLICATION">pg_standby</SPAN>是设计在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.2
及更新版本上使用的。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.3提供了<TT CLASS="LITERAL">%r</TT>宏，
让<SPAN CLASS="APPLICATION">pg_standby</SPAN>知道它需要保存的最后文件。
在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.2中，如果需要清理归档，则必须使用<TT CLASS="LITERAL">-k</TT>
选项。这个选项在8.3中保持可用，但是它的使用已经废弃了。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4提供了<TT CLASS="VARNAME">recovery_end_command</TT>选项。
没有这个选项，那么剩下的触发器文件可能是危险的。</P><P><SPAN CLASS="APPLICATION">pg_standby</SPAN>是使用C语言写的，
并且有一个容易修改的源代码，有专门指定的部分用来按你的需要修改。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152240"></A><H2>例子</H2><P>在Linux或Unix系统上，你可能使用：
</P><PRE CLASS="PROGRAMLISTING">archive_command = 'cp %p .../archive/%f'

restore_command = 'pg_standby -d -s 2 -t /tmp/pgsql.trigger.5442 .../archive %f %p %r 2&#62;&#62;standby.log'

recovery_end_command = 'rm -f /tmp/pgsql.trigger.5442'</PRE><P>
这里的归档目录在物理上位于备用服务器上，所以<TT CLASS="VARNAME">archive_command</TT>
通过NFS访问它，但是文件对于备用服务器来说是本地的（启用<TT CLASS="LITERAL">ln</TT>）。
这将：
<P></P></P><UL><LI><P>在<TT CLASS="FILENAME">standby.log</TT>中产生调试输出</P></LI><LI><P>在检查下一个WAL文件可用性之前睡眠2秒</P></LI><LI><P>只在触发器文件调用<TT CLASS="FILENAME">/tmp/pgsql.trigger.5442</TT>出现时停止等待，
并根据它的内容执行故障切换</P></LI><LI><P>当恢复结束时删除触发器文件</P></LI><LI><P>从归档目录中删除不再需要的文件</P></LI></UL><P>
</P><P>在Windows上，你可能使用：
</P><PRE CLASS="PROGRAMLISTING">archive_command = 'copy %p ...\\archive\\%f'

restore_command = 'pg_standby -d -s 5 -t C:\pgsql.trigger.5442 ...\archive %f %p %r 2&#62;&#62;standby.log'

recovery_end_command = 'del C:\pgsql.trigger.5442'</PRE><P>
请注意，反斜杠在<TT CLASS="VARNAME">archive_command</TT>中需要双写，
但是在<TT CLASS="VARNAME">restore_command</TT>或<TT CLASS="VARNAME">recovery_end_command</TT>
中<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不</I></SPAN>需要。这将：
<P></P></P><UL><LI><P>使用<TT CLASS="LITERAL">copy</TT>命令从归档中恢复WAL文件</P></LI><LI><P>在<TT CLASS="FILENAME">standby.log</TT>中产生调试输出</P></LI><LI><P>在检查下一个WAL文件可用性之前睡眠5秒</P></LI><LI><P>只在触发器文件调用<TT CLASS="FILENAME">C:\pgsql.trigger.5442</TT>出现时停止等待，
并根据它的内容执行故障切换</P></LI><LI><P>当恢复结束时删除触发器文件</P></LI><LI><P>从归档目录中删除不再需要的文件</P></LI></UL><P>
</P><P>Windows上的<TT CLASS="LITERAL">copy</TT>命令在文件完全拷贝之前设置最后的文件大小，
这通常会混淆<SPAN CLASS="APPLICATION">pg_standby</SPAN>。因此<SPAN CLASS="APPLICATION">pg_standby</SPAN>
一到它认为合适的大小就等待<TT CLASS="LITERAL">sleeptime</TT>秒。
GNUWin32的<TT CLASS="LITERAL">cp</TT>只在文件拷贝完成之后设置文件的大小。</P><P>因为Windows示例在两端都使用<TT CLASS="LITERAL">copy</TT>，
所以一个或两个服务器可以通过网络访问归档目录。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152289"></A><H2>作者</H2><P> Simon Riggs <CODE CLASS="EMAIL">&#60;<A HREF="mailto:simon@2ndquadrant.com">simon@2ndquadrant.com</A>&#62;</CODE>
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152293"></A><H2>又见</H2><A HREF="pgarchivecleanup.html"><SPAN CLASS="APPLICATION">pg_archivecleanup</SPAN></A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="pgarchivecleanup.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="pgtestfsync.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><SPAN CLASS="APPLICATION">pg_archivecleanup</SPAN></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="contrib-prog-server.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><SPAN CLASS="APPLICATION">pg_test_fsync</SPAN></TD></TR></TABLE></DIV></BODY></HTML>
