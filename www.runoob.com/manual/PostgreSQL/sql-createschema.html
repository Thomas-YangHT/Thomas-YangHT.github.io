<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>CREATE SCHEMA</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="CREATE RULE" HREF="sql-createrule.html"><LINK REL="NEXT" TITLE="CREATE SEQUENCE" HREF="sql-createsequence.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/create_schema.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="CREATE RULE" HREF="sql-createrule.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="CREATE SEQUENCE" HREF="sql-createsequence.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-CREATESCHEMA"></A>CREATE SCHEMA</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN71947"></A><H2>&#21517;&#31216;</H2>CREATE SCHEMA&nbsp;--&nbsp;定义一个新模式</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN71952"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">CREATE SCHEMA <TT
CLASS="REPLACEABLE"
><I
>schema_name</I
></TT
> [ AUTHORIZATION <TT
CLASS="REPLACEABLE"
><I
>user_name</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>schema_element</I
></TT
> [ ... ] ]
CREATE SCHEMA AUTHORIZATION <TT
CLASS="REPLACEABLE"
><I
>user_name</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>schema_element</I
></TT
> [ ... ] ]
CREATE SCHEMA IF NOT EXISTS <TT
CLASS="REPLACEABLE"
><I
>schema_name</I
></TT
> [ AUTHORIZATION <TT
CLASS="REPLACEABLE"
><I
>user_name</I
></TT
> ]
CREATE SCHEMA IF NOT EXISTS AUTHORIZATION <TT
CLASS="REPLACEABLE"
><I
>user_name</I
></TT
></PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71962"></A><H2>描述</H2><P><TT CLASS="COMMAND">CREATE SCHEMA</TT>在当前数据库里输入一个新模式。
该模式名将在当前数据库里现存的所有模式名中唯一。</P><P>模式实际上是一个名字空间：它包含命名对象(表、数据类型、函数、操作符)
这些名字可以和其它模式里存在的其它对象重名。命名对象要么是通过用模式名作为前缀
<SPAN CLASS="QUOTE">"修饰"</SPAN>进行访问，要么是通过设置一个搜索路径包含所需要的模式。
一条带着无修饰对象名的<TT CLASS="LITERAL">CREATE</TT>命令都是在当前模式中创建创建对象的
(在搜索路径最前面的模式；可以用<CODE CLASS="FUNCTION">current_schema</CODE>函数来判断)。</P><P>另外，<TT CLASS="COMMAND">CREATE SCHEMA</TT>可以包括在新模式中创建对象的子命令。
这些子命令和那些在创建完模式后发出的命令没有任何区别，
只不过是如果使用了<TT CLASS="LITERAL">AUTHORIZATION</TT>子句，那么所有创建的对象都将被该用户拥有。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN71973"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>schema_name</I></TT></DT><DD><P>要创建的模式名字。如果省略，则使用
<TT CLASS="REPLACEABLE"><I>user_name</I></TT>作为模式名。
这个名字不能以<TT CLASS="LITERAL">pg_</TT>开头，因为这样的名字保留给系统模式使用。</P></DD><DT><TT CLASS="REPLACEABLE"><I>user_name</I></TT></DT><DD><P>将拥有该模式的用户的角色名。如果省略，缺省为执行该命令的用户名。
要想创建一个属于其他角色的模式，你必须是那个角色的直接或非直接成员，或是超级用户。</P></DD><DT><TT CLASS="REPLACEABLE"><I>schema_element</I></TT></DT><DD><P>一个 SQL 语句，定义一个要在模式里创建的对象。目前，只有<TT CLASS="COMMAND">CREATE TABLE</TT>、
<TT CLASS="COMMAND">CREATE VIEW</TT>、<TT CLASS="COMMAND">CREATE INDEX</TT>、<TT CLASS="COMMAND">CREATE SEQUENCE</TT>、
<TT CLASS="COMMAND">CREATE TRIGGER</TT>和<TT CLASS="COMMAND">GRANT</TT>是可以接受的子句。
其它类型的对象可以在创建完模式之后的独立命令里创建。</P></DD><DT><TT CLASS="LITERAL">IF NOT EXISTS</TT></DT><DD><P>如果相同名字的模式已经存在，那么什么也不要做（除了发出一个通知）。
当使用此选项时，不能包括<TT CLASS="REPLACEABLE"><I>schema_element</I></TT>子命令。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72005"></A><H2>注意</H2><P>要创建模式，调用该命令的用户必需在当前数据库上有<TT CLASS="LITERAL">CREATE</TT>权限。
（当然，超级用户可以绕开这个检查。）</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72009"></A><H2>例子</H2><P>
创建一个模式：
</P><PRE CLASS="PROGRAMLISTING">CREATE SCHEMA myschema;</PRE><P>
</P><P>
为用户<TT CLASS="LITERAL">joe</TT>创建模式，模式名也叫<TT CLASS="LITERAL">joe</TT>：
</P><PRE CLASS="PROGRAMLISTING">CREATE SCHEMA AUTHORIZATION joe;</PRE><P>
</P><P>
创建一个名为<TT CLASS="LITERAL">test</TT>的模式，该模式被用户<TT CLASS="LITERAL">joe</TT>所拥有，
除非已经有一个名为<TT CLASS="LITERAL">test</TT>的模式。
（这与<TT CLASS="LITERAL">joe</TT>是否拥有早已存在的模式无关。）
</P><PRE CLASS="PROGRAMLISTING">CREATE SCHEMA IF NOT EXISTS test AUTHORIZATION joe;</PRE><P>
</P><P>
创建一个模式并且在里面创建一个表：
</P><PRE CLASS="PROGRAMLISTING">CREATE SCHEMA hollywood
    CREATE TABLE films (title text, release date, awards text[])
    CREATE VIEW winners AS
        SELECT title, release FROM films WHERE awards IS NOT NULL;</PRE><P>
请注意上面独立的子命令不是由分号结尾的
</P><P>
下面的命令是实现同样结果的等效语句：
</P><PRE CLASS="PROGRAMLISTING">CREATE SCHEMA hollywood;
CREATE TABLE hollywood.films (title text, release date, awards text[]);
CREATE VIEW hollywood.winners AS
    SELECT title, release FROM hollywood.films WHERE awards IS NOT NULL;</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72027"></A><H2>兼容性</H2><P>SQL 标准允许在<TT CLASS="COMMAND">CREATE SCHEMA</TT>里面有一个
<TT CLASS="LITERAL">DEFAULT CHARACTER SET</TT>子句以及比目前<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
可以接受的更多的子命令。</P><P>SQL 标准声明在<TT CLASS="COMMAND">CREATE SCHEMA</TT>里的子命令可以以任意顺序出现。
目前<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里的实现还不能处理所有子命令里前向引用的情况；
有时候可能需要重排一下子命令的顺序以避免前向引用。</P><P>在 SQL 标准里，模式的所有者总是拥有其中的所有对象。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许模式包含非模式所有者拥有的对象。
只有在模式所有者将自己模式的<TT CLASS="LITERAL">CREATE</TT>权限给了其他人，
或者超级用户选择在该模式中创建对象时，才可能出现。</P><P><TT CLASS="LITERAL">IF NOT EXISTS</TT>选项是一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扩展。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72042"></A><H2>又见</H2><A HREF="sql-alterschema.html">ALTER SCHEMA</A>, <A HREF="sql-dropschema.html">DROP SCHEMA</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-createrule.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-createsequence.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">CREATE RULE</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">CREATE SEQUENCE</TD></TR></TABLE></DIV></BODY></HTML>
