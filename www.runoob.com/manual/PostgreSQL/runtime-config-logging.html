<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>错误报告和日志</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="服务器配置" HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html"><LINK REL="PREVIOUS" TITLE="查询规划" HREF="runtime-config-query.html"><LINK REL="NEXT" TITLE="运行时统计" HREF="runtime-config-statistics.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/config.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="查询规划" HREF="runtime-config-query.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 18. 服务器配置</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="运行时统计" HREF="runtime-config-statistics.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="RUNTIME-CONFIG-LOGGING">18.8. 错误报告和日志</A></H1><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="RUNTIME-CONFIG-LOGGING-WHERE">18.8.1. 在哪里记录日志</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="GUC-LOG-DESTINATION"></A><TT CLASS="VARNAME">log_destination</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>支持多种记录服务器日志的方法，包括<SPAN CLASS="SYSTEMITEM">stderr</SPAN>, <SPAN CLASS="SYSTEMITEM">csvlog</SPAN>和
<SPAN CLASS="SYSTEMITEM">syslog</SPAN>。
在Windows里，还支持<SPAN CLASS="SYSTEMITEM">eventlog</SPAN>。把这个选项设置为一个逗号分隔的日志目标的列表。
缺省是只记录到<SPAN CLASS="SYSTEMITEM">stderr</SPAN>。这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件
或者服务器命令行设置。</P><P> 如果<SPAN CLASS="SYSTEMITEM">csvlog</SPAN>包含在<TT CLASS="VARNAME">log_destination</TT>中，
日志项是用<SPAN CLASS="QUOTE">"逗号分隔"</SPAN>(<ACRONYM CLASS="ACRONYM">CSV</ACRONYM>)格式的输出，这便于加载日志到程序。参见<A HREF="runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-CSVLOG">第 18.8.4 &#33410;</A>获取更多详情。
<A HREF="runtime-config-logging.html#GUC-LOGGING-COLLECTOR">logging_collector</A>必须能够产生CSV格式的日志输出。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>
在大多数Unix系统上，你将需要改变您的系统<SPAN CLASS="APPLICATION">syslog</SPAN>守护进程的配置，
以便充分利用<TT CLASS="VARNAME">log_destination</TT>的<SPAN CLASS="SYSTEMITEM">syslog</SPAN>选项。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>可以通过<TT CLASS="LITERAL">LOCAL7</TT>(参见<A HREF="runtime-config-logging.html#GUC-SYSLOG-FACILITY">syslog_facility</A>)记录<SPAN CLASS="APPLICATION">syslog</SPAN>设施<TT CLASS="LITERAL">LOCAL0</TT>，
但缺省大多数平台上<SPAN CLASS="APPLICATION">syslog</SPAN>配置将忽略所有这样的消息。
你将需要添加类似于下面的信息：
</P><PRE CLASS="PROGRAMLISTING">local0.*    /var/log/postgresql</PRE><P>
到<SPAN CLASS="APPLICATION">syslog</SPAN>守护程序的配置文件中，使其工作。
</P><P> 在Windows上，当您使用<TT CLASS="VARNAME">log_destination</TT>的<TT CLASS="LITERAL">eventlog</TT>选项，
你应该注册一个事件源及其操作系统作业库，
使Windows事件查看器可以有规则的显示事件日志信息。
参见<A HREF="event-log-registration.html">第 17.11 &#33410;</A>获取更多详细信息。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="GUC-LOGGING-COLLECTOR"></A><TT CLASS="VARNAME">logging_collector</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 这个参数启动<I CLASS="FIRSTTERM">日志收集</I>，
这是一个后台进程，抓取发送到<SPAN CLASS="SYSTEMITEM">stderr</SPAN>的日志消息，并会将他们重定向到日志文件。
这个方法通常比记录到<SPAN CLASS="APPLICATION">syslog</SPAN>更有用，
因为有些消息类型可能不会出现在<SPAN CLASS="APPLICATION">syslog</SPAN>输出中
(一个常见的例子是动态连接失败的消息；另外一个是通过脚本比如<TT CLASS="VARNAME">archive_command</TT>
产生的错误消息。）
这个值只能在服务器启动的时候设置。&#13;</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 不使用日志收集器可以登录到<SPAN CLASS="SYSTEMITEM">stderr</SPAN>;
无论服务器的<SPAN CLASS="SYSTEMITEM">stderr</SPAN>被定向到哪，则日志消息就定位到那里。然而，
该方法是只适用于低日志卷，因为它没有提供方便的方式来旋转日志文件。
另外，在某些平台上不使用日志收集器可能会导致丢失或乱码日志输出，
因为多个进程同时写入同一个日志文件可能覆盖彼此的输出。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 日志收集器设计永远不会丢失消息。
这意味着在非常高的负载情况下，
当收集器已经落后而试图发送额外的日志消息的时候，封锁服务器进程。
与此相反，<SPAN CLASS="APPLICATION">syslog</SPAN>更喜欢忽略消息，
如果它无法写入，这意味着它可能无法记录这些消息，这种情况下，
但它不会阻止该系统的其余部分。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="GUC-LOG-DIRECTORY"></A><TT CLASS="VARNAME">log_directory</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 在打开了<TT CLASS="VARNAME">logging_collector</TT>的时候，这个选项判断日志文件在哪个目录里创建。
它可以声明成绝对路径，或者是与集群的数据目录相对的路径。
这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器命令行设置。</P></DD><DT><A NAME="GUC-LOG-FILENAME"></A><TT CLASS="VARNAME">log_filename</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 在打开了<TT CLASS="VARNAME">logging_collector</TT>的时候，这个选项设置所创建的日志文件的文件名。
这个数值将被当作<CODE CLASS="FUNCTION">strftime</CODE>模式看待。因此可以用<TT CLASS="LITERAL">%</TT>转义声明随时间而变的文件名。
（注意，如果有任何时区相关<TT CLASS="LITERAL">%</TT>转义，由<A HREF="runtime-config-logging.html#GUC-LOG-TIMEZONE">log_timezone</A>声明的时区进行计算。）
支持的<TT CLASS="LITERAL">%</TT>转义类似于Open Group上的<A HREF="http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html" TARGET="_top">strftime</A>规范列表中的。
注意，不直接使用这个系统的<SPAN CLASS="SYSTEMITEM">strftime</SPAN>，所以特定平台的（非标准）扩展不起作用。 </P><P> 如果您没有转义指定文件名，你应该计划使用日志旋转程序以避免最终填充
整个磁盘。在8.4之前的版本中，如果没有<TT CLASS="LITERAL">%</TT>的转义符出现，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将追加新日志文件创建时间的时间戳，
但是不再是这种情况了。</P><P> 如果启用<TT CLASS="VARNAME">log_destination</TT>中的CSV格式输出，
<TT CLASS="LITERAL">.csv</TT>将追加时间戳日志文件名来创建CSV格式输出的文件名。
（如果<TT CLASS="VARNAME">log_filename</TT>以<TT CLASS="LITERAL">.log</TT>为结束，后缀代替）。
在上面的例子情况下，CSV文件名是<TT CLASS="LITERAL">server_log.1093827753.csv</TT>。</P><P> 这个参数只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器命令行上设置。</P></DD><DT><A NAME="GUC-LOG-FILE-MODE"></A><TT CLASS="VARNAME">log_file_mode</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 在Unix系统上，当<TT CLASS="VARNAME">logging_collector</TT>已启用时（在Microsoft Windows上将忽略此参数），
此参数用于设置日志文件的权限。
该参数值预期为通过<CODE CLASS="FUNCTION">chmod</CODE>和<CODE CLASS="FUNCTION">umask</CODE>
系统调用接受的格式指定的数字模式。
（为了使用习惯八进制格式的数字必须以<TT CLASS="LITERAL">0</TT>(zero)开始）。</P><P> 默认的权限<TT CLASS="LITERAL">0600</TT>，只意味着
服务器拥有者可以读取或写入日志文件。其他较普遍
有用的设置是<TT CLASS="LITERAL">0640</TT>，让拥有者组成员来读取文件。
但是请注意，为了充分使用这种设置，你需要改变<A HREF="runtime-config-logging.html#GUC-LOG-DIRECTORY">log_directory</A>到集群数据目录之外的
某处存储这些文件。无论如何，使日志文件全局可读是不明智的，因为它们可能包含敏感数据。</P><P> 这个参数可以在<TT CLASS="FILENAME">postgresql.conf</TT>文件或者服务器命令行上设置。</P></DD><DT><A NAME="GUC-LOG-ROTATION-AGE"></A><TT CLASS="VARNAME">log_rotation_age</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 在打开了<TT CLASS="VARNAME">logging_collector</TT>的时候，这个选项设置一个独立日志文件的最大生存期。
在数值指定的分钟过去之后，将创建一个新的日志文件。设置为零可以关闭以时间为基础的新日志文件的创建。
这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器命令行设置。</P></DD><DT><A NAME="GUC-LOG-ROTATION-SIZE"></A><TT CLASS="VARNAME">log_rotation_size</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 在打开了<TT CLASS="VARNAME">logging_collector</TT>的时候，这个选项设置一个独立的日志文件的最大尺寸。
在数值指定的千字节写入日志文件之后，将会创建一个新的日志文件。
设置为零可以关闭以尺寸为基础的新日志文件的创建。
这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器命令行上设置。</P></DD><DT><A NAME="GUC-LOG-TRUNCATE-ON-ROTATION"></A><TT CLASS="VARNAME">log_truncate_on_rotation</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 在打开了<TT CLASS="VARNAME">logging_collector</TT>的时候，这个选项将导致<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
覆盖而不是附加到任何同名的现有日志文件上。
不过，覆盖只是发生在基于时间滚动而创建的新文件上，而不是在服务器启动的时候或者以尺寸为基础的滚动上。
如果为 off ，将始终向已存在的文件结尾追加。比如，
使用这个选项和类似<TT CLASS="LITERAL">postgresql-%H.log</TT>这样的<TT CLASS="VARNAME">log_filename</TT>设置将导致生成
24个按小时生成的日志文件然后在这些文件上循环。
这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者在服务器启动的时候设置。</P><P> 例子：保留 7 天的日志，每天一个日志文件，叫做<TT CLASS="LITERAL">server_log.Mon</TT>, <TT CLASS="LITERAL">server_log.Tue</TT>等等，
并且上周的日志会自动被这周的日志覆盖。把<TT CLASS="VARNAME">log_filename</TT>设置为<TT CLASS="LITERAL">server_log.%a</TT>,
把<TT CLASS="VARNAME">log_truncate_on_rotation</TT>设置为<TT CLASS="LITERAL">on</TT>，并且把
<TT CLASS="VARNAME">log_rotation_age</TT>设置为<TT CLASS="LITERAL">1440</TT>。</P><P> 例子：保留 24 小时的日志，每小时一个日志，但是如果日志文件尺寸大于 1GB 也旋转日志。
把<TT CLASS="VARNAME">log_filename</TT>设置为<TT CLASS="LITERAL">server_log.%H%M</TT>,
<TT CLASS="VARNAME">log_truncate_on_rotation</TT>设置为<TT CLASS="LITERAL">on</TT>,
<TT CLASS="VARNAME">log_rotation_age</TT>设置为<TT CLASS="LITERAL">60</TT>并且把
<TT CLASS="VARNAME">log_rotation_size</TT>设置为<TT CLASS="LITERAL">1000000</TT>。
在<TT CLASS="VARNAME">log_filename</TT>里包含<TT CLASS="LITERAL">%M</TT>
允许任何尺寸驱动的旋转选取一个和开始的文件名同小时数但是名字不同的文件。</P></DD><DT><A NAME="GUC-SYSLOG-FACILITY"></A><TT CLASS="VARNAME">syslog_facility</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 如果向<SPAN CLASS="APPLICATION">syslog</SPAN>进行记录，那么这个选项判断要使用的<SPAN CLASS="APPLICATION">syslog</SPAN><SPAN CLASS="QUOTE">"设施"</SPAN>。
你可以从<TT CLASS="LITERAL">LOCAL0</TT>, <TT CLASS="LITERAL">LOCAL1</TT>,
<TT CLASS="LITERAL">LOCAL2</TT>, <TT CLASS="LITERAL">LOCAL3</TT>, <TT CLASS="LITERAL">LOCAL4</TT>,
<TT CLASS="LITERAL">LOCAL5</TT>, <TT CLASS="LITERAL">LOCAL6</TT>, <TT CLASS="LITERAL">LOCAL7</TT>中选择。缺省是<TT CLASS="LITERAL">LOCAL0</TT>。
又见你的系统的<SPAN CLASS="APPLICATION">syslog</SPAN>守护进程文档。
这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器启动的时候设置。</P></DD><DT><A NAME="GUC-SYSLOG-IDENT"></A><TT CLASS="VARNAME">syslog_ident</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 如果向<SPAN CLASS="APPLICATION">syslog</SPAN>进行记录，这个选项决定用于在<SPAN CLASS="APPLICATION">syslog</SPAN>日志中标识<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的程序名。
缺省是<TT CLASS="LITERAL">postgres</TT>。这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器启动的时候设置。</P></DD><DT><A NAME="GUC-EVENT-SOURCE"></A><TT CLASS="VARNAME">event_source</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 当启用记录<SPAN CLASS="APPLICATION">event log</SPAN>时，此参数
确定用于识别<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>消息日志的程序名称。
缺省是<TT CLASS="LITERAL">PostgreSQL</TT>。
该参数只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件或者服务器命令行上设置。</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="RUNTIME-CONFIG-LOGGING-WHEN">18.8.2. 什么时候记录日志</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="GUC-CLIENT-MIN-MESSAGES"></A><TT CLASS="VARNAME">client_min_messages</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 这个选项控制哪些信息发送到客户端。
有效的数值是<TT CLASS="LITERAL">DEBUG5</TT>,
<TT CLASS="LITERAL">DEBUG4</TT>, <TT CLASS="LITERAL">DEBUG3</TT>, <TT CLASS="LITERAL">DEBUG2</TT>,
<TT CLASS="LITERAL">DEBUG1</TT>, <TT CLASS="LITERAL">LOG</TT>, <TT CLASS="LITERAL">NOTICE</TT>,
<TT CLASS="LITERAL">WARNING</TT>, <TT CLASS="LITERAL">ERROR</TT>, <TT CLASS="LITERAL">FATAL</TT>,
和<TT CLASS="LITERAL">PANIC</TT>。
每个级别包含所有它后面的级别，级别越靠后，发送的信息越少。缺省是<TT CLASS="LITERAL">NOTICE</TT>。
需要注意的是这里的<TT CLASS="LITERAL">LOG</TT>和<TT CLASS="VARNAME">log_min_messages</TT>里的级别不同。</P></DD><DT><A NAME="GUC-LOG-MIN-MESSAGES"></A><TT CLASS="VARNAME">log_min_messages</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 控制写到服务器日志里的信息的详细程度。
有效值是<TT CLASS="LITERAL">DEBUG5</TT>, <TT CLASS="LITERAL">DEBUG4</TT>,
<TT CLASS="LITERAL">DEBUG3</TT>, <TT CLASS="LITERAL">DEBUG2</TT>, <TT CLASS="LITERAL">DEBUG1</TT>,
<TT CLASS="LITERAL">INFO</TT>, <TT CLASS="LITERAL">NOTICE</TT>, <TT CLASS="LITERAL">WARNING</TT>,
<TT CLASS="LITERAL">ERROR</TT>, <TT CLASS="LITERAL">LOG</TT>, <TT CLASS="LITERAL">FATAL</TT>和
<TT CLASS="LITERAL">PANIC</TT>。
每个级别都包含它后面的级别。越靠后的数值发往服务器日志的信息越少。缺省是<TT CLASS="LITERAL">WARNING</TT>。
需要注意的是这里的<TT CLASS="LITERAL">LOG</TT>和<TT CLASS="VARNAME">client_min_messages</TT>里的级别不同。只有超级用户可以修改这个设置。</P></DD><DT><A NAME="GUC-LOG-MIN-ERROR-STATEMENT"></A><TT CLASS="VARNAME">log_min_error_statement</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 控制在服务器日志里输出哪一条导致错误条件的SQL语句。
所有导致一个特定级别(或者更高级别)错误的 SQL 语句都要被记录。
有效的值有<TT CLASS="LITERAL">DEBUG5</TT>,
<TT CLASS="LITERAL">DEBUG4</TT>, <TT CLASS="LITERAL">DEBUG3</TT>,
<TT CLASS="LITERAL">DEBUG2</TT>, <TT CLASS="LITERAL">DEBUG1</TT>,
<TT CLASS="LITERAL">INFO</TT>, <TT CLASS="LITERAL">NOTICE</TT>,
<TT CLASS="LITERAL">WARNING</TT>, <TT CLASS="LITERAL">ERROR</TT>,
<TT CLASS="LITERAL">LOG</TT>,
<TT CLASS="LITERAL">FATAL</TT>和<TT CLASS="LITERAL">PANIC</TT>。
缺省是<TT CLASS="LITERAL">ERROR</TT>，
表示所有导致错误、日志信息，致命错误、恐慌的SQL语句都将被记录。
设置为<TT CLASS="LITERAL">PANIC</TT>表示把这个特性关闭。只有超级用户可以改变这个设置。</P></DD><DT><A NAME="GUC-LOG-MIN-DURATION-STATEMENT"></A><TT CLASS="VARNAME">log_min_duration_statement</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 如果某个语句的持续时间大于或者等于这个毫秒数，那么在日志行上记录该语句及其持续时间。
设置为零将打印所有查询和他们的持续时间。设置为-1(缺省值)关闭这个功能。比如，
如果你把它设置为<TT CLASS="LITERAL">250ms</TT>，那么所有运行时间等于或者超过 250ms 的 SQL 语句都会被记录。
打开这个选项可以很方便地跟踪需要优化的查询。只有超级用户可以改变这个设置。</P><P> 对于使用扩展查询协议的客户端，语法分析、邦定、执行每一步所花时间都分别记录。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 当此选项与<A HREF="runtime-config-logging.html#GUC-LOG-STATEMENT">log_statement</A>同时使用时，
已经被<TT CLASS="VARNAME">log_statement</TT>记录的语句文本不会被重复记录。
如果没有使用<SPAN CLASS="APPLICATION">syslog</SPAN>的话，推荐使用<A HREF="runtime-config-logging.html#GUC-LOG-LINE-PREFIX">log_line_prefix</A>记录
PID 或会话ID，
这样就可以使用它们将语句消息连接耗时消息。</P></BLOCKQUOTE></DIV></DD></DL></DIV><P> <A HREF="runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS">&#34920; 18-1</A>解释了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>使用的
信息严重程度。如果日志输出发送到<SPAN CLASS="SYSTEMITEM">syslog</SPAN>或者Windows的
<SPAN CLASS="SYSTEMITEM">eventlog</SPAN>，则严重程度如下表所示。</P><DIV CLASS="TABLE"><A NAME="RUNTIME-CONFIG-SEVERITY-LEVELS"></A><P><B>&#34920; 18-1. 信息严重级别</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>严重级别</TH><TH>用法</TH><TH><SPAN CLASS="SYSTEMITEM">syslog</SPAN></TH><TH><SPAN CLASS="SYSTEMITEM">eventlog</SPAN></TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">DEBUG1..DEBUG5</TT></TD><TD>提供开发人员使用的连续更多详细信息</TD><TD><TT CLASS="LITERAL">DEBUG</TT></TD><TD><TT CLASS="LITERAL">INFORMATION</TT></TD></TR><TR><TD><TT CLASS="LITERAL">INFO</TT></TD><TD>提供用户隐含要求的信息，比如在<TT CLASS="COMMAND">VACUUM VERBOSE</TT>过程输出的信息。</TD><TD><TT CLASS="LITERAL">INFO</TT></TD><TD><TT CLASS="LITERAL">INFORMATION</TT></TD></TR><TR><TD><TT CLASS="LITERAL">NOTICE</TT></TD><TD>提供可能对用户有帮助的信息，比如，长标识符的截断</TD><TD><TT CLASS="LITERAL">NOTICE</TT></TD><TD><TT CLASS="LITERAL">INFORMATION</TT></TD></TR><TR><TD><TT CLASS="LITERAL">WARNING</TT></TD><TD>提供可能问题的警告，比如在事务块范围之外的<TT CLASS="COMMAND">COMMIT</TT></TD><TD><TT CLASS="LITERAL">NOTICE</TT></TD><TD><TT CLASS="LITERAL">WARNING</TT></TD></TR><TR><TD><TT CLASS="LITERAL">ERROR</TT></TD><TD>报告导致当前命令退出的错误。</TD><TD><TT CLASS="LITERAL">WARNING</TT></TD><TD><TT CLASS="LITERAL">ERROR</TT></TD></TR><TR><TD><TT CLASS="LITERAL">LOG</TT></TD><TD>报告一些管理员感兴趣的信息，比如，检查点活跃性。</TD><TD><TT CLASS="LITERAL">INFO</TT></TD><TD><TT CLASS="LITERAL">INFORMATION</TT></TD></TR><TR><TD><TT CLASS="LITERAL">FATAL</TT></TD><TD>报告导致当前会话终止的错误。</TD><TD><TT CLASS="LITERAL">ERR</TT></TD><TD><TT CLASS="LITERAL">ERROR</TT></TD></TR><TR><TD><TT CLASS="LITERAL">PANIC</TT></TD><TD>报告导致所有数据库会话退出的错误。</TD><TD><TT CLASS="LITERAL">CRIT</TT></TD><TD><TT CLASS="LITERAL">ERROR</TT></TD></TR></TBODY></TABLE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="RUNTIME-CONFIG-LOGGING-WHAT">18.8.3. 记录什么</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="GUC-APPLICATION-NAME"></A><TT CLASS="VARNAME">application_name</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 该<TT CLASS="VARNAME">application_name</TT>可以是小于<TT CLASS="SYMBOL">NAMEDATALEN</TT>字符
（标准构建64个字符）的任何字符串。它通常是由应用程序连接到服务器设置。
该名称将显示在<TT CLASS="STRUCTNAME">pg_stat_activity</TT>视图中
并包含在CSV格式的日志项中。它也可以被包括在
通过<A HREF="runtime-config-logging.html#GUC-LOG-LINE-PREFIX">log_line_prefix</A>参数的常规日志项中。
只有可打印的ASCII字符可能用在<TT CLASS="VARNAME">application_name</TT>值中。其它字符会
用问号(<TT CLASS="LITERAL">?</TT>)代替。</P></DD><DT><TT CLASS="VARNAME">debug_print_parse</TT> (<TT CLASS="TYPE">boolean</TT>)<BR><TT CLASS="VARNAME">debug_print_rewritten</TT> (<TT CLASS="TYPE">boolean</TT>)<BR><TT CLASS="VARNAME">debug_print_plan</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 这些选项打开各种调试输出。当设置，它们打印生成的解析树，查询重写输出，
或每个执行查询的执行计划。 这些消息在<TT CLASS="LITERAL">LOG</TT>消息级别发出的，
所以默认情况下它们会出现在服务器日志中，但不会被发送到客户端。
您可以通过调整<A HREF="runtime-config-logging.html#GUC-CLIENT-MIN-MESSAGES">client_min_messages</A>和/或
<A HREF="runtime-config-logging.html#GUC-LOG-MIN-MESSAGES">log_min_messages</A>改变。这些参数缺省都是关闭的。</P></DD><DT><TT CLASS="VARNAME">debug_pretty_print</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 当设置时，<TT CLASS="VARNAME">debug_pretty_print</TT>缩进<TT CLASS="VARNAME">debug_print_parse</TT>,
<TT CLASS="VARNAME">debug_print_rewritten</TT>或者<TT CLASS="VARNAME">debug_print_plan</TT>产生的消息，
这样更加可读，但是，当关闭它时，比<SPAN CLASS="QUOTE">"紧凑型"</SPAN>格式更长的输出，缺省是打开的。</P></DD><DT><A NAME="GUC-LOG-CHECKPOINTS"></A><TT CLASS="VARNAME">log_checkpoints</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 导致检查点和重启点被记录在服务器日志中。
一些统计都包含在日志信息中，包括缓冲区写入数量和编写它们的花费的时间。
这些参数只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件或者服务器命令行上设置，缺省是off。</P></DD><DT><A NAME="GUC-LOG-CONNECTIONS"></A><TT CLASS="VARNAME">log_connections</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 导致记录到服务器的每个尝试连接，以及成功完成客户端认证。
该参数在会话开始之后不能改变，缺省是off。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 某些客户端程序，如<SPAN CLASS="APPLICATION">psql</SPAN>当确定是否需要密码的时候，
企图连接两次。所以复制<SPAN CLASS="QUOTE">"连接收到"</SPAN>的消息不一定表示有问题。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="GUC-LOG-DISCONNECTIONS"></A><TT CLASS="VARNAME">log_disconnections</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 这个选项类似<TT CLASS="VARNAME">log_connections</TT>，但是在会话结束的时候在服务器日志里输出一行。
并且包含会话持续时间。
缺省是关闭的。这个参数在会话开始之后不能被改变。</P></DD><DT><A NAME="GUC-LOG-DURATION"></A><TT CLASS="VARNAME">log_duration</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 记录每个已完成语句的持续时间。默认值是<TT CLASS="LITERAL">off</TT>。只有超级用户可以改变这个设置。</P><P> 对于使用扩展查询协议的客户端，语法分析、邦定、执行每一步所花时间都分别记录。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 设置为0时该选项与<A HREF="runtime-config-logging.html#GUC-LOG-MIN-DURATION-STATEMENT">log_min_duration_statement</A>
的不同之处在于<TT CLASS="VARNAME">log_min_duration_statement</TT>
强制记录查询文本。但是这个选项不可以。因此，如果<TT CLASS="VARNAME">log_duration</TT>为<TT CLASS="LITERAL">on</TT>并且<TT CLASS="VARNAME">log_min_duration_statement</TT>
大于零将记录所有持续时间，但是仅记录那些超过阈值的语句。
这可以用于在高负载情况下搜集统计信息。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="GUC-LOG-ERROR-VERBOSITY"></A><TT CLASS="VARNAME">log_error_verbosity</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 控制记录的每条信息写到服务器日志里的详细程度。
有效的值是<TT CLASS="LITERAL">TERSE</TT>,<TT CLASS="LITERAL">DEFAULT</TT>和<TT CLASS="LITERAL">VERBOSE</TT>，
逐个向显示的信息里增加更多的字段。<TT CLASS="LITERAL">TERSE</TT>包含
<TT CLASS="LITERAL">DETAIL</TT>的记录, <TT CLASS="LITERAL">HINT</TT>,<TT CLASS="LITERAL">QUERY</TT>和<TT CLASS="LITERAL">CONTEXT</TT>错误信息。
<TT CLASS="LITERAL">VERBOSE</TT>输出包含<TT CLASS="SYMBOL">SQLSTATE</TT>错误代码
(参见<A HREF="http://school.yunwei.edu/manual/PostgreSQL/errcodes-appendix.html">&#38468;&#24405; A</A>)以及源代码文件名称，函数名称，以及产生错误的行数。
只有超级用户可以改变这个设置。</P></DD><DT><A NAME="GUC-LOG-HOSTNAME"></A><TT CLASS="VARNAME">log_hostname</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 缺省时，连接日志只记录所连接主机的IP地址。打开这个选项导致同时记录主机名。
请注意，这样有可能带来一些不可忽略的性能损失(取决于你的名字解析的设置)。
这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器命令行设置。</P></DD><DT><A NAME="GUC-LOG-LINE-PREFIX"></A><TT CLASS="VARNAME">log_line_prefix</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P>
这是一个<CODE CLASS="FUNCTION">printf</CODE>风格的字符串，在日志的每行开头输出。
<TT CLASS="LITERAL">%</TT>字符开始<SPAN CLASS="QUOTE">"转义序列"</SPAN>被如下所述状态信息替换。
无法识别的转义被忽略。其它字符都直接拷贝到日志行中。
有些转义只被会话进程识别，被后端进程忽略，比如主服务器进程。
这个选项只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件里或者服务器命令行设置。
缺省是空字符串。
<DIV CLASS="INFORMALTABLE"><P></P><A NAME="AEN29800"></A><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>转义</TH><TH>效果</TH><TH>仅用于会话</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">%a</TT></TD><TD>Application name</TD><TD>yes</TD></TR><TR><TD><TT CLASS="LITERAL">%u</TT></TD><TD>User name</TD><TD>yes</TD></TR><TR><TD><TT CLASS="LITERAL">%d</TT></TD><TD>Database name</TD><TD>yes</TD></TR><TR><TD><TT CLASS="LITERAL">%r</TT></TD><TD>Remote host name or IP address, and remote port</TD><TD>yes</TD></TR><TR><TD><TT CLASS="LITERAL">%h</TT></TD><TD>Remote host name or IP address</TD><TD>yes</TD></TR><TR><TD><TT CLASS="LITERAL">%p</TT></TD><TD>Process ID</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%t</TT></TD><TD>Time stamp without milliseconds</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%m</TT></TD><TD>Time stamp with milliseconds</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%i</TT></TD><TD>Command tag: type of session's current command</TD><TD>yes</TD></TR><TR><TD><TT CLASS="LITERAL">%e</TT></TD><TD>SQLSTATE error code</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%c</TT></TD><TD>Session ID: see below</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%l</TT></TD><TD>Number of the log line for each session or process, starting at 1</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%s</TT></TD><TD>Process start time stamp</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%v</TT></TD><TD>Virtual transaction ID (backendID/localXID)</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%x</TT></TD><TD>Transaction ID (0 if none is assigned)</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%q</TT></TD><TD>Produces no output, but tells non-session
processes to stop at this point in the string; ignored by
session processes</TD><TD>no</TD></TR><TR><TD><TT CLASS="LITERAL">%%</TT></TD><TD>Literal <TT CLASS="LITERAL">%</TT></TD><TD>no</TD></TR></TBODY></TABLE><P></P></DIV>
<TT CLASS="LITERAL">%c</TT>转义打印唯一会话标识符，
由两个点号分隔的4字节的十六进制数字（没有前导零）组成。
数字是该过程的开始时间和进程ID，
所以<TT CLASS="LITERAL">%c</TT>也可以用做一种打印这些项目的节约空间的方法。
例如，为了从<TT CLASS="LITERAL">pg_stat_activity</TT>中生成会话标识符，使用这个查询：
</P><PRE CLASS="PROGRAMLISTING">SELECT to_hex(EXTRACT(EPOCH FROM backend_start)::integer) || '.' ||
       to_hex(pid)
FROM pg_stat_activity;</PRE><P>
</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B> 如果你设置<TT CLASS="VARNAME">log_line_prefix</TT>的非空值，你应该经常使其最后一个字符是一个空格，
提供来自日志行的其余部分的视觉分离。一个标点符号也可以使用。</P></BLOCKQUOTE></DIV><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B> <SPAN CLASS="APPLICATION">Syslog</SPAN>产生自身时间戳和进程ID信息，如果你记录到<SPAN CLASS="APPLICATION">syslog</SPAN>，
所以你可能不想包括那些逃脱。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="GUC-LOG-LOCK-WAITS"></A><TT CLASS="VARNAME">log_lock_waits</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 当会话等待比<A HREF="runtime-config-locks.html#GUC-DEADLOCK-TIMEOUT">deadlock_timeout</A>获得锁更长的时间时，控制是否产生一个日志消息。
决定如果锁等待造成很差的性能，这是很有用处的。默认是<TT CLASS="LITERAL">off</TT>。</P></DD><DT><A NAME="GUC-LOG-STATEMENT"></A><TT CLASS="VARNAME">log_statement</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 控制记录哪些SQL语句。有效的值是<TT CLASS="LITERAL">none</TT> (off), <TT CLASS="LITERAL">ddl</TT>, <TT CLASS="LITERAL">mod</TT>和
<TT CLASS="LITERAL">all</TT> (所有语句)。<TT CLASS="LITERAL">ddl</TT>记录所有数据定义命令，比如<TT CLASS="COMMAND">CREATE</TT>,
<TT CLASS="COMMAND">ALTER</TT>和<TT CLASS="COMMAND">DROP</TT>语句。
<TT CLASS="LITERAL">mod</TT>记录所有<TT CLASS="LITERAL">ddl</TT>语句，
加上数据修改语句<TT CLASS="COMMAND">INSERT</TT>,<TT CLASS="COMMAND">UPDATE</TT>, <TT CLASS="COMMAND">DELETE</TT>, <TT CLASS="COMMAND">TRUNCATE</TT>,
和<TT CLASS="COMMAND">COPY FROM</TT>。如果所包含的命令类型吻合，那么<TT CLASS="COMMAND">PREPARE</TT>, <TT CLASS="COMMAND">EXECUTE</TT>和
<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>语句也同样被记录。
对于使用扩展查询协议的客户端，记录发生在接受到扩展信息并包含邦定参数(内置单引号要双写)的时候。</P><P> 缺省是<TT CLASS="LITERAL">none</TT>。只有超级用户可以改变这个设置。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 即使设置了<TT CLASS="VARNAME">log_statement</TT> = <TT CLASS="LITERAL">all</TT>，包含简单语法错误的语句也不会被记录。
因为仅在完成基本的语法分析并确定了语句类型之后才记录日志。在使用扩展查询协议的情况下，
在执行阶段之前(语法分析或规划阶段)同样不会记录。
将<TT CLASS="VARNAME">log_min_error_statement</TT>设为<TT CLASS="LITERAL">ERROR</TT>或更低才能记录这些语句。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="GUC-LOG-TEMP-FILES"></A><TT CLASS="VARNAME">log_temp_files</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 控件的临时文件名称和大小。临时文件可以创建的分类，哈希，和临时的查询结果。
当它被删除时，一个日志项有利于每个临时文件。
零值记录所有临时文件的信息，
同时正值记录文件大小大于或等于千字节指定数量。
默认设置是-1，禁用这样的日志。只有超级用户可以更改此设置。</P></DD><DT><A NAME="GUC-LOG-TIMEZONE"></A><TT CLASS="VARNAME">log_timezone</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置用于写入服务器日志的时间戳的时区。不像<A HREF="runtime-config-client.html#GUC-TIMEZONE">TimeZone</A>，这个值是簇范围，
因此，所有会话将持续报告时间戳。默认值<TT CLASS="LITERAL">GMT</TT>，但这通常被
<TT CLASS="FILENAME">postgresql.conf</TT>覆盖；<SPAN CLASS="APPLICATION">initdb</SPAN>
将安装与其系统环境一致的设置。参见<A HREF="datatype-datetime.html#DATATYPE-TIMEZONES">第 8.5.3 &#33410;</A>获取更多信息。
这个参数只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件或者服务器命令行上进行。</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="RUNTIME-CONFIG-LOGGING-CSVLOG">18.8.4. 使用CSV-格式日志输出</A></H2><P>
在<TT CLASS="VARNAME">log_destination</TT>列表中包含<TT CLASS="LITERAL">csvlog</TT>
提供了一种便捷的方式导入日志文件到一个数据库表。
此选项在逗号分隔值(<ACRONYM CLASS="ACRONYM">CSV</ACRONYM>)中发出日志行，这些列为：
time stamp with milliseconds,
user name,
database name,
process ID,
client host:port number,
session ID,
per-session line number,
command tag,
session start time,
virtual transaction ID,
regular transaction ID,
error severity,
SQLSTATE code,
error message,
error message detail,
hint,
导致错误的内部查询（如果有），字符计算错误位置，
包含错误文本，导致错误的用户查询（如果有并且通过<TT CLASS="VARNAME">log_min_error_statement</TT>启动），
字符计算错误位置。其中有PostgreSQL源代码错误的位置（如果<TT CLASS="VARNAME">log_error_verbosity</TT>设置为<TT CLASS="LITERAL">verbose</TT>），
以及应用程序的名称。这是一个用于存储CSV格式的日志输出样本表定义：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE postgres_log
(
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  PRIMARY KEY (session_id, session_line_num)
);</PRE><P>
</P><P>
使用<TT CLASS="COMMAND">COPY FROM</TT>命令，将日志文件导入到这个表中：
</P><PRE CLASS="PROGRAMLISTING">COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;</PRE><P>
</P><P>
你需要做几件事情简化导入CSV日志文件：
<P></P></P><OL TYPE="1"><LI><P>
设置<TT CLASS="VARNAME">log_filename</TT>和
<TT CLASS="VARNAME">log_rotation_age</TT>为你的日志文件
提供一个一致的，可预见的命名方式。
这让你预测哪些文件的名称以及独立日志文件是完整的，因此可以准备导入。
</P></LI><LI><P> 设置<TT CLASS="VARNAME">log_rotation_size</TT>为0以禁用基于大小的日志旋转，
因为它很难预测日志文件名。
</P></LI><LI><P> 设置<TT CLASS="VARNAME">log_truncate_on_rotation</TT>到<TT CLASS="LITERAL">on</TT>，以致于
旧的日志数据不与同一文件的新数据混合。</P></LI><LI><P> 上面表定义包括主密钥规范。这是为了防止意外导入相同的有用信息两次。
<TT CLASS="COMMAND">COPY</TT>命令要求所有的数据一次导入，所以任何错误都将导致整个导入过程失败。
如果你导入部分日志文件，当它完成时，然后再导入该文件，主键冲突会导致导入过程失败。
等待直到日志是完整的，并且导入之前关闭。
该程序也将防止意外导入尚未完全写入的局部行，
这也将导致<TT CLASS="COMMAND">COPY</TT>失败。</P></LI></OL><P>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="runtime-config-query.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="runtime-config-statistics.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">查询规划</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">运行时统计</TD></TR></TABLE></DIV></BODY></HTML>
