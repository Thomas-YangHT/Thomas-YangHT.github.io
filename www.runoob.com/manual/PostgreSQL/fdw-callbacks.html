<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>外数据封装回调程序</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="写一个外数据包" HREF="http://school.yunwei.edu/manual/PostgreSQL/fdwhandler.html"><LINK REL="PREVIOUS" TITLE="外数据封装函数" HREF="fdw-functions.html"><LINK REL="NEXT" TITLE="外数据封装辅助函数" HREF="fdw-helpers.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/fdwhandler.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="外数据封装函数" HREF="fdw-functions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/fdwhandler.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 52. 写一个外数据包</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="外数据封装辅助函数" HREF="fdw-helpers.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FDW-CALLBACKS">52.2. 外数据封装回调程序</A></H1><P>
FDW处理函数返回包含指向下面描述的回调函数指针的palloc'd <TT CLASS="STRUCTNAME">FdwRoutine</TT>结构。
扫描相关函数是必须的，其余的是可选的。</P><P> 在<TT CLASS="FILENAME">src/include/foreign/fdwapi.h</TT>中声明<TT CLASS="STRUCTNAME">FdwRoutine</TT>结构类型，
参阅额外详情。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FDW-CALLBACKS-SCAN">52.2.1. 扫描外表的FDW程序</A></H2><P></P><PRE CLASS="PROGRAMLISTING">void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);</PRE><P>
获得评估外表关系大小。这就是所谓的开始扫描外表的查询规划。
<TT CLASS="LITERAL">root</TT>是关于查询的规划器的全局信息；
<TT CLASS="LITERAL">baserel</TT>是关于这个表的规划器信息；
<TT CLASS="LITERAL">foreigntableid</TT>是外表的<TT CLASS="STRUCTNAME">pg_class</TT> OID。
（<TT CLASS="LITERAL">foreigntableid</TT>可以从规划器数据结构中获得，
但是它明确被传递用来节省力气。）
</P><P> 在说明限制资格测试执行过滤之后，
该函数应该更新<TT CLASS="LITERAL">baserel-&gt;rows</TT>为通过表扫描返回的行期望数。
<TT CLASS="LITERAL">baserel-&gt;rows</TT>的初始值仅仅是恒定缺省估计，
如果可能的话，这应该被替换。如果它可以对平均结果行宽度计算出更好的评估，那么
该函数可能也会选择更新<TT CLASS="LITERAL">baserel-&gt;width</TT>。</P><P> 参阅<A HREF="fdw-planning.html">第 52.4 &#33410;</A>可以获取额外信息。 </P><P></P><PRE CLASS="PROGRAMLISTING">void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);</PRE><P>
创建外表扫描的可能访问路径。
这就是所谓的查询规划。
它被调用的参数和<CODE CLASS="FUNCTION">GetForeignRelSize</CODE>相同。
</P><P> 该函数必须为外表扫描产生至少1个访问路径(<TT CLASS="STRUCTNAME">ForeignPath</TT>节点)而且
必须调用<CODE CLASS="FUNCTION">add_path</CODE>添加每个这样的路径到<TT CLASS="LITERAL">baserel-&gt;pathlist</TT>中。
推荐使用<CODE CLASS="FUNCTION">create_foreignscan_path</CODE>建立<TT CLASS="STRUCTNAME">ForeignPath</TT>节点。
该函数可以生成多个访问路径，比如具有有效<TT CLASS="LITERAL">pathkeys</TT>表示预排序结果路径。
每个访问路径必须包含成本估计，并且包含需要标识具体预期扫描方法的任何FDW-私有信息。</P><P> 参阅<A HREF="fdw-planning.html">第 52.4 &#33410;</A>获取额外信息。</P><P></P><PRE CLASS="PROGRAMLISTING">ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses);</PRE><P>
从所选择的外访问路径中创建<TT CLASS="STRUCTNAME">ForeignScan</TT>规划节点。
这从查询规划结尾被调用。
该参数为<CODE CLASS="FUNCTION">GetForeignRelSize</CODE>，加上所选择的<TT CLASS="STRUCTNAME">ForeignPath</TT>
（通过<CODE CLASS="FUNCTION">GetForeignPaths</CODE>预先生成），
通过规划节点发出目标列表，并且限制子句通过规划节点被执行。
</P><P> 该函数必须创建并且返回<TT CLASS="STRUCTNAME">ForeignScan</TT>规划节点；
推荐使用<CODE CLASS="FUNCTION">make_foreignscan</CODE>建立<TT CLASS="STRUCTNAME">ForeignScan</TT>节点。</P><P> 参阅<A HREF="fdw-planning.html">第 52.4 &#33410;</A>获取额外信息。</P><P></P><PRE CLASS="PROGRAMLISTING">void
BeginForeignScan (ForeignScanState *node,
                  int eflags);</PRE><P>
开始执行一个外部扫描。这是在执行器启动期间调用。它应该执行扫描开始前需要的任何初始化。
但没有开始执行实际扫描（应该执行第一次调用<CODE CLASS="FUNCTION">IterateForeignScan</CODE>）。
<TT CLASS="STRUCTNAME">ForeignScanState</TT>节点已经被创建，但是它的<TT CLASS="STRUCTFIELD">fdw_state</TT>字段仍然是NULL。
通过<TT CLASS="STRUCTNAME">ForeignScanState</TT>节点扫描的表信息（尤其是，来自底层的<TT CLASS="STRUCTNAME">ForeignScan</TT>规划节点，
它包含任何通过<CODE CLASS="FUNCTION">GetForeignPlan</CODE>提供的FDW-私有信息）。
<TT CLASS="LITERAL">eflags</TT>包含描述该规划节点执行器的操作模式的标志位。
</P><P> 注意当<TT CLASS="LITERAL">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</TT>为真时，
该函数不应该执行任何外部可见行为；
它应该为<CODE CLASS="FUNCTION">ExplainForeignScan</CODE>和
<CODE CLASS="FUNCTION">EndForeignScan</CODE>执行最小需求使得节点状态有效。
</P><P></P><PRE CLASS="PROGRAMLISTING">TupleTableSlot *
IterateForeignScan (ForeignScanState *node);</PRE><P>
从外部源读取一行，在元组表槽中返回它（节点的<TT CLASS="STRUCTFIELD">ScanTupleSlot</TT>用于这个目的）。
如果没有更多行可用，那么返回NULL。元组表槽基础设施允许返回物理或者虚拟元组。
在大多数情况下后者选择从性能角度更可取。
注意这被称为在调用期间被重置的短暂内存语境。如果
你需要较长时间存储，或者使用节点的<TT CLASS="STRUCTNAME">EState</TT>的<TT CLASS="STRUCTFIELD">es_query_cxt</TT>，
那么在<CODE CLASS="FUNCTION">BeginForeignScan</CODE>中创建内存上下文。
</P><P> 返回的行必须匹配扫描外表的列标志。如果你选择优化掉不需要的列，那么
你应该在那些列位置插入空值。</P><P> 注意<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的执行器并不在乎返回的行是否违反任何在外表列定义的<TT CLASS="LITERAL">NOT NULL</TT>
约束&mdash; 但是规划器关心，如果<TT CLASS="LITERAL">NULL</TT>值出现在声明列中而不包含它们，那么可能错误地优化查询。
当用户声明不应该存在时，如果遇到<TT CLASS="LITERAL">NULL</TT>值，它可能会适当提高错误
（正如你需要在数据类型不匹配的情况下执行）。</P><P></P><PRE CLASS="PROGRAMLISTING">void
ReScanForeignScan (ForeignScanState *node);</PRE><P>
从开始重启扫描。注意任何参数扫描取决于已改变的值，
因此扫描不一定返回完全相同的行。
</P><P></P><PRE CLASS="PROGRAMLISTING">void
EndForeignScan (ForeignScanState *node);</PRE><P>
结束扫描并且释放资源。释放palloc内存往往不重要，但是比如打开文件并且链接远程服务器应该
被清理干净。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FDW-CALLBACKS-UPDATE">52.2.2. 更新外表FDW程序</A></H2><P> 如果FDW支持可写外表，
那么它应该提供一些或者所有下面的依赖于
FDW的需要和能力的回调函数：</P><P></P><PRE CLASS="PROGRAMLISTING">void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation);</PRE><P>
在通过表扫描函数预先读取行之前执行<TT CLASS="COMMAND">UPDATE</TT>和<TT CLASS="COMMAND">DELETE</TT>操作。
FDW可能需要额外信息，比如行ID或者主键列值，为了确保它可以找到确切行更新或者删除。
为了支持它，该函数可以添加额外隐藏，或者<SPAN CLASS="QUOTE">"junk"</SPAN>，在<TT CLASS="COMMAND">UPDATE</TT>或者
<TT CLASS="COMMAND">DELETE</TT>中从外表中检索列表中的目标列。
</P><P> 要做到这一点，添加<TT CLASS="STRUCTNAME">TargetEntry</TT>项到
<TT CLASS="LITERAL">parsetree-&gt;targetList</TT>，包含读取的额外值的表达式。
每个这样的项必须被标记<TT CLASS="STRUCTFIELD">resjunk</TT> = <TT CLASS="LITERAL">true</TT>，
并且有一个不同的<TT CLASS="STRUCTFIELD">resname</TT>在执行期间标识它。
避免使用匹配<TT CLASS="LITERAL">ctid<TT CLASS="REPLACEABLE"><I>N</I></TT></TT>或者
<TT CLASS="LITERAL">wholerow<TT CLASS="REPLACEABLE"><I>N</I></TT></TT>的名称，正如核心系统可以
产生这些名字的垃圾列。</P><P> 在改写过程中调用该函数，而不是规划器，因此该可用信息不同于可用的规划程序。
当<TT CLASS="LITERAL">target_rte</TT>和
<TT CLASS="LITERAL">target_relation</TT>描述目标外表时，<TT CLASS="LITERAL">parsetree</TT>是<TT CLASS="COMMAND">UPDATE</TT>或者
<TT CLASS="COMMAND">DELETE</TT>命令的解析树。</P><P> 如果<CODE CLASS="FUNCTION">AddForeignUpdateTargets</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，
那么没有额外目标表达式被添加。
（这将不可能实现<TT CLASS="COMMAND">DELETE</TT>操作，尽管<TT CLASS="COMMAND">UPDATE</TT>可能仍然是可行的，
如果FDW依赖于一个标识行的未改变主键）。</P><P></P><PRE CLASS="PROGRAMLISTING">List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index);</PRE><P>
执行任何额外规划操作需要插入，更新或者删除外表。
该函数产生附属于执行更新操作的<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点
的FDW-私有信息。这个私有信息必须有<TT CLASS="LITERAL">List</TT>形式，并且
在执行阶段将转交给<CODE CLASS="FUNCTION">BeginForeignModify</CODE>。
</P><P> <TT CLASS="LITERAL">root</TT>是关于查询的规划器的全局信息。
<TT CLASS="LITERAL">plan</TT>是<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点，
除了<TT CLASS="STRUCTFIELD">fdwPrivLists</TT>字段外它是完整的。
<TT CLASS="LITERAL">resultRelation</TT>通过射程表索引识别目标外表。
<TT CLASS="LITERAL">subplan_index</TT>识别从零开始计算的<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点是哪个目标；
如果你想要索引<TT CLASS="LITERAL">plan-&gt;plans</TT>或者其他<TT CLASS="LITERAL">plan</TT>节点的子结构，那么使用它。
</P><P> 参阅<A HREF="fdw-planning.html">第 52.4 &#33410;</A>获取更多额外信息。</P><P> 如果<CODE CLASS="FUNCTION">PlanForeignModify</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，
没有采取额外规划时间操作，并且<TT CLASS="LITERAL">fdw_private</TT>列表转交给
<CODE CLASS="FUNCTION">BeginForeignModify</CODE>为零。</P><P></P><PRE CLASS="PROGRAMLISTING">void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags);</PRE><P>
开始执行一个外表修改操作。这个程序在执行器启动时调用。
应该在实际表修改前执行任何初始化。随后，<CODE CLASS="FUNCTION">ExecForeignInsert</CODE>, <CODE CLASS="FUNCTION">ExecForeignUpdate</CODE>或者
<CODE CLASS="FUNCTION">ExecForeignDelete</CODE>需要每个元组被插入，更新或者删除。
</P><P> <TT CLASS="LITERAL">mtstate</TT>是被执行的<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点的整体状态；
关于规划的全局数据和执行状态通过该结构是可用的。
<TT CLASS="LITERAL">rinfo</TT>是描述目标外表的<TT CLASS="STRUCTNAME">ResultRelInfo</TT>结构。
（<TT CLASS="STRUCTNAME">ResultRelInfo</TT>的<TT CLASS="STRUCTFIELD">ri_FdwState</TT>字段用于FDW存储任何需要该操作的私有状态。）
如果任何的，那么<TT CLASS="LITERAL">fdw_private</TT>包含通过<CODE CLASS="FUNCTION">PlanForeignModify</CODE>产生的私有数据。
<TT CLASS="LITERAL">subplan_index</TT>识别<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点是哪个目标。
<TT CLASS="LITERAL">eflags</TT>包含描述这个规划节点的执行器操作模式的标志位。</P><P> 注意当<TT CLASS="LITERAL">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</TT>为真时，
该函数不应该执行任何外部可见操作；
它应该为<CODE CLASS="FUNCTION">ExplainForeignModify</CODE>和
<CODE CLASS="FUNCTION">EndForeignModify</CODE>执行最小需求使得节点状态有效。</P><P> 如果<CODE CLASS="FUNCTION">BeginForeignModify</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，
那么在执行器启动期间不采取任何操作。</P><P></P><PRE CLASS="PROGRAMLISTING">TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</PRE><P>
插入一个元组到外表。<TT CLASS="LITERAL">estate</TT>是查询的全局执行状态。
<TT CLASS="LITERAL">rinfo</TT>是描述目标外表的<TT CLASS="STRUCTNAME">ResultRelInfo</TT>结构。
<TT CLASS="LITERAL">slot</TT>包含要插入的元组；它将匹配外表rowtype定义。
<TT CLASS="LITERAL">planSlot</TT>包含通过<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点的子计划产生的元组；
它不同于可能包含额外<SPAN CLASS="QUOTE">"junk"</SPAN>列的<TT CLASS="LITERAL">slot</TT>。
</P><P> 返回值要么是包含实际插入的数据的槽（这可能与提供的数据不同，比如作为触发器操作结果），
如果没有行实际被插入，那么返回NULL（再次，通常作为触发器结果）。
传入的<TT CLASS="LITERAL">slot</TT>可以重新用于这个目的。
</P><P> 只有<TT CLASS="COMMAND">INSERT</TT>查询有<TT CLASS="LITERAL">RETURNING</TT>子句时，
才使用返回槽中的数据。因此，FDW可能选择优化返回依赖于<TT CLASS="LITERAL">RETURNING</TT>子句内容的一些或者全部列。
然而，必须返回一些插槽表示成功，或者查询报告的行数是错误的。</P><P> 如果<CODE CLASS="FUNCTION">ExecForeignInsert</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，
尝试插入外表将带有错误信息而失败。</P><P></P><PRE CLASS="PROGRAMLISTING">TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</PRE><P>
更新外表上的元组。
<TT CLASS="LITERAL">estate</TT>是查询的全局执行状态。<TT CLASS="LITERAL">rinfo</TT>是描述目标外表的
<TT CLASS="STRUCTNAME">ResultRelInfo</TT>结构。<TT CLASS="LITERAL">slot</TT>包含元组的新数据；
它将匹配外表rowtype定义。
<TT CLASS="LITERAL">planSlot</TT>包含通过<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点的子计划产生的元组；
它不同于可能包含额外<SPAN CLASS="QUOTE">"junk"</SPAN>列的<TT CLASS="LITERAL">slot</TT>。
尤其是，通过<CODE CLASS="FUNCTION">AddForeignUpdateTargets</CODE>请求的任何垃圾列将从该槽中提供。
</P><P> 返回值要么是包含实际更新的行的槽（这可能与提供的数据不同，比如作为触发器操作结果），
如果没有行实际被更新，那么返回NULL（再次，通常作为触发器结果）。
传入的<TT CLASS="LITERAL">slot</TT>可以重新用于这个目的。</P><P> 只有<TT CLASS="COMMAND">UPDATE</TT>查询有<TT CLASS="LITERAL">RETURNING</TT>子句时，
才使用返回槽中的数据。因此，FDW可能选择优化返回依赖于<TT CLASS="LITERAL">RETURNING</TT>子句内容的一些或者全部列。
然而，必须返回一些插槽表示成功，或者查询报告的行数是错误的。</P><P> 如果<CODE CLASS="FUNCTION">ExecForeignUpdate</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，
尝试更新外表将带有错误信息而失败。</P><P></P><PRE CLASS="PROGRAMLISTING">TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</PRE><P>
删除外表上的元组。
<TT CLASS="LITERAL">estate</TT>是查询的全局执行状态。<TT CLASS="LITERAL">rinfo</TT>是描述目标外表的
<TT CLASS="STRUCTNAME">ResultRelInfo</TT>结构。<TT CLASS="LITERAL">slot</TT>不包含任何有用调用，
但是可以用于保留返回的元组。
<TT CLASS="LITERAL">planSlot</TT>包含通过<TT CLASS="STRUCTNAME">ModifyTable</TT>规划节点的子计划产生的元组；
尤其是，它将具有通过<CODE CLASS="FUNCTION">AddForeignUpdateTargets</CODE>请求的任何垃圾列。
垃圾列必须用于标识要删除的元组。
</P><P> 返回值要么是包含实际被删除行的槽，
如果没有行实际被删除，那么返回NULL（再次，通常作为触发器结果）。
传入的<TT CLASS="LITERAL">slot</TT>可以用于保留返回的元组。</P><P> 只有<TT CLASS="COMMAND">DELETE</TT>查询有<TT CLASS="LITERAL">RETURNING</TT>子句时，
才使用返回槽中的数据。因此，FDW可能选择优化返回依赖于<TT CLASS="LITERAL">RETURNING</TT>子句内容的一些或者全部列。
然而，必须返回一些插槽表示成功，或者查询报告的行数是错误的。</P><P> 如果<CODE CLASS="FUNCTION">ExecForeignDelete</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，
尝试删除外表将带有错误信息而失败。</P><P></P><PRE CLASS="PROGRAMLISTING">void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo);</PRE><P>
结束表更新并且释放资源。释放palloc内存往往不重要，但是比如打开文件并且链接远程服务器应该
被清理干净。
</P><P> 如果<CODE CLASS="FUNCTION">EndForeignModify</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，
那么在执行器关闭期间不采取任何操作。 </P><P></P><PRE CLASS="PROGRAMLISTING">int
IsForeignRelUpdatable (Relation rel);</PRE><P>
报告指定外表支持的更新操作。返回值应该是规则事件数的位掩码，标志着
使用<TT CLASS="LITERAL">CmdType</TT>枚举通过外表支持的操作；即<TT CLASS="LITERAL">(1 &#60;&#60; CMD_UPDATE) = 4</TT>为<TT CLASS="COMMAND">UPDATE</TT>,
<TT CLASS="LITERAL">(1 &#60;&#60; CMD_INSERT) = 8</TT>为<TT CLASS="COMMAND">INSERT</TT>并且
<TT CLASS="LITERAL">(1 &#60;&#60; CMD_DELETE) = 16</TT>为<TT CLASS="COMMAND">DELETE</TT>。
</P><P> 如果<CODE CLASS="FUNCTION">IsForeignRelUpdatable</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，那么FDW分别
提供<CODE CLASS="FUNCTION">ExecForeignInsert</CODE>,
<CODE CLASS="FUNCTION">ExecForeignUpdate</CODE>或者<CODE CLASS="FUNCTION">ExecForeignDelete</CODE>，那么
外表被认为是可插入，可更新或者可删除的。
如果FDW支持一些可更新的和一些不可更新的表，那么需要这个函数。
（即使这样，它允许在执行程序中抛出错误而不是在这个函数中进行检查。然而，该函数
用于在<TT CLASS="LITERAL">information_schema</TT>视图中显示可更新。）
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FDW-CALLBACKS-EXPLAIN">52.2.3. <TT CLASS="COMMAND">EXPLAIN</TT>的FDW程序</A></H2><P></P><PRE CLASS="PROGRAMLISTING">void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);</PRE><P>
为外表扫描打印额外<TT CLASS="COMMAND">EXPLAIN</TT>输出。
该函数可以调用<CODE CLASS="FUNCTION">ExplainPropertyText</CODE>和相关函数添加到<TT CLASS="COMMAND">EXPLAIN</TT>输出字段。
<TT CLASS="LITERAL">es</TT>中的标志位可以用于决定打印什么，并且检查<TT CLASS="STRUCTNAME">ForeignScanState</TT>节点状态
用来在<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>情况下提供运行时统计。
</P><P> 如果<CODE CLASS="FUNCTION">ExplainForeignScan</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，那么
在<TT CLASS="COMMAND">EXPLAIN</TT>期间不打印额外信息。</P><P></P><PRE CLASS="PROGRAMLISTING">void
ExplainForeignModify (ModifyTableState *mtstate,
                      ResultRelInfo *rinfo,
                      List *fdw_private,
                      int subplan_index,
                      struct ExplainState *es);</PRE><P>
为外表更新打印额外<TT CLASS="COMMAND">EXPLAIN</TT>输出。
该函数可以调用<CODE CLASS="FUNCTION">ExplainPropertyText</CODE>和相关函数添加到<TT CLASS="COMMAND">EXPLAIN</TT>输出字段。
<TT CLASS="LITERAL">es</TT>中的标志位可以用于决定打印什么，并且检查<TT CLASS="STRUCTNAME">ModifyTableState</TT>节点状态
用来在<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>情况下提供运行时统计。前四个参数为<CODE CLASS="FUNCTION">BeginForeignModify</CODE>
是相同的。
</P><P> 如果<CODE CLASS="FUNCTION">ExplainForeignModify</CODE>指针被设置为<TT CLASS="LITERAL">NULL</TT>，那么
在<TT CLASS="COMMAND">EXPLAIN</TT>期间不打印任何额外信息。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FDW-CALLBACKS-ANALYZE">52.2.4. <TT CLASS="COMMAND">ANALYZE</TT>的FDW程序</A></H2><P></P><PRE CLASS="PROGRAMLISTING">bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);</PRE><P>
当在外表上执行<A HREF="sql-analyze.html">ANALYZE</A>时，调用该函数。
如果FDW可以收集外表的统计，它应该返回<TT CLASS="LITERAL">真</TT>，
并且提供一个指针给函数，该函数从<TT CLASS="PARAMETER">func</TT>中的表中收集样本行。
以及<TT CLASS="PARAMETER">totalpages</TT>的页中表的估计大小。
否则，返回<TT CLASS="LITERAL">false</TT>。
</P><P> 如果FDW不支持任何表的统计，那么<CODE CLASS="FUNCTION">AnalyzeForeignTable</CODE>指针可以设置为<TT CLASS="LITERAL">NULL</TT>。</P><P>
如果提供，那么样本收集函数必须有识别标志
</P><PRE CLASS="PROGRAMLISTING">int
AcquireSampleRowsFunc (Relation relation, int elevel,
                       HeapTuple *rows, int targrows,
                       double *totalrows,
                       double *totaldeadrows);</PRE><P>
应该从表中收集达到<TT CLASS="PARAMETER">targrows</TT>行的随机抽样调查，并且存储到
调用者提供的<TT CLASS="PARAMETER">rows</TT>数组。必须返回收集行的真实数。
此外，将表中死的和活行
总数估计存储到输出参数<TT CLASS="PARAMETER">totalrows</TT>和
<TT CLASS="PARAMETER">totaldeadrows</TT>中。（如果FDW
没有死行的任何概念，那么设置<TT CLASS="PARAMETER">totaldeadrows</TT>为零。）
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="fdw-functions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="fdw-helpers.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">外数据封装函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/fdwhandler.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">外数据封装辅助函数</TD></TR></TABLE></DIV></BODY></HTML>
