<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>postgres_fdw</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="pg_trgm" HREF="pgtrgm.html"><LINK REL="NEXT" TITLE="seg" HREF="seg.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/postgres-fdw.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_trgm" HREF="pgtrgm.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="seg" HREF="seg.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="POSTGRES-FDW">F.31. postgres_fdw</A></H1><P> <TT CLASS="FILENAME">postgres_fdw</TT>模块提供外部数据封装器的功能，PostgreSQL通过
它可以访问存储在外部的 <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器上的数据。
</P><P> 本模块提供的功能不但涵盖老版本中<A HREF="dblink.html">dblink</A>模块实现的功能，
而且postgres_fdw提供更加透明和符合标准的语法来访问远程表，并在许多情况下
提供更好的性能。
</P><P>
使用<TT CLASS="FILENAME">postgres_fdw</TT>模块做远程访问的准备:
<P></P></P><OL COMPACT="COMPACT" TYPE="1"><LI><P>
使用<A HREF="sql-createextension.html">CREATE EXTENSION</A>语句安装<TT CLASS="FILENAME">postgres_fdw</TT>.
</P></LI><LI><P>
使用<A HREF="sql-createserver.html">CREATE SERVER</A>语句,为每个需要连接的远程数据库
创建一个外部服务器对象。指定除了<TT CLASS="LITERAL">user</TT>和<TT CLASS="LITERAL">password</TT>
以外的连接信息作为服务器对象的选项。
</P></LI><LI><P>
使用<A HREF="sql-createusermapping.html">CREATE USER MAPPING</A>语句，为每个需要通过外部服务器
访问的数据库创建用户映射。指定远程的和密码作为映射用户的<TT CLASS="LITERAL">user</TT>
和<TT CLASS="LITERAL">password</TT>。
</P></LI><LI><P>
使用<A HREF="sql-createforeigntable.html">CREATE FOREIGN TABLE</A>语句，为每个需要访问的远程表创建外部表。
创建的外部表的对应列必须与远程表匹配。也可以在外部表中使用与远程表不同的表名和列名，
但前提是你必须将正确的远程对象名作为创建外部表对象的选项。
</P></LI></OL><P>
</P><P> 上面的操作成功后就可以使用<TT CLASS="COMMAND">SELECT</TT>外部表的方式访问存储在
远程表中的数据了。同样<TT CLASS="COMMAND">INSERT</TT>, <TT CLASS="COMMAND">UPDATE</TT>和
<TT CLASS="COMMAND">DELETE</TT>操作都是可以执行的。（映射的远程用户需要有能做这些操作的权限）
</P><P>
建议外部表的字段和相关联的远程表使用相同的数据类型和校对规则，虽然
<TT CLASS="FILENAME">postgres_fdw</TT>允许在需要的时候进行字符类型的转换，但当数据
类型和校对规则不匹配的时候，由于远程服务器和本地服务器对于
<TT CLASS="LITERAL">WHERE</TT>条件的不同解释，也许会造成语义的错误。
</P><P> 需要注意的是一个外部表可以声明比和他关联的远程表更少的列，列的排序也可以
不同。和远程表列的关联用的是列名，和列的位置无关。
</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149608">F.31.1. postgres_fdw中FDW选项</A></H2><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN149610">F.31.1.1. 连接选项</A></H3><P>
一个作为封装外部数据使用的外部服务器，可以使用libpq接受的连接字符串，详见
<A HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS">第 31.1.2 &#33410;</A>，除了下面的选项是不允许使用的：
<P></P></P><UL COMPACT="COMPACT"><LI><P>
<TT CLASS="LITERAL">user</TT>和<TT CLASS="LITERAL">password</TT>（将在用户映射中指定）
</P></LI><LI><P>
<TT CLASS="LITERAL">client_encoding</TT>(根据本地服务器编码自动设定）
</P></LI><LI><P>
<TT CLASS="LITERAL">fallback_application_name</TT>(设定为<TT CLASS="LITERAL">postgres_fdw</TT>）
</P></LI></UL><P>
</P><P>
只有超级用户连接到外部服务器是不需要密码的，所以需要为映射的普通用户指定
<TT CLASS="LITERAL">password</TT>。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN149628">F.31.1.2. 对象名称选项</A></H3><P>
这些设置选项被用来控制被发往远程postgres服务器中的sql语句对象名称。
在外部表的名和关联的远程表名不同时，用于设置关联。
</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">schema_name</TT></DT><DD><P>
这个选项可以为外部表指定模式名，和远程服务器上的表做关联。如果忽略
这个选项，远程表本身的模式名会被外部表使用。
</P></DD><DT><TT CLASS="LITERAL">table_name</TT></DT><DD><P>
这个选项可以为外部表指定表名，和远程服务器上的表做关联。如果忽略
这个选项，远程表本身的表名会被外部表使用。
</P></DD><DT><TT CLASS="LITERAL">column_name</TT></DT><DD><P>
这个选项可以为外部表列指定表名，和远程服务器上的列做关联。如果忽略
这个选项，远程表本身的列名会被外部表使用。
</P></DD></DL></DIV></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN149647">F.31.1.3. 成本估算选项</A></H3><P>
<TT CLASS="FILENAME">postgres_fdw</TT>检索数据是在远程服务器上执行的，所以成本的估算
不只是远程服务器扫描外部表的效率，还应该加上网络通信的开销。想要获得预期
结果最可靠的方式是对远程服务器做请求增加开销，但是对于一些简单查询来说可能
不值得这样做，所<TT CLASS="FILENAME">postgres_fdw</TT>提供如下选项做成本估算：
</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">use_remote_estimate</TT></DT><DD><P>
外部表或者外部服务器可以指定该选项，用来控制<TT CLASS="FILENAME">postgres_fdw</TT>是否发出远程的
<TT CLASS="COMMAND">EXPLAIN</TT>命令来获取成本估算。表的设定优先于服务器的设定，但只限于
设定的表。默认值的false。
</P></DD><DT><TT CLASS="LITERAL">fdw_startup_cost</TT></DT><DD><P>
外部服务器可以指定该选项，该数值类型的选项会在每个外部表的查询开始前加入
一个数值成本。用这个值代表建立连接，在远程端的查询分析和规划的额外开销。
默认值是 <TT CLASS="LITERAL">100</TT>。
</P></DD><DT><TT CLASS="LITERAL">fdw_tuple_cost</TT></DT><DD><P>
外部服务器可以指定该选项，该数值类型的选项会根据外部表扫描结果为每行加入
一个额外的成本。这个代表服务器间传输数据的额外的网络开销。可以用这个数值
的高低来反应到远程服务器的网络延迟。默认值是<TT CLASS="LITERAL">0.01</TT>。
</P></DD></DL></DIV><P>
<TT CLASS="LITERAL">use_remote_estimate</TT>值为真的时候，成本估算的方法是
<TT CLASS="FILENAME">postgres_fdw</TT>获取远程服务器的语句执行操作成本估算值加上
<TT CLASS="LITERAL">fdw_startup_cost</TT>和<TT CLASS="LITERAL">use_remote_estimate</TT>。
当值为假的时候，成本估算方法只能是按照语句本地的执行成本加上
<TT CLASS="LITERAL">fdw_startup_cost</TT>和<TT CLASS="LITERAL">use_remote_estimate</TT>。
除非本地表的统计信息和远程表统计信息的相同，否则本地的估算一般是不精确的。
在外部表执行<A HREF="sql-analyze.html">ANALYZE</A>操作来刷新远程表的统计信息，
这个操作会扫描远程表，使计算和存储统计信息就像在本地一样。在本地保存统计信息
可以减少远程表的每个查询的执行计划都造成系统开销。但是如果远程表被更新的频率
太高，本地的统计信息也会很快失去应有的作用。
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN149680">F.31.1.4. 更新选型</A></H3><P>
默认情况下，所有<TT CLASS="FILENAME">postgres_fdw</TT>相关外部表都假设是可以更新的。应用时
优先下面的选项
功能:
</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">updatable</TT></DT><DD><P>
这个选项用来控制外部表是否可以用<TT CLASS="COMMAND">INSERT</TT>,<TT CLASS="COMMAND">UPDATE</TT>和
<TT CLASS="COMMAND">DELETE</TT>来修改。该选项可以被外部表或者外部服务器指定。表级别的
选项优先于服务器级别的。默认值是<TT CLASS="LITERAL">true</TT>。
</P><P>
当然如果一个远程表本身是不能用增删改的，那将会报错。错误直接会在本地抛出。
注意<TT CLASS="LITERAL">information_schema</TT>将会根据这个选项的设置显示一个外部表是
否可以增删改，而不会去检查远程服务器。
</P></DD></DL></DIV></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149696">F.31.2. 连接管理</A></H2><P>
<TT CLASS="FILENAME">postgres_fdw</TT>会在第一个查询外部服务器关联的外部表时
建立和外部服务器的连接。这个连接会一直保持，而且在同一个会话中被重用。
如果涉及多个用户（用户映射）访问外部服务器时，每个用户映射都户建立一个连接。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149700">F.31.3. 事务管理</A></H2><P>
当查询涉及外部服务器的远程表时，将在本地开启一个对应的事务,
<TT CLASS="FILENAME">postgres_fdw</TT>将会在远程服务器也开启事务。
远程事务会和本地事务提交终保持同步。保存点也是一样。
</P><P>
当本地的事务隔离级别为<TT CLASS="LITERAL">SERIALIZABLE</TT>时，远程的事务隔离级别也使用
<TT CLASS="LITERAL">SERIALIZABLE</TT>。否者远程的隔离级别将是<TT CLASS="LITERAL">REPEATABLE READ</TT>。
这是为了保证如果一个查询涉及远程服器上多个表的扫描，所有的扫描都会得到一致
的快照结果。这样产生的结果是即使远程服务器上的数据由于其他的操作在更新，单
个事务查询返回的结果也是一样的。上述结果在本地事务隔离级别 <TT CLASS="LITERAL">SERIALIZABLE</TT>
和<TT CLASS="LITERAL">REPEATABLE READ</TT>无论怎样都是可以实现的，但是在<TT CLASS="LITERAL">READ COMMITTED</TT>
下可能会得到意想不到的结果。未来的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>发行版本也许会
修改这些规则。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149712">F.31.4. 远程查询优化</A></H2><P>
postgres_fdw尝试优化远程查询，以减少从外部服务器的数据传输量。通用将带
<TT CLASS="LITERAL">WHERE</TT>查询条件的语句传到远程服务器上执行和不取回与查询结果不相关
的列来实现。为了减少查询未被执行的风险,<TT CLASS="LITERAL">WHERE</TT>从句中都是内建的数据类型
操作和函数的时候才会被传到远程服务器上。在从句中的操作和函数必须是不可变的。
</P><P>
<TT CLASS="COMMAND">EXPLAIN VERBOSE</TT>可以用来检查被送到远程服务器上的查询执行的实际状况。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149719">F.31.5. 版本兼容</A></H2><P>
<TT CLASS="FILENAME">postgres_fdw</TT>可以将<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>8.3版本以后的服务器
作为远程服务器使用。8.1,8,2的服务器只能提供读的功能。有这样个问题由于版本的差异
将where中的内建函数送到远程服务器上执行的时候，远程服务器由于版本低无法识别会报
<SPAN CLASS="QUOTE">"function does not exist"</SPAN>或者相似的错误。可以用从写sql的方式解决，我们嵌入
一个子查询sub-<TT CLASS="LITERAL">SELECT</TT> with <TT CLASS="LITERAL">OFFSET 0</TT>,将有问题的函数和操作移
出 sub-<TT CLASS="LITERAL">SELECT</TT>。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149728">F.31.6. 作者</A></H2><P> Shigeru Hanada <CODE CLASS="EMAIL">&#60;<A HREF="mailto:shigeru.hanada@gmail.com">shigeru.hanada@gmail.com</A>&#62;</CODE>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="pgtrgm.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="seg.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">pg_trgm</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">seg</TD></TR></TABLE></DIV></BODY></HTML>
