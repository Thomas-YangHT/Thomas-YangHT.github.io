<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pg_test_timing</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="服务器端应用程序" HREF="contrib-prog-server.html"><LINK REL="PREVIOUS" TITLE="pg_test_fsync" HREF="pgtestfsync.html"><LINK REL="NEXT" TITLE="pg_upgrade" HREF="pgupgrade.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/pgtesttiming.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_test_fsync" HREF="pgtestfsync.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="contrib-prog-server.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="pg_upgrade" HREF="pgupgrade.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="PGTESTTIMING"></A><SPAN CLASS="APPLICATION">pg_test_timing</SPAN></H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN152379"></A><H2>&#21517;&#31216;</H2>pg_test_timing&nbsp;--&nbsp;测量时间开销</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN152384"></A><H2>&#22823;&#32434;</H2><P><TT CLASS="COMMAND">pg_test_timing</TT> [<TT CLASS="REPLACEABLE"><I>option</I></TT>...]</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152389"></A><H2>描述</H2><P> <SPAN CLASS="APPLICATION">pg_test_timing</SPAN>是一个在你的系统上测量时间开销的工具，
并确认系统时间从不向后移动。缓慢的收集时间数据的系统会给出较小精度的
<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>结果。
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152394"></A><H2>选项</H2><P>
<SPAN CLASS="APPLICATION">pg_test_timing</SPAN>接受下列的命令行选项：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-d <TT CLASS="REPLACEABLE"><I>duration</I></TT></TT><BR><TT CLASS="OPTION">--duration=<TT CLASS="REPLACEABLE"><I>duration</I></TT></TT></DT><DD><P>
声明测试持续时间，以秒计。较长的持续时间给出稍微较好的精度，
并且更有可能发现系统时钟向后移动的问题。缺省的测试持续时间是3秒。
</P></DD><DT><TT CLASS="OPTION">-V</TT><BR><TT CLASS="OPTION">--version</TT></DT><DD><P>
输出<SPAN CLASS="APPLICATION">pg_test_timing</SPAN>版本并退出。
</P></DD><DT><TT CLASS="OPTION">-?</TT><BR><TT CLASS="OPTION">--help</TT></DT><DD><P>
显示关于<SPAN CLASS="APPLICATION">pg_test_timing</SPAN>命令行参数的帮助，并退出。
</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152424"></A><H2>用法</H2><DIV CLASS="REFSECT2"><A NAME="AEN152426"></A><H3>解释结果</H3><P>好的结果将显示大多数(&#62;90%)单个时间调用花费不到一微妙。平均每循环开销将更低，
低于100纳秒。这个示例来自一个Intel i7-860系统，使用TSC时钟资源，显示性能优良：
</P><PRE CLASS="SCREEN">Testing timing overhead for 3 seconds.
Per loop time including overhead: 35.96 nsec
Histogram of timing durations:
&#60; usec   % of total      count
     1     96.40465   80435604 
     2      3.59518    2999652  
     4      0.00015        126  
     8      0.00002         13  
    16      0.00000          2  </PRE><P>
</P><P>请注意，每循环时间和直方图使用的时间单位不同。当单个时间调用只能降低到一微妙（usec）解决时，
该循环可以在几纳秒内解决（nsec）。
</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN152431"></A><H3>测量执行者时间开销</H3><P>当查询执行者使用<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>运行一个语句时，
单个操作的时间也可以显示一个总结。你的系统开销可以通过<SPAN CLASS="APPLICATION">psql</SPAN>
程序计数行来检查：
</P><PRE CLASS="SCREEN">CREATE TABLE t AS SELECT * FROM generate_series(1,100000);
\timing
SELECT COUNT(*) FROM t;
EXPLAIN ANALYZE SELECT COUNT(*) FROM t;</PRE><P>
</P><P>i7-860系统测量运行计数查询使用了9.8 ms，而<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>
版本使用了16.6 ms，每个处理超出100,000行。6.8 ms的差异意味着时间开销每行是68 ns，
大约是pg_test_timing预估的两倍。即使是相对少量的开销，也使得完整时间计数语句多花费了近70%。
在更大量的查询上，时间开销将会有更少的问题。
</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN152439"></A><H3>改变时间来源</H3><P>在一些较新的Linux系统上，随时修改用于统计时间数据的时钟来源是可能的。
第二个例子显示了通过切换到较缓慢acpi_pm时间来源变缓的可能，
在同一个系统上用于上面快速的结果：
</P><PRE CLASS="SCREEN"># cat /sys/devices/system/clocksource/clocksource0/available_clocksource
tsc hpet acpi_pm
# echo acpi_pm &#62; /sys/devices/system/clocksource/clocksource0/current_clocksource
# pg_test_timing
Per loop time including overhead: 722.92 nsec
Histogram of timing durations:
&#60; usec   % of total      count
     1     27.84870    1155682 
     2     72.05956    2990371 
     4      0.07810       3241  
     8      0.01357        563  
    16      0.00007          3  </PRE><P>
</P><P>在这个配置中，上面的<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>示例花费了115.9 ms。
1061纳秒的时间开销，再次是这个工具直接测量的几倍。
那么多时间开销意味着实际查询本身只花费了其中的一小部分，大多数被消耗掉了。
在这个配置中，任何<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>总计都包括许多时间开销显著膨胀的操作。
</P><P>FreeBSD也允许在运行中修改时间来源，并且它记录在启动时选择的计时器：
</P><PRE CLASS="SCREEN"># dmesg | grep "Timecounter"
Timecounter "ACPI-fast" frequency 3579545 Hz quality 900
Timecounter "i8254" frequency 1193182 Hz quality 0
Timecounters tick every 10.000 msec
Timecounter "TSC" frequency 2531787134 Hz quality 800
# sysctl kern.timecounter.hardware=TSC
kern.timecounter.hardware: ACPI-fast -&#62; TSC</PRE><P>
</P><P>其他系统可能只允许在启动时设置时间来源。在老一些的Linux系统上，
"clock"内核设置是修改时间来源的唯一方式。即使是在一些最近的系统上，
你看到的时钟来源的唯一选项是"jiffies"。Jiffies是老一些的Linux软件时钟实现，
当它依靠在足够快的时间硬件上时，可以有很好的解决，如下面的例子：
</P><PRE CLASS="SCREEN">$ cat /sys/devices/system/clocksource/clocksource0/available_clocksource
jiffies
$ dmesg | grep time.c
time.c: Using 3.579545 MHz WALL PM GTOD PIT/TSC timer.
time.c: Detected 2400.153 MHz processor.
$ pg_test_timing
Testing timing overhead for 3 seconds.
Per timing duration including loop overhead: 97.75 ns
Histogram of timing durations:
&#60; usec   % of total      count
     1     90.23734   27694571 
     2      9.75277    2993204  
     4      0.00981       3010  
     8      0.00007         22  
    16      0.00000          1  
    32      0.00000          1  </PRE><P></P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN152450"></A><H3>时钟硬件和时间精度</H3><P>收集准确的时间信息通常是在计算机上使用硬件时钟和各种级别的精度来完成的。
在一些硬件上，操作系统可以传递系统时钟时间直接到程序。
系统时钟也可以来自一个芯片，简单的提供时间中断，周期性的在一些已知的时间间隔运转。
在这两种情况下，操作系统内核提供一个时钟资源，隐藏了这些细节。
但是时钟资源的精度和它可以多快的返回结果基于底层硬件的不同。
</P><P>不准确的时间会导致系统不稳定。要小心的测试任何时钟源的改变。
操作系统默认是有时在支持最好的精度的情况下提供最高的可靠性。如果你正在使用一个虚拟机，
看看推荐的时间资源兼容。虚拟硬件在计算时间时面临更多的困难，
通常有供应商建议的每操作系统设置。
</P><P>时间戳计数器(TSC)时钟资源是在当前一代CPU上可用的最精确的一个。
当操作系统支持它并且TSC时钟可靠时，这是追踪系统时间的首选方式。
有几种方式，TSC未能提供准确的时间源，使得它不可靠。
较老的系统可能有一个基于CPU温度变化的TSC时钟，使其无法计时。
在一些较老的多核CPU上尝试使用TSC会给出与多核不一致的报告时间。
这会导致时间回退，一个这个程序检查的问题。甚至最新的系统在非常节能的配置下，
也未能提供准确的TSC时间。
</P><P>较新的操作系统会检查已知的TSC问题，并在观察到问题时切换到一个较缓慢、更稳定的时钟源。
如果你的系统支持TSC时间，但是缺省不是它，它可能是因为一个好的原因而禁用了。
一些操作系统可能不能正确的检测所有可能的问题，或者在已知不准确的情况下允许使用TSC。
</P><P>高精度事件定时器(HPET)在可用并且TSC不准确的系统上是首选的定时器。
定时器芯片本身是可编程的，允许高达100纳秒的精度，但是你可能在你的系统时钟上没有看到有多精确。
</P><P>高级配置和电源接口(ACPI)提供了一个电源管理(PM)定时器，Linux称其为acpi_pm。
该时钟来源于acpi_pm，最高提供300纳秒的精度。
</P><P>较老PC硬件上使用的定时器包括8254可编程间隔计时器(PIT)、实时时钟(RTC)、
高级可编程中断控制器(APIC)定时器和Cyclone定时器。这些定时器是毫秒精度的。
</P></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152459"></A><H2>作者</H2><P> Ants Aasma <CODE CLASS="EMAIL">&#60;<A HREF="mailto:ants.aasma@eesti.ee">ants.aasma@eesti.ee</A>&#62;</CODE>
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN152463"></A><H2>又见</H2><A HREF="sql-explain.html">EXPLAIN</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="pgtestfsync.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="pgupgrade.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><SPAN CLASS="APPLICATION">pg_test_fsync</SPAN></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="contrib-prog-server.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><SPAN CLASS="APPLICATION">pg_upgrade</SPAN></TD></TR></TABLE></DIV></BODY></HTML>
