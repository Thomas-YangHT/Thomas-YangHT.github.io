<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>开发人员选项</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="服务器配置" HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html"><LINK REL="PREVIOUS" TITLE="自定义选项" HREF="runtime-config-custom.html"><LINK REL="NEXT" TITLE="短选项" HREF="runtime-config-short.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/config.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="自定义选项" HREF="runtime-config-custom.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 18. 服务器配置</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="短选项" HREF="runtime-config-short.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="RUNTIME-CONFIG-DEVELOPER">18.17. 开发人员选项</A></H1><P> 下面的选项目的是在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>代码上使用，并且在某些情况下可以帮助恢复严重损坏了的数据库。
在生产环境里没有理由使用这些设置。因此，我们把他们从样例<TT CLASS="FILENAME">postgresql.conf</TT>文件中排除了出去。
请注意许多这些选项要求特殊的源代码编译标志才能运转。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="GUC-ALLOW-SYSTEM-TABLE-MODS"></A><TT CLASS="VARNAME">allow_system_table_mods</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 允许修改系统表的结构。它可以被<TT CLASS="COMMAND">initdb</TT>使用。这个值只能在服务器启动的时候设置。</P></DD><DT><A NAME="GUC-DEBUG-ASSERTIONS"></A><TT CLASS="VARNAME">debug_assertions</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 打开各种断言检查。这是调试助手。如果你经历了奇怪的问题或者崩溃，
那么你可能会想把这个打开，因为它可能暴露编程的错误。要使用这个选项，
我们必须在编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的时候定义宏<TT CLASS="SYMBOL">USE_ASSERT_CHECKING</TT>
(通过<TT CLASS="COMMAND">configure</TT>选项<TT CLASS="OPTION">--enable-cassert</TT>完成)。
请注意，如果启用断言选项编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>，那么<TT CLASS="VARNAME">debug_assertions</TT>缺省就是<TT CLASS="LITERAL">on</TT></P></DD><DT><A NAME="GUC-IGNORE-SYSTEM-INDEXES"></A><TT CLASS="VARNAME">ignore_system_indexes</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 读取系统表时忽略系统索引(但是修改系统表时依然同时修改索引)。
这个在从系统索引被破坏的表中恢复数据的时候很有用。该参数不能在会话启动之后修改。</P></DD><DT><A NAME="GUC-POST-AUTH-DELAY"></A><TT CLASS="VARNAME">post_auth_delay</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 如果为非零，那么在一个新的服务器进程启动并完成认证过程之后，
就会延迟这么多秒。这样就给开发人员一个机会用调试器附着在一个服务器进程上。
该参数不能在会话启动之后修改。</P></DD><DT><A NAME="GUC-PRE-AUTH-DELAY"></A><TT CLASS="VARNAME">pre_auth_delay</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 如果为非零，那么在一个新的服务器进程派生出来之后，
就会延迟这么多秒，然后才会继续认证过程。
这样就给开发人员一个机会用调试器附着在一个服务器进程上跟踪认证里面的异常行为。
这个选项只能在服务器启动的时候或者在<TT CLASS="FILENAME">postgresql.conf</TT>文件里设置。</P></DD><DT><A NAME="GUC-TRACE-NOTIFY"></A><TT CLASS="VARNAME">trace_notify</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 为<TT CLASS="COMMAND">LISTEN</TT>和<TT CLASS="COMMAND">NOTIFY</TT>命令生成大量调试输出。
<A HREF="runtime-config-logging.html#GUC-CLIENT-MIN-MESSAGES">client_min_messages</A>或者<A HREF="runtime-config-logging.html#GUC-LOG-MIN-MESSAGES">log_min_messages</A>
必须是<TT CLASS="LITERAL">DEBUG1</TT>。
或者更低才能把这些输出分别发送到客户端或者服务器日志。</P></DD><DT><A NAME="GUC-TRACE-RECOVERY-MESSAGES"></A><TT CLASS="VARNAME">trace_recovery_messages</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 启用恢复相关的调试输出的日志记录，否则
不会被记录。该参数允许用户覆盖<A HREF="runtime-config-logging.html#GUC-LOG-MIN-MESSAGES">log_min_messages</A>的正常设置，
但仅限于特定消息。打算调试双机热备时使用。
有效值<TT CLASS="LITERAL">DEBUG5</TT>, <TT CLASS="LITERAL">DEBUG4</TT>,<TT CLASS="LITERAL">DEBUG3</TT>, <TT CLASS="LITERAL">DEBUG2</TT>,
<TT CLASS="LITERAL">DEBUG1</TT>和<TT CLASS="LITERAL">LOG</TT>。
默认情况下，<TT CLASS="LITERAL">LOG</TT>不影响记录决定。其他值会导致恢复相关的
记录优先级或更高的调试消息，虽然他们
有<TT CLASS="LITERAL">LOG</TT>的优先级;对于<TT CLASS="VARNAME">log_min_messages</TT>常用的设置
导致无条件地发送这些到服务器日志。
这个参数只能在<TT CLASS="FILENAME">postgresql.conf</TT>文件或者服务器命令行中设置。</P></DD><DT><A NAME="GUC-TRACE-SORT"></A><TT CLASS="VARNAME">trace_sort</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果打开，发出在排序操作中的资源使用的有关信息。
这个选项只有在编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的时候定义了<TT CLASS="SYMBOL">TRACE_SORT</TT>
宏的时候才可用(不过，目前<TT CLASS="SYMBOL">TRACE_SORT</TT>缺省就是定义了的)。</P></DD><DT><TT CLASS="VARNAME">trace_locks</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P>
如果打开，发出关于锁用法信息。信息转储包括锁定操作的类型，锁定类型和
被锁定或解锁的对象的唯一标识符。
还包括已授权在该对象上的锁类型
以及等待此对象上的锁类型的位掩码。
对于每个锁类型的授予锁和等待锁的数量计数以及总数都被转储。
该日志文件输出的例子在这显示：
</P><PRE CLASS="SCREEN">LOG:  LockAcquire: new: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  GrantLock: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(2) req(1,0,0,0,0,0,0)=1 grant(1,0,0,0,0,0,0)=1
      wait(0) type(AccessShareLock)
LOG:  UnGrantLock: updated: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  CleanUpLock: deleting: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(INVALID)</PRE><P>
结构详情可以从<TT CLASS="FILENAME">src/include/storage/lock.h</TT>里找到。
</P><P> 当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时，如果定义了<TT CLASS="SYMBOL">LOCK_DEBUG</TT>
宏指令，则只能使用这个参数。</P></DD><DT><TT CLASS="VARNAME">trace_lwlocks</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果打开，则发出轻量级锁用法信息。轻量级锁主要提供访问互斥以共享内存数据结构。</P><P> 当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时，如果定义了<TT CLASS="SYMBOL">LOCK_DEBUG</TT>
宏指令，则只能使用这个参数。</P></DD><DT><TT CLASS="VARNAME">trace_userlocks</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果打开，则发出关于用户锁用法的信息。输出类似于<TT CLASS="SYMBOL">trace_locks</TT>，
仅仅为了咨询锁。</P><P> 当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时，如果定义了<TT CLASS="SYMBOL">LOCK_DEBUG</TT>
宏指令，则只能使用这个参数。</P></DD><DT><TT CLASS="VARNAME">trace_lock_oidmin</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 如果设置，不跟踪低于这个OID的表锁。（为了避免系统表输出）</P><P> 当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时，如果定义了<TT CLASS="SYMBOL">LOCK_DEBUG</TT>
宏指令，则只能使用这个参数。</P></DD><DT><TT CLASS="VARNAME">trace_lock_table</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 无条件跟踪表（OID）上的锁。</P><P> 当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时，如果定义了<TT CLASS="SYMBOL">LOCK_DEBUG</TT>
宏指令，则只能使用这个参数。</P></DD><DT><TT CLASS="VARNAME">debug_deadlocks</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 当死锁发生超时，如果设置，那么备份所有当前锁的信息。</P><P> 当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时，如果定义了<TT CLASS="SYMBOL">LOCK_DEBUG</TT>
宏指令，则只能使用这个参数。</P></DD><DT><TT CLASS="VARNAME">log_btree_build_stats</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果设置，日志系统资源用法在各种B-tree操作上统计(内存和CPU)。 </P><P> 当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时，如果定义了<TT CLASS="SYMBOL">BTREE_BUILD_STATS</TT>
宏指令，则只能使用这个参数。</P></DD><DT><A NAME="GUC-WAL-DEBUG"></A><TT CLASS="VARNAME">wal_debug</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 打开 WAL 相关的调试输出。只有在编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的时候打开了
<TT CLASS="SYMBOL">WAL_DEBUG</TT>宏定义的情况下，这个选项才可用。&#13;</P></DD><DT><A NAME="GUC-IGNORE-CHECKSUM-FAILURE"></A><TT CLASS="VARNAME">ignore_checksum_failure</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果启动<A HREF="app-initdb.html#APP-INITDB-DATA-CHECKSUMS">data checksums</A>，已经受到影响。</P><P> 在读期间校验失败检测导致<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>报告错误，
终止当前事务。设置<TT CLASS="VARNAME">ignore_checksum_failure</TT>的原因系统忽略失败
（但仍然报告一个警告），并且
继续处理。这种行为可能<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">造成死机，传播或隐藏的崩溃，或其他严重的问题</I></SPAN>。
然而，如果块头仍然是清醒的，它可能允许你获取错误并且检索仍然完好无损出现在表中未处理元组 。
如果头部崩溃，即使启用这个选项也将报告一个错误。
默认设置为<TT CLASS="LITERAL">off</TT>，它只能由超级用户改变。</P></DD><DT><A NAME="GUC-ZERO-DAMAGED-PAGES"></A><TT CLASS="VARNAME">zero_damaged_pages</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果侦测到一个损坏了的页面头通常会导致<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>报告一个错误，并且退出当前事务。
把<TT CLASS="VARNAME">zero_damaged_pages</TT>设置为 on 则令系统报告一个警告，把内存中损坏的页面填充零，然后继续处理。
这种行为会<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">破坏数据</I></SPAN>，也就是所有在已经损坏页面上的行。
但是它允许你绕开坏页面然后从表中尚存的未损坏页面上继续检索数据行。
因此它在因为硬件或者软件错误导致的崩溃中进行恢复是很有用的。
通常你不应该把它设置为 on ，
除非你已经彻底放弃从崩溃的页面中恢复数据。
零填充页面不强制到磁盘，所以建议重新创建表或再次关闭此参数之前的索引。
缺省的设置是<TT CLASS="LITERAL">off</TT>，并且只有超级用户可以改变它。</P></DD></DL></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="runtime-config-custom.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="runtime-config-short.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">自定义选项</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">短选项</TD></TR></TABLE></DIV></BODY></HTML>
