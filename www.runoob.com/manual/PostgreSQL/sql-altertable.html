<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>ALTER TABLE</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="ALTER SERVER" HREF="sql-alterserver.html"><LINK REL="NEXT" TITLE="ALTER TABLESPACE" HREF="sql-altertablespace.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/alter_table.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="ALTER SERVER" HREF="sql-alterserver.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="ALTER TABLESPACE" HREF="sql-altertablespace.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-ALTERTABLE"></A>ALTER TABLE</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN66452"></A><H2>&#21517;&#31216;</H2>ALTER TABLE&nbsp;--&nbsp;修改表的定义</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN66457"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ * ]
    <TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ * ]
    RENAME [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> TO <TT
CLASS="REPLACEABLE"
><I
>new_column_name</I
></TT
>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ * ]
    RENAME CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> TO <TT
CLASS="REPLACEABLE"
><I
>new_constraint_name</I
></TT
>
ALTER TABLE [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>
    RENAME TO <TT
CLASS="REPLACEABLE"
><I
>new_name</I
></TT
>
ALTER TABLE [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>
    SET SCHEMA <TT
CLASS="REPLACEABLE"
><I
>new_schema</I
></TT
>

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>其中<TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
> 可以是以选项之一：</SPAN
></SPAN
>

    ADD [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>column_constraint</I
></TT
> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [ SET DATA ] TYPE <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ USING <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ]
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET DEFAULT <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> DROP DEFAULT
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET STATISTICS <TT
CLASS="REPLACEABLE"
><I
>integer</I
></TT
>
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET ( <TT
CLASS="REPLACEABLE"
><I
>attribute_option</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] )
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> RESET ( <TT
CLASS="REPLACEABLE"
><I
>attribute_option</I
></TT
> [, ... ] )
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <TT
CLASS="REPLACEABLE"
><I
>table_constraint</I
></TT
> [ NOT VALID ]
    ADD <TT
CLASS="REPLACEABLE"
><I
>table_constraint_using_index</I
></TT
>
    VALIDATE CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
>
    DROP CONSTRAINT [ IF EXISTS ]  <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
> | ALL | USER ]
    ENABLE TRIGGER [ <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
> | ALL | USER ]
    ENABLE REPLICA TRIGGER <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
>
    ENABLE ALWAYS TRIGGER <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
>
    DISABLE RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    ENABLE RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    ENABLE REPLICA RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    ENABLE ALWAYS RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    CLUSTER ON <TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] )
    RESET ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> [, ... ] )
    INHERIT <TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
>
    NO INHERIT <TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
>
    OF <TT
CLASS="REPLACEABLE"
><I
>type_name</I
></TT
>
    NOT OF
    OWNER TO <TT
CLASS="REPLACEABLE"
><I
>new_owner</I
></TT
>
    SET TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>new_tablespace</I
></TT
>

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>and <TT
CLASS="REPLACEABLE"
><I
>table_constraint_using_index</I
></TT
> is:</SPAN
></SPAN
>

    [ CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN66519"></A><H2>描述</H2><P> <TT CLASS="COMMAND">ALTER TABLE</TT> 改变一个现存表的定义。它有好几种子形式：</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">ADD COLUMN</TT></DT><DD><P>这种形式使用和<A HREF="sql-createtable.html">CREATE TABLE</A>一样的语法向表中增加一个新的字段。</P></DD><DT><TT CLASS="LITERAL">DROP COLUMN [ IF EXISTS ]</TT></DT><DD><P>这种形式从表中删除一个字段。和这个字段相关的索引和表约束也会被自动删除。
如果任何表之外的对象依赖于这个字段，必须使用<TT CLASS="LITERAL">CASCADE</TT>选项，比如外键约束、视图等。
如果使用了<TT CLASS="LITERAL">IF EXISTS</TT>选项并且相关字段不存在，则在删除时不会显示错误，仅会有一个提示信息。</P></DD><DT><TT CLASS="LITERAL">IF EXISTS</TT></DT><DD><P>如果使用了<TT CLASS="LITERAL">IF EXISTS</TT>选项并且表不存在，则在删除时不会显示错误，仅会有一个提示信息。。</P></DD><DT><TT CLASS="LITERAL">SET DATA TYPE</TT></DT><DD><P>这种形式改变表中一个字段的类型。该字段涉及的索引和简单的表约束将被自动地转换为使用新的字段类型，方法是重新分析最初提供的表达式。
可选的<TT CLASS="LITERAL">COLLATE</TT>选项定义了新列的字符集排序方式，如果不加这个选项，则排序方式使用新类型的缺省值。
可选的<TT CLASS="LITERAL">USING</TT>选项定义如何从旧的字段值里计算新的字段值；如果省略，那么缺省的转换就是从旧类型向新类型的赋值转换。
如果从旧数据类型到新类型没有隐含或者赋值的转换，那么必须提供一个<TT CLASS="LITERAL">USING</TT>选项。</P></DD><DT><TT CLASS="LITERAL">SET</TT>/<TT CLASS="LITERAL">DROP DEFAULT</TT></DT><DD><P>这种形式设置或是删除一列的缺省值。缺省值仅会对后续的<TT CLASS="COMMAND">INSERT</TT>或是<TT CLASS="COMMAND">UPDATE</TT>命令，不会影响已经在表中存在的记录。</P></DD><DT><TT CLASS="LITERAL">SET</TT>/<TT CLASS="LITERAL">DROP NOT NULL</TT></DT><DD><P>这种形式修改一个字段是否允许 NULL 值或者拒绝 NULL 值。如果表中字段里包含非 NULL值 ，那么你只可以使用<TT CLASS="LITERAL">SET NOT NULL</TT>选项。</P></DD><DT><TT CLASS="LITERAL">SET STATISTICS</TT></DT><DD><P>这种形式为后续的<A HREF="sql-analyze.html">ANALYZE</A>操作设置每列的数据统计目标值。
目标值可以设置为0至10000；相应地，设置为-1则会反向使用系统缺省的统计目标值 (<A HREF="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</A>)。
有关<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>查询规划器使用数据统计方面的更多信息，可以参阅<A HREF="planner-stats.html">第 14.2 &#33410;</A>。</P></DD><DT><TT CLASS="LITERAL">SET ( <TT CLASS="REPLACEABLE"><I>attribute_option</I></TT> = <TT CLASS="REPLACEABLE"><I>value</I></TT> [, ... ] )</TT><BR><TT CLASS="LITERAL">RESET ( <TT CLASS="REPLACEABLE"><I>attribute_option</I></TT> [, ... ] )</TT></DT><DD><P>这种形式设置或者重置每个属性的参数值。目前，已定义的属性参数值是<TT CLASS="LITERAL">n_distinct</TT>和<TT CLASS="LITERAL">n_distinct_inherited</TT>，
它们会覆盖由随后的<A HREF="sql-analyze.html">ANALYZE</A>操作所估算的number-of-distinct-values。
<TT CLASS="LITERAL">n_distinct</TT>影响表本身的统计值，而<TT CLASS="LITERAL">n_distinct_inherited</TT>影响表及其继承子表的统计。
当设置为一个正值时，<TT CLASS="COMMAND">ANALYZE</TT>将会假定列准确包含明确的非空值的指定数目。
当设置为一个必须大于或者等于-1的负值时，<TT CLASS="COMMAND">ANALYZE</TT>将会假定在列中的不同的非空值的数目与表的大小关系是线性的；
确切的统计通过将估算的表大小与给定数字的绝对值相乘来统计。
例如， 值-1意味着在此列中的所有值是不同的，值-0.5意味着每个值平均出现两次。
当表的大小随时间变化时这是很有效的，尽管表中行数的乘法运算在查询规划计时前是不会这样计算的，
声明一个0值来正常地恢复到估计不同数值的数目。
要获取关于使用<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>查询优化器做统计的信息，请参阅<A HREF="planner-stats.html">第 14.2 &#33410;</A>。</P></DD><DT><TT CLASS="LITERAL">SET STORAGE</TT></DT><DD><P>这种形式为一个字段设置存储模式。这个设置控制这个字段是内联保存还是保存在一个<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>附属的表里，以及数据是否要压缩。
<TT CLASS="LITERAL">PLAIN</TT>选项必须用于定长的数值，比如<TT CLASS="TYPE">integer</TT>并且是内联的、不压缩的。
<TT CLASS="LITERAL">MAIN</TT>用于内联、可压缩的数据。
<TT CLASS="LITERAL">EXTERNAL</TT>用于外部保存、不压缩的数据，<TT CLASS="LITERAL">EXTENDED</TT>用于外部的压缩数据。
<TT CLASS="LITERAL">EXTENDED</TT>是大多数支持非<TT CLASS="LITERAL">PLAIN</TT>存储的数据的缺省值。
使用<TT CLASS="LITERAL">EXTERNAL</TT>将会在<TT CLASS="TYPE">text</TT>和<TT CLASS="TYPE">bytea</TT>字段上的字符串操作更快，但付出的代价是增加了存储空间。
请注意<TT CLASS="LITERAL">SET STORAGE</TT>本身并不改变表上的任何东西，只是设置将来的表操作时，建议使用的策略。参阅<A HREF="storage-toast.html">第 58.2 &#33410;</A>获取更多信息。 </P></DD><DT><TT CLASS="LITERAL">ADD <TT CLASS="REPLACEABLE"><I>table_constraint</I></TT> [ NOT VALID ]</TT></DT><DD><P>这种形式给表增加一个新的约束，使用的语法和<A HREF="sql-createtable.html">CREATE TABLE</A>一样，而与<TT CLASS="LITERAL">NOT VALID</TT>选项组合时，这种约束仅在对外键和CHECK类药束有效。
如果约束条件增加了<TT CLASS="LITERAL">NOT VALID</TT>选项后，表中已有记录是否满足初始约束检查会被跳过。这种约束会对后续的新增记录或是记录更新产生影响（在外键约束的情况下，
除非是参照的表中有匹配的记录，否则这样的情形会出错；而在CHECK约束下，除非是新增记录满足CHECK约束条件，否则也会也错）。
但数据库自身不会认定这种约束会对表中所有记录生效，除非是在使用了<TT CLASS="LITERAL">VALIDATE CONSTRAINT</TT>选项进行了有效性检查。</P></DD><DT><TT CLASS="LITERAL">ADD <TT CLASS="REPLACEABLE"><I>table_constraint_using_index</I></TT></TT></DT><DD><P>这种形式根据已有的唯一索引给表增加新的<TT CLASS="LITERAL">PRIMARY KEY</TT>或<TT CLASS="LITERAL">UNIQUE</TT>约束。索引中所有的列也会在包含在约束中。</P><P>索引中不能含有表达式列或者是局部索引。另外索引的缺省排序方式应是B-tree类型。这些限制保证了索引会与通过正常<TT CLASS="LITERAL">ADD PRIMARY KEY</TT>或<TT CLASS="LITERAL">ADD UNIQUE</TT>选项生成的索引相同。</P><P>如果使用了<TT CLASS="LITERAL">PRIMARY KEY</TT>选项，则索引的列不能已定义为<TT CLASS="LITERAL">NOT NULL</TT>，因为这个选项会对涉及的列去执行<TT CLASS="LITERAL">ALTER COLUMN SET NOT NULL</TT>。
这也会对全表数据进行扫描以验证该列是否包含空值，（全表扫描很慢），在其他情况下，这是一个很快的操作。</P><P>如果指定了一个约束名，索引将会被重命名为指定的约束中的名称。相反，约束会被命名为索引名。</P><P>在这个命令执行后，约束就相当于是索引的<SPAN CLASS="QUOTE">"所有者"</SPAN>了，就如同使用了<TT CLASS="LITERAL">ADD PRIMARY KEY</TT>或<TT CLASS="LITERAL">ADD UNIQUE</TT>命令创建的索引一样。
特别要注意的事，这种情况下删除约束也会清除了索引。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>在新增约束时使用已有的索引对新约束增加时对表记录的较长时间不能更新的问题有较好的帮助。
使用<TT CLASS="COMMAND">CREATE INDEX CONCURRENTLY</TT>指令可以实现这种方式，参见下面的示例。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">VALIDATE CONSTRAINT</TT></DT><DD><P>这种形式用于验证一个外键或是一个使用<TT CLASS="LITERAL">NOT VALID</TT>选项创建的检查类约束，通过扫描全表来保证所有记录都符合约束条件。
如果约束已标记为有效时，什么操作也不会发生。</P><P>对大表的记录进行验证一般是一个很长的过程，并且目前这种操作还需要<TT CLASS="LITERAL">ACCESS EXCLUSIVE</TT>排他类锁。
初始的不同验证可以将验证工作后延至系统不忙时进行，或者通过先花一点额外的时间来纠正可能存在的错误以防止新错误的发生。</P></DD><DT><TT CLASS="LITERAL">DROP CONSTRAINT [ IF EXISTS ]</TT></DT><DD><P>这种形式删除一个表中指定的约束，如果使用了 <TT CLASS="LITERAL">IF EXISTS</TT>选项并且约束并不存在时，也不会有错误产生，仅会有一个提示信息。</P></DD><DT><TT CLASS="LITERAL">DISABLE</TT>/<TT CLASS="LITERAL">ENABLE [ REPLICA | ALWAYS ] TRIGGER</TT></DT><DD><P>这种形式禁用或者启用属于该表的触发器。一个被关闭掉的触发器是系统仍然知道的，但是在触发器事件发生的时候不会被执行。
对于一个推迟了的触发器，在触发事件发生的时候会检查打开状态，触发器相关的函数实际也不会执行。
可以通过指定名字的方法启用或者禁用任意一个触发器，或者是该表上的所有触发器，或者只是用户自定义的触发器(这个选项排除了那些用于实现外键约束或是可延迟的唯一性约束或是排他性约束的触发器)。
启用或者禁用约束触发器要求超级用户权限；这么做的时候应该小心，因为如果触发器不执行的话，约束保证的数据完整性也就没有办法确保了。
触发器启动原理也受配置变量<A HREF="runtime-config-client.html#GUC-SESSION-REPLICATION-ROLE">session_replication_role</A>影响。
简单启动的触发器将会在复制任务为<SPAN CLASS="QUOTE">"初始"</SPAN>(默认情况)或者<SPAN CLASS="QUOTE">"本地"</SPAN>时启动。
配置为<TT CLASS="LITERAL">ENABLE REPLICA</TT>的触发器将会仅在会话为"replica" 模式时启动，而配置为<TT CLASS="LITERAL">ENABLE ALWAYS</TT>的触发器将总是会启动，无论是否为当前复制模式。</P></DD><DT><TT CLASS="LITERAL">DISABLE</TT>/<TT CLASS="LITERAL">ENABLE [ REPLICA | ALWAYS ] RULE</TT></DT><DD><P>这种形式配置属于表的重写规则制定。一个已禁用的规则对系统来说仍然是可知的，但在查询重写期间是不被应用的。
语义为关闭/启动触发器。这个配置对<TT CLASS="LITERAL">ON SELECT</TT>规则来说是可忽略的，常常用来保持视图工作，即使当前会话处于一个非默认的复制角色中。</P></DD><DT><TT CLASS="LITERAL">CLUSTER ON</TT></DT><DD><P>这种形式为将来的<A HREF="sql-cluster.html">CLUSTER</A>操作选择默认索引。 实际上并没有重新聚簇该表。</P></DD><DT><TT CLASS="LITERAL">SET WITHOUT CLUSTER</TT></DT><DD><P>这种形式从表中删除最近一次用到的<A HREF="sql-cluster.html">CLUSTER</A>索引定义。这会影响将来不指定索引的聚簇操作。</P></DD><DT><TT CLASS="LITERAL">SET WITH OIDS</TT></DT><DD><P>这种形式向表中增加一个<TT CLASS="LITERAL">oid</TT>系统字段（参见<A HREF="ddl-system-columns.html">第 5.4 &#33410;</A>）。
如果表中已存在有OID字段，则操作对表无任何影响。</P><P>注意这种形式与<TT CLASS="LITERAL">ADD COLUMN oid oid</TT>选项并不相同，后者对给表增加一个普通的字段，只不过它的名称恰好是叫 <TT CLASS="LITERAL">oid</TT>，并非是系统字段。</P></DD><DT><TT CLASS="LITERAL">SET WITHOUT OIDS</TT></DT><DD><P>这种形式从表中删除 <TT CLASS="LITERAL">oid</TT>系统字段。它和<TT CLASS="LITERAL">DROP COLUMN oid RESTRICT</TT>完全相同，只不过是如果表上已经没有<TT CLASS="LITERAL">oid</TT>字段的时候不会报错。</P></DD><DT><TT CLASS="LITERAL">SET ( <TT CLASS="REPLACEABLE"><I>storage_parameter</I></TT> = <TT CLASS="REPLACEABLE"><I>value</I></TT> [, ... ] )</TT></DT><DD><P>这种形式改变表的一个或者更多存储参数。参阅<A HREF="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS"><I>存储参数</I></A>获取关于可用参数的详细信息。
请注意表的内容将不会因为此命令被立刻调整；根据此参数你可能需要重写此表来得到希望的效果。
这可以通过<A HREF="sql-vacuum.html">VACUUM FULL</A>、<A HREF="sql-cluster.html">CLUSTER</A>或者<TT CLASS="COMMAND">ALTER TABLE</TT>命令中的选项之一来实现。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>尽管<TT CLASS="COMMAND">CREATE TABLE</TT>允许<TT CLASS="LITERAL">OIDS</TT>在<TT CLASS="LITERAL">WITH (<TT CLASS="REPLACEABLE"><I>storage_parameter</I></TT>)</TT>语义中声明，
但<TT CLASS="COMMAND">ALTER TABLE</TT>不会将<TT CLASS="LITERAL">OIDS</TT>作为一个存储参数。
相反地，要使用<TT CLASS="LITERAL">SET WITH OIDS</TT>和<TT CLASS="LITERAL">SET WITHOUT OIDS</TT>形式来更改OID状态。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">RESET ( <TT CLASS="REPLACEABLE"><I>storage_parameter</I></TT> [, ... ] )</TT></DT><DD><P>这种形式重置表的一个或多个存储参数为缺省值。与<TT CLASS="LITERAL">SET</TT>选项一样，根据参数的不同可能需要重写表才能获得想要的效果。</P></DD><DT><TT CLASS="LITERAL">INHERIT <TT CLASS="REPLACEABLE"><I>parent_table</I></TT></TT></DT><DD><P>这种形式将目标表添加为指定父表的新子表。
之后在父表上的查询将包含目标表中的记录。
要被添加为一个子表，目标表必须已经包含所有与父表相同的字段(除此之外 当然也可以包含一些其它字段)，这些字段的数据类型必须匹配，并且如果父表的字段有<TT CLASS="LITERAL">NOT NULL</TT>约束的话子表的相应字段也必须有<TT CLASS="LITERAL">NOT NULL</TT>约束。</P><P>所有父表的<TT CLASS="LITERAL">CHECK</TT>约束必须同时与子表的约束匹配。
不过一些标记为不可继承类的约束（类似使用<TT CLASS="LITERAL">ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</TT>创建的约束）不包括在内，
所有子表匹配的约束也不能标记为不可继承。
目前<TT CLASS="LITERAL">UNIQUE</TT>、<TT CLASS="LITERAL">PRIMARY KEY</TT>和<TT CLASS="LITERAL">FOREIGN KEY</TT>约束不被考虑在内，但是将来可能会有所改变。</P></DD><DT><TT CLASS="LITERAL">NO INHERIT <TT CLASS="REPLACEABLE"><I>parent_table</I></TT></TT></DT><DD><P>这种形式从指定父表的子表列表中删除目标表。这样，在父表上的查询将不再目标表中的记录。</P></DD><DT><TT CLASS="LITERAL">OF <TT CLASS="REPLACEABLE"><I>type_name</I></TT></TT></DT><DD><P>这种形式将表链接至一种复合类型，就好象是使用<TT CLASS="COMMAND">CREATE TABLE OF</TT>选项创建表一样。
表的字段的名称和类型必须精确匹配复合类型中的定义，不过<TT CLASS="LITERAL">oid</TT>系统字段允许不一样。
表不能是从任何其他表继承的。
这些限制确保<TT CLASS="COMMAND">CREATE TABLE OF</TT>选项允许一个相同的表定义。</P></DD><DT><TT CLASS="LITERAL">NOT OF</TT></DT><DD><P>这种形式将一个与某类型进行关联的表进行关联的解除。</P></DD><DT><TT CLASS="LITERAL">OWNER</TT></DT><DD><P>这种形式改变表、序列或是视图的所有者为一个指定的用户。</P></DD><DT><TT CLASS="LITERAL">SET TABLESPACE</TT></DT><DD><P>这种形式更改表的表空间为一个指定的表空间，并将与这个表相关的数据文件移至新的表空间。
表上如果有索引，一般不会移动。不过它们也可以通过使用<TT CLASS="LITERAL">SET TABLESPACE</TT>命令单独移动，参见<A HREF="sql-createtablespace.html">CREATE TABLESPACE</A>。</P></DD><DT><TT CLASS="LITERAL">RENAME</TT></DT><DD><P><TT CLASS="LITERAL">RENAME</TT>形式改变一个表(或者索引、序列、视图)的名称，表中单个字段的名称，或是表中约束的名称。
它们对存储的数据没有影响。</P></DD><DT><TT CLASS="LITERAL">SET SCHEMA</TT></DT><DD><P>这种形式把表移动到另外一个模式。相关的索引、约束、序列都跟着移动。</P></DD></DL></DIV><P>除了<TT CLASS="LITERAL">RENAME</TT>和<TT CLASS="LITERAL">SET SCHEMA</TT>之外所有动作都可以组合在一个多次修改列表中同时使用。
比如，可以在一个命令里增加几个字段和/或修改几个字段的类型。
对于大表，这么做特别有用，因为只需要对该表做一次处理。</P><P>要使用<TT CLASS="COMMAND">ALTER TABLE</TT>，你必须是该表的所有者。
要修改一个表的模式，你还必须在新模式上拥有<TT CLASS="LITERAL">CREATE</TT>权限。
要把该表添加为一个父表的新子表，你必须同时是父表的所有者。
要修改所有者，你还必须是新的所有角色的直接或间接成员，并且该成员必须在此表的模式上有<TT CLASS="LITERAL">CREATE</TT>权限。
（这些限制强制了修改该所有者不会做任何通过删除和重建表不能做的事情。不过，超级用户可以以任何方式修改任意表的所有权。）
增加一个字段或是改变字段的类型或是使用<TT CLASS="LITERAL">OF</TT>选项，你也必须对那个数据类型有<TT CLASS="LITERAL">USAGE</TT>权限。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN66804"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>name</I></TT></DT><DD><P>要修改的已有表的名称（可以有模式修饰）。若声明了<TT CLASS="LITERAL">ONLY</TT>选项，则只有那个表被更改。若未声明<TT CLASS="LITERAL">ONLY</TT>，该表及其所有子表都将会被更改。
另外，可以在表名称后面精确地增加<TT CLASS="LITERAL">*</TT>选项来指定包括子表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>column_name</I></TT></DT><DD><P>现存或新的字段名称。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_column_name</I></TT></DT><DD><P>现存字段的新名称。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_name</I></TT></DT><DD><P>表的新名称。</P></DD><DT><TT CLASS="REPLACEABLE"><I>type</I></TT></DT><DD><P>新字段的类型，或者现存字段的新类型。</P></DD><DT><TT CLASS="REPLACEABLE"><I>table_constraint</I></TT></DT><DD><P>新的表约束。</P></DD><DT><TT CLASS="REPLACEABLE"><I>constraint_name</I></TT></DT><DD><P>要删除的现有约束的名字。</P></DD><DT><TT CLASS="LITERAL">CASCADE</TT></DT><DD><P>级联删除依赖于被依赖字段或者约束的对象(比如引用该字段的视图)。</P></DD><DT><TT CLASS="LITERAL">RESTRICT</TT></DT><DD><P>如果字段或者约束还有任何依赖的对象，则拒绝删除该字段。这是缺省行为。。</P></DD><DT><TT CLASS="REPLACEABLE"><I>trigger_name</I></TT></DT><DD><P>要启用或者禁用的单个触发器的名字。</P></DD><DT><TT CLASS="LITERAL">ALL</TT></DT><DD><P>启用或者禁用所有属于该表的触发器。（如果任何触发器属于内部会产生约束的触发器，这要求超级用户权限，例如那些用于执行外键约束或者可推迟的独特性和排除约束。）</P></DD><DT><TT CLASS="LITERAL">USER</TT></DT><DD><P>启用或者禁用所有属于表的触发器，除了任何属于内部会产生约束的触发器，例如那些用于执行外键约束或者可推迟的独特性和排除约束。）</P></DD><DT><TT CLASS="REPLACEABLE"><I>index_name</I></TT></DT><DD><P>标记实施表的聚簇操作的索引名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>storage_parameter</I></TT></DT><DD><P>表的存储参数的名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>value</I></TT></DT><DD><P>表的存储参数的新值，根据参数的不同，可能是一个数字或单词。</P></DD><DT><TT CLASS="REPLACEABLE"><I>parent_table</I></TT></DT><DD><P>将要与该表建立/取消关联的父表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_owner</I></TT></DT><DD><P>该表的新所有者的用户名。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_tablespace</I></TT></DT><DD><P>这个表将要移动到的表空间名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_schema</I></TT></DT><DD><P>表将移动到的新模式的名字。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN66905"></A><H2>注意</H2><P><TT CLASS="LITERAL">COLUMN</TT>关键字是多余的，可以省略。。</P><P>如果用<TT CLASS="LITERAL">ADD COLUMN</TT>增加一个字段，那么所有表中现有行都初始化为该字段的缺省值(如果没有声明<TT CLASS="LITERAL">DEFAULT</TT>子句，那么就是 NULL)。</P><P>添加一个非空缺省值列或者改变一个原有列的类型需要重写整个表和索引。
不过也有例外，如果使用<TT CLASS="LITERAL">USING</TT>选项不改变字段的内容并且字段的新旧类型是二进制兼容的，也可以不重写表。
添加或者删除一个系统<TT CLASS="LITERAL">oid</TT>列同样需要重写整个表。
大表及索引的重写可能需要非常长的时间，并且也临时需要两倍的磁盘空间。</P><P>增加一个<TT CLASS="LITERAL">CHECK</TT>或<TT CLASS="LITERAL">NOT NULL</TT>约束将会扫描该表以保证现有的行符合约束要求。</P><P>提供在一个<TT CLASS="COMMAND">ALTER TABLE</TT>里面声明多个修改的主要原因是原先需要的对表的多次扫描和重写可以组合成一个操作。</P><P><TT CLASS="LITERAL">DROP COLUMN</TT>命令并不是物理上把字段删除，而只是简单地 把它标记为对 SQL 操作不可见。
随后对该表的插入和更新将在该字段存储一个 NULL 。
因此，删除一个字段是很快的，但是它不会立即释放表在磁盘上的空间，因为被删除 了的字段占据的空间还没有回收。
这些空间将随着现有的行的更新而得到回收。 (在删除系统<TT CLASS="LITERAL">oid</TT>列时，方式有点不同，这个操作是直接执行了一次表的重写。)</P><P>要强制立刻执行一次表的重写，可以使用<A HREF="sql-vacuum.html">VACUUM FULL</A>、<A HREF="sql-cluster.html">CLUSTER</A>或是ALTER TABLE命令中的一些形式。
这些命令从可见的语义上不会对表产生更新，但会清除不再有用的数据。</P><P>使用<TT CLASS="LITERAL">SET DATA TYPE</TT>命令中的<TT CLASS="LITERAL">USING</TT>选项实际上可以指定任何表达式涉及到记录旧值；
也就是说，它可以引用除了正在被转换的字段之外其它的字段。
这样，就可以用<TT CLASS="LITERAL">SET DATA TYPE</TT>E语法做非常普遍性的转换。
因为这个灵活性， <TT CLASS="LITERAL">USING</TT>表达式并没有应用于该字段的缺省值(如果有的话)；结果可能不是缺省表达式要求的常量表达式。
这就意味着如果从旧类型到新类型没有隐含或者赋值 转换的话，那么即使存在<TT CLASS="LITERAL">USING</TT>选项，<TT CLASS="LITERAL">SET DATA TYPE</TT>也可能无法把缺省值转换成新的类型。
在这种情况下，应该用<TT CLASS="LITERAL">DROP DEFAULT</TT>先删除缺省值，执行 <TT CLASS="LITERAL">ALTER TYPE</TT>，然后使用<TT CLASS="LITERAL">SET DEFAULT</TT>增加一个 合适的新缺省值。
类似的考虑也适用于涉及该字段的索引和约束。</P><P>如果一个表有子表，那么如果不在子表上做同样的修改的话，就不允许在父表上增加、 重命名、修改一个字段的类型。
也就是说，<TT CLASS="COMMAND">ALTER TABLE ONLY</TT>将被拒绝执行。
这样就保证了子表总是有和父表匹配的字段。</P><P>一个递归 <TT CLASS="LITERAL">DROP COLUMN</TT>操作将只有在子表并不从任何其它父表中继承该字段并且从来没有独立定义该字段的时候才能删除一个子表的字段。
一个非递归的<TT CLASS="LITERAL">DROP COLUMN</TT>(也就是 <TT CLASS="COMMAND">ALTER TABLE ONLY ... DROP COLUMN</TT>) 从来不会删除任何子表字段，
而是把他们标记为独立定义的(而不是继承的)。
。</P><P><TT CLASS="LITERAL">TRIGGER</TT>、<TT CLASS="LITERAL">CLUSTER</TT>、<TT CLASS="LITERAL">OWNER</TT>和<TT CLASS="LITERAL">TABLESPACE</TT>的操作绝不会递归影响到子表；
也就是说，它们的行为就像总是声明了<TT CLASS="LITERAL">ONLY</TT> 一样。 只有没有标记为<TT CLASS="LITERAL">NO INHERIT</TT>的<TT CLASS="LITERAL">CHECK</TT>约束才能添加一个递归性的约束。</P><P>不允许更改系统表结构的任何部分。</P><P>请参考<A HREF="sql-createtable.html">CREATE TABLE</A>部分获取更多有效参数的描述。<A HREF="http://school.yunwei.edu/manual/PostgreSQL/ddl.html">第 5 &#31456;</A>章节里有更多有关继承的信息。。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN66954"></A><H2>例子</H2><P>向表中增加一个<TT CLASS="TYPE">varchar</TT>字段：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ADD COLUMN address varchar(30);</PRE><P></P><P>从表中删除一个字段：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors DROP COLUMN address RESTRICT;</PRE><P></P><P>在一个操作中修改两个现有字段的类型：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);</PRE><P></P><P>使用一个<TT CLASS="LITERAL">USING</TT>选项，把一个包含 UNIX 时间戳的 integer 字段转化成 <TT CLASS="TYPE">timestamp with time zone</TT>字段：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';</PRE><P></P><P>同样地，当字段有一个不会自动转换成新类型的缺省值表达式时：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();</PRE><P></P><P>对现有字段改名：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors RENAME COLUMN address TO city;</PRE><P></P><P>更改现有表的名字：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors RENAME TO suppliers;</PRE><P></P><P>更改现有约束的名字：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;</PRE><P></P><P>给一个字段增加一个非空约束：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;</PRE><P>
从一个字段里删除一个非空约束：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;</PRE><P></P><P>给一个表增加一个检查约束：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);</PRE><P></P><P>给一个表且不包含其子表增加一个检查约束：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;</PRE><P>
（这个检查约束也不会被以后新增的子表继承。）</P><P>删除一个表及其所有子表的检查约束：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors DROP CONSTRAINT zipchk;</PRE><P></P><P>从表中删除一个检查约束（不包含子表）：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;</PRE><P>
（这个检查约束对所有子表仍保留。）</P><P>向表中增加一个外键约束：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);</PRE><P></P><P>给表增加一个(多字段)唯一约束：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);</PRE><P></P><P>给一个表增加一个自动命名的主键约束，要注意的是一个表只能有一个主键：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors ADD PRIMARY KEY (dist_id);</PRE><P></P><P>把表移动到另外一个表空间：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE distributors SET TABLESPACE fasttablespace;</PRE><P></P><P>把表移动到另外一个模式：
</P><PRE CLASS="PROGRAMLISTING">ALTER TABLE myschema.distributors SET SCHEMA yourschema;</PRE><P></P><P>重新创建一个主键约束，并且在主键索引在创建时不影响记录的更新：
</P><PRE CLASS="PROGRAMLISTING">CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN66998"></A><H2>兼容性</H2><P><TT CLASS="LITERAL">ADD</TT> (不包含<TT CLASS="LITERAL">USING INDEX</TT>)、<TT CLASS="LITERAL">DROP</TT>、<TT CLASS="LITERAL">SET DEFAULT</TT>和<TT CLASS="LITERAL">SET DATA TYPE</TT> (不包含<TT CLASS="LITERAL">USING</TT>)形式与 SQL 标准兼容。
其它形式是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对 SQL 标准 的扩展。还有，在一个<TT CLASS="COMMAND">ALTER TABLE</TT>命令里声明多个操作也是扩展。</P><P><TT CLASS="COMMAND">ALTER TABLE DROP COLUMN</TT>可以用于删除表中的唯一的一个字段，留下一个零字段的表。这是对 SQL 的扩展，它不允许零字段表。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN67011"></A><H2>参见</H2><A HREF="sql-createtable.html">CREATE TABLE</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-alterserver.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-altertablespace.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">ALTER SERVER</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">ALTER TABLESPACE</TD></TR></TABLE></DIV></BODY></HTML>
