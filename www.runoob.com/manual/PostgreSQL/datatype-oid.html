<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>对象标识符类型</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="数据类型" HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html"><LINK REL="PREVIOUS" TITLE="范围类型" HREF="rangetypes.html"><LINK REL="NEXT" TITLE="伪类型" HREF="datatype-pseudo.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/datatype.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="范围类型" HREF="rangetypes.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 8. 数据类型</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="伪类型" HREF="datatype-pseudo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="DATATYPE-OID">8.18. 对象标识符类型</A></H1><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>在内部使用对象标识符(OID)作为各种系统表的主键。
同时，系统不会给用户创建的表增加一个 OID 系统字段(除非在建表时声明了<TT CLASS="LITERAL">WITH OIDS</TT>
或者配置参数<A HREF="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS">default_with_oids</A>设置为开启)。<TT CLASS="TYPE">oid</TT>
类型代表一个对象标识符。除此以外<TT CLASS="TYPE">oid</TT>还有几个别名：<TT CLASS="TYPE">regproc</TT>,
<TT CLASS="TYPE">regprocedure</TT>, <TT CLASS="TYPE">regoper</TT>, <TT CLASS="TYPE">regoperator</TT>, <TT CLASS="TYPE">regclass</TT>,
<TT CLASS="TYPE">regtype</TT>, <TT CLASS="TYPE">regconfig</TT>, 和<TT CLASS="TYPE">regdictionary</TT>。
<A HREF="datatype-oid.html#DATATYPE-OID-TABLE">&#34920; 8-23</A>显示了概览。</P><P>目前<TT CLASS="TYPE">oid</TT>类型用一个四字节的无符号整数实现。因此，
它不够提供大数据库范围内的唯一性保证，甚至在单个的大表中也不行。
因此，我们不鼓励在用户创建的表中使用 OID 字段做主键。OID 最好只是用于系统表。</P><P><TT CLASS="TYPE">oid</TT>类型本身除了比较之外还有几个操作。不过，它可以转换为整数，
然后用标准的整数操作符操作。如果你这么干，请注意可能的有符号和无符号之间的混淆。</P><P>OID 别名类型除了输入和输出过程之外没有自己的操作。
这些过程可以为系统对象接受和显示符号名，而不仅仅是类型<TT CLASS="TYPE">oid</TT>
将要使用的行数值。别名类型允许我们简化为对象查找 OID 值的过程。比如，
检查和一个表<TT CLASS="LITERAL">mytable</TT>相关的<TT CLASS="STRUCTNAME">pg_attribute</TT>行，我们可以这样写:
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;</PRE><P>
而不用:
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');</PRE><P>
虽然看上去不坏，但是这个例子还是简化了好多，如果在不同的模式里有好多叫
<TT CLASS="LITERAL">mytable</TT>的表，那么我们需要写一个更复杂的子查询。<TT CLASS="TYPE">regclass</TT>
的输入转换器处理根据模式路径设置的表检索工作，所以它自动干了<SPAN CLASS="QUOTE">"正确的事情"</SPAN>。
类似的还有，把一个表的 OID 转换成<TT CLASS="TYPE">regclass</TT>是查找一个 OID 对应的符号名称的最简单方法。
</P><DIV CLASS="TABLE"><A NAME="DATATYPE-OID-TABLE"></A><P><B>&#34920; 8-23. 对象标识符类型</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>引用</TH><TH>描述</TH><TH>数值例子</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="TYPE">oid</TT></TD><TD>任意</TD><TD>数字化的对象标识符</TD><TD><TT CLASS="LITERAL">564182</TT></TD></TR><TR><TD><TT CLASS="TYPE">regproc</TT></TD><TD><TT CLASS="STRUCTNAME">pg_proc</TT></TD><TD>函数名字</TD><TD><TT CLASS="LITERAL">sum</TT></TD></TR><TR><TD><TT CLASS="TYPE">regprocedure</TT></TD><TD><TT CLASS="STRUCTNAME">pg_proc</TT></TD><TD>带参数类型的函数</TD><TD><TT CLASS="LITERAL">sum(int4)</TT></TD></TR><TR><TD><TT CLASS="TYPE">regoper</TT></TD><TD><TT CLASS="STRUCTNAME">pg_operator</TT></TD><TD>操作符名</TD><TD><TT CLASS="LITERAL">+</TT></TD></TR><TR><TD><TT CLASS="TYPE">regoperator</TT></TD><TD><TT CLASS="STRUCTNAME">pg_operator</TT></TD><TD>带参数类型的操作符</TD><TD><TT CLASS="LITERAL">*(integer,integer)</TT> 或 <TT CLASS="LITERAL">-(NONE,integer)</TT></TD></TR><TR><TD><TT CLASS="TYPE">regclass</TT></TD><TD><TT CLASS="STRUCTNAME">pg_class</TT></TD><TD>关系名</TD><TD><TT CLASS="LITERAL">pg_type</TT></TD></TR><TR><TD><TT CLASS="TYPE">regtype</TT></TD><TD><TT CLASS="STRUCTNAME">pg_type</TT></TD><TD>数据类型名</TD><TD><TT CLASS="LITERAL">integer</TT></TD></TR><TR><TD><TT CLASS="TYPE">regconfig</TT></TD><TD><TT CLASS="STRUCTNAME">pg_ts_config</TT></TD><TD>文本搜索配置</TD><TD><TT CLASS="LITERAL">english</TT></TD></TR><TR><TD><TT CLASS="TYPE">regdictionary</TT></TD><TD><TT CLASS="STRUCTNAME">pg_ts_dict</TT></TD><TD>文本搜索字典</TD><TD><TT CLASS="LITERAL">simple</TT></TD></TR></TBODY></TABLE></DIV><P>所有 OID 别名类型都接受有模式修饰的名字，
并且如果在当前搜索路径中不增加修饰无法找到该对象的话，
那么在输出时将显示有模式修饰的名字。<TT CLASS="TYPE">regproc</TT>和<TT CLASS="TYPE">regoper</TT>
别名类型将只接受唯一的输入名字(不能重载)，因此它们的用途有限。
对于大多数应用，<TT CLASS="TYPE">regprocedure</TT>或<TT CLASS="TYPE">regoperator</TT>更合适。
对于<TT CLASS="TYPE">regoperator</TT>，单目操作符是通过在那些未用的操作数上写<TT CLASS="LITERAL">NONE</TT>
来标识的。</P><P>OID 别名类型的一个额外的属性是依赖关系的创建。
如果这些类型之一的常量出现在一个存储的表达式里(比如字段缺省表达式或者视图)，
它在被引用的对象上创建一个依赖性。比如，如果一个字段有缺省的
<TT CLASS="LITERAL">nextval('my_seq'::regclass)</TT>表达式，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
理解缺省表达式依赖于序列<TT CLASS="LITERAL">my_seq</TT>；系统将不允许在删除缺省的表达式之前删除该序列。</P><P>系统使用的另外一个标识符类型是事务(缩写<ABBR CLASS="ABBREV">xact</ABBR>)标识符<TT CLASS="TYPE">xid</TT>。
它是系统字段<TT CLASS="STRUCTFIELD">xmin</TT>和<TT CLASS="STRUCTFIELD">xmax</TT>的数据类型。事务标识符是 32 位的量。</P><P>系统需要的第三种标识符类型是命令标识符<TT CLASS="TYPE">cid</TT>。
它是系统字段<TT CLASS="STRUCTFIELD">cmin</TT>和<TT CLASS="STRUCTFIELD">cmax</TT>的数据类型。命令标识符也是 32 位的量。</P><P>系统使用的最后一个标识符类型是行标识符<TT CLASS="TYPE">tid</TT>。
它是系统表字段<TT CLASS="STRUCTFIELD">ctid</TT>的数据类型。行 ID 是一对数值(块号，块内的行索引)，
它标识该行在其所在表内的物理位置。</P><P>系统字段在<A HREF="ddl-system-columns.html">第 5.4 &#33410;</A>里有更多解释。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="rangetypes.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="datatype-pseudo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">范围类型</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">伪类型</TD></TR></TABLE></DIV></BODY></HTML>
