<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>日期/时间类型</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="数据类型" HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html"><LINK REL="PREVIOUS" TITLE="二进制数据类型" HREF="datatype-binary.html"><LINK REL="NEXT" TITLE="布尔类型" HREF="datatype-boolean.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/datatype.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="二进制数据类型" HREF="datatype-binary.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 8. 数据类型</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="布尔类型" HREF="datatype-boolean.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="DATATYPE-DATETIME">8.5. 日期/时间类型</A></H1><P><A HREF="datatype-datetime.html#DATATYPE-DATETIME-TABLE">&#34920; 8-9</A>显示了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
支持的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>中所有日期和时间类型。
这些数据类型上可以进行的操作在<A HREF="functions-datetime.html">第 9.9 &#33410;</A>中描述。
日期是按照公历计算的，甚至日历之前的年份也介绍了
（参阅<A HREF="datetime-units-history.html">第 B.4 &#33410;</A>获取更多信息）。</P><DIV CLASS="TABLE"><A NAME="DATATYPE-DATETIME-TABLE"></A><P><B>&#34920; 8-9. 日期/时间类型</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>存储空间</TH><TH>描述</TH><TH>最低值</TH><TH>最高值</TH><TH>分辨率</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="TYPE">timestamp [ (<TT CLASS="REPLACEABLE"><I>p</I></TT>) ] [ without time zone ]</TT></TD><TD>8 字节</TD><TD>日期和时间(无时区)</TD><TD>4713 BC</TD><TD>294276 AD</TD><TD>1 毫秒 / 14 位</TD></TR><TR><TD><TT CLASS="TYPE">timestamp [ (<TT CLASS="REPLACEABLE"><I>p</I></TT>) ] with time zone</TT></TD><TD>8 字节</TD><TD>日期和时间，有时区</TD><TD>4713 BC</TD><TD>294276 AD</TD><TD>1 毫秒 / 14 位</TD></TR><TR><TD><TT CLASS="TYPE">date</TT></TD><TD>4 字节</TD><TD>只用于日期</TD><TD>4713 BC</TD><TD>5874897 AD</TD><TD>1 天</TD></TR><TR><TD><TT CLASS="TYPE">time [ (<TT CLASS="REPLACEABLE"><I>p</I></TT>) ] [ without time zone ]</TT></TD><TD>8 字节</TD><TD>只用于一日内时间</TD><TD>00:00:00</TD><TD>24:00:00</TD><TD>1 毫秒 / 14 位</TD></TR><TR><TD><TT CLASS="TYPE">time [ (<TT CLASS="REPLACEABLE"><I>p</I></TT>) ] with time zone</TT></TD><TD>12 字节</TD><TD>只用于一日内时间，带时区</TD><TD>00:00:00+1459</TD><TD>24:00:00-1459</TD><TD>1 毫秒 / 14 位</TD></TR><TR><TD><TT CLASS="TYPE">interval [ <TT CLASS="REPLACEABLE"><I>fields</I></TT> ] [ (<TT CLASS="REPLACEABLE"><I>p</I></TT>) ]</TT></TD><TD>12 字节</TD><TD>时间间隔</TD><TD>-178000000 年</TD><TD>178000000 年</TD><TD>1 毫秒 / 14 位</TD></TR></TBODY></TABLE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>
SQL标准要求仅仅将<TT CLASS="TYPE">timestamp</TT>类型等于<TT CLASS="TYPE">timestamp without time zone</TT>
类型，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>遵守这个行为。（7.3之前的版本将其看做
<TT CLASS="TYPE">timestamp with time zone</TT>。） <TT CLASS="TYPE">timestamptz</TT>作为
<TT CLASS="TYPE">timestamp with time zone</TT>的缩写被接受；这是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
的一个扩展。</P></BLOCKQUOTE></DIV><P><TT CLASS="TYPE">time</TT>, <TT CLASS="TYPE">timestamp</TT>和<TT CLASS="TYPE">interval</TT>接受一个可选的精度值
<TT CLASS="REPLACEABLE"><I>p</I></TT>以指明秒域中小数部分的位数。没有明确的缺省精度，
<TT CLASS="REPLACEABLE"><I>p</I></TT>的范围对<TT CLASS="TYPE">timestamp</TT>和<TT CLASS="TYPE">interval</TT>类型是从0到6。 &#13;</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>如果<TT CLASS="TYPE">timestamp</TT>数值是以8字节整数(目前的缺省)的方式存储的，
那么微秒的精度就可以在数值的全部范围内都可以获得。如果<TT CLASS="TYPE">timestamp</TT>
数值是以双精度浮点数(一个废弃的编译时的选项)的方式存储的，
那么有效精度会小于 6 。<TT CLASS="TYPE">timestamp</TT>值是以 2000-01-01 午夜之前或之后的秒数存储的。
当<TT CLASS="TYPE">timestamp</TT>值用浮点数实现时，微秒的精度是为那些在 2000-01-01 前后几年的日期实现的，
对于那些远一些的日子，精度会下降。注意，使用浮点时间允许一个比上面显示的更大的
<TT CLASS="TYPE">timestamp</TT>值变化范围：从4713BC到5874897AD。</P><P>同一个编译时选项也决定<TT CLASS="TYPE">time</TT>和<TT CLASS="TYPE">interval</TT>值是保存成浮点数还是八字节整数。
在以浮点数存储的时候，随着时间间隔的增加，大的 <TT CLASS="TYPE">interval</TT>数值的精度会降低。</P></BLOCKQUOTE></DIV><P>对于<TT CLASS="TYPE">time</TT>类型，如果使用了八字节的整数存储，那么<TT CLASS="REPLACEABLE"><I>p</I></TT>
允许的范围是从 0 到 6 ，如果使用的是浮点数存储，那么这个范围是 0 到 10 。</P><P><TT CLASS="TYPE">interval</TT>类型有一个额外的选项，通过下下面词组之一限制存储的字段值：
</P><PRE CLASS="LITERALLAYOUT">YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND</PRE><P>
注意如果同时指定了<TT CLASS="REPLACEABLE"><I>fields</I></TT>和<TT CLASS="REPLACEABLE"><I>p</I></TT>，
<TT CLASS="REPLACEABLE"><I>fields</I></TT>必须包含<TT CLASS="LITERAL">SECOND</TT>，因为精度只应用于秒。
</P><P><TT CLASS="TYPE">time with time zone</TT>类型是 SQL 标准定义的，
但是完整定义的有些方面会导致有问题的用法。在大多数情况下，<TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">time</TT>,
<TT CLASS="TYPE">timestamp without time zone</TT>, 和<TT CLASS="TYPE">timestamp with time zone</TT>
的组合就应该能提供一切应用需要的日期/时间的完整功能。</P><P><TT CLASS="TYPE">abstime</TT>和<TT CLASS="TYPE">reltime</TT>类型是低分辨率类型，它们被用于系统内部。
我们反对你在应用中使用这些类型，因为这些内部类型可能会在未来的版本里消失。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DATATYPE-DATETIME-INPUT">8.5.1. 日期/时间输入</A></H2><P>日期和时间的输入几乎可以是任何合理的格式，包括 ISO-8601 格式、<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>-兼容格式、
传统<SPAN CLASS="PRODUCTNAME">POSTGRES</SPAN>格式、其它的形式。对于一些格式，
日期输入里的日、月、年可能会让人迷惑，因此系统支持自定义这些字段的顺序。
把<A HREF="runtime-config-client.html#GUC-DATESTYLE">DateStyle</A>参数设置为<TT CLASS="LITERAL">MDY</TT>就按照"月-日-年"解析，
设置为<TT CLASS="LITERAL">DMY</TT>就按照"日-月-年"解析，设置为<TT CLASS="LITERAL">YMD</TT>就按照"年-月-日"解析。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>在处理日期/时间输入上比<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>
标准要求的更灵活。参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/datetime-appendix.html">&#38468;&#24405; B</A>
获取关于日期/时间输入的准确分析规则和可识别文本字段，包括月份、星期几、时区。</P><P>请记住任何日期或者时间的文本输入需要由单引号包围，就像一个文本字符串一样。
参考<A HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC">第 4.1.2.7 &#33410;</A>获取更多信息。
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>要求使用下面的语法：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] '<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>'</PRE><P>
可选的精度声明中的<TT CLASS="REPLACEABLE"><I>p</I></TT>是一个整数，表示在秒域中小数部分的位数，
我们可以对<TT CLASS="TYPE">time</TT>,<TT CLASS="TYPE">timestamp</TT>,<TT CLASS="TYPE">interval</TT>类型声明精度。
允许的精度在上面已经说明。如果在常量声明中没有声明精度，缺省是文本值的精度。
</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN5608">8.5.1.1. 日期</A></H3><P><A HREF="datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE">&#34920; 8-10</A>显示了<TT CLASS="TYPE">date</TT>类型可能的输入方式。</P><DIV CLASS="TABLE"><A NAME="DATATYPE-DATETIME-DATE-TABLE"></A><P><B>&#34920; 8-10. Date Input</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>例子</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD>1999-01-08</TD><TD>ISO 8601格式(建议格式)，任何方式下都是 1999 年 1 月 8 号</TD></TR><TR><TD>January 8, 1999</TD><TD>在任何<TT CLASS="VARNAME">datestyle</TT>输入模式下都无歧义</TD></TR><TR><TD>1/8/1999</TD><TD>有歧义，在<TT CLASS="LITERAL">MDY</TT>下是一月八号；在<TT CLASS="LITERAL">DMY</TT>模式下是八月一日</TD></TR><TR><TD>1/18/1999</TD><TD><TT CLASS="LITERAL">MDY</TT>模式下是一月十八日，其它模式下被拒绝</TD></TR><TR><TD>01/02/03</TD><TD><TT CLASS="LITERAL">MDY</TT>模式下的 2003 年 1 月 2 日；
<TT CLASS="LITERAL">DMY</TT>模式下的 2003 年 2 月 1 日；
<TT CLASS="LITERAL">YMD</TT>模式下的 2001 年 2 月 3 日
</TD></TR><TR><TD>1999-Jan-08</TD><TD>任何模式下都是 1 月 8 日</TD></TR><TR><TD>Jan-08-1999</TD><TD>任何模式下都是 1 月 8 日</TD></TR><TR><TD>08-Jan-1999</TD><TD>任何模式下都是 1 月 8 日</TD></TR><TR><TD>99-Jan-08</TD><TD><TT CLASS="LITERAL">YMD</TT>模式下是 1 月 8 日，否则错误</TD></TR><TR><TD>08-Jan-99</TD><TD>一月八日，除了在<TT CLASS="LITERAL">YMD</TT>模式下是错误的之外</TD></TR><TR><TD>Jan-08-99</TD><TD>一月八日，除了在<TT CLASS="LITERAL">YMD</TT>模式下是错误的之外</TD></TR><TR><TD>19990108</TD><TD>ISO 8601；任何模式下都是 1999 年 1 月 8 日</TD></TR><TR><TD>990108</TD><TD>ISO 8601；任何模式下都是 1999 年 1 月 8 日</TD></TR><TR><TD>1999.008</TD><TD>年和年里的第几天</TD></TR><TR><TD>J2451187</TD><TD>儒略日</TD></TR><TR><TD>January 8, 99 BC</TD><TD>公元前 99 年</TD></TR></TBODY></TABLE></DIV></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN5681">8.5.1.2. 时间</A></H3><P>当日时间类型是<TT CLASS="TYPE">time [ (<TT CLASS="REPLACEABLE"><I>p</I></TT>) ] without time zone</TT>
和<TT CLASS="TYPE">time [ (<TT CLASS="REPLACEABLE"><I>p</I></TT>) ] with time zone</TT>。
只写<TT CLASS="TYPE">time</TT>等效于<TT CLASS="TYPE">time without time zone</TT>。</P><P>这些类型的有效输入由当日时间后面跟着可选的时区组成(参阅
<A HREF="datatype-datetime.html#DATATYPE-DATETIME-TIME-TABLE">&#34920; 8-11</A>和<A HREF="datatype-datetime.html#DATATYPE-TIMEZONE-TABLE">&#34920; 8-12</A>)。
如果在<TT CLASS="TYPE">time without time zone</TT>类型的输入中声明了时区，那么它会被悄悄地忽略。
同样指定的日期也会被忽略，除非使用了一个包括夏令时规则的时区名，比如
<TT CLASS="LITERAL">America/New_York</TT>，在这种情况下，
必须指定日期以确定这个时间是标准时间还是夏令时。时区偏移将记录在
<TT CLASS="TYPE">time with time zone</TT>中。</P><DIV CLASS="TABLE"><A NAME="DATATYPE-DATETIME-TIME-TABLE"></A><P><B>&#34920; 8-11. 时间输入</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>例子</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">04:05:06.789</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">04:05:06</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">04:05</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">040506</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">04:05 AM</TT></TD><TD>与 04:05 一样；AM 不影响数值</TD></TR><TR><TD><TT CLASS="LITERAL">04:05 PM</TT></TD><TD>与 16:05 一样；输入小时数必须&lt;= 12</TD></TR><TR><TD><TT CLASS="LITERAL">04:05:06.789-8</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">04:05:06-08:00</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">04:05-08:00</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">040506-08</TT></TD><TD>ISO 8601</TD></TR><TR><TD><TT CLASS="LITERAL">04:05:06 PST</TT></TD><TD>缩写的时区</TD></TR><TR><TD><TT CLASS="LITERAL">2003-04-12 04:05:06 America/New_York</TT></TD><TD>用名字声明的时区</TD></TR></TBODY></TABLE></DIV><DIV CLASS="TABLE"><A NAME="DATATYPE-TIMEZONE-TABLE"></A><P><B>&#34920; 8-12. 时区输入</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>例子</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">PST</TT></TD><TD>太平洋标准时间(Pacific Standard Time)</TD></TR><TR><TD><TT CLASS="LITERAL">America/New_York</TT></TD><TD>完整时区名称</TD></TR><TR><TD><TT CLASS="LITERAL">PST8PDT</TT></TD><TD>POSIX 风格的时区</TD></TR><TR><TD><TT CLASS="LITERAL">-8:00</TT></TD><TD>ISO-8601 与 PST 的偏移</TD></TR><TR><TD><TT CLASS="LITERAL">-800</TT></TD><TD>ISO-8601 与 PST 的偏移</TD></TR><TR><TD><TT CLASS="LITERAL">-8</TT></TD><TD>ISO-8601 与 PST 的偏移</TD></TR><TR><TD><TT CLASS="LITERAL">zulu</TT></TD><TD>军方对 UTC 的缩写(译注：可能是美军)</TD></TR><TR><TD><TT CLASS="LITERAL">z</TT></TD><TD><TT CLASS="LITERAL">zulu</TT>的缩写</TD></TR></TBODY></TABLE></DIV><P>参考<A HREF="datatype-datetime.html#DATATYPE-TIMEZONES">第 8.5.3 &#33410;</A>以获取如何指定时区的更多信息。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN5801">8.5.1.3. 时间戳</A></H3><P>时间戳类型的有效输入由一个日期和时间的连接组成，后面跟着一个可选的时区，
一个可选的<TT CLASS="LITERAL">AD</TT>或<TT CLASS="LITERAL">BC</TT>。另外，
<TT CLASS="LITERAL">AD</TT>/<TT CLASS="LITERAL">BC</TT>可以出现在时区前面，
但这个顺序并非最佳的。因此：
</P><PRE CLASS="PROGRAMLISTING">1999-01-08 04:05:06</PRE><P>
和：
</P><PRE CLASS="PROGRAMLISTING">1999-01-08 04:05:06 -8:00</PRE><P>
都是有效的数值，它是兼容<ACRONYM CLASS="ACRONYM">ISO</ACRONYM>-8601 的。另外，
也支持下面这种使用广泛的格式：
</P><PRE CLASS="PROGRAMLISTING">January 8 04:05:06 1999 PST</PRE><P>
</P><P><ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准通过<SPAN CLASS="QUOTE">"+"</SPAN>或者<SPAN CLASS="QUOTE">"-"</SPAN>是否存在和时间后的失去偏移来区分
<TT CLASS="TYPE">timestamp without time zone</TT>和<TT CLASS="TYPE">timestamp with time zone</TT>文本。因此，
根据标准，</P><PRE CLASS="PROGRAMLISTING">TIMESTAMP '2004-10-19 10:23:54'</PRE><P>是一个
<TT CLASS="TYPE">timestamp without time zone</TT>，而</P><PRE CLASS="PROGRAMLISTING">TIMESTAMP '2004-10-19 10:23:54+02'</PRE><P>
是一个<TT CLASS="TYPE">timestamp with time zone</TT>。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
从来不会在确定文本的类型之前检查文本内容，因此会把上面两个都看做是
<TT CLASS="TYPE">timestamp without time zone</TT>。因此要保证把上面的第二个当作
<TT CLASS="TYPE">timestamp with time zone</TT>看待，就要给它明确的类型：
</P><PRE CLASS="PROGRAMLISTING">TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</PRE><P>
如果一个文本已被确定是<TT CLASS="TYPE">timestamp without time zone</TT>，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
将悄悄忽略任何文本中指出的时区。因此，生成的日期/时间值是从输入值的日期/时间字段衍生出来的，
并且没有就时区进行调整。</P><P>对于<TT CLASS="TYPE">timestamp with time zone</TT>，内部存储的数值总是 UTC(全球统一时间，
以前也叫格林威治时间<ACRONYM CLASS="ACRONYM">GMT</ACRONYM>)。如果一个输入值有明确的时区声明，
那么它将用该时区合适的偏移量转换成 UTC 。如果在输入字符串里没有时区声明，
那么它就假设是在系统的<A HREF="runtime-config-client.html#GUC-TIMEZONE">TimeZone</A>参数里的那个时区，
然后使用这个<TT CLASS="VARNAME">timezone</TT>时区转换成 UTC 。</P><P>如果输出一个<TT CLASS="TYPE">timestamp with time zone</TT>，那么它总是从 UTC 转换成当前的
<TT CLASS="VARNAME">timezone</TT>时区，并且显示为该时区的本地时间。要看其它时区的该时间，
要么修改<TT CLASS="VARNAME">timezone</TT>，要么使用<TT CLASS="LITERAL">AT TIME ZONE</TT>构造
(参阅<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT">第 9.9.3 &#33410;</A>)。</P><P>在<TT CLASS="TYPE">timestamp without time zone</TT>和<TT CLASS="TYPE">timestamp with time zone</TT>
之间的转换通常假设<TT CLASS="TYPE">timestamp without time zone</TT>数值应该以
<TT CLASS="VARNAME">timezone</TT>本地时间的形式接受或者写出。其它的时区可以用
<TT CLASS="LITERAL">AT TIME ZONE</TT>的方式为转换声明。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN5851">8.5.1.4. 特殊值</A></H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>为方便起见支持在
<A HREF="datatype-datetime.html#DATATYPE-DATETIME-SPECIAL-TABLE">&#34920; 8-13</A>里面显示的几个特殊输入值。
值<TT CLASS="LITERAL">infinity</TT>和<TT CLASS="LITERAL">-infinity</TT>是特别在系统内部表示的，
并且将按照同样的方式显示；但是其它的都只是符号缩写，
在读取的时候将被转换成普通的日期/时间值。特别是<TT CLASS="LITERAL">now</TT>
和相关的字符串在读取的时候就被转换成对应的数值。
所有这些值在 SQL 命令里当作普通常量对待时，都需要包围在单引号里面。</P><DIV CLASS="TABLE"><A NAME="DATATYPE-DATETIME-SPECIAL-TABLE"></A><P><B>&#34920; 8-13. 特殊日期/时间输入</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>输入字符串</TH><TH>适用类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">epoch</TT></TD><TD><TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">timestamp</TT></TD><TD>1970-01-01 00:00:00+00 (Unix 系统零时)</TD></TR><TR><TD><TT CLASS="LITERAL">infinity</TT></TD><TD><TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">timestamp</TT></TD><TD>比任何其它时间戳都晚</TD></TR><TR><TD><TT CLASS="LITERAL">-infinity</TT></TD><TD><TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">timestamp</TT></TD><TD>比任何其它时间戳都早</TD></TR><TR><TD><TT CLASS="LITERAL">now</TT></TD><TD><TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">time</TT>, <TT CLASS="TYPE">timestamp</TT></TD><TD>当前事务的开始时间</TD></TR><TR><TD><TT CLASS="LITERAL">today</TT></TD><TD><TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">timestamp</TT></TD><TD>今日午夜</TD></TR><TR><TD><TT CLASS="LITERAL">tomorrow</TT></TD><TD><TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">timestamp</TT></TD><TD>明日午夜</TD></TR><TR><TD><TT CLASS="LITERAL">yesterday</TT></TD><TD><TT CLASS="TYPE">date</TT>, <TT CLASS="TYPE">timestamp</TT></TD><TD>昨日午夜</TD></TR><TR><TD><TT CLASS="LITERAL">allballs</TT></TD><TD><TT CLASS="TYPE">time</TT></TD><TD>00:00:00.00 UTC</TD></TR></TBODY></TABLE></DIV><P>下列<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>兼容函数也可以用于获取对应数据类型的当前时间值：
<TT CLASS="LITERAL">CURRENT_DATE</TT>, <TT CLASS="LITERAL">CURRENT_TIME</TT>,
<TT CLASS="LITERAL">CURRENT_TIMESTAMP</TT>, <TT CLASS="LITERAL">LOCALTIME</TT>,
<TT CLASS="LITERAL">LOCALTIMESTAMP</TT>。后四个接受一个可选的精度声明(
<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>)。不过，请注意这些 SQL 函数<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不是</I></SPAN>
被当作数据输入字符串识别的。</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DATATYPE-DATETIME-OUTPUT">8.5.2. 日期/时间输出</A></H2><P>日期/时间类型的输出格式可以设成 ISO 8601(默认)、<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>(Ingres)、
传统的<SPAN CLASS="PRODUCTNAME">POSTGRES</SPAN>(Unix <SPAN CLASS="APPLICATION">date</SPAN>格式)或German四种风格之一。
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准要求使用 ISO 8601 格式。<SPAN CLASS="QUOTE">"SQL"</SPAN>输出格式的名字是历史偶然。
<A HREF="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT-TABLE">&#34920; 8-14</A>显示了每种输出风格的例子。
<TT CLASS="TYPE">date</TT>和<TT CLASS="TYPE">time</TT>类型的输出当然只是给出的例子里面的日期和时间部分。</P><DIV CLASS="TABLE"><A NAME="DATATYPE-DATETIME-OUTPUT-TABLE"></A><P><B>&#34920; 8-14. 日期/时间输出风格</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>风格</TH><TH>描述</TH><TH>例子</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">ISO</TT></TD><TD>ISO 8601，SQL 标准</TD><TD><TT CLASS="LITERAL">1997-12-17 07:37:16-08</TT></TD></TR><TR><TD><TT CLASS="LITERAL">SQL</TT></TD><TD>传统风格</TD><TD><TT CLASS="LITERAL">12/17/1997 07:37:16.00 PST</TT></TD></TR><TR><TD><TT CLASS="LITERAL">Postgres</TT></TD><TD>原始风格</TD><TD><TT CLASS="LITERAL">Wed Dec 17 07:37:16 1997 PST</TT></TD></TR><TR><TD><TT CLASS="LITERAL">German</TT></TD><TD>地区风格</TD><TD><TT CLASS="LITERAL">17.12.1997 07:37:16.00 PST</TT></TD></TR></TBODY></TABLE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>ISO 8601指定用大写字母<TT CLASS="LITERAL">T</TT>分隔日期和时间。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
在输入上接受这种格式，但是在输出上使用一个空格而不是<TT CLASS="LITERAL">T</TT>，就像上面显示的。
这样更易读而且和RFC 3399或者其他的数据库系统一致。</P></BLOCKQUOTE></DIV><P>如果声明了 DMY 顺序，那么在<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>和 POSTGRES 风格里，
日期在月份之前出现，否则月份出现在日期之前(参阅<A HREF="datatype-datetime.html#DATATYPE-DATETIME-INPUT">第 8.5.1 &#33410;</A>
看看这个设置如何影响对输入值的解释)。<A HREF="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT2-TABLE">&#34920; 8-15</A>
显示了一个例子。</P><DIV CLASS="TABLE"><A NAME="DATATYPE-DATETIME-OUTPUT2-TABLE"></A><P><B>&#34920; 8-15. 日期顺序习惯</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH><TT CLASS="VARNAME">datestyle</TT>设置</TH><TH>输入顺序</TH><TH>输出样例</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">SQL, DMY</TT></TD><TD><TT CLASS="REPLACEABLE"><I>日</I></TT>/<TT CLASS="REPLACEABLE"><I>月</I></TT>/<TT CLASS="REPLACEABLE"><I>年</I></TT></TD><TD><TT CLASS="LITERAL">17/12/1997 15:37:16.00 CET</TT></TD></TR><TR><TD><TT CLASS="LITERAL">SQL, MDY</TT></TD><TD><TT CLASS="REPLACEABLE"><I>月</I></TT>/<TT CLASS="REPLACEABLE"><I>日</I></TT>/<TT CLASS="REPLACEABLE"><I>年</I></TT></TD><TD><TT CLASS="LITERAL">12/17/1997 07:37:16.00 PST</TT></TD></TR><TR><TD><TT CLASS="LITERAL">Postgres, DMY</TT></TD><TD><TT CLASS="REPLACEABLE"><I>日</I></TT>/<TT CLASS="REPLACEABLE"><I>月</I></TT>/<TT CLASS="REPLACEABLE"><I>年</I></TT></TD><TD><TT CLASS="LITERAL">Wed 17 Dec 07:37:16 1997 PST</TT></TD></TR></TBODY></TABLE></DIV><P>用户可以用<TT CLASS="COMMAND">SET datestyle</TT>命令选取日期/时间的风格，
也可以在配置文件<TT CLASS="FILENAME">postgresql.conf</TT>
中的<A HREF="runtime-config-client.html#GUC-DATESTYLE">DateStyle</A>参数中设置，或者在服务器或客户端的
<TT CLASS="ENVAR">PGDATESTYLE</TT>环境变量中设置。</P><P>我们也可以用格式化函数<CODE CLASS="FUNCTION">to_char</CODE>(参见<A HREF="functions-formatting.html">第 9.8 &#33410;</A>)
来更灵活地控制时间/日期地输出。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DATATYPE-TIMEZONES">8.5.3. 时区</A></H2><P>时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。
到了 19 世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，
部分是因为夏时制规则。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
使用广泛使用的<TT CLASS="LITERAL">zoneinfo</TT>（Olson）时区信息数据库有关历史时区的规则。
对于未来的时间，假设对于给定时区最近的规则将在未来继续无期限的遵守。</P><P>
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>在典型应用中尽可能与<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>
的定义相兼容。但<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准在日期/时间类型和功能上有一些奇怪的混淆。
两个显而易见的问题是：
<P></P></P><UL><LI><P><TT CLASS="TYPE">date</TT>类型与时区没有联系，而<TT CLASS="TYPE">time</TT>类型却有或可以有。
然而，现实世界的时区只有在与时间和日期都关联时才有意义，
因为时间偏移量(时差)可能因为实行类似夏时制这样的制度而在一年里有所变化。</P></LI><LI><P>缺省的时区用一个数字常量表示与<ACRONYM CLASS="ACRONYM">UTC</ACRONYM>的偏移(时差)。因此，
当跨<ACRONYM CLASS="ACRONYM">DST</ACRONYM>(夏时制)界限做日期/时间算术时，
我们根本不可能把夏时制这样的因素计算进去。</P></LI></UL><P>
</P><P>为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。
我们建议<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不要</I></SPAN>使用<TT CLASS="TYPE">time with time zone</TT>类型(尽管
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>出于合理应用以及为了与<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>
标准兼容的考虑支持这个类型)。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
假设你用于任何类型的本地时区都只包含日期或时间(而不包含时区)。</P><P>在系统内部，所有日期和时间都用全球统一时间<ACRONYM CLASS="ACRONYM">UTC</ACRONYM>格式存储，
时间在发给客户前端前由数据库服务器根据<A HREF="runtime-config-client.html#GUC-TIMEZONE">TimeZone</A>
配置参数声明的时区转换成本地时间。</P><P>
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许你用三种方法指定时区：
<P></P></P><UL><LI><P>完整的时区名。例如<TT CLASS="LITERAL">America/New_York</TT>。所有可以识别的时区名在
<TT CLASS="LITERAL">pg_timezone_names</TT>视图中列出(参见
<A HREF="view-pg-timezone-names.html">第 47.71 &#33410;</A>)。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
使用广泛使用的<TT CLASS="LITERAL">zoneinfo</TT>时区数据，
所以这些时区名在其它软件里也能被轻松的识别。</P></LI><LI><P>时区缩写。例如<TT CLASS="LITERAL">PST</TT>。这种缩写名通常只是定义了相对于 UTC 的偏移量，
而前一种完整的时区名可能还隐含着一组夏时制转换规则。
所有可以识别的时区缩写在<TT CLASS="LITERAL">pg_timezone_abbrevs</TT>视图中列出(参见
<A HREF="view-pg-timezone-abbrevs.html">第 47.70 &#33410;</A>)。你不能设置
<A HREF="runtime-config-client.html#GUC-TIMEZONE">TimeZone</A>或<A HREF="runtime-config-logging.html#GUC-LOG-TIMEZONE">log_timezone</A>
配置参数为时区缩写，但是你可以在日期/时间输入值中结合<TT CLASS="LITERAL">AT TIME ZONE</TT>
操作符使用时区缩写。</P></LI><LI><P>除完整的时区名及其缩写之外，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>还接受 POSIX 风格的
<TT CLASS="REPLACEABLE"><I>STD</I></TT><TT CLASS="REPLACEABLE"><I>offset</I></TT>或<TT CLASS="REPLACEABLE"><I>STD</I></TT><TT CLASS="REPLACEABLE"><I>offset</I></TT><TT CLASS="REPLACEABLE"><I>DST</I></TT>
格式的时区，其中的<TT CLASS="REPLACEABLE"><I>STD</I></TT>是时区缩写、<TT CLASS="REPLACEABLE"><I>offset</I></TT>
是一个相对于 UTC 的小时偏移量、<TT CLASS="REPLACEABLE"><I>DST</I></TT>是一个可选的夏时制时区缩写
(假定相对于给定的偏移量提前一小时)。例如，如果<TT CLASS="LITERAL">EST5EDT</TT>不是一个已识别的时区名，
那么它将等同于美国东部时间。如果存在夏时制时区名是当前时区名，根据<TT CLASS="LITERAL">zoneinfo</TT>
时区数据库的 <TT CLASS="FILENAME">posixrules</TT>条目中相同的夏时制事务规则，可以考虑使用这个特性。
在一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>标准安装中，<TT CLASS="FILENAME">posixrules</TT>与<TT CLASS="LITERAL">US/Eastern</TT>
相同，因此POSIX格式的时区声明遵循USA夏时制规则。如果需要，可以通过替换<TT CLASS="FILENAME">posixrules</TT>
文件来调整该习惯。</P></LI></UL><P>
简言之，这就是完整的时区名与时区缩写之间的差异：时区缩写总是代表一个相对于 UTC 的固定偏移量，
然而大多数完整的时区名隐含着一个本地夏令时规则，因此就有可能有两个相对于 UTC 的不同偏移量。
</P><P>需要警惕的是，由于没有合理的时区缩写检查，POSIX格式的时区特点能导致静默的伪输入。
例如，使用<TT CLASS="LITERAL">SET TIMEZONE TO FOOBAR0</TT>时，实际上系统使用的是一个很特别的UTC缩写。
另一个需要注意的是，在POSIX时区名中，积极的偏移用于<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">west</I></SPAN>格林尼治位置。
在其他地方，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>遵循ISO-8601规定，
即积极的时区偏移<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">east</I></SPAN>格林威治。</P><P>总体而言，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.2 版本以后时区名在所有情况下都是大小写无关的。
而之前的版本在某些情况下是大小写敏感的。</P><P>无论是完整的时区名还是时区缩写都不是硬连接进服务器的，它们都是从安装目录下的
<TT CLASS="FILENAME">.../share/timezone/</TT>和<TT CLASS="FILENAME">.../share/timezonesets/</TT>
配置文件中获取的(参见<A HREF="datetime-config-files.html">第 B.3 &#33410;</A>)。</P><P>
可以在<TT CLASS="FILENAME">postgresql.conf</TT>文件里设置<A HREF="runtime-config-client.html#GUC-TIMEZONE">TimeZone</A>
配置参数，或者用任何其它在<A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html">第 18 &#31456;</A>描述的标准方法。
除此之外，还有好几种特殊方法可以设置它：
<P></P></P><UL><LI><P>使用<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令<TT CLASS="COMMAND">SET TIME ZONE</TT>为会话设置时区，
这是<TT CLASS="COMMAND">SET TIMEZONE TO</TT>的一个可选的拼写方式，更加兼容标准。</P></LI><LI><P>如果在客户端设置了<TT CLASS="ENVAR">PGTZ</TT>环境变量，那么<SPAN CLASS="APPLICATION">libpq</SPAN>
在连接时将使用这个环境变量给后端发送一个<TT CLASS="COMMAND">SET TIME ZONE</TT>命令。</P></LI></UL><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DATATYPE-INTERVAL-INPUT">8.5.4. 间隔输入</A></H2><P><TT CLASS="TYPE">interval</TT>类型值可以用下面的详细语法写：
</P><PRE CLASS="SYNOPSIS">[<SPAN
CLASS="OPTIONAL"
>@</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
>...</SPAN
>] [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>direction</I
></TT
></SPAN
>]</PRE><P>
这里<TT CLASS="REPLACEABLE"><I>quantity</I></TT>是一个数字（可能已标记）；<TT CLASS="REPLACEABLE"><I>unit</I></TT>
可以是<TT CLASS="LITERAL">microsecond</TT>，<TT CLASS="LITERAL">millisecond</TT>，<TT CLASS="LITERAL">second</TT>，
<TT CLASS="LITERAL">minute</TT>，<TT CLASS="LITERAL">hour</TT>，<TT CLASS="LITERAL">day</TT>，
<TT CLASS="LITERAL">week</TT>，<TT CLASS="LITERAL">month</TT>，<TT CLASS="LITERAL">year</TT>，
<TT CLASS="LITERAL">decade</TT>，<TT CLASS="LITERAL">century</TT>，<TT CLASS="LITERAL">millennium</TT>
或这些单位的缩写或复数。<TT CLASS="REPLACEABLE"><I>direction</I></TT>可以是<TT CLASS="LITERAL">ago</TT>或为空。
<TT CLASS="LITERAL">@</TT>标记是可选的。不同的单位的数量被隐式地添加适当的计算符号。
<TT CLASS="LITERAL">ago</TT>否定所有。如果<A HREF="runtime-config-client.html#GUC-INTERVALSTYLE">IntervalStyle</A>
设置为<TT CLASS="LITERAL">postgres_verbose</TT>，那么这个语法同样用于间隔输出。
</P><P>可以在没有明确单位标记的情况下声明天，小时，分钟和秒。例如，<TT CLASS="LITERAL">'1 12:59:10'</TT>
等同于<TT CLASS="LITERAL">'1 day 12 hours 59 min 10 sec'</TT>。同样，
可以用一个破折号来声明一个年和月的组合，例如<TT CLASS="LITERAL">'200-10'</TT>等同于
<TT CLASS="LITERAL">'200 years 10 months'</TT>。（事实上，<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准值允许短的格式，
并且当<TT CLASS="VARNAME">IntervalStyle</TT>设置为<TT CLASS="LITERAL">sql_standard</TT>时，用于输出）。</P><P>要么使用4.4.3.2的<SPAN CLASS="QUOTE">"format with designators"</SPAN>，要么使用4.4.3.3的
<SPAN CLASS="QUOTE">"alternative format"</SPAN>，间隔值可以写为ISO 8601的时间间隔。格式如下：
</P><PRE CLASS="SYNOPSIS">P <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> ...</SPAN
>] [<SPAN
CLASS="OPTIONAL"
> T [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> ...</SPAN
>]</SPAN
>]</PRE><P>
字符串必须以<TT CLASS="LITERAL">P</TT>开始，并且可以含有一个<TT CLASS="LITERAL">T</TT>用以指明一天中时间的格式。
可用单位的缩写在<A HREF="datatype-datetime.html#DATATYPE-INTERVAL-ISO8601-UNITS">&#34920; 8-16</A>有说明。可以忽略单位，
也可以以任意顺序声明，但单位小于一天时必须在<TT CLASS="LITERAL">T</TT>之后。
尤其<TT CLASS="LITERAL">M</TT>的含义依赖于它在<TT CLASS="LITERAL">T</TT>之前或之后。
</P><DIV CLASS="TABLE"><A NAME="DATATYPE-INTERVAL-ISO8601-UNITS"></A><P><B>&#34920; 8-16. ISO 8601 间隔单位的缩写</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>缩写</TH><TH>含义</TH></TR></THEAD><TBODY><TR><TD>Y</TD><TD>年</TD></TR><TR><TD>M</TD><TD>月（日期部分）</TD></TR><TR><TD>W</TD><TD>周</TD></TR><TR><TD>D</TD><TD>日</TD></TR><TR><TD>H</TD><TD>小时</TD></TR><TR><TD>M</TD><TD>分钟（时间部分）</TD></TR><TR><TD>S</TD><TD>秒</TD></TR></TBODY></TABLE></DIV><P>以缩写格式：
</P><PRE CLASS="SYNOPSIS">P [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>years</I
></TT
>-<TT
CLASS="REPLACEABLE"
><I
>months</I
></TT
>-<TT
CLASS="REPLACEABLE"
><I
>days</I
></TT
> </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> T <TT
CLASS="REPLACEABLE"
><I
>hours</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>minutes</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
> </SPAN
>]</PRE><P>
一个字符串必须以<TT CLASS="LITERAL">P</TT>开始，然后以<TT CLASS="LITERAL">T</TT>隔开日期和时间。
给出的值是如同ISO 8601日期的数字。
</P><P>当用<TT CLASS="REPLACEABLE"><I>fields</I></TT>规范写一个时间间隔常数，或将一个字符串标记为用
<TT CLASS="REPLACEABLE"><I>fields</I></TT>规范定义的一个间隔列时，未标记单位的解释由<TT CLASS="REPLACEABLE"><I>fields</I></TT>
解释。如<TT CLASS="LITERAL">INTERVAL '1' YEAR</TT>读作1年，然而<TT CLASS="LITERAL">INTERVAL '1'</TT>代表1秒。
同样，<TT CLASS="REPLACEABLE"><I>fields</I></TT>规范中<SPAN CLASS="QUOTE">"最低"</SPAN>有效字段值规定会被静默的忽略。
如，<TT CLASS="LITERAL">INTERVAL '1 day 2:03:04' HOUR TO MINUTE</TT>会导致删除秒字段，而不是天字段。</P><P>根据<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准，间隔值的所有字段必须有相同的符号，因此前导负号可以用于所有字段；
如<TT CLASS="LITERAL">'-1 2:03:04'</TT>中负号同时应用于天和小时/分钟/秒。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
允许字段有不同的标记，并且传统上，文本表述中的每个字段会被认为是独立标记的，
因此在这个例子中的小时/分钟/秒被认为是正值。如果<TT CLASS="VARNAME">IntervalStyle</TT>被设置为
<TT CLASS="LITERAL">sql_standard</TT>，那么前导标记被认为是应用于所有字段的
（当然前提是没有再出现其他标记），否则会使用传统的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>解释。
为了避免这种歧义，如果任何字段是负的，建议为每个字段附上一个明确的标记。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>内部，<TT CLASS="TYPE">interval</TT>值被存储为月，日，秒的格式，
这是因为月中包含天数不同，并且如果进行了夏令时调整，那么一天可以有23或25小时。
当秒字段可以存储分数时，月和天字段可以是整数型。
由于时间间隔通常是由常量字符串或<TT CLASS="TYPE">timestamp</TT>减法来定义的，
这种存储方法在大多数情况下很有效。<CODE CLASS="FUNCTION">justify_days</CODE>和<CODE CLASS="FUNCTION">justify_hours</CODE>
函数可用于调整溢出正常范围值的天和小时。</P><P>在详细的输入格式，以及更紧凑的输入格式中，字段值可以有小数部分，
例如<TT CLASS="LITERAL">'1.5 week'</TT>或<TT CLASS="LITERAL">'01:02:03.45'</TT>。这种输入被转换成恰当的月，
天和秒来存储。由于这样会产生小数的月或天，因此在低阶字段中引入了分数，
使用1 month = 30 days 和 1 day = 24 hours的转换。例如，<TT CLASS="LITERAL">'1.5 month'</TT>
即1个月15天。输出中，只有秒可以写成分数形式。</P><P><A HREF="datatype-datetime.html#DATATYPE-INTERVAL-INPUT-EXAMPLES">&#34920; 8-17</A>中有一些有效的<TT CLASS="TYPE">interval</TT>输入的例子。</P><DIV CLASS="TABLE"><A NAME="DATATYPE-INTERVAL-INPUT-EXAMPLES"></A><P><B>&#34920; 8-17. 间隔输入</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>示例</TH><TH>说明</TH></TR></THEAD><TBODY><TR><TD>1-2</TD><TD>SQL标准格式：一年两个月</TD></TR><TR><TD>3 4:05:06</TD><TD>SQL标准格式：3天4小时5分6秒</TD></TR><TR><TD>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</TD><TD>传统Postgres格式: 1年2个月3天4小时5分钟6秒</TD></TR><TR><TD>P1Y2M3DT4H5M6S</TD><TD>ISO 8601 <SPAN CLASS="QUOTE">"带标识符格式"</SPAN>:与上面相同含义</TD></TR><TR><TD>P0001-02-03T04:05:06</TD><TD>ISO 8601 <SPAN CLASS="QUOTE">"缩写格式"</SPAN>:与上面相同含义</TD></TR></TBODY></TABLE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DATATYPE-INTERVAL-OUTPUT">8.5.5. 间隔输出</A></H2><P>间隔类型的输出格式可以用命令<TT CLASS="LITERAL">SET intervalstyle</TT>设置为下面四种类型：
<TT CLASS="LITERAL">sql_standard</TT>，<TT CLASS="LITERAL">postgres</TT>，<TT CLASS="LITERAL">postgres_verbose</TT>或
<TT CLASS="LITERAL">iso_8601</TT>。默认是<TT CLASS="LITERAL">postgres</TT>格式，
<A HREF="datatype-datetime.html#INTERVAL-STYLE-OUTPUT-TABLE">&#34920; 8-18</A>中有每种格式的示例。</P><P><TT CLASS="LITERAL">sql_standard</TT>格式产生的输出结果符合SQL的间隔字符串标准，
如果间隔值满足标准的限制（无论只有年-月，或只有天-时间，没有积极和消极的构成的混合）。
否则输出类似一个标准年-月文本字符串后跟有一个天-时间文本字符串，
带有添加明确标记的消除歧义混合信号的时间间隔。</P><P>当参数<A HREF="runtime-config-client.html#GUC-DATESTYLE">DateStyle</A>设置为<TT CLASS="LITERAL">ISO</TT>时，
<TT CLASS="LITERAL">postgres</TT>格式的输出与<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4之前的版本一致。</P><P>当参数<TT CLASS="VARNAME">DateStyle</TT>设置为非-<TT CLASS="LITERAL">ISO</TT>，
<TT CLASS="LITERAL">postgres_verbose</TT>格式的输出与<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4之前的版本一致。</P><P><TT CLASS="LITERAL">iso_8601</TT>格式的输出与ISO 8601标准4.4.3.2节中的<SPAN CLASS="QUOTE">"format with designators"</SPAN>一致。</P><DIV CLASS="TABLE"><A NAME="INTERVAL-STYLE-OUTPUT-TABLE"></A><P><B>&#34920; 8-18. 间隔输出格式示例</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>格式</TH><TH>年-月间隔</TH><TH>天-时间间隔</TH><TH>混合间隔</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">sql_standard</TT></TD><TD>1-2</TD><TD>3 4:05:06</TD><TD>-1-2 +3 -4:05:06</TD></TR><TR><TD><TT CLASS="LITERAL">postgres</TT></TD><TD>1 年 2 个月</TD><TD>3 天 04:05:06</TD><TD>-1 年 -2 个月 +3 天 -04:05:06</TD></TR><TR><TD><TT CLASS="LITERAL">postgres_verbose</TT></TD><TD>@ 1 年 2 个月</TD><TD>@ 3 天 4 小时 5 分 6 秒</TD><TD>@ 1 年 2 个月 -3 天 4 小时 5 分 6 秒以前</TD></TR><TR><TD><TT CLASS="LITERAL">iso_8601</TT></TD><TD>P1Y2M</TD><TD>P3DT4H5M6S</TD><TD>P-1Y-2M3DT-4H-5M-6S</TD></TR></TBODY></TABLE></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="datatype-binary.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="datatype-boolean.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">二进制数据类型</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">布尔类型</TD></TR></TABLE></DIV></BODY></HTML>
