<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>SQL转储</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="备份与恢复" HREF="http://school.yunwei.edu/manual/PostgreSQL/backup.html"><LINK REL="PREVIOUS" TITLE="备份与恢复" HREF="http://school.yunwei.edu/manual/PostgreSQL/backup.html"><LINK REL="NEXT" TITLE="文件系统级别备份" HREF="backup-file.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/backup.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="备份与恢复" HREF="http://school.yunwei.edu/manual/PostgreSQL/backup.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/backup.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 24. 备份与恢复</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="文件系统级别备份" HREF="backup-file.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="BACKUP-DUMP">24.1. <ACRONYM CLASS="ACRONYM">SQL</ACRONYM>转储</A></H1><P>
SQL转储的方法是创建一个文本文件，里面都是SQL命令，
当把这个文件回馈给服务器时，将重建与转储时状态一样的数据库。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>为这个用途提供了<A HREF="app-pgdump.html">pg_dump</A>工具。
这条命令的基本用法是：
</P><PRE CLASS="SYNOPSIS">pg_dump <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> &gt; <TT
CLASS="REPLACEABLE"
><I
>outfile</I
></TT
></PRE><P>
正如你所见，<SPAN CLASS="APPLICATION">pg_dump</SPAN>把结果输出到标准输出。
我们下面就可以看到这样做有什么好处。
</P><P> <SPAN CLASS="APPLICATION">pg_dump</SPAN>是一个普通的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
客户端应用(尽管是个相当聪明的东西)。
这就意味着你可以从任何可以访问该数据库的远端主机上面进行备份工作。
但是请记住<SPAN CLASS="APPLICATION">pg_dump</SPAN>不会以任何特殊权限运行。具体说来，
就是它必须要有你想备份的表的读权限，因此，
实际上你几乎总是要成为数据库超级用户。</P><P> 要声明<SPAN CLASS="APPLICATION">pg_dump</SPAN>应该以哪个用户身份进行连接，
使用命令行选项<TT CLASS="OPTION">-h<TT CLASS="REPLACEABLE"><I>host</I></TT></TT>和<TT CLASS="OPTION">-p <TT CLASS="REPLACEABLE"><I>port</I></TT></TT>。
缺省主机是本地主机或环境变量
<TT CLASS="ENVAR">PGPORT</TT>声明的值。类似的，缺省端口是环境变量<TT CLASS="ENVAR">PGPORT</TT>或
(如果它不存在的话)编译好了的缺省值。服务器通常都有相同的缺省，
所以还算方便。</P><P> 和任何其它<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>客户端应用一样，<SPAN CLASS="APPLICATION">pg_dump</SPAN>缺省时用
与当前操作系统用户名同名的数据库用户名进行连接。
要覆盖这个名字，要么声明<TT CLASS="OPTION">-U</TT>选项，
要么设置环境变量<TT CLASS="ENVAR">PGUSER</TT>。请注意<SPAN CLASS="APPLICATION">pg_dump</SPAN>
的连接也和普通客户应用一样要通过客户认证机制(在<A HREF="http://school.yunwei.edu/manual/PostgreSQL/client-authentication.html">第 19 &#31456;</A>里描述)。</P><P> <SPAN CLASS="APPLICATION">pg_dump</SPAN>超过后边描述的其它备份方法的一个重要优点
是<SPAN CLASS="APPLICATION">pg_dump</SPAN>的输出通常可以
重新载入<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>新版本，
然而文件级别备份和连续归档都因
服务器版本而异。<SPAN CLASS="APPLICATION">pg_dump</SPAN>是
将传输数据库到另一台机器体系结构工作时唯一的方法，
如从32位变到64位服务器。</P><P> 由<SPAN CLASS="APPLICATION">pg_dump</SPAN>创建的备份在内部是一致的，
也就是说，在<SPAN CLASS="APPLICATION">pg_dump</SPAN>运行的时候转储的是数据库的快照。
<SPAN CLASS="APPLICATION">pg_dump</SPAN>工作的时候并不阻塞其它的对数据库的操作
(但是会阻塞那些需要排它锁的操作，比如<TT CLASS="COMMAND">ALTER TABLE</TT>)。&#13;</P><DIV CLASS="IMPORTANT"><BLOCKQUOTE CLASS="IMPORTANT"><P><B>&#37325;&#35201;: </B> 如果你的数据库结构依赖于OID(比如说用做外键)，
那么你必须告诉<SPAN CLASS="APPLICATION">pg_dump</SPAN>把OID也导出来。要导出OID，
可以使用<TT CLASS="OPTION">-o</TT>命令行选项。&#13;</P></BLOCKQUOTE></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="BACKUP-DUMP-RESTORE">24.1.1. 从转储中恢复</A></H2><P>
</P><PRE CLASS="SYNOPSIS">psql <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> &lt; <TT
CLASS="REPLACEABLE"
><I
>infile</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>infile</I></TT>
就是通过<SPAN CLASS="APPLICATION">pg_dump</SPAN>命令的文件输出。
这条命令不会创建<TT CLASS="REPLACEABLE"><I>dbname</I></TT>数据库，
你必须在执行<SPAN CLASS="APPLICATION">psql</SPAN>前自己从
<TT CLASS="LITERAL">template0</TT>创建(也就是用<TT CLASS="LITERAL">createdb -T template0 <TT CLASS="REPLACEABLE"><I>dbname</I></TT></TT>命令)。
<SPAN CLASS="APPLICATION">psql</SPAN>支持类似<SPAN CLASS="APPLICATION">pg_dump</SPAN>的选项用以控制数据库服务器位置和用户名。
参阅<A HREF="app-psql.html"><SPAN CLASS="APPLICATION">psql</SPAN></A>的手册获取更多信息。
</P><P> 在开始运行恢复之前，目标库和所有在转储出来的库中拥有对象的用户，
以及曾经在某些对象上被赋予权限的用户都必须已经存在。如果这些不存在，
那么恢复将失败，因为恢复过程无法把这些对象恢复成原有的所有权和/或权限。
有时候你希望恢复权限，不过通常你不需要这么做。</P><P>
缺省时，<SPAN CLASS="APPLICATION">psql</SPAN>脚本将在遇到错误的时候仍然继续执行。
你可能希望运行带有<TT CLASS="LITERAL">ON_ERROR_STOP</TT>变量设置的
<SPAN CLASS="APPLICATION">psql</SPAN>以改变操作，并且如果发生SQL错误则带有
退出状态码3的<SPAN CLASS="APPLICATION">psql</SPAN>退出。
</P><PRE CLASS="PROGRAMLISTING">psql --set ON_ERROR_STOP=on dbname &lt; infile</PRE><P>
不管上述哪种方法都只能得到部分恢复了的数据库。另外，
你可以将整个恢复过程当成一个单独的事务，这样就能够保证要么全部恢复成功，
要么全部回滚。可以通过向<SPAN CLASS="APPLICATION">psql</SPAN>传递<TT CLASS="OPTION">-1</TT>或者<TT CLASS="OPTION">--single-transaction</TT>命令行
参数达到此目的。使用这个模式的时候即使一个很微小的错误也将导致已经运行
了好几个小时的恢复过程回滚。尽管如此，这种模式也比手动清除哪些不完整的
恢复数据强。
</P><P>
<SPAN CLASS="APPLICATION">pg_dump</SPAN>和<SPAN CLASS="APPLICATION">psql</SPAN>可以通过管道读写，
这样我们就可能从一台主机上将数据库目录转储到另一台主机上，比如：
</P><PRE CLASS="PROGRAMLISTING">pg_dump -h <TT
CLASS="REPLACEABLE"
><I
>host1</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> | psql -h <TT
CLASS="REPLACEABLE"
><I
>host2</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE><P>
</P><DIV CLASS="IMPORTANT"><BLOCKQUOTE CLASS="IMPORTANT"><P><B>&#37325;&#35201;: </B> <SPAN CLASS="APPLICATION">pg_dump</SPAN>生成的转储输出是相对于<TT CLASS="LITERAL">template0</TT>的。
这就意味着任何加入到<TT CLASS="LITERAL">template1</TT>的语言、
过程等都会经由<SPAN CLASS="APPLICATION">pg_dump</SPAN>转储。
这样在恢复的时候，如果你使用的是自定义的<TT CLASS="LITERAL">template1</TT>，
那么你必须从<TT CLASS="LITERAL">template0</TT>中创建空的数据库，
就像我们上面的例子那样。&#13;</P></BLOCKQUOTE></DIV><P> 一旦完成恢复，在每个数据库上运行<A HREF="sql-analyze.html">ANALYZE</A>是明智的举动，
这样优化器就有可用的统计数据了。
<A HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS">第 23.1.3 &#33410;</A>
和<A HREF="routine-vacuuming.html#AUTOVACUUM">第 23.1.6 &#33410;</A>获取更多信息。
关于如何有效加载海量数据到<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的更多信息，
参考<A HREF="populate.html">第 14.4 &#33410;</A>。&#13;</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="BACKUP-DUMP-ALL">24.1.2. 使用<SPAN CLASS="APPLICATION">pg_dumpall</SPAN></A></H2><P>
<SPAN CLASS="APPLICATION">pg_dump</SPAN>在一个时间只转储一个单独的数据库，
它不转储有关角色或表空间信息（因为这些是集群范围，而不是每个数据库）。
为了支持 方便转储整个数据库集群的全部内容。
因此我们提供了<A HREF="app-pg-dumpall.html"><SPAN CLASS="APPLICATION">pg_dumpall</SPAN></A>程序。
<SPAN CLASS="APPLICATION">pg_dumpall</SPAN>备份一个给出的集群中
的每个数据库，同时还确保保留像角色和表空间这样的全局数据状态。
这个命令的基本用法是：
</P><PRE CLASS="SYNOPSIS">pg_dumpall &gt; <TT
CLASS="REPLACEABLE"
><I
>outfile</I
></TT
></PRE><P>
生成的转储可以用<SPAN CLASS="APPLICATION">psql</SPAN>恢复：
</P><PRE CLASS="SYNOPSIS">psql -f <TT
CLASS="REPLACEABLE"
><I
>infile</I
></TT
> postgres</PRE><P>
实际上，你可以声明任意现有的数据库进行连接，
但是如果你是向一个空的数据库集群装载，
那么<TT CLASS="LITERAL">postgres</TT>应该是比较好的选择。
恢复<SPAN CLASS="APPLICATION">pg_dumpall</SPAN>的转储的时候通常需要数据库超级用户权限，
因为我们需要它来恢复角色和表空间信息。如果使用了表空间，
需要注意转储中的表空间路径必须适合新的安装。
</P><P> <SPAN CLASS="APPLICATION">pg_dumpall</SPAN>的工作原理是发射命令来重新创建角色，
表空间和空数据库，然后为每个数据库调用<SPAN CLASS="APPLICATION">pg_dump</SPAN>。
这意味着，虽然每个数据库内部一致， 但不同的数据库快照可能不是恰好同步。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="BACKUP-DUMP-LARGE">24.1.3. 处理大数据库</A></H2><P> 当创建大的<SPAN CLASS="APPLICATION">pg_dump</SPAN>输出文件时，
限制产生问题的一些操作系统允许最大文件大小。
因为<SPAN CLASS="APPLICATION">pg_dump</SPAN>输出到标准输出，
你可以用标准的Unix工具绕开这个问题：有一些可能的方法：</P><DIV CLASS="FORMALPARA"><P><B>使用压缩转储. </B>
使用你熟悉的压缩程序(比如<SPAN CLASS="APPLICATION">gzip</SPAN>)：
</P><PRE CLASS="PROGRAMLISTING">pg_dump <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> | gzip &gt; <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.gz</PRE><P>
使用下面命令恢复：
</P><PRE CLASS="PROGRAMLISTING">gunzip -c <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.gz | psql <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE><P>
或者：
</P><PRE CLASS="PROGRAMLISTING">cat <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.gz | gunzip | psql <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE><P>
</P></DIV><DIV CLASS="FORMALPARA"><P><B>使用<TT CLASS="COMMAND">split</TT>. </B>
<TT CLASS="COMMAND">split</TT>允许用下面的方法把输出分解成操作系统可以接受的大小。
比如，让每个块大小为1MB：
</P><PRE CLASS="PROGRAMLISTING">pg_dump <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> | split -b 1m - <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></PRE><P>
用下面命令恢复：
</P><PRE CLASS="PROGRAMLISTING">cat <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>* | psql <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE><P>
</P></DIV><DIV CLASS="FORMALPARA"><P><B>使用<SPAN CLASS="APPLICATION">pg_dump</SPAN>自定义转储格式. </B>
如果<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>是在一个安装了<SPAN CLASS="APPLICATION">zlib</SPAN>
压缩库的系统上制作的，
那么自定义转储格式将在写入输出文件的时候压缩数据。
它会生成和使用<TT CLASS="COMMAND">gzip</TT>类似大小的转储文件，但是还附加了一个优点：
你可以有选择地恢复库中的表。下面的命令用自定义转储格式转储一个数据库：
</P><PRE CLASS="PROGRAMLISTING">pg_dump -Fc <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> &gt; <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></PRE><P>
自定义格式的转储不是脚本，不能用于<SPAN CLASS="APPLICATION">psql</SPAN>，而是需要使用<SPAN CLASS="APPLICATION">pg_restore</SPAN>转储。
比如：
</P><PRE CLASS="PROGRAMLISTING">pg_restore -d <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></PRE><P>
请参阅<A HREF="app-pgdump.html">pg_dump</A>和<A HREF="app-pgrestore.html">pg_restore</A>手册获取细节。
</P></DIV><P> 对于非常大的数据库，你可能需要结合<TT CLASS="COMMAND">split</TT>以及其他两种方法之一。</P><DIV CLASS="FORMALPARA"><P><B>使用<SPAN CLASS="APPLICATION">pg_dump</SPAN>的并行转储功能. </B>
为了加快大数据库的转储，你可以使用<SPAN CLASS="APPLICATION">pg_dump</SPAN>并行模式。
这将同时转储多个表。你可以使用<TT CLASS="COMMAND">-j</TT>参数控制并行性程度。
并行转储只支持"目录"归档模式。
</P><PRE CLASS="PROGRAMLISTING">pg_dump -j <TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> -F d -f <TT
CLASS="REPLACEABLE"
><I
>out.dir</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE><P>
你可以使用<TT CLASS="COMMAND">pg_restore -j</TT>并行地恢复转储。这对于任何"自定义"或者
"目录"格式的备份文件都是有效的，不管该文件是否是使用<TT CLASS="COMMAND">pg_dump -j</TT>创建的。
</P></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/backup.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="backup-file.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">备份与恢复</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/backup.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">文件系统级别备份</TD></TR></TABLE></DIV></BODY></HTML>
