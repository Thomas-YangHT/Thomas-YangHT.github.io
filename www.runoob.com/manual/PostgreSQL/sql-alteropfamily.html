<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>ALTER OPERATOR FAMILY</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="ALTER OPERATOR CLASS" HREF="sql-alteropclass.html"><LINK REL="NEXT" TITLE="ALTER ROLE" HREF="sql-alterrole.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/alter_opfamily.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="ALTER OPERATOR CLASS" HREF="sql-alteropclass.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="ALTER ROLE" HREF="sql-alterrole.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-ALTEROPFAMILY"></A>ALTER OPERATOR FAMILY</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN65704"></A><H2>&#21517;&#31216;</H2>ALTER OPERATOR FAMILY&nbsp;--&nbsp;修改操作符族的定义</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN65709"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">ALTER OPERATOR FAMILY <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> USING <TT
CLASS="REPLACEABLE"
><I
>index_method</I
></TT
> ADD
  {  OPERATOR <TT
CLASS="REPLACEABLE"
><I
>strategy_number</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator_name</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> ) [ FOR SEARCH | FOR ORDER BY <TT
CLASS="REPLACEABLE"
><I
>sort_family_name</I
></TT
> ]
   | FUNCTION <TT
CLASS="REPLACEABLE"
><I
>support_number</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> [ , <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> ] ) ] <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>argument_type</I
></TT
> [, ...] )
  } [, ... ]
ALTER OPERATOR FAMILY <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> USING <TT
CLASS="REPLACEABLE"
><I
>index_method</I
></TT
> DROP
  {  OPERATOR <TT
CLASS="REPLACEABLE"
><I
>strategy_number</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> [ , <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> ] )
   | FUNCTION <TT
CLASS="REPLACEABLE"
><I
>support_number</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> [ , <TT
CLASS="REPLACEABLE"
><I
>op_type</I
></TT
> ] )
  } [, ... ]
ALTER OPERATOR FAMILY <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> USING <TT
CLASS="REPLACEABLE"
><I
>index_method</I
></TT
> RENAME TO <TT
CLASS="REPLACEABLE"
><I
>new_name</I
></TT
>
ALTER OPERATOR FAMILY <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> USING <TT
CLASS="REPLACEABLE"
><I
>index_method</I
></TT
> OWNER TO <TT
CLASS="REPLACEABLE"
><I
>new_owner</I
></TT
>
ALTER OPERATOR FAMILY <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> USING <TT
CLASS="REPLACEABLE"
><I
>index_method</I
></TT
> SET SCHEMA <TT
CLASS="REPLACEABLE"
><I
>new_schema</I
></TT
></PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN65740"></A><H2>描述</H2><P><TT CLASS="COMMAND">ALTER OPERATOR FAMILY</TT>修改一个操作符族的定义。
你可以添加操作符和支持函数到该族、从该族中删除它们或修改该族的名字或所有者。</P><P>当使用<TT CLASS="COMMAND">ALTER OPERATOR FAMILY</TT>添加操作符和支持函数到一个族时，
它们不是该操作符族中任意指定操作符类的一部分，只是<SPAN CLASS="QUOTE">"松散"</SPAN>在该族中。
这表明这些操作符和函数与该族的语义兼容，但不是正确运行任何指定索引的所需。
（操作符和函数要成为索引的所需，应该被声明为一个操作符类的一部分；参阅
<A HREF="sql-createopclass.html">CREATE OPERATOR CLASS</A>。）<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
将允许一个族的松散成员在任何时候被从该族中删除，但是操作符类的成员不能被删除，
除非删除整个类和任何依赖于它的索引。典型的，单数据类型操作符和函数是操作符类的一部分，
因为需要它们支持一个特定数据类型的索引，而交叉数据类型操作符和函数由族的松散成员组成。</P><P>要使用<TT CLASS="COMMAND">ALTER OPERATOR FAMILY</TT>，你必须是一个超级用户。
（做这个限制是因为一个错误的操作符族定义会混淆或者甚至崩溃服务器。）</P><P><TT CLASS="COMMAND">ALTER OPERATOR FAMILY</TT>
目前并不检查操作符族定义是否包括索引方法所需的所有操作符和函数，
也不检查操作符和函数是否来自一个自相一致的集合。定义一个有效的操作符族是用户的责任。</P><P>参阅<A HREF="xindex.html">第 35.14 &#33410;</A>获取更多信息。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN65755"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>name</I></TT></DT><DD><P>一个现有操作符族的名字（可以有模式修饰）。</P></DD><DT><TT CLASS="REPLACEABLE"><I>index_method</I></TT></DT><DD><P>使用这个操作符族的索引方法的名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>strategy_number</I></TT></DT><DD><P>该索引方法的与该操作符族相关的一个操作符的策略数。</P></DD><DT><TT CLASS="REPLACEABLE"><I>operator_name</I></TT></DT><DD><P>与该操作符族相关的一个操作符的名字（可以有模式修饰）。</P></DD><DT><TT CLASS="REPLACEABLE"><I>op_type</I></TT></DT><DD><P>在一个<TT CLASS="LITERAL">OPERATOR</TT>子句中，该操作符的操作数的数据类型或<TT CLASS="LITERAL">NONE</TT>
表示一个左目或右目操作符。不像<TT CLASS="COMMAND">CREATE OPERATOR CLASS</TT>
中可比较的语法，必须总是指定操作数的数据类型。</P><P>在一个<TT CLASS="LITERAL">ADD FUNCTION</TT>子句中，函数的操作数的数据类型如果与该函数的输入数据类型不同，
则打算支持操作数的数据类型。对于B-tree比较函数和哈希函数，不需要指定
<TT CLASS="REPLACEABLE"><I>op_type</I></TT>，
因为函数的输入数据类型总是要使用的正确类型。对于B-tree排序支持函数和所有在GiST、
SP-GiST和GIN操作符类中的函数，必须指定该函数要使用的操作数的数据类型。</P><P>在<TT CLASS="LITERAL">DROP FUNCTION</TT>子句中，打算支持的函数的操作数的数据类型必须指定。</P></DD><DT><TT CLASS="REPLACEABLE"><I>sort_family_name</I></TT></DT><DD><P>描述与一个排序操作符相关的排序顺序的现有<TT CLASS="LITERAL">btree</TT>操作符族的名字
（可以有模式修饰）。</P><P>如果既没有指定<TT CLASS="LITERAL">FOR SEARCH</TT>也没有指定<TT CLASS="LITERAL">FOR ORDER BY</TT>，
那么<TT CLASS="LITERAL">FOR SEARCH</TT>是缺省。</P></DD><DT><TT CLASS="REPLACEABLE"><I>support_number</I></TT></DT><DD><P>与该操作符族相关的一个函数的索引方法的支持过程数量。</P></DD><DT><TT CLASS="REPLACEABLE"><I>function_name</I></TT></DT><DD><P>该操作符族的索引方法支持过程的函数的名字（可以有模式修饰）。</P></DD><DT><TT CLASS="REPLACEABLE"><I>argument_type</I></TT></DT><DD><P>该函数的参数数据类型。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_name</I></TT></DT><DD><P>操作符族的新名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_owner</I></TT></DT><DD><P>操作符族的新所有者。</P></DD><DT><TT CLASS="REPLACEABLE"><I>new_schema</I></TT></DT><DD><P>操作符族的新模式。</P></DD></DL></DIV><P><TT CLASS="LITERAL">OPERATOR</TT>和<TT CLASS="LITERAL">FUNCTION</TT>子句可以以任意顺序出现。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN65834"></A><H2>注意</H2><P>请注意，<TT CLASS="LITERAL">DROP</TT>语法只指定了操作符族中的<SPAN CLASS="QUOTE">"位置"</SPAN>，
通过策略或支持数和输入数据类型。占领该位置的操作符或函数的名字没有提及。
另外，对于<TT CLASS="LITERAL">DROP FUNCTION</TT>来说，要指定的类型是该函数打算支持的输入数据类型；
对于GiST、SP-GiST和GIN索引来说，可能与该函数的实际输入参数类型无关。</P><P>因为索引机制在使用函数之前并不检查函数上的访问权限，
包括一个操作符族中的函数或操作符相当于赋予了公共执行权限。
这对于操作符族中有用的函数的种类通常不是一个问题。</P><P>操作符不应该通过SQL函数定义。一个SQL函数可以内联到调用查询，
这将阻止优化器认识到该查询匹配一个索引。</P><P>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4之前，<TT CLASS="LITERAL">OPERATOR</TT>子句
会包括一个<TT CLASS="LITERAL">RECHECK</TT>选项。现在不再支持这个了，因为一个索引操作符是否是
<SPAN CLASS="QUOTE">"松散的"</SPAN>决定了运行时的动态。这允许有效的处理操作符可能或可能不是松散的的情况。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN65847"></A><H2>例子</H2><P>下列的示例命令添加了跨数据类型的操作符和支持函数到一个操作符族，
该操作符族早已包含数据类型<TT CLASS="TYPE">int4</TT>和<TT CLASS="TYPE">int2</TT>的B-tree操作符类。</P><PRE CLASS="PROGRAMLISTING">ALTER OPERATOR FAMILY integer_ops USING btree ADD

  -- int4 vs int2
  OPERATOR 1 &lt; (int4, int2) ,
  OPERATOR 2 &lt;= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 &gt;= (int4, int2) ,
  OPERATOR 5 &gt; (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- int2 vs int4
  OPERATOR 1 &lt; (int2, int4) ,
  OPERATOR 2 &lt;= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 &gt;= (int2, int4) ,
  OPERATOR 5 &gt; (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;</PRE><P>再次删除这些条目：</P><PRE CLASS="PROGRAMLISTING">ALTER OPERATOR FAMILY integer_ops USING btree DROP

  -- int4 vs int2
  OPERATOR 1 (int4, int2) ,
  OPERATOR 2 (int4, int2) ,
  OPERATOR 3 (int4, int2) ,
  OPERATOR 4 (int4, int2) ,
  OPERATOR 5 (int4, int2) ,
  FUNCTION 1 (int4, int2) ,

  -- int2 vs int4
  OPERATOR 1 (int2, int4) ,
  OPERATOR 2 (int2, int4) ,
  OPERATOR 3 (int2, int4) ,
  OPERATOR 4 (int2, int4) ,
  OPERATOR 5 (int2, int4) ,
  FUNCTION 1 (int2, int4) ;</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN65855"></A><H2>兼容性</H2><P>SQL标准中没有<TT CLASS="COMMAND">ALTER OPERATOR FAMILY</TT>语句。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN65859"></A><H2>又见</H2><A HREF="sql-createopfamily.html">CREATE OPERATOR FAMILY</A>, <A HREF="sql-dropopfamily.html">DROP OPERATOR FAMILY</A>, <A HREF="sql-createopclass.html">CREATE OPERATOR CLASS</A>, <A HREF="sql-alteropclass.html">ALTER OPERATOR CLASS</A>, <A HREF="sql-dropopclass.html">DROP OPERATOR CLASS</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-alteropclass.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-alterrole.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">ALTER OPERATOR CLASS</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">ALTER ROLE</TD></TR></TABLE></DIV></BODY></HTML>
