<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>报告服务器里的错误</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PostgreSQL 编码约定" HREF="http://school.yunwei.edu/manual/PostgreSQL/source.html"><LINK REL="PREVIOUS" TITLE="格式" HREF="source-format.html"><LINK REL="NEXT" TITLE="错误消息风格指导" HREF="error-style-guide.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/sources.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="格式" HREF="source-format.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/source.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 49. PostgreSQL 编码约定</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="错误消息风格指导" HREF="error-style-guide.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="ERROR-MESSAGE-REPORTING">49.2. 报告服务器里的错误</A></H1><P>在服务器代码里生成的错误、警告以及日志信息应该用<CODE CLASS="FUNCTION">ereport</CODE>
或者它的兄弟<CODE CLASS="FUNCTION">elog</CODE>创建。这个函数的使用已经复杂得需要做些解释了。</P><P>每条消息都有两个必须的要素：一个严重级别(范围从<TT CLASS="LITERAL">DEBUG</TT>到
<TT CLASS="LITERAL">PANIC</TT>)和一个主要消息文本。除此之外还有可选的元素，
最常见的就是一个遵循 SQL 标准的 SQLSTATE 习惯的错误标识码。
<CODE CLASS="FUNCTION">ereport</CODE>本身只是一个壳函数，
它的存在主要是为了便于让消息生成看起来像 C 代码里的函数调用。
<CODE CLASS="FUNCTION">ereport</CODE>直接接受的唯一参数是严重级别。
主消息文本和任何附加消息元素都是通过在<CODE CLASS="FUNCTION">ereport</CODE>
调用里调用辅助函数(比如<CODE CLASS="FUNCTION">errmsg</CODE>)生成的。</P><P>典型的调用<CODE CLASS="FUNCTION">ereport</CODE>的方式看起来可能像下面这样：
</P><PRE CLASS="PROGRAMLISTING">ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));</PRE><P>
这样就声明了错误严重级别<TT CLASS="LITERAL">ERROR</TT>(一个普通错误)。
<CODE CLASS="FUNCTION">errcode</CODE>调用指定一个在<TT CLASS="FILENAME">src/include/utils/errcodes.h</TT>
里面使用宏定义的SQLSTATE错误代码。<CODE CLASS="FUNCTION">errmsg</CODE>调用提供主要的消息文本。
请注意包围在辅助函数调用周围的额外的圆括弧&mdash;这么做虽然烦人，
但是语法上是必须的。</P><P>然后是一个更复杂的例子：
</P><PRE CLASS="PROGRAMLISTING">ereport(ERROR,
        (errcode(ERRCODE_AMBIGUOUS_FUNCTION),
         errmsg("function %s is not unique",
                func_signature_string(funcname, nargs,
                                      NIL, actual_arg_types)),
         errhint("Unable to choose a best candidate function. "
                 "You might need to add explicit typecasts.")));</PRE><P>
这个例子演示了使用格式化代码把运行时数值嵌入一个消息文本的用法。
同样，还提供了一个可选的<SPAN CLASS="QUOTE">"暗示"</SPAN>信息。
</P><P><CODE CLASS="FUNCTION">ereport</CODE>可用的附属过程有：
<P></P></P><UL><LI><P><CODE CLASS="FUNCTION">errcode(sqlerrcode)</CODE>为该条件声明 SQLSTATE 错误标识符代码。
如果没有调用这个过程，并且错误严重级别是<TT CLASS="LITERAL">ERROR</TT>或更高，
那么错误标识符缺省是<TT CLASS="LITERAL">ERRCODE_INTERNAL_ERROR</TT>，
如果错误严重级别是<TT CLASS="LITERAL">WARNING</TT>则为<TT CLASS="LITERAL">ERRCODE_WARNING</TT>，
否则(用于<TT CLASS="LITERAL">NOTICE</TT>或者更低级别)为<TT CLASS="LITERAL">ERRCODE_SUCCESSFUL_COMPLETION</TT>。
虽然这些缺省都很方便，但是最好还是在省略<CODE CLASS="FUNCTION">errcode()</CODE>调用之前三思。</P></LI><LI><P><CODE CLASS="FUNCTION">errmsg(const char *msg, ...)</CODE>声明主错误消息文本，
以及可能的插入其中的运行时数值。插入是使用<CODE CLASS="FUNCTION">sprintf</CODE>
风格的格式代码插入的。除了<CODE CLASS="FUNCTION">sprintf</CODE>接受的标准格式代码，
还接受<TT CLASS="LITERAL">%m</TT>用于插入<CODE CLASS="FUNCTION">strerror</CODE>为当前<TT CLASS="LITERAL">errno</TT>
值返回的错误信息。
<A NAME="AEN100421" HREF="error-message-reporting.html#FTN.AEN100421"><SPAN CLASS="footnote">[1]</SPAN></A>
<TT CLASS="LITERAL">%m</TT>并不要求在<CODE CLASS="FUNCTION">errmsg</CODE>的参数列表里有任何对应的项目。
请注意这个消息字符串在格式代码得到处理之前将不会通过<CODE CLASS="FUNCTION">gettext</CODE>
运行获取合适的本地化。
</P></LI><LI><P><CODE CLASS="FUNCTION">errmsg_internal(const char *msg, ...)</CODE>和<CODE CLASS="FUNCTION">errmsg</CODE>
一样，只是消息字符串将不会包含在国际化消息字典里。这个函数应该用于
<SPAN CLASS="QUOTE">"不可能发生"</SPAN>的情况，也就是不值得展开进行翻译的场合。</P></LI><LI><P><CODE CLASS="FUNCTION">errmsg_plural(const char *fmt_singular, const char *fmt_plural,
unsigned long n, ...)</CODE>就像是<CODE CLASS="FUNCTION">errmsg</CODE>，
但是支持消息的各种复数形式。<TT CLASS="REPLACEABLE"><I>fmt_singular</I></TT>是英语单数形式，
<TT CLASS="REPLACEABLE"><I>fmt_plural</I></TT>是英语复数形式，<TT CLASS="REPLACEABLE"><I>n</I></TT>
是决定使用哪个复数形式的整数值，剩余的参数根据选择的格式字符串进行格式化。
更多信息请查看<A HREF="nls-programmer.html#NLS-GUIDELINES">第 50.2.2 &#33410;</A>。</P></LI><LI><P><CODE CLASS="FUNCTION">errdetail(const char *msg, ...)</CODE>提供一个可选的<SPAN CLASS="QUOTE">"详细"</SPAN>信息；
在存在额外的信息，并且很适合放在主消息里面的时候使用这个函数。
消息字符串处理的方法和<CODE CLASS="FUNCTION">errmsg</CODE>完全一样。</P></LI><LI><P><CODE CLASS="FUNCTION">errdetail_internal(const char *msg, ...)</CODE>和<CODE CLASS="FUNCTION">errdetail</CODE>一样，
只是消息字符串将不会包含在国际化消息字典里。这个函数应该用于不值得展开进行翻译的详细消息，
比如，因为它们太技术了以至于对大多数用户来说无用。</P></LI><LI><P><CODE CLASS="FUNCTION">errdetail_plural(const char *fmt_singular, const char *fmt_plural,
unsigned long n, ...)</CODE>类似于<CODE CLASS="FUNCTION">errdetail</CODE>，
但是支持消息的各种复数形式。更多信息请查阅<A HREF="nls-programmer.html#NLS-GUIDELINES">第 50.2.2 &#33410;</A>。</P></LI><LI><P><CODE CLASS="FUNCTION">errdetail_log(const char *msg, ...)</CODE>和
<CODE CLASS="FUNCTION">errdetail</CODE> 一样，除了这个字符串只到服务器日志，从不到客户端。
如果<CODE CLASS="FUNCTION">errdetail</CODE>（或它的以上相同的其中之一）和<CODE CLASS="FUNCTION">errdetail_log</CODE>
都使用了，那么一个字符串到客户端，另一个到服务器日志。
这对于过于安全敏感或太大而不能包含进发送到客户端的报告中的错误细节来说是有用的。</P></LI><LI><P><CODE CLASS="FUNCTION">errhint(const char *msg, ...)</CODE>提供一个可选的<SPAN CLASS="QUOTE">"暗示"</SPAN>消息；
这个函数用于提供如何修补问题的建议，而不是提供错误的事实。
消息字符串处理的方式和<CODE CLASS="FUNCTION">errmsg</CODE>一样。</P></LI><LI><P><CODE CLASS="FUNCTION">errcontext(const char *msg, ...)</CODE>通常不会直接从<CODE CLASS="FUNCTION">ereport</CODE>
消息点里直接调用；而是用在<TT CLASS="LITERAL">error_context_stack</TT>
回调函数里提供有关错误发生的环境的信息，比如，当前的位置是在一个 PL 函数里等等。
消息字符串的处理和<CODE CLASS="FUNCTION">errmsg</CODE>完全一样。和其它辅助函数不同，
这个函数在一次<CODE CLASS="FUNCTION">ereport</CODE>调用里可以调用多次；
随后的调用生成的字符串将带着各自的换行符连接在原来的字符串上。</P></LI><LI><P><CODE CLASS="FUNCTION">errposition(int cursorpos)</CODE>声明一个错误在查询字符串里的文本位置。
目前它只是在报告查询处理过程中的词法和语法分析阶段检测到的错误有用。</P></LI><LI><P><CODE CLASS="FUNCTION">errtable(Relation rel)</CODE>指定一个关系，
关系名和模式名应该作为辅助字段包含在错误报告内。</P></LI><LI><P><CODE CLASS="FUNCTION">errtablecol(Relation rel, int attnum)</CODE>指定一个字段，
该字段的名字、表名和模式名应该作为辅助字段包含在错误报告中。</P></LI><LI><P><CODE CLASS="FUNCTION">errtableconstraint(Relation rel, const char *conname)</CODE>
指定一个表约束，该表约束的名字、表名和模式名应该作为辅助字段包含在错误报告中。
不管它们是否有一个相关的<TT CLASS="STRUCTNAME">pg_constraint</TT>项，索引都应该被认为是约束。
小心地传递底层堆关系，不只是索引本身，作为<TT CLASS="LITERAL">rel</TT>。</P></LI><LI><P><CODE CLASS="FUNCTION">errdatatype(Oid datatypeOid)</CODE>指定一个数据类型，
它的名字和模式名应该作为辅助字段包含在错误报告中。</P></LI><LI><P><CODE CLASS="FUNCTION">errdomainconstraint(Oid datatypeOid, const char *conname)</CODE>
指定一个域约束，该域约束的名字、域名和模式名应该作为附属字段包含在错误报告中。</P></LI><LI><P><CODE CLASS="FUNCTION">errcode_for_file_access()</CODE>是一个便利函数，
它可以为一个文件访问类的系统调用选择一个合适的 SQLSTATE 错误标识符。
它利用保存下来的<TT CLASS="LITERAL">errno</TT>判断生成哪个错误代码。
通常它应该和主错误消息文本里的<TT CLASS="LITERAL">%m</TT>结合使用。</P></LI><LI><P><CODE CLASS="FUNCTION">errcode_for_socket_access()</CODE>是一个便利函数，
它可以为一个套接字相关的系统调用选择一个合适的 SQLSTATE 错误标识符。</P></LI><LI><P><CODE CLASS="FUNCTION">errhidestmt(bool hide_stmt)</CODE>可以用来在主日志中指定消息的
<TT CLASS="LITERAL">STATEMENT:</TT>部分的消除。如果消息文本早已包括当前语句，
那么这通常是合适的。</P></LI></UL><P>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><CODE CLASS="FUNCTION">errtable</CODE>、<CODE CLASS="FUNCTION">errtablecol</CODE>、<CODE CLASS="FUNCTION">errtableconstraint</CODE>、
<CODE CLASS="FUNCTION">errdatatype</CODE>或<CODE CLASS="FUNCTION">errdomainconstraint</CODE>
中最多只有一个函数应该用在一个<CODE CLASS="FUNCTION">ereport</CODE>调用中。
这些函数的存在允许应用提取与没有检测潜在本地化错误消息文本的错误条件相关的数据库对象的名字。
这些函数应该用在应用希望自动错误处理的错误报告中。自<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.3起，
完全覆盖只是为了SQLSTATE class 23中的错误而存在（违反完整约束），
但是有可能会在未来扩展。</P></BLOCKQUOTE></DIV><P>还有一个老一些的<CODE CLASS="FUNCTION">elog</CODE>函数，仍然在频繁使用。一个<CODE CLASS="FUNCTION">elog</CODE>调用：
</P><PRE CLASS="PROGRAMLISTING">elog(level, "format string", ...);</PRE><P>
完全等效于：
</P><PRE CLASS="PROGRAMLISTING">ereport(level, (errmsg_internal("format string", ...)));</PRE><P>
请注意 SQLSTATE 错误代码总是缺省的，并且消息字符串并没有翻译。因此，
<CODE CLASS="FUNCTION">elog</CODE>应该只用于内部错误以及低层的调试日志。
任何普通用户感兴趣的消息都应该通过<CODE CLASS="FUNCTION">ereport</CODE>生成。当然，
还有大量内部的<SPAN CLASS="QUOTE">"不可能发生"</SPAN>的错误检查使用<CODE CLASS="FUNCTION">elog</CODE>；
因为这些信息最好还是表示得简单些好。
</P><P>书写好的错误消息的建议可以在<A HREF="error-style-guide.html">第 49.3 &#33410;</A>找到。</P></DIV><H3 CLASS="FOOTNOTES">&#22791;&#27880;</H3><TABLE BORDER="0" CLASS="FOOTNOTES" WIDTH="100%"><TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="5%"><A NAME="FTN.AEN100421" HREF="error-message-reporting.html#AEN100421"><SPAN CLASS="footnote">[1]</SPAN></A></TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95%"><P>也就是说，在到达<CODE CLASS="FUNCTION">ereport</CODE>调用的时候当前的数值；
在附属报告过程里对<TT CLASS="LITERAL">errno</TT>的修改将不会影响他。但是如果你在
<CODE CLASS="FUNCTION">errmsg</CODE>的参数列表里明确地写<TT CLASS="LITERAL">strerror(errno)</TT>，
这一点就不能保证了，因此，请不要这么做。</P></TD></TR></TABLE><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="source-format.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="error-style-guide.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">格式</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/source.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">错误消息风格指导</TD></TR></TABLE></DIV></BODY></HTML>
