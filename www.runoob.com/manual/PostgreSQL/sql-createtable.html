<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>CREATE TABLE</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="CREATE SERVER" HREF="sql-createserver.html"><LINK REL="NEXT" TITLE="CREATE TABLE AS" HREF="sql-createtableas.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/create_table.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="CREATE SERVER" HREF="sql-createserver.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="CREATE TABLE AS" HREF="sql-createtableas.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-CREATETABLE"></A>CREATE TABLE</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN72329"></A><H2>&#21517;&#31216;</H2>CREATE TABLE&nbsp;--&nbsp;定义一个新表</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN72334"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> ( [
  { <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>column_constraint</I
></TT
> [ ... ] ]
    | <TT
CLASS="REPLACEABLE"
><I
>table_constraint</I
></TT
>
    | LIKE <TT
CLASS="REPLACEABLE"
><I
>source_table</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>like_option</I
></TT
> ... ] }
    [, ... ]
] )
[ INHERITS ( <TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
> [, ... ] ) ]
[ WITH ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>tablespace_name</I
></TT
> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>
    OF <TT
CLASS="REPLACEABLE"
><I
>type_name</I
></TT
> [ (
  { <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> WITH OPTIONS [ <TT
CLASS="REPLACEABLE"
><I
>column_constraint</I
></TT
> [ ... ] ]
    | <TT
CLASS="REPLACEABLE"
><I
>table_constraint</I
></TT
> }
    [, ... ]
) ]
[ WITH ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>tablespace_name</I
></TT
> ]

 <SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>这里的<TT
CLASS="REPLACEABLE"
><I
>column_constraint</I
></TT
>是:</SPAN
></SPAN
>

[ CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> ]
{ NOT NULL |
  NULL |
  CHECK ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ) [ NO INHERIT ] |
  DEFAULT <TT
CLASS="REPLACEABLE"
><I
>default_expr</I
></TT
> |
  UNIQUE <TT
CLASS="REPLACEABLE"
><I
>index_parameters</I
></TT
> |
  PRIMARY KEY <TT
CLASS="REPLACEABLE"
><I
>index_parameters</I
></TT
> |
  REFERENCES <TT
CLASS="REPLACEABLE"
><I
>reftable</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>refcolumn</I
></TT
> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
> ] [ ON UPDATE <TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

 <SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>而<TT
CLASS="REPLACEABLE"
><I
>table_constraint</I
></TT
>是:</SPAN
></SPAN
>

[ CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> ]
{ CHECK ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ) [ NO INHERIT ] |
  UNIQUE ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ... ] ) <TT
CLASS="REPLACEABLE"
><I
>index_parameters</I
></TT
> |
  PRIMARY KEY ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ... ] ) <TT
CLASS="REPLACEABLE"
><I
>index_parameters</I
></TT
> |
  EXCLUDE [ USING <TT
CLASS="REPLACEABLE"
><I
>index_method</I
></TT
> ] ( <TT
CLASS="REPLACEABLE"
><I
>exclude_element</I
></TT
> WITH <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> [, ... ] ) <TT
CLASS="REPLACEABLE"
><I
>index_parameters</I
></TT
> [ WHERE ( <TT
CLASS="REPLACEABLE"
><I
>predicate</I
></TT
> ) ] |
  FOREIGN KEY ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ... ] ) REFERENCES <TT
CLASS="REPLACEABLE"
><I
>reftable</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>refcolumn</I
></TT
> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
> ] [ ON UPDATE <TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

 <SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
><TT
CLASS="REPLACEABLE"
><I
>like_option</I
></TT
>是:</SPAN
></SPAN
>

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }

 <SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>在<TT
CLASS="LITERAL"
>UNIQUE</TT
>、<TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>和
 <TT
CLASS="LITERAL"
>EXCLUDE</TT
>约束中的<TT
CLASS="REPLACEABLE"
><I
>index_parameters</I
></TT
>是:</SPAN
></SPAN
>

[ WITH ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>] [, ... ] ) ]
[ USING INDEX TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>tablespace_name</I
></TT
> ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
><TT
CLASS="REPLACEABLE"
><I
>exclude_element</I
></TT
> in an <TT
CLASS="LITERAL"
>EXCLUDE</TT
> constraint is:</SPAN
></SPAN
>

{ <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ) } [ <TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="SQL-CREATETABLE-DESCRIPTION"></A><H2>描述</H2><P><TT CLASS="COMMAND">CREATE TABLE</TT>在当前数据库创建一个新的空白表。
该表将由发出此命令的用户所拥有。</P><P>如果给出了模式名(比如<TT CLASS="LITERAL">CREATE TABLE myschema.mytable ...</TT>)，
那么在指定的模式中创建表，否则在当前模式中创建。临时表存在于一个特殊的模式里，
因此创建临时表的时候不能指定模式名。表名字必需在同一模式中的其它表、
序列、索引、视图或外部表名字中唯一。</P><P><TT CLASS="COMMAND">CREATE TABLE</TT>还自动创建一个与该表的行对应的复合数据类型。
因此，表不能和同模式中的现有数据类型同名。</P><P>可选的约束子句声明约束，新行或者更新的行必须满足这些约束才能成功插入或更新。
约束是一个 SQL 对象，它以多种方式协助在表上定义有效数值的集合。</P><P>定义约束有两种方法：表约束和列约束。列约束是作为一个列定义的一部分定义的。
而表约束并不和某个列绑在一起，它可以作用于多个列上。每个列约束也可以写成表约束；
如果某个约束只影响一个列，那么列约束只是符号上的简洁方式而已。</P><P>要能创建一个表，你必须分别在所有列类型或<TT CLASS="LITERAL">OF</TT>
子句的类型上有<TT CLASS="LITERAL">USAGE</TT>权限。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72414"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">TEMPORARY</TT> 或 <TT CLASS="LITERAL">TEMP</TT></DT><DD><P>如果声明了，则创建为临时表。临时表在会话结束或(可选)当前事务的结尾
(参阅下面的<TT CLASS="LITERAL">ON COMMIT</TT>)自动删除。除非用模式修饰的名字引用，
否则现有的同名永久表在临时表存在期间，在本会话过程中是不可见的。
任何在临时表上创建的索引也都会被自动删除。</P><P><A HREF="routine-vacuuming.html#AUTOVACUUM">自动清理进程</A>不能访问，因此不能清理或分析临时表。
由于这个原因，适当的清理和分析操作应该通过会话SQL命令来执行。例如，
如果一个临时表用于复杂查询中，那么在填充临时表之后在临时表上运行
<TT CLASS="COMMAND">ANALYZE</TT>是明智的。</P><P>可以选择在<TT CLASS="LITERAL">TEMPORARY</TT>或<TT CLASS="LITERAL">TEMP</TT>前面放上<TT CLASS="LITERAL">GLOBAL</TT>
或<TT CLASS="LITERAL">LOCAL</TT>。不过这目前对<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>来说没有任何区别，
并且已经废弃了；可以参阅<A HREF="sql-createtable.html#SQL-CREATETABLE-COMPATIBILITY"><I>兼容性</I></A>。</P></DD><DT><TT CLASS="LITERAL">UNLOGGED</TT></DT><DD><P>如果指定了，则表作为非日志表来创建。写入到非日志表中的数据并不写入预写式日志
（参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/wal.html">第 29 &#31456;</A>），这使得他们比普通表快的多。不过，
他们不是崩溃安全的：一个非日志表在崩溃或不清理关机之后被自动截断。
非日志表的内容也不复制到备用服务器。任何在非日志表上创建的索引也自动是非日志的。</P></DD><DT><TT CLASS="LITERAL">IF NOT EXISTS</TT></DT><DD><P>如果同名的关系已经存在，那么不要抛出一个错误。在这种情况下发出一个通知。
请注意，不保证已经存在的关系和要创建的关系相像。</P></DD><DT><TT CLASS="REPLACEABLE"><I>table_name</I></TT></DT><DD><P>要创建的表的名字(可以用模式修饰)</P></DD><DT><TT CLASS="LITERAL">OF <TT CLASS="REPLACEABLE"><I>type_name</I></TT></TT></DT><DD><P>创建一个<I CLASS="FIRSTTERM">类型化的表</I>，它的结构来自指定的复合类型
（名字可以有模式修饰）。一个类型化的表绑定到它的类型；
例如，如果类型被删除（使用<TT CLASS="LITERAL">DROP TYPE ... CASCADE</TT>），
则该表也将被删除。</P><P>当类型化的表被创建时，字段的数据类型取决于底层复合类型，
而不是通过<TT CLASS="LITERAL">CREATE TABLE</TT>命令指定。
但是<TT CLASS="LITERAL">CREATE TABLE</TT>命令可以给表添加缺省和约束，
并且可以指定存储参数。</P></DD><DT><TT CLASS="REPLACEABLE"><I>column_name</I></TT></DT><DD><P>在新表中要创建的字段名字。</P></DD><DT><TT CLASS="REPLACEABLE"><I>data_type</I></TT></DT><DD><P>该字段的数据类型。它可以包括数组说明符。有关<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
支持的数据类型的更多信息，请参考<A HREF="http://school.yunwei.edu/manual/PostgreSQL/datatype.html">第 8 &#31456;</A>。</P></DD><DT><TT CLASS="LITERAL">COLLATE <TT CLASS="REPLACEABLE"><I>collation</I></TT></TT></DT><DD><P><TT CLASS="LITERAL">COLLATE</TT>给字段（必须是可排序的数据类型）分配一个排序规则。
如果没有指定，则使用字段数据类型的缺省排序。</P></DD><DT><TT CLASS="LITERAL">INHERITS ( <TT CLASS="REPLACEABLE"><I>parent_table</I></TT> [, ... ] )</TT></DT><DD><P>可选的<TT CLASS="LITERAL">INHERITS</TT>子句声明一系列的表，新表自动从这一系列表中继承所有字段。</P><P>使用<TT CLASS="LITERAL">INHERITS</TT>将在新的子表和其父表之间创建一个永久的关系。
对父表结构的修改通常也会传播到子表。缺省时，扫描父表的时候也会扫描子表。</P><P>如果在多个父表中存在同名字段，那么就会报告一个错误，
除非这些字段的数据类型在每个父表里都是匹配的。如果没有冲突，
那么重复的字段在新表中融合成一个字段。如果列出的新表字段名和继承字段同名，
那么它的数据类型也必须和继承字段匹配，并且这些字段定义会融合成一个。
如果新表为该字段明确声明了缺省值，那么此缺省值将覆盖任何继承字段的缺省值。
否则，该字段的所有父字段缺省值都必须相同，否则就会报错。</P><P><TT CLASS="LITERAL">CHECK</TT>约束本质上以和字段一样的方式合并：如果多个父表和/或新表的定义包含相同名字的
<TT CLASS="LITERAL">CHECK</TT>约束，那么这些约束必须都有相同的检查表达式，否则会报告一个错误。
有相同名字和表达式的约束将合并到一个。在父表中标记为<TT CLASS="LITERAL">NO INHERIT</TT>
的约束将不被考虑。请注意，新表中未命名的<TT CLASS="LITERAL">CHECK</TT>约束将永远不被合并，
因为它将永远都有一个唯一的名字。</P><P>字段<TT CLASS="LITERAL">STORAGE</TT>设置也从父表中拷贝。</P></DD><DT><TT CLASS="LITERAL">LIKE <TT CLASS="REPLACEABLE"><I>source_table</I></TT> [ <TT CLASS="REPLACEABLE"><I>like_option</I></TT> ... ]</TT></DT><DD><P><TT CLASS="LITERAL">LIKE</TT>子句声明一个表，
新表自动从这个表里面继承所有字段名及其数据类型和非空约束。</P><P>和<TT CLASS="LITERAL">INHERITS</TT>不同，新表与原来的表之间在创建动作完毕之后是完全无关的。
在源表做的任何修改都不会传播到新表中，并且也不可能在扫描源表的时候包含新表的数据。</P><P>字段缺省表达式只有在声明了<TT CLASS="LITERAL">INCLUDING DEFAULTS</TT>之后才会包含进来。
缺省是不包含缺省表达式的，结果是新表中所有字段的缺省值都是 NULL 。</P><P>非空约束将总是复制到新表中，<TT CLASS="LITERAL">CHECK</TT>约束则仅在指定了
<TT CLASS="LITERAL">INCLUDING CONSTRAINTS</TT>的时候才复制。源表上的索引、
<TT CLASS="LITERAL">PRIMARY KEY</TT>和<TT CLASS="LITERAL">UNIQUE</TT>约束仅在指定了
<TT CLASS="LITERAL">INCLUDING INDEXES</TT>子句的时候才在新表上创建。
此规则同时适用于表约束和列约束。</P><P>拷贝字段定义的<TT CLASS="LITERAL">STORAGE</TT>设置只在声明了<TT CLASS="LITERAL">INCLUDING STORAGE</TT>
的时候才拷贝。缺省是不包括<TT CLASS="LITERAL">STORAGE</TT>设置的，
结果是新表中的拷贝字段有特定类型的缺省设置。关于<TT CLASS="LITERAL">STORAGE</TT>
设置的更多信息，请参阅<A HREF="storage-toast.html">第 58.2 &#33410;</A>。</P><P>拷贝字段、约束和索引的注释只在声明了<TT CLASS="LITERAL">INCLUDING COMMENTS</TT>
的时候拷贝。缺省是不包含注释的，结果是新表中拷贝的字段和约束没有注释。</P><P><TT CLASS="LITERAL">INCLUDING ALL</TT>是<TT CLASS="LITERAL">INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</TT>
的一个简写形式。</P><P>请注意，和<TT CLASS="LITERAL">INHERITS</TT>不同，通过<TT CLASS="LITERAL">LIKE</TT>
拷贝的列和约束并不使用相同的名字进行融合。
如果明确的指定了相同的名字或者在另外一个<TT CLASS="LITERAL">LIKE</TT>子句中，那么将会报错。</P><P><TT CLASS="LITERAL">LIKE</TT>子句也可以用来从视图、外表或复合类型中拷贝字段。
不适用的选项（如，从一个视图中<TT CLASS="LITERAL">INCLUDING INDEXES</TT>）都被忽略。</P></DD><DT><TT CLASS="LITERAL">CONSTRAINT <TT CLASS="REPLACEABLE"><I>constraint_name</I></TT></TT></DT><DD><P>可选的列约束或表约束的名字。如果约束本身是非法的，那么其名字将会出现在错误信息中，
因此像<TT CLASS="LITERAL">col must be positive</TT>这样的名字可以表达有用的约束信息。
如果约束名中含有空格则必须用双引号界定。如果没有指定约束名，那么系统将会自动生成一个名字。</P></DD><DT><TT CLASS="LITERAL">NOT NULL</TT></DT><DD><P>字段不允许包含 NULL 值</P></DD><DT><TT CLASS="LITERAL">NULL</TT></DT><DD><P>字段允许包含 NULL 值，这是缺省。</P><P>这个子句的存在只是为和那些非标准 SQL 数据库兼容。不建议在新应用中使用它。</P></DD><DT><TT CLASS="LITERAL">CHECK ( <TT CLASS="REPLACEABLE"><I>expression</I></TT> ) [ NO INHERIT ] </TT></DT><DD><P><TT CLASS="LITERAL">CHECK</TT>约束声明一个生成布尔结果的表达式，
每次将要插入的新行或者将要被更新的行必须使表达式结果为真或未知才能成功，
否则会抛出一个异常并且不会修改数据库。
声明为字段约束的检查约束应该只引用该字段的数值，
而在表约束里出现的表达式可以引用多个字段。</P><P>目前，<TT CLASS="LITERAL">CHECK</TT>表达式不能包含子查询也不能引用除当前行字段之外的变量。</P><P>用<TT CLASS="LITERAL">NO INHERIT</TT>标记的约束将不会传递到子表中去。</P></DD><DT><TT CLASS="LITERAL">DEFAULT
<TT CLASS="REPLACEABLE"><I>default_expr</I></TT></TT></DT><DD><P><TT CLASS="LITERAL">DEFAULT</TT>子句给字段指定缺省值。该数值可以是任何不含变量的表达式
(不允许使用子查询和对本表中的其它字段的交叉引用)。
缺省表达式的数据类型必须和字段类型匹配。</P><P>缺省表达式将被用于任何未声明该字段数值的插入操作。
如果没有指定缺省值则缺省值为 NULL 。</P></DD><DT><TT CLASS="LITERAL">UNIQUE</TT> (column constraint)<BR><TT CLASS="LITERAL">UNIQUE ( <TT CLASS="REPLACEABLE"><I>column_name</I></TT> [, ... ] )</TT> (table constraint)</DT><DD><P><TT CLASS="LITERAL">UNIQUE</TT>约束表示表里的一个或多个字段的组合必须在全表范围内唯一。
唯一约束的行为和列约束一样，只不过多了跨多行的能力。</P><P>对于唯一约束而言，NULL 被认为是互不相等的。</P><P>每个唯一约束都必须给其使用的字段集合赋予一个与其它唯一约束都不同的名字，
并且也不能和主键约束的名字相同，否则就被认为是同样的约束写了两次。</P></DD><DT><TT CLASS="LITERAL">PRIMARY KEY</TT> (column constraint)<BR><TT CLASS="LITERAL">PRIMARY KEY ( <TT CLASS="REPLACEABLE"><I>column_name</I></TT> [, ... ] )</TT> (table constraint)</DT><DD><P>主键约束表明表中的一个或者一些字段只能包含唯一(不重复)的非 NULL 值。
从技术上讲，<TT CLASS="LITERAL">PRIMARY KEY</TT>只是<TT CLASS="LITERAL">UNIQUE</TT>
和<TT CLASS="LITERAL">NOT NULL</TT>的组合，不过把一套字段标识为主键同时也体现了模式设计的元数据，
因为主键意味着可以拿这套字段用做行的唯一标识。</P><P>一个表只能声明一个主键，不管是作为字段约束还是表约束。</P><P>主键约束使用的字段集合应该与其它唯一约束都不同。</P></DD><DT><A NAME="SQL-CREATETABLE-EXCLUDE"></A><TT CLASS="LITERAL">EXCLUDE [ USING <TT CLASS="REPLACEABLE"><I>index_method</I></TT> ] ( <TT CLASS="REPLACEABLE"><I>exclude_element</I></TT> WITH <TT CLASS="REPLACEABLE"><I>operator</I></TT> [, ... ] ) <TT CLASS="REPLACEABLE"><I>index_parameters</I></TT> [ WHERE ( <TT CLASS="REPLACEABLE"><I>predicate</I></TT> ) ]</TT></DT><DD><P><TT CLASS="LITERAL">EXCLUDE</TT>子句定义一个排除约束，保证了两个行在指定的字段或使用指定操作符的表达式上比较时，
并不都返回<TT CLASS="LITERAL">TRUE</TT>。如果所有指定的操作符测试都相等，
那么就等同于<TT CLASS="LITERAL">UNIQUE</TT>约束，尽管一个普通的唯一约束会更快速。
不过，排除约束可以指定比简单相等更普通的约束。例如，
你可以通过使用<TT CLASS="LITERAL">&amp;&amp;</TT>操作符指定一个约束，
在一个表中没有两个行包含重叠的圆圈(参阅<A HREF="datatype-geometric.html">第 8.8 &#33410;</A>)。</P><P>排除约束是使用索引实现的，所以每个指定的操作符都必须和索引访问方法的一个合适的操作符类
（参阅<A HREF="indexes-opclass.html">第 11.9 &#33410;</A>）相关。要求操作符是可交换的。
每个<TT CLASS="REPLACEABLE"><I>exclude_element</I></TT>
可以指定一个操作符类和/或排序选项；这些在<A HREF="sql-createindex.html">CREATE INDEX</A>中有充分的描述。</P><P>访问方法必须支持<TT CLASS="LITERAL">amgettuple</TT> (参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/indexam.html">第 54 &#31456;</A>)；
目前，这意味着不能使用<ACRONYM CLASS="ACRONYM">GIN</ACRONYM>。尽管允许使用，
但是在排除约束中使用B-tree或哈希索引没什么意义，
因为一个普通唯一约束做的更好。所以实际中，访问方法总是<ACRONYM CLASS="ACRONYM">GiST</ACRONYM>
或<ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>。</P><P><TT CLASS="REPLACEABLE"><I>predicate</I></TT>允许在表的子集上声明一个排除约束；
在内部这创建了一个部分索引。请注意，谓语需要有括号包围。</P></DD><DT><TT CLASS="LITERAL">REFERENCES <TT CLASS="REPLACEABLE"><I>reftable</I></TT> [ ( <TT CLASS="REPLACEABLE"><I>refcolumn</I></TT> ) ] [ MATCH <TT CLASS="REPLACEABLE"><I>matchtype</I></TT> ] [ ON DELETE <TT CLASS="REPLACEABLE"><I>action</I></TT> ] [ ON UPDATE <TT CLASS="REPLACEABLE"><I>action</I></TT> ]</TT> (column constraint)<BR><TT CLASS="LITERAL">FOREIGN KEY ( <TT CLASS="REPLACEABLE"><I>column_name</I></TT> [, ... ] )
REFERENCES <TT CLASS="REPLACEABLE"><I>reftable</I></TT> [ ( <TT CLASS="REPLACEABLE"><I>refcolumn</I></TT> [, ... ] ) ]
[ MATCH <TT CLASS="REPLACEABLE"><I>matchtype</I></TT> ]
[ ON DELETE <TT CLASS="REPLACEABLE"><I>action</I></TT> ]
[ ON UPDATE <TT CLASS="REPLACEABLE"><I>action</I></TT> ]</TT>
(table constraint)</DT><DD><P>这些子句声明一个外键约束，外键约束要求新表中一列或多列组成的组应该只包含
匹配被参考的表中对应字段中的值。如果省略<TT CLASS="REPLACEABLE"><I>refcolumn</I></TT>，则使用
<TT CLASS="REPLACEABLE"><I>reftable</I></TT>的主键。
被参考字段必须是被参考表中的唯一字段或者主键。请注意，
不能在临时表和永久表之间定义外键约束。</P><P>向参考字段插入的数值将使用给出的匹配类型与被参考表中被参考列的数值进行匹配。
有三种匹配类型：<TT CLASS="LITERAL">MATCH FULL</TT>, <TT CLASS="LITERAL">MATCH PARTIAL</TT>,
<TT CLASS="LITERAL">MATCH SIMPLE</TT>(缺省)。<TT CLASS="LITERAL">MATCH FULL</TT>
不允许一个多字段外键的字段为 NULL ，除非所有外键字段都为 NULL；
如果都是NULL，那么该行在引用的表中不需要有匹配。<TT CLASS="LITERAL">MATCH SIMPLE</TT>
允许任意外键字段为 NULL；如果都是NULL，那么该行在引用的表中不需要有匹配。
<TT CLASS="LITERAL">MATCH PARTIAL</TT>目前尚未实现。（当然，<TT CLASS="LITERAL">NOT NULL</TT>
约束可以应用于引用字段，以阻止这些情况的发生。）</P><P>另外，当被参考字段中的数据改变的时候，那么将对本表的字段中的数据执行某种操作。
<TT CLASS="LITERAL">ON DELETE</TT>子句声明当被参考表中的被参考行被删除的时候要执行的操作。
类似的，<TT CLASS="LITERAL">ON UPDATE</TT>子句声明被参考表中被参考字段更新为新值的时候要执行的动作。
如果该行被更新，但被参考的字段实际上没有变化，那么就不会有任何动作。
除了<TT CLASS="LITERAL">NO ACTION</TT>检查之外的其他参考动作都不能推迟，
即使该约束声明为可推迟也是如此。下面是每个子句的可能动作：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">NO ACTION</TT></DT><DD><P>生成一个错误，表明删除或更新将产生一个违反外键约束的动作。
如果该约束是可推迟的，并且如果还存在任何引用行，那么这个错误将在检查约束的时候生成。
这是缺省动作。</P></DD><DT><TT CLASS="LITERAL">RESTRICT</TT></DT><DD><P>生成一个表明删除或更新将导致违反外键约束的错误。
和<TT CLASS="LITERAL">NO ACTION</TT>一样，只是动作不可推迟。</P></DD><DT><TT CLASS="LITERAL">CASCADE</TT></DT><DD><P>删除任何引用了被删除行的行，或者分别把引用行的字段值更新为被参考字段的新数值。</P></DD><DT><TT CLASS="LITERAL">SET NULL</TT></DT><DD><P>把引用行设置为 NULL 。</P></DD><DT><TT CLASS="LITERAL">SET DEFAULT</TT></DT><DD><P>把引用字段设置为它们的缺省值。（如果他们为非空，那么被引用的表中必须有一行匹配缺省值，
否则该操作将会失败。）</P></DD></DL></DIV><P>
</P><P>如果被参考字段经常更新，那么给引用字段增加一个索引可能是合适的，
这样与外键约束相关联的引用动作可以更有效地执行。</P></DD><DT><TT CLASS="LITERAL">DEFERRABLE</TT><BR><TT CLASS="LITERAL">NOT DEFERRABLE</TT></DT><DD><P>这两个关键字设置该约束是否可推迟。一个不可推迟的约束将在每条命令之后马上检查。
可推迟约束可以推迟到事务结尾使用<A HREF="sql-set-constraints.html">SET CONSTRAINTS</A>命令检查。
缺省是<TT CLASS="LITERAL">NOT DEFERRABLE</TT>。目前，只有<TT CLASS="LITERAL">UNIQUE</TT>、
<TT CLASS="LITERAL">PRIMARY KEY</TT>、<TT CLASS="LITERAL">EXCLUDE</TT>和<TT CLASS="LITERAL">REFERENCES</TT>（外键）
约束接受这个子句。<TT CLASS="LITERAL">NOT NULL</TT>和<TT CLASS="LITERAL">CHECK</TT>约束都是不可推迟的。</P></DD><DT><TT CLASS="LITERAL">INITIALLY IMMEDIATE</TT><BR><TT CLASS="LITERAL">INITIALLY DEFERRED</TT></DT><DD><P>如果约束是可推迟的，那么这个子句声明检查约束的缺省时间。
如果约束是<TT CLASS="LITERAL">INITIALLY IMMEDIATE</TT>(缺省)，
那么每条语句之后就立即检查它。如果约束是<TT CLASS="LITERAL">INITIALLY DEFERRED</TT>，
那么只有在事务结尾才检查它。约束检查的时间可以用
<A HREF="sql-set-constraints.html">SET CONSTRAINTS</A>命令修改。</P></DD><DT><TT CLASS="LITERAL">WITH ( <TT CLASS="REPLACEABLE"><I>storage_parameter</I></TT> [= <TT CLASS="REPLACEABLE"><I>value</I></TT>] [, ... ] )</TT></DT><DD><P>这个子句为表或索引指定一个可选的存储参数，参见<A HREF="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS"><I>存储参数</I></A>获取更多信息。
用于表的<TT CLASS="LITERAL">WITH</TT>子句还可以包含<TT CLASS="LITERAL">OIDS=TRUE</TT>或单独的
<TT CLASS="LITERAL">OIDS</TT>来指定给新表中的每一行都分配一个 OID(对象标识符)，
或者<TT CLASS="LITERAL">OIDS=FALSE</TT>表示不分配 OID 。如果没有指定<TT CLASS="LITERAL">OIDS</TT>
默认行为取决于<A HREF="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS">default_with_oids</A>配置参数。
如果新表是从有 OID 的表继承而来，那么即使明确指定<TT CLASS="LITERAL">OIDS=FALSE</TT>
也将强制按照<TT CLASS="LITERAL">OIDS=TRUE</TT>执行。</P><P>如果明确或隐含的指定了<TT CLASS="LITERAL">OIDS=FALSE</TT>，新表将不会存储 OID ，
也不会为插入的行分配 OID 。这将减小 OID 的开销并因此延缓了 32-bit OID
计数器的循环。因为一旦计数器发生循环之后 OID 将不能被视为唯一，
这将大大降低 OID 的实用性。另外，
排除了 OID 的表也为每条记录减小了 4 字节的存储空间（在大多数机器上），
从而可以稍微提升一些性能。</P><P>可以使用<A HREF="sql-altertable.html">ALTER TABLE</A>从已有的表中删除 OID 列。</P></DD><DT><TT CLASS="LITERAL">WITH OIDS</TT><BR><TT CLASS="LITERAL">WITHOUT OIDS</TT></DT><DD><P>这些是被废弃的、分别等价于<TT CLASS="LITERAL">WITH (OIDS)</TT>和<TT CLASS="LITERAL">WITH (OIDS=FALSE)</TT>
的语法。如果想同时给出<TT CLASS="LITERAL">OIDS</TT>设置和存储参数，必须使用
<TT CLASS="LITERAL">WITH ( ... )</TT>语法；见上文。</P></DD><DT><TT CLASS="LITERAL">ON COMMIT</TT></DT><DD><P>可以使用<TT CLASS="LITERAL">ON COMMIT</TT>控制临时表在事务块结尾的行为。
这三个选项是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">PRESERVE ROWS</TT></DT><DD><P>在事务的结尾不采取任何特别的动作，这是缺省。</P></DD><DT><TT CLASS="LITERAL">DELETE ROWS</TT></DT><DD><P>在每个事务块的结尾都删除临时表中的所有行。
本质上是在每次提交事务后自动执行一个<A HREF="sql-truncate.html">TRUNCATE</A>命令。</P></DD><DT><TT CLASS="LITERAL">DROP</TT></DT><DD><P>在当前事务块的结尾删除临时表。</P></DD></DL></DIV><P></P></DD><DT><TT CLASS="LITERAL">TABLESPACE <TT CLASS="REPLACEABLE"><I>tablespace_name</I></TT></TT></DT><DD><P>指定新表将要在<TT CLASS="REPLACEABLE"><I>tablespace_name</I></TT>
表空间内创建。如果没有声明，将使用<A HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</A>，
如果该表为临时表，那么将使用<A HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</A>。</P></DD><DT><TT CLASS="LITERAL">USING INDEX TABLESPACE <TT CLASS="REPLACEABLE"><I>tablespace_name</I></TT></TT></DT><DD><P>这个子句允许选择与一个<TT CLASS="LITERAL">UNIQUE</TT>、<TT CLASS="LITERAL">PRIMARY KEY</TT>
或<TT CLASS="LITERAL">EXCLUDE</TT>约束相关的索引创建时所在的表空间。如果没有声明，
将使用<A HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</A>，
如果该表为临时表，那么将使用<A HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</A>。</P></DD></DL></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-CREATETABLE-STORAGE-PARAMETERS"></A><H3>存储参数</H3><P><TT CLASS="LITERAL">WITH</TT>子句可以为表指定<I CLASS="FIRSTTERM">存储参数</I>，并在索引上创建
<TT CLASS="LITERAL">UNIQUE</TT>、<TT CLASS="LITERAL">PRIMARY KEY</TT>或<TT CLASS="LITERAL">EXCLUDE</TT>
约束。用于索引的存储参数在<A HREF="sql-createindex.html">CREATE INDEX</A>里面描述。
目前可以在表上使用的存储参数在下面列出。对于每个参数，除非指明了，
有一个额外的参数是相同的名字加上<TT CLASS="LITERAL">toast.</TT>前缀，
可以用来控制表的次要<ACRONYM CLASS="ACRONYM">TOAST</ACRONYM>表的行为，如果有
(参阅<A HREF="storage-toast.html">第 58.2 &#33410;</A>获取更多关于TOAST的信息)。
请注意，TOAST表从它的父表中继承<TT CLASS="LITERAL">autovacuum_*</TT>值，
如果没有设置<TT CLASS="LITERAL">toast.autovacuum_*</TT>设置。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">fillfactor</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>一个表的填充因子(fillfactor)是一个介于 10 和 100 之间的百分数。
100(完全填充)是默认值。如果指定了较小的填充因子，<TT CLASS="COMMAND">INSERT</TT>
操作仅按照填充因子指定的百分率填充表页。每个页上的剩余空间将用于在该页上更新行，
这就使得<TT CLASS="COMMAND">UPDATE</TT>有机会在同一页上放置同一条记录的新版本，
这比把新版本放置在其它页上更有效。对于一个从不更新的表将填充因子设为 100
是最佳选择，但是对于频繁更新的表，较小的填充因子则更加有效。
这个参数不能为TOAST表设置。</P></DD><DT><TT CLASS="LITERAL">autovacuum_enabled</TT>, <TT CLASS="LITERAL">toast.autovacuum_enabled</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P>在一个特别的表上启用或禁用自动清理守护进程。如果为真，
当更新或删除的元组的数量超过<TT CLASS="LITERAL">autovacuum_vacuum_threshold</TT>
加上<TT CLASS="LITERAL">autovacuum_vacuum_scale_factor</TT>倍的当前关系中评估的活动的元组时，
自动清理守护进程将在一个特定的表上发起一个<TT CLASS="COMMAND">VACUUM</TT>操作。
相似的，当插入、更新或删除的元组的数量超过<TT CLASS="LITERAL">autovacuum_analyze_threshold</TT>
加上<TT CLASS="LITERAL">autovacuum_analyze_scale_factor</TT>倍的当前关系中评估的活动的元组时，
自动清理守护进程将发起一个<TT CLASS="COMMAND">ANALYZE</TT>操作。如果为假，
这个表将不被自动清理，除了防止事务Id循环。参阅<A HREF="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND">第 23.1.5 &#33410;</A>
获取更多关于预防循环的信息。注意，这个变量从<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM">autovacuum</A>
设置中继承值。</P></DD><DT><TT CLASS="LITERAL">autovacuum_vacuum_threshold</TT>, <TT CLASS="LITERAL">toast.autovacuum_vacuum_threshold</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>在一个特定的表上发起<TT CLASS="COMMAND">VACUUM</TT>操作之前，更新或删除的元组的最小值。</P></DD><DT><TT CLASS="LITERAL">autovacuum_vacuum_scale_factor</TT>, <TT CLASS="LITERAL">toast.autovacuum_vacuum_scale_factor</TT> (<TT CLASS="TYPE">float4</TT>)</DT><DD><P>添加到<TT CLASS="LITERAL">autovacuum_vacuum_threshold</TT>的<TT CLASS="STRUCTFIELD">reltuples</TT>的乘数。</P></DD><DT><TT CLASS="LITERAL">autovacuum_analyze_threshold</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>在一个特定的表上发起<TT CLASS="COMMAND">ANALYZE</TT>操作之前，插入、更新或删除的元组的最小值。</P></DD><DT><TT CLASS="LITERAL">autovacuum_analyze_scale_factor</TT> (<TT CLASS="TYPE">float4</TT>)</DT><DD><P>添加到<TT CLASS="LITERAL">autovacuum_analyze_threshold</TT>的<TT CLASS="STRUCTFIELD">reltuples</TT>乘数。</P></DD><DT><TT CLASS="LITERAL">autovacuum_vacuum_cost_delay</TT>, <TT CLASS="LITERAL">toast.autovacuum_vacuum_cost_delay</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>自定义<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-DELAY">autovacuum_vacuum_cost_delay</A>参数。</P></DD><DT><TT CLASS="LITERAL">autovacuum_vacuum_cost_limit</TT>, <TT CLASS="LITERAL">toast.autovacuum_vacuum_cost_limit</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>自定义<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-LIMIT">autovacuum_vacuum_cost_limit</A>参数。</P></DD><DT><TT CLASS="LITERAL">autovacuum_freeze_min_age</TT>, <TT CLASS="LITERAL">toast.autovacuum_freeze_min_age</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>自定义<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-LIMIT">autovacuum_vacuum_cost_limit</A>参数。请注意，
自动清理将忽略设置一个每表<TT CLASS="LITERAL">autovacuum_freeze_min_age</TT>
大于半个系统范围的<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</A>设置的尝试。</P></DD><DT><TT CLASS="LITERAL">autovacuum_freeze_max_age</TT>, <TT CLASS="LITERAL">toast.autovacuum_freeze_max_age</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>自定义<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</A>参数。请注意，
自动清理将忽略设置一个每表<TT CLASS="LITERAL">autovacuum_freeze_max_age</TT>
大于系统范围的设置的尝试（它只能设置的较小一些）。注意，
你可以将<TT CLASS="LITERAL">autovacuum_freeze_max_age</TT>设置的非常小，甚至为零，
这通常是不明智的，因为它将强制频繁的清理。</P></DD><DT><TT CLASS="LITERAL">autovacuum_freeze_table_age</TT>, <TT CLASS="LITERAL">toast.autovacuum_freeze_table_age</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>自定义<A HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</A>参数。</P></DD></DL></DIV></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="SQL-CREATETABLE-NOTES"></A><H2>注意</H2><P>不建议在新应用中使用 OID ，可能情况下，更好的选择是使用一个<TT CLASS="LITERAL">SERIAL</TT>
或者其它序列发生器做表的主键。如果一个应用使用了 OID 标识表中的特定行，
那么建议在该表的<TT CLASS="STRUCTFIELD">oid</TT>字段上创建一个唯一约束，
以确保该表的 OID 即使在计数器循环之后也是唯一的。
如果你需要一个整个数据库范围的唯一标识，那么就要避免假设 OID 是跨表唯一的，
你可以用<TT CLASS="STRUCTFIELD">tableoid</TT>和行 OID 的组合来实现这个目的。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>对那些没有主键的表，不建议使用<TT CLASS="LITERAL">OIDS=FALSE</TT>，
因为如果既没有 OID 又没有唯一数据字段，那么就很难标识特定的行。</P></BLOCKQUOTE></DIV><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
自动为每个唯一约束和主键约束创建一个索引以确保其唯一性。因此，
不必为主键字段明确的创建索引。参阅<A HREF="sql-createindex.html">CREATE INDEX</A>获取更多信息。</P><P>唯一约束和主键在目前的实现里是不能继承的。
如果把继承和唯一约束组合在一起会导致无法运转。</P><P>一个表不能超过 1600 个字段。实际的限制比这个更低，因为还有元组长度限制。</P></DIV><DIV CLASS="REFSECT1"><A NAME="SQL-CREATETABLE-EXAMPLES"></A><H2>例子</H2><P>创建<TT CLASS="STRUCTNAME">films</TT>和<TT CLASS="STRUCTNAME">distributors</TT>表：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);</PRE><P>
</P><P>创建一个带有 2 维数组的表：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE array_int (
    vector  int[][]
);</PRE><P>
</P><P>为表<TT CLASS="LITERAL">films</TT>定义一个唯一表约束。
唯一表约束可以在表的一个或多个字段上定义：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);</PRE><P>
</P><P>定义一个检查列约束：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);</PRE><P>
</P><P>定义一个检查表约束：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    did     integer,
    name    varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);</PRE><P>
</P><P>为表<TT CLASS="STRUCTNAME">films</TT>定义一个主键表约束。
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);</PRE><P>
</P><P>为表<TT CLASS="STRUCTNAME">distributors</TT>定义一个主键约束。下面两个例子是等效的，
第一个例子使用了表约束语法，第二个使用了列约束语法。
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);</PRE><P>
</P><P>下面这个例子给字段<TT CLASS="LITERAL">name</TT>赋予了一个文本常量缺省值，
并且将字段<TT CLASS="LITERAL">did</TT>的缺省值安排为通过选择序列对象的下一个值生成。
<TT CLASS="LITERAL">modtime</TT>的缺省值将是该行插入的时间戳。
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);</PRE><P>
</P><P>在表<CODE CLASS="CLASSNAME">distributors</CODE>上定义两个<TT CLASS="LITERAL">NOT NULL</TT>列约束，
其中之一明确给出了名字：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);</PRE><P>
</P><P>为<TT CLASS="LITERAL">name</TT>字段定义一个唯一约束：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);</PRE><P>
相同的，声明为一个表约束：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);</PRE><P>
</P><P>创建同样的表，并为表以及唯一索引指定 70% 填充率：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);</PRE><P>
</P><P>创建一个带有排除约束的表<TT CLASS="STRUCTNAME">circles</TT>，
阻止任意两个圆重叠：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);</PRE><P>
</P><P>在表空间<TT CLASS="STRUCTNAME">diskvol1</TT>里创建<TT CLASS="STRUCTNAME">cinemas</TT>表：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;</PRE><P>
</P><P>创建一个复合类型和类型化的表：
</P><PRE CLASS="PROGRAMLISTING">CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="SQL-CREATETABLE-COMPATIBILITY"></A><H2>兼容性</H2><P><TT CLASS="COMMAND">CREATE TABLE</TT>遵循<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准，
一些例外情况在下面列出。</P><DIV CLASS="REFSECT2"><A NAME="AEN72960"></A><H3>临时表</H3><P>尽管<TT CLASS="LITERAL">CREATE TEMPORARY TABLE</TT>的语法和 SQL 标准的类似，但是效果是不同的。
在标准里，临时表只是定义一次并且从空内容开始自动存在于任何需要它们的会话中。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>要求每个会话为它们使用的每个临时表发出它们自己的
<TT CLASS="LITERAL">CREATE TEMPORARY TABLE</TT>命令。
这样就允许不同的会话将相同的临时表名字用于不同的目的，
而标准的实现方法则把一个临时表名字约束为具有相同的表结构。</P><P>标准定义的临时表的行为被广泛地忽略了。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
在这方面上的行为类似于许多其它 SQL 数据库系统。</P><P>SQL标准也区分全局和局部临时表，局部临时表对于每个会话中的每个SQL模块都有一个单独的内容设置，
虽然它的定义仍然在会话中共享。因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
不支持SQL模块，所以这个差别在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不相关。</P><P>出于兼容考虑，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将接受临时表声明中的
<TT CLASS="LITERAL">GLOBAL</TT>和<TT CLASS="LITERAL">LOCAL</TT>关键字，但是他们没有任何作用。
不建议使用这些关键字，因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
的未来版本可能采取更加标准兼容的它们的含义。</P><P>临时表的<TT CLASS="LITERAL">ON COMMIT</TT>子句也类似于 SQL 标准，但是有些区别。
如果忽略了<TT CLASS="LITERAL">ON COMMIT</TT>子句，SQL 标准声明缺省的行为是
<TT CLASS="LITERAL">ON COMMIT DELETE ROWS</TT>。但是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
里的缺省行为是<TT CLASS="LITERAL">ON COMMIT PRESERVE ROWS</TT>。
在 SQL 标准里不存在<TT CLASS="LITERAL">ON COMMIT DROP</TT>选项。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN72983"></A><H3>非延迟的唯一性约束</H3><P>当<TT CLASS="LITERAL">UNIQUE</TT>或<TT CLASS="LITERAL">PRIMARY KEY</TT>约束是不可延迟的时，
当插入或修改一个行时，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
立即检查唯一性。SQL标准说唯一约束应该只在语句的结尾强制执行；
这使得它和<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不同，例如，
一个命令更新多个键值。要获得标准兼容的行为，声明该约束为
<TT CLASS="LITERAL">DEFERRABLE</TT>但是不能延迟（也就是说，<TT CLASS="LITERAL">INITIALLY IMMEDIATE</TT>）。
要知道，这会比立即检查唯一性要慢的多。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN72992"></A><H3>列检查约束</H3><P>SQL 标准说<TT CLASS="LITERAL">CHECK</TT>列约束只能引用他们作用的字段；
只有<TT CLASS="LITERAL">CHECK</TT>表约束才能引用多个字段。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
并不强制这个限制；它把字段和表约束看作相同的东西。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN72998"></A><H3><TT CLASS="LITERAL">EXCLUDE</TT> 约束</H3><P><TT CLASS="LITERAL">EXCLUDE</TT>约束类型是一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扩展。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN73004"></A><H3><TT CLASS="LITERAL">NULL</TT> <SPAN CLASS="QUOTE">"约束"</SPAN></H3><P><TT CLASS="LITERAL">NULL</TT> <SPAN CLASS="QUOTE">"约束"</SPAN>(实际上不是约束)是
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对 SQL 标准的扩展，
包括它是为了和其它一些数据库系统兼容以及为了和<TT CLASS="LITERAL">NOT NULL</TT>
约束对称。因为它是任何字段的缺省，所以它的出现是没有意义的。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN73013"></A><H3>继承</H3><P>通过<TT CLASS="LITERAL">INHERITS</TT>子句的多重继承是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
语言的扩展。SQL:1999 及以后的标准使用不同的语法和语义定义了单继承。
SQL:1999风格的继承还没有在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>中实现。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN73019"></A><H3>零字段表</H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许创建没有字段的表(比如
<TT CLASS="LITERAL">CREATE TABLE foo();</TT>)。这是对 SQL 标准的扩展，
标准不允许存在零字段表。零字段表本身没什么用，
但是禁止他们会给<TT CLASS="COMMAND">ALTER TABLE DROP COLUMN</TT>带来很奇怪的情况，
所以，这个时候忽视标准的限制概念非常清楚。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN73025"></A><H3><TT CLASS="LITERAL">WITH</TT> 子句</H3><P><TT CLASS="LITERAL">WITH</TT>子句是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的扩展，同样，
存储参数和 OID 也是扩展。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN73031"></A><H3>表空间</H3><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的表空间概念不是标准的东西。
因此<TT CLASS="LITERAL">TABLESPACE</TT>和<TT CLASS="LITERAL">USING INDEX TABLESPACE</TT>都是扩展。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN73037"></A><H3>类型化的表</H3><P>类型化的表实现了SQL标准的一个子集。根据标准，
类型化的表有对应于底层复合类型和一个其他的<SPAN CLASS="QUOTE">"自我参考字段"</SPAN>。
PostgreSQL没有明确支持这些自我参考字段，但是相同的效果可以使用OID特性达到。</P></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73041"></A><H2>又见</H2><A HREF="sql-altertable.html">ALTER TABLE</A>, <A HREF="sql-droptable.html">DROP TABLE</A>, <A HREF="sql-createtableas.html">CREATE TABLE AS</A>, <A HREF="sql-createtablespace.html">CREATE TABLESPACE</A>, <A HREF="sql-createtype.html">CREATE TYPE</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-createserver.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-createtableas.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">CREATE SERVER</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">CREATE TABLE AS</TD></TR></TABLE></DIV></BODY></HTML>
