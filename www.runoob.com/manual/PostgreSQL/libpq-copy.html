<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>与COPY命令相关的函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="异步通知" HREF="libpq-notify.html"><LINK REL="NEXT" TITLE="控制函数" HREF="libpq-control.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="异步通知" HREF="libpq-notify.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="控制函数" HREF="libpq-control.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-COPY">31.9. 与<TT CLASS="COMMAND">COPY</TT>命令相关的函数</A></H1><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里的<TT CLASS="COMMAND">COPY</TT>命令里有用于
<SPAN CLASS="APPLICATION">libpq</SPAN>从网络连接读出或者写入的选项。
本节描述的函数允许应用通过提供或者消耗拷贝数据，充分利用这个功能。</P><P>整个过程是应用首先通过<CODE CLASS="FUNCTION">PQexec</CODE>或者一个等效的函数发出
<TT CLASS="COMMAND">COPY</TT>命令。对这个命令的响应（如果命令无误）
将是一个带着状态码<TT CLASS="LITERAL">PGRES_COPY_OUT</TT>或者<TT CLASS="LITERAL">PGRES_COPY_IN</TT>
的<TT CLASS="STRUCTNAME">PGresult</TT>（具体根据声明的拷贝方向）。
应用然后就应该使用本节的函数接受或者发送数据行。在数据传输结束之后，
返回另外一个<TT CLASS="STRUCTNAME">PGresult</TT>对象以表明传输的成功或者失败。它的状态将是
<TT CLASS="LITERAL">PGRES_COMMAND_OK</TT>表示成功或者如果发生了一些问题，是
<TT CLASS="LITERAL">PGRES_FATAL_ERROR</TT>。这个时候开始我们可以通过<CODE CLASS="FUNCTION">PQexec</CODE>
发出更多 SQL 命令。（<TT CLASS="COMMAND">COPY</TT>操作在处理的过程中，
我们不可能用同一个连接执行其它 SQL 命令。</P><P>如果一个<TT CLASS="COMMAND">COPY</TT>是通过<CODE CLASS="FUNCTION">PQexec</CODE>
在一个可以包含额外命令的字串里发出的，那么应用在完成<TT CLASS="COMMAND">COPY</TT>
序列之后必须继续用<CODE CLASS="FUNCTION">PQgetResult</CODE>抓取结果。只有在<CODE CLASS="FUNCTION">PQgetResult</CODE>
返回<TT CLASS="SYMBOL">NULL</TT>的时候，我们才能确信<CODE CLASS="FUNCTION">PQexec</CODE>
的命令字串已经处理完毕，并且已经可以安全地发出更多命令。</P><P>本节的这些函数应该只在从<CODE CLASS="FUNCTION">PQexec</CODE>或<CODE CLASS="FUNCTION">PQgetResult</CODE>
获得了<TT CLASS="LITERAL">PGRES_COPY_OUT</TT>或<TT CLASS="LITERAL">PGRES_COPY_IN</TT>结果状态的情况下执行。</P><P>一个承载了这些状态值之一地<TT CLASS="STRUCTNAME">PGresult</TT>对象运载了某些有关正在开始的
<TT CLASS="COMMAND">COPY</TT>操作的额外信息。这些额外的数据可以用那些同时也处理查询结果的函数获取。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQNFIELDS-1"></A><CODE CLASS="FUNCTION">PQnfields</CODE>
</DT><DD><P>返回要拷贝的字段（数据域）个数</P></DD><DT><A NAME="LIBPQ-PQBINARYTUPLES-1"></A><CODE CLASS="FUNCTION">PQbinaryTuples</CODE>
</DT><DD><P>0 表示全部拷贝格式都是文本的（行之间用换行分隔，字段用分隔符分隔，等等）。
1 表示全部拷贝格式都是二进制。参阅<A HREF="sql-copy.html">COPY</A>获取更多信息。</P></DD><DT><A NAME="LIBPQ-PQFFORMAT-1"></A><CODE CLASS="FUNCTION">PQfformat</CODE>
</DT><DD><P>返回和拷贝操作的每个字段相关的格式代码（0 是文本，1 是二进制）。
如果全部拷贝格式是文本，那么每字段的格式码将总是零，但是（整体）
二进制格式可以支持文本和二进制字段并存。（不过，就目前的<TT CLASS="COMMAND">COPY</TT>实现，
在二进制拷贝里只出现二进制字段；所以目前每字段的格式总是匹配整体格式。）</P></DD></DL></DIV><P>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这些额外的数据值只能在使用 3.0 版本的协议的时候获得。在使用 2.0 版本的协议时，所有这些函数都返回 0。</P></BLOCKQUOTE></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-COPY-SEND">31.9.1. 用于发送<TT CLASS="COMMAND">COPY</TT>数据的函数</A></H2><P>这些函数用于在<TT CLASS="LITERAL">COPY FROM STDIN</TT>过程中发送数据。
如果在连接不是处于<TT CLASS="LITERAL">COPY_IN</TT>状态下，它们会失败。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQPUTCOPYDATA"></A><CODE CLASS="FUNCTION">PQputCopyData</CODE>
</DT><DD><P>在<TT CLASS="LITERAL">COPY_IN</TT>状态里向服务器发送数据。
</P><PRE CLASS="SYNOPSIS">int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);</PRE><P>
</P><P>传输指定的<TT CLASS="PARAMETER">buffer</TT>里的，长度为<TT CLASS="PARAMETER">nbytes</TT>的<TT CLASS="COMMAND">COPY</TT>
数据到服务器。如果数据发送成功，结果是 1，如果因为发送企图会阻塞
（这种情况只有在连接是非阻塞模式时才有可能）而没有成功，那么是零，
或者是在发生错误的时候是 -1。（如果返回 -1，那么使用<CODE CLASS="FUNCTION">PQerrorMessage</CODE>
检索细节。如果值是零，那么等待写准备好然后重试。）</P><P>应用可以把<TT CLASS="COMMAND">COPY</TT>数据流分隔成任意合适的大小放到缓冲区里。在发送的时候，
缓冲区的边界没有什么特殊的语意。数据流的内容必须匹配<TT CLASS="COMMAND">COPY</TT>命令预期的数据格式；
参阅<A HREF="sql-copy.html">COPY</A>获取细节。</P></DD><DT><A NAME="LIBPQ-PQPUTCOPYEND"></A><CODE CLASS="FUNCTION">PQputCopyEnd</CODE>
</DT><DD><P>在<TT CLASS="LITERAL">COPY_IN</TT>状态里向服务器发送数据完毕的指示。
</P><PRE CLASS="SYNOPSIS">int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);</PRE><P>
</P><P>如果<TT CLASS="PARAMETER">errormsg</TT>是<TT CLASS="SYMBOL">NULL</TT>，则成功结束<TT CLASS="LITERAL">COPY_IN</TT>操作。
如果<TT CLASS="PARAMETER">errormsg</TT>不是<TT CLASS="SYMBOL">NULL</TT>则<TT CLASS="COMMAND">COPY</TT>操作被强制失败，
<TT CLASS="PARAMETER">errormsg</TT>指向的字串是错误信息。（我们不能认为同样的信息可能会从服务器传回，
因为服务器可能已经因为自己的原因让<TT CLASS="COMMAND">COPY</TT>失败。
还要注意的是在使用 3.0 版本之前的协议连接时，强制失败的选项是不能用的。）</P><P>如果终止数据发送，则结果为 1，如果发送企图会阻塞（只有在连接是在非阻塞模式的情况下才可能出现这个情况），
则为零，如果发生错误则返回 -1。（如果返回值是 -1，用<CODE CLASS="FUNCTION">PQerrorMessage</CODE>
检索细节。如果值是零，那么等待写准备好然后重新尝试。）</P><P>在成功调用<CODE CLASS="FUNCTION">PQputCopyEnd</CODE>之后，调用<CODE CLASS="FUNCTION">PQgetResult</CODE>获取<TT CLASS="COMMAND">COPY</TT>
命令的最终结果状态。我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-COPY-RECEIVE">31.9.2. 用于接收<TT CLASS="COMMAND">COPY</TT>数据的函数</A></H2><P>这些函数用于在<TT CLASS="LITERAL">COPY TO STDOUT</TT>的过程中检索数据。
如果连接不在<TT CLASS="LITERAL">COPY_OUT</TT>状态，那么他们将会失败。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQGETCOPYDATA"></A><CODE CLASS="FUNCTION">PQgetCopyData</CODE>
</DT><DD><P>在<TT CLASS="LITERAL">COPY_OUT</TT>状态下从服务器接收数据。
</P><PRE CLASS="SYNOPSIS">int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);</PRE><P>
</P><P>在一个<TT CLASS="COMMAND">COPY</TT>的过程中试图从服务器获取另外一行数据。数据总是每次返回一个数据行；
如果只有一部分行可用，那么它不会被返回。成功返回一个数据行包括分配一个内存块来保存这些数据。
<TT CLASS="PARAMETER">buffer</TT>参数必须是非<TT CLASS="SYMBOL">NULL</TT>。<TT CLASS="PARAMETER">*buffer</TT>
设置为指向分配出来的内存的指针，或者是如果没有返回缓冲区，那么为<TT CLASS="SYMBOL">NULL</TT>。
一个非<TT CLASS="SYMBOL">NULL</TT>的结果缓冲区在不再需要的时候必须用<CODE CLASS="FUNCTION">PQfreemem</CODE>释放。</P><P>在成功返回一行之后，那么返回的值就是该数据行里数据的字节数（这个将总是大于零）。
返回的字串总是空结尾的，虽然可能只是对文本的<TT CLASS="COMMAND">COPY</TT>有用。
一个零的结果表示该<TT CLASS="COMMAND">COPY</TT>仍然在处理中，但是还没有可以用的行
（这个只有在<TT CLASS="PARAMETER">async</TT>为真的时候才可能）。一个结果为 -1 的值表示
<TT CLASS="COMMAND">COPY</TT>已经结束。结果为 -2 表示发生了错误（参考<CODE CLASS="FUNCTION">PQerrorMessage</CODE>获取原因）。</P><P>在<TT CLASS="PARAMETER">async</TT>为真的时候（非零），<CODE CLASS="FUNCTION">PQgetCopyData</CODE>将不会阻塞住等待输入；
如果该<TT CLASS="COMMAND">COPY</TT>仍在处理过程中并且没有可用的完整行，那么它将返回零。
（在这种情况下它等待读准备好，然后在再次调用<CODE CLASS="FUNCTION">PQgetCopyData</CODE>之前，
调用<CODE CLASS="FUNCTION">PQconsumeInput</CODE>。）在<TT CLASS="PARAMETER">async</TT>是假（零）的时候，
<CODE CLASS="FUNCTION">PQgetCopyData</CODE>将阻塞住，直到数据可用或者操作完成。</P><P>在<CODE CLASS="FUNCTION">PQgetCopyData</CODE>返回 -1 之后，调用<CODE CLASS="FUNCTION">PQgetResult</CODE>获取
<TT CLASS="COMMAND">COPY</TT>命令的最后结果状态。我们可以用通常的方法等待这个结果可用。然后返回到正常操作。</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-COPY-DEPRECATED">31.9.3. 用于<TT CLASS="COMMAND">COPY</TT>的废弃的函数</A></H2><P>下面的这些函数代表了以前的处理<TT CLASS="COMMAND">COPY</TT>的方法。尽管他们还能用，但是现在已经废弃了，
因为他们的错误处理实在是太糟糕了，并且检测数据结束的方法也很不方便，并且缺少对二进制和非阻塞传输的支持。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQGETLINE"></A><CODE CLASS="FUNCTION">PQgetline</CODE>
</DT><DD><P>读取一个以新行符结尾的字符行（由服务器传输）到一个长度为<TT CLASS="PARAMETER">length</TT>的字符串缓冲区。
</P><PRE CLASS="SYNOPSIS">int PQgetline(PGconn *conn,
              char *buffer,
              int length);</PRE><P>
</P><P>这个函数拷贝最多<TT CLASS="PARAMETER">length</TT>-1个字符到缓冲区里，然后把终止的新行符转换成一个字节零。
<CODE CLASS="FUNCTION">PQgetline</CODE>在输入结束时返回<TT CLASS="SYMBOL">EOF</TT>，如果整行都被读取了返回 0，
如果缓冲区填满了而还没有遇到结束的新行符则返回 1。</P><P>注意，应用程序必须检查新行是否包含两个字符<TT CLASS="LITERAL">\.</TT>，
这表明服务器已经完成了<TT CLASS="COMMAND">COPY</TT>命令的结果的发送。
如果应用可能收到超过<TT CLASS="PARAMETER">length</TT>-1字符长的字符，我们就应该确保正确识别
<TT CLASS="LITERAL">\.</TT>行（例如，不要把一个长的数据行的结束当作一个终止行）。</P></DD><DT><A NAME="LIBPQ-PQGETLINEASYNC"></A><CODE CLASS="FUNCTION">PQgetlineAsync</CODE>
</DT><DD><P>不阻塞地读取一行<TT CLASS="COMMAND">COPY</TT>数据（由服务器传输）到一个缓冲区中。
</P><PRE CLASS="SYNOPSIS">int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);</PRE><P>
</P><P>这个函数类似于<CODE CLASS="FUNCTION">PQgetline</CODE>，但是可以用于那些必须异步读取<TT CLASS="COMMAND">COPY</TT>
数据的应用，也就是不阻塞的应用。在使用了<TT CLASS="COMMAND">COPY</TT>命令和获取了<TT CLASS="LITERAL">PGRES_COPY_OUT</TT>
响应之后，应用应该调用<CODE CLASS="FUNCTION">PQconsumeInput</CODE>和<CODE CLASS="FUNCTION">PQgetlineAsync</CODE>
直到收到数据结束的信号。</P><P>不像<CODE CLASS="FUNCTION">PQgetline</CODE>，这个函数负责检测数据结束。</P><P>在每次调用时，如果<SPAN CLASS="APPLICATION">libpq</SPAN>的输入缓冲区内有可用的一个完整的数据行，
<CODE CLASS="FUNCTION">PQgetlineAsync</CODE>都将返回数据。否则，在其他数据到达之前不会返回数据。
如果见到了拷贝数据结束的标志，此函数返回 -1，如果没有可用数据，
或者是给出一个正数表明返回的数据的字节数，返回 0。如果返回 -1，调用者下一步必须调用
<CODE CLASS="FUNCTION">PQendcopy</CODE>，然后回到正常处理。</P><P>返回的数据将不超过一行的范围。如果可能，每次将返回一个完整行。但如果调用者提供的缓冲区太小，
无法容下服务器发出的整行，那么将返回部分行。对于文本数据，这个可以通过测试返回的最后一个字节是否是
<TT CLASS="LITERAL">\n</TT>来确认。（在二进制<TT CLASS="COMMAND">COPY</TT>中，我们需要对<TT CLASS="COMMAND">COPY</TT>
数据格式进行实际的分析，以便做相同的判断。）返回的字符串不是空结尾的。（如果你想得到一个空结尾的字串，
确保你传递了一个比实际可用空间少一字节的<TT CLASS="PARAMETER">bufsize</TT>。）</P></DD><DT><A NAME="LIBPQ-PQPUTLINE"></A><CODE CLASS="FUNCTION">PQputline</CODE>
</DT><DD><P>向服务器发送一个空结尾的字符串。成功时返回 0，如果不能发送字符串返回<TT CLASS="SYMBOL">EOF</TT>。
</P><PRE CLASS="SYNOPSIS">int PQputline(PGconn *conn,
              const char *string);</PRE><P>
</P><P>一系列<CODE CLASS="FUNCTION">PQputline</CODE>调用发送的<TT CLASS="COMMAND">COPY</TT>数据流和
<CODE CLASS="FUNCTION">PQgetlineAsync</CODE>返回的数据有着一样的格式，只是应用不需要明确地在每次
<CODE CLASS="FUNCTION">PQputline</CODE>调用中发送一个数据行；每次调用发送多行或者部分行都是可以的。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>协议3.0之前，应用必须明确的发送两个字符<TT CLASS="LITERAL">\.</TT>
作为行结束，向服务器表明它已经完成了发送<TT CLASS="COMMAND">COPY</TT>数据。虽然这个仍然工作，
但是已经废弃了，并且<TT CLASS="LITERAL">\.</TT>的特殊含义在将来的版本中有望删除。
在发送实际数据之后调用<CODE CLASS="FUNCTION">PQendcopy</CODE>就足够了。</P></BLOCKQUOTE></DIV></DD><DT><A NAME="LIBPQ-PQPUTNBYTES"></A><CODE CLASS="FUNCTION">PQputnbytes</CODE>
</DT><DD><P>向服务器发送一个非空结尾的字符串。成功时返回 0，如果不能发送字符串返回<TT CLASS="SYMBOL">EOF</TT>。
</P><PRE CLASS="SYNOPSIS">int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);</PRE><P>
</P><P>此函数类似<CODE CLASS="FUNCTION">PQputline</CODE>，除了数据缓冲区不需要是空结尾的之外，
因为要发送的字节数是直接声明的。在发送二进制数据的时候使用这个过程。</P></DD><DT><A NAME="LIBPQ-PQENDCOPY"></A><CODE CLASS="FUNCTION">PQendcopy</CODE>
</DT><DD><P>与服务器同步。
</P><PRE CLASS="SYNOPSIS">int PQendcopy(PGconn *conn);</PRE><P>
这个函数将等待直到服务器完成拷贝。你可以在用<CODE CLASS="FUNCTION">PQputline</CODE>
向服务器发送完最后一个字符串后或者用<CODE CLASS="FUNCTION">PGgetline</CODE>
从服务器获取最后一行字符串后调用它。我们必须调用这个函数，否则服务器可能会和前端
<SPAN CLASS="QUOTE">"不同步"</SPAN>。在这个函数返回后，服务器就已经准备好接收下一个 SQL 命令了。
成功时返回0，否则返回非零值。（如果返回值为非 0，用<CODE CLASS="FUNCTION">PQerrorMessage</CODE>检索细节。）</P><P>在使用<CODE CLASS="FUNCTION">PQgetResult</CODE>时，应用应该对<TT CLASS="LITERAL">PGRES_COPY_OUT</TT>
的结果做出反应：重复调用<CODE CLASS="FUNCTION">PQgetline</CODE>，并且在收到结束行时调用
<CODE CLASS="FUNCTION">PQendcopy</CODE>。然后应该返回到<CODE CLASS="FUNCTION">PQgetResult</CODE>
循环直到<CODE CLASS="FUNCTION">PQgetResult</CODE>返回空指针。类似地，<TT CLASS="LITERAL">PGRES_COPY_IN</TT>
结果是用一系列<CODE CLASS="FUNCTION">PQputline</CODE>调用最后跟着<CODE CLASS="FUNCTION">PQendcopy</CODE>，
然后返回到<CODE CLASS="FUNCTION">PQgetResult</CODE>循环。这样的排列将保证嵌入到一系列
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令里的<TT CLASS="COMMAND">COPY</TT>命令将被正确执行。</P><P>旧的应用大多通过<CODE CLASS="FUNCTION">PQexec</CODE>提交一个<TT CLASS="COMMAND">COPY</TT>
命令并且假设在<CODE CLASS="FUNCTION">PQendcopy</CODE>后事务完成。这样只有在<TT CLASS="COMMAND">COPY</TT>
是命令字串里的唯一的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令时才能正确工作。</P></DD></DL></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-notify.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-control.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">异步通知</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">控制函数</TD></TR></TABLE></DIV></BODY></HTML>
