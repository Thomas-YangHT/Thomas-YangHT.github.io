<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>日志传送备份服务器</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="高可用性与负载均衡，复制" HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html"><LINK REL="PREVIOUS" TITLE="不同解决方案的比较" HREF="different-replication-solutions.html"><LINK REL="NEXT" TITLE="失效切换" HREF="warm-standby-failover.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/high-availability.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="不同解决方案的比较" HREF="different-replication-solutions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 25. 高可用性与负载均衡，复制</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="失效切换" HREF="warm-standby-failover.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="WARM-STANDBY">25.2. 日志传送备份服务器</A></H1><P> 连续归档可以配合随时准备取代失效主服务器的一个或多个<I CLASS="FIRSTTERM">备份服务器</I>，
用于创建一个<I CLASS="FIRSTTERM">高可用性</I>(HA)集群。
这个能力通常被称为<I CLASS="FIRSTTERM">热备份</I>或<I CLASS="FIRSTTERM">日志传送</I>。</P><P> 虽然主服务器和备份服务器只是松散的耦合在一起，
但它们必须同时运行。主服务器以连续归档模式运行，
备份服务器以连续恢复模式运行并从主服务器不停的读取WAL文件。
因为数据库的表无需为此进行任何改变，所以与其它复制方法相比，
额外的管理开销很小。并且这种方法对主服务器的性能影响也很小。</P><P> 直接从一个数据库服务器移动WAL到另一个服务器通常被称为日志传送(LogShipping)。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>实现了基于文件的日志传送，
意思是WAL记录每次移动一个完整的文件(WAL段)。
WAL文件（16MB）可以被轻易的在任意两个地点之间传送，
不管是与邻近的系统还是地球另一面的系统。
所需带宽取决于主服务器的事务发生速度。
基于记录的日志传送更加细粒度，并且WAL流在网络连接中增量改变。</P><P> 日志传送是异步的，也就是WAL记录在事务提交之后才被传送。
也就是说主服务器遭遇致命故障后尚未传送的事务数据将会丢失。
数据丢失的长度可以使用<TT CLASS="VARNAME">archive_timeout</TT>加以限制，比如限制为几秒钟。
当然这么小的设置也导致了传送带宽的大幅增长。
流复制（参阅<A HREF="warm-standby.html#STREAMING-REPLICATION">第 25.2.5 &#33410;</A>）允许数据丢失的更小窗口。</P><P> 恢复性能足够好，备份服务器一旦被激活通常只有很短的时间不能使用。
因此，我们认为这个方案可以作为热备份来提供高可用性。
将服务器从一个已归档的基础备份中恢复将可能耗费大量时间，
所以这个方案只能用于灾难恢复而不能用于提供高可用性。
备用服务器还可以用于只读查询，在这种情况下它被称为热备份服务器。
参见<A HREF="hot-standby.html">第 25.5 &#33410;</A>获取更多信息。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="STANDBY-PLANNING">25.2.1. 规划</A></H2><P> 至少从数据库服务器的角度看，
创建主服务器和备份服务器并令两者尽可能完全相同是非常明智的。
特别是表空间的路径名必须保持完全一致，
这样主服务器和备份服务器就必须拥有同样的表空间挂载路径(如果使用了表空间的话)。
需要记住的是如果在主服务器上执行了<A HREF="sql-createtablespace.html">CREATE TABLESPACE</A>命令，
那么该命令需要的任何新挂载点必须在执行该命令之前同时在主服务器和备份服务器
上创建。 硬件不必完全相同，但是经验显示维护两个完全相同的系统比维护两
个不同的系统要少许多麻烦。 无论如何，应尽量保持体系结构相同&mdash;
比如一个是32-bit系统另一个是64-bit系统将不能正常工作。</P><P> 通常，在主<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>版本不同的服务器之间传送日志是不可能的，
它是PostgreSQL全球开发组在次要版本升级中不能改变磁盘格式的一种策略。
在主服务器和备份服务器上运行不同的次要版本可能成功。
但是，没有正式支持，建议你尽可能的保持主服务器和备用服务器在同一个级别上。
在进行版本升级的时候，正确的做法是首先升级备份服务器&mdash;
因为新版本的服务器通常可以读取老版本的WAL文件，但反之则不然。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="STANDBY-SERVER-OPERATION">25.2.2. 备用服务器操作</A></H2><P> 在备用模式，该服务器连续应用从主服务器收取的WAL。
备服务器可以从一个WAL归档（参阅<A HREF="archive-recovery-settings.html#RESTORE-COMMAND">restore_command</A>）
或直接通过一个TCP连接（流复制）从主服务器上读取WAL。
备服务器也可以在备用集群<TT CLASS="FILENAME">pg_xlog</TT>尝试查找恢复任何WAL。
这通常发生在服务器重启后，当备服务器重播，在备服务器重启前，
从主服务器流复制的WAL，但是你也可以手工复制文件到<TT CLASS="FILENAME">pg_xlog</TT>，
在任何时候可以重播它们。</P><P> 在启动，备服务器恢复可用在所有的WAL开始存档位置,调用<TT CLASS="VARNAME">restore_command</TT>。
一旦它到达可用WAL的结束，<TT CLASS="VARNAME">restore_command</TT>失败，
将尝试恢复<TT CLASS="FILENAME">pg_xlog</TT>目录下任何可用的WAL。
如果那也失败了，并且已经配置了流复制，则尝试连接到主服务器，
从在归档或<TT CLASS="FILENAME">pg_xlog</TT>找到最后一条有效的记录开始WAL流。如果那也失败了，
或没有配置流复制，或连接断开，备服务器再次回到步骤1，循环尝试从归档里恢复文件。
从归档，<TT CLASS="FILENAME">pg_xlog</TT>，通过连续流复制直到服务器停止或有触发器文件触发的失效切换时。</P><P> 当运行<TT CLASS="COMMAND">pg_ctl promote</TT>时，或者找到一个触发文件（<TT CLASS="VARNAME">trigger_file</TT>）时，
退出备用模式并且服务器切换到正常运行。
在失效切换前，将立即恢复归档或<TT CLASS="FILENAME">pg_xlog</TT>任何可用的WAL，
但不做尝试连接主服务器。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PREPARING-MASTER-FOR-STANDBY">25.2.3. 为备用服务器准备主服务器</A></H2><P> 在主服务器上设置连续归档到一个备服务器可访问的存档目录，
正如<A HREF="continuous-archiving.html">第 24.3 &#33410;</A>所描述的。即使主服务器关掉，
从备服务器应该可以访问这个归档位置。
即它应该驻留在被服务器自身或其它可信赖的服务器，
而不是主服务器。</P><P> 如果你想使用流复制，在主服务器上设置认证，允许从备用服务器复制连接；
在<TT CLASS="FILENAME">pg_hba.conf</TT>提供一个或多个合适项使用数据库字段设置<TT CLASS="LITERAL">replication</TT>。
还要在主服务器的配置文件确保设置<TT CLASS="VARNAME">max_wal_senders</TT>足够大。</P><P> 启动备用服务器做一个基准备份，参见<A HREF="continuous-archiving.html#BACKUP-BASE-BACKUP">第 24.3.2 &#33410;</A>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="STANDBY-SERVER-SETUP">25.2.4. 建立备用服务器</A></H2><P> 要建立备用服务器，从主服务器恢复基准备份（参阅<A HREF="continuous-archiving.html#BACKUP-PITR-RECOVERY">第 24.3.4 &#33410;</A>）。
在备用服务器的集群数据目录，创建一个恢复命令文件<TT CLASS="FILENAME">recovery.conf</TT>,
开启<TT CLASS="VARNAME">standby_mode</TT>。设置<TT CLASS="VARNAME">restore_command</TT>
为一条从WAL归档复制文件的简单命令。如果为了高可用性目的计划有多个备用服务器，
设置<TT CLASS="VARNAME">recovery_target_timeline</TT>为<TT CLASS="LITERAL">latest</TT>，
使得备用服务器按照发生故障转移到另一个备用服务器的时间变化。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 不要使用内置在这里描述的备用模式pg_standby或类似的工具。
如果该文件不存在，<TT CLASS="VARNAME">restore_command</TT>应该立即返回。
如果必要服务器将再次尝试这个命令。
关于使用工具像pg_standby的详情参阅<A HREF="log-shipping-alternative.html">第 25.4 &#33410;</A>。</P></BLOCKQUOTE></DIV><P> 如果你想使用流复制，在<TT CLASS="VARNAME">primary_conninfo</TT>填写一个libpq连接串，
其包括主机名（或IP地址）和连接到主服务器需要的其它详细信息。
如果主服务器需要个密码验证，也要在<TT CLASS="VARNAME">primary_conninfo</TT>指定所需要的密码。</P><P> 如果你要建立高可用目的备服务器，设置WAL归档，
像主服务器的连接和身份验证，因为在失效切换后，
备服务器要作为主服务器运行。</P><P> 如果你使用WAL归档，其大小可以使用<A HREF="archive-recovery-settings.html#ARCHIVE-CLEANUP-COMMAND">archive_cleanup_command</A>这个参数设置最小
，用来删除那些备服务器不再需要的文件。
专门设计的<SPAN CLASS="APPLICATION">pg_archivecleanup</SPAN>这个实用程序就是在通常的单备配置里，
使用<TT CLASS="VARNAME">archive_cleanup_command</TT>的。参阅<A HREF="pgarchivecleanup.html"><SPAN CLASS="APPLICATION">pg_archivecleanup</SPAN></A>。
请注意，如果你使用备份目的归档，
你仍要保留需要恢复的至少最新的基准备份文件，
即使备服务器不再需要。</P><P>
<TT CLASS="FILENAME">recovery.conf</TT>的一个简单例子：
</P><PRE CLASS="PROGRAMLISTING">standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'</PRE><P>
</P><P> 你可能有任何数目的备服务器，但是如果你用流复制，
确保你在主服务器上设置的<TT CLASS="VARNAME">max_wal_senders</TT>足够大允许它们同时连接。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="STREAMING-REPLICATION">25.2.5. 流复制</A></H2><P> 与基于文件日志传送相比，流复制允许保持备服务器更新。
备服务器连接主服务器，其产生的流WAL记录到备服务器，
而不需要等待填写WAL文件。</P><P> 流复制是异步的，参阅<A HREF="warm-standby.html#SYNCHRONOUS-REPLICATION">第 25.2.7 &#33410;</A>，
在主服务器上提交事务和备用服务器上变化可见之间有一个小的延迟。
这个延迟远小于基于文件日志传送，通常1秒内足够与负载保持。
使用流复制，为减少数据丢失窗口<TT CLASS="VARNAME">archive_timeout</TT>不是必要的。</P><P> 如果使用流复制而不是基于文件连续归档，
你要在主服务器设置<TT CLASS="VARNAME">wal_keep_segments</TT>为一个足够大的值以使不太早的回收旧WAL段，
当备服务器可能仍需要它们赶上。如果备服务器落后太多，
需要用一个新基准备份重新初始化。如果你设置一个备服务器可访问的WAL归档，
<TT CLASS="VARNAME">wal_keep_segments</TT>是不必要的，
作为备服务器总是使用归档来赶上。</P><P> 要使用流复制，建立一个基于文件的日志传送备服务器描述在<A HREF="warm-standby.html">第 25.2 &#33410;</A>。
该步将一个基于文件的日志传送备服务器转为流复制备服务器，
在<TT CLASS="FILENAME">recovery.conf</TT>文件中设置<TT CLASS="VARNAME">primary_conninfo</TT>指向主服务器。
在主服务器上设置<A HREF="runtime-config-connection.html#GUC-LISTEN-ADDRESSES">listen_addresses</A>和身份验证选项
（参阅<TT CLASS="FILENAME">pg_hba.conf</TT>），
因此备用服务器可以连接到在主服务器的<TT CLASS="LITERAL">replication</TT>伪数据库
（参阅<A HREF="warm-standby.html#STREAMING-REPLICATION-AUTHENTICATION">第 25.2.5.1 &#33410;</A>）。</P><P> 系统上支持保持活动的套接字选项，
设置<A HREF="runtime-config-connection.html#GUC-TCP-KEEPALIVES-IDLE">tcp_keepalives_idle</A>,
<A HREF="runtime-config-connection.html#GUC-TCP-KEEPALIVES-INTERVAL">tcp_keepalives_interval</A>和
<A HREF="runtime-config-connection.html#GUC-TCP-KEEPALIVES-COUNT">tcp_keepalives_count</A>
帮助主机及时发现断开的连接。</P><P> 设置备用服务器的最大并发连接数。
（参阅<A HREF="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</A>获取更多详细信息）。</P><P> 当启动了备服务器并且正确设置了<TT CLASS="VARNAME">primary_conninfo</TT>,
该备服务器在回放所有可用的WAL文件后，将连接到主服务器。如果成功建立了该连接，
你将在备服务器中看到WAL接收进程，并且在主服务器相应的一个WAL发送进程。</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="STREAMING-REPLICATION-AUTHENTICATION">25.2.5.1. 身份验证</A></H3><P> 复制的访问权限设置是很重要的，所以只有受信任的用户可以读取WAL流，
因为很容易从中提取权限信息。备服务器必须验证作为主服务器的超级用户或者有
<TT CLASS="LITERAL">REPLICATION</TT>权限的用户。
建议为复制创建一个带有<TT CLASS="LITERAL">REPLICATION</TT>和<TT CLASS="LITERAL">LOGIN</TT>权限的专有用户账号。
当<TT CLASS="LITERAL">REPLICATION</TT>权限有很高权限时，不允许用户修改主服务器上的任何数据，
其中<TT CLASS="LITERAL">SUPERUSER</TT>就是这样的。</P><P>
由一条<TT CLASS="FILENAME">pg_hba.conf</TT>记录指定<TT CLASS="LITERAL">replication</TT>在<TT CLASS="REPLACEABLE"><I>database</I></TT>字段，
控制客户端的复制验证。例如，如果备服务器是运行在主机IP <TT CLASS="LITERAL">192.168.1.100</TT>和复制时超级用户名为<TT CLASS="LITERAL">foo</TT>，
管理员可以在主服务器<TT CLASS="FILENAME">pg_hba.conf</TT>文件里添加下面行：
</P><PRE CLASS="PROGRAMLISTING"># Allow the user "foo" from host 192.168.1.100 to connect to the primary
# as a replication standby if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5</PRE><P>
</P><P>
主服务器的主机名和端口号，连接用户名，和在<TT CLASS="FILENAME">recovery.conf</TT>文件指定的密码。
该密码也可以在备服务器的<TT CLASS="FILENAME">~/.pgpass</TT>文件里设置。
（在<TT CLASS="REPLACEABLE"><I>database</I></TT>字段指定<TT CLASS="LITERAL">replication</TT>）。例如，
如果主服务器是运行的主机IP <TT CLASS="LITERAL">192.168.1.50</TT>,端口号<TT CLASS="LITERAL">5432</TT>,
复制时用户名为<TT CLASS="LITERAL">foo</TT>，和密码为<TT CLASS="LITERAL">foopass</TT>，
管理员可以在备服务的<TT CLASS="FILENAME">recovery.conf</TT>文件里添加下面行：
</P><PRE CLASS="PROGRAMLISTING"># The standby connects to the primary that is running on host 192.168.1.50
# and port 5432 as the user "foo" whose password is "foopass".
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="STREAMING-REPLICATION-MONITORING">25.2.5.2. 监控</A></H3><P> 流复制的一个重要的健康指标是在主服务器生成的WAL记录数，
而不是在备服务器应用的数量。通过比较在主服务器当前WAL写的位置和备服务器收到
的最后一个WAL位置，就可以计算出这种滞后。
在主服务器上使用<CODE CLASS="FUNCTION">pg_current_xlog_location</CODE>和在备服务器上使用
<CODE CLASS="FUNCTION">pg_last_xlog_receive_location</CODE>可以分别检索到它们
（参阅<A HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE">&#34920; 9-60</A>和
<A HREF="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE">&#34920; 9-61</A>关于详细信息）。
在备服务器收到最后的WAL位置也会进程状态的WAL接收进程显示，
使用<TT CLASS="COMMAND">ps</TT>命令显示（参阅<A HREF="monitoring-ps.html">第 27.1 &#33410;</A>关于详细信息）。</P><P> 你可以通过<A HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"> <TT CLASS="LITERAL">pg_stat_replication</TT></A>视图回收WAL发送程序列表。
在<CODE CLASS="FUNCTION">pg_current_xlog_location</CODE>和<TT CLASS="LITERAL">sent_location</TT>字段之间的不同可能表明
主服务器在大负载下，而备库上<TT CLASS="LITERAL">sent_location</TT>和
<CODE CLASS="FUNCTION">pg_last_xlog_receive_location</CODE>的不同可能表明网络延迟，或者备库也处于重大负载之下。 </P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="CASCADING-REPLICATION">25.2.6. Cascading Replication</A></H2><P> 级联复制功能允许备用服务器接受复制连接和到其他备库的流WAL记录，充当延迟。
这可以用来降低直接连接主库的数量，同时也尽量减少站点间的带宽开销。</P><P> 同时充当接收器和发送器的待机称为级联
待机状态。更直接地连接到主库的备库作为上游服务器已知，
而备用服务器较远的下游服务器。级联复制不放在数量限制或
下游服务器的安排，虽然每个备库连接到一个上流服务器，
而最终链接到一个单一的主/主服务器。</P><P> 级联备库不仅仅发送来自主库的WAL记录，而且来自归档的记录。
因此即使一些上流连接的复制连接终止，
连接复制继续往下只要有新的WAL记录可用。</P><P> 级联复制当前是异步的，同步复制（参阅<A HREF="warm-standby.html#SYNCHRONOUS-REPLICATION">第 25.2.7 &#33410;</A>）设置当前不影响级联复制。</P><P> 热备用反馈传播到上游，无论级联配置。</P><P> 如果上游备用服务器上升成为新主库，下游服务器将继续流向新主库，
如果<TT CLASS="VARNAME">recovery_target_timeline</TT>设置为<TT CLASS="LITERAL">'latest'</TT>。</P><P> 使用级联复制，建立连锁备库从而接受复制连接（即设置
<A HREF="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</A>和<A HREF="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</A>，
以及配置<A HREF="auth-pg-hba-conf.html">host-based authentication</A>）。
在下游备库指向级联备库中你还需要设定<TT CLASS="VARNAME">primary_conninfo</TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SYNCHRONOUS-REPLICATION">25.2.7. 同步复制</A></H2><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>流复制缺省是异步的。如果主服务器崩溃，然后一些事务承诺不得不
复制到备用服务器，造成数据丢失。数据丢失量是与故障转移时的复制延迟是成比例的。</P><P> 同步复制提供确认所有变化已经由事务转移到一个同步备用服务器的能力。
这延伸一个事务提交的耐久性标准。
这种级别的保护是指2-安全复制的计算机科学理论。</P><P> 当请求同步复制，每次提交的写事务将等待直到确认收到提交已被写入到主库和备用服务器磁盘上的事务日志。
这些数据丢失的可能性是如果主库和备库同一时间遭受崩溃。
这可以提供一个更高层次的耐久性，但如果系统管理员对两个服务器的安置和管理非常谨慎。
等待确认增加用户的信心，在服务器崩溃的情况下更改将不会丢失，而是增加请求事务的响应时间。
最小等待时间是主库到备库的往返时间。</P><P> 只读事务和事务回滚不需要等待从备用服务器的回复。
子事务提交不等待从备用服务器的响应，只有顶级提交。
长时间运行动作如加载数据或索引建立不等待直到最后提交信息。
所有的两阶段提交的行动需要提交等待，包括准备和提交。</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SYNCHRONOUS-REPLICATION-CONFIG">25.2.7.1. 基础配置</A></H3><P> 一旦流复制已配置，配置同步复制仅需要一个额外的配置步骤：
<A HREF="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES">synchronous_standby_names</A>必须设置为
一个非空值。<TT CLASS="VARNAME">synchronous_commit</TT>也必须设置为<TT CLASS="LITERAL">on</TT>，
但因为这是默认值，通常是没有改变的。
（参见<A HREF="runtime-config-wal.html#RUNTIME-CONFIG-WAL-SETTINGS">第 18.5.1 &#33410;</A>和
<A HREF="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-MASTER">第 18.6.2 &#33410;</A>）。
这种配置将导致每次提交会等待确认备库书面提交记录到持久存储。
<TT CLASS="VARNAME">synchronous_commit</TT>可以由个人用户设置，
所以它可以被配置在配置文件中，特别是
用户或数据库中，或动态的应用程序中，
以保证每个事务的基础上控制耐久性。</P><P> 一个提交记录已被写入到主库磁盘上，WAL记录随后被发送到待机状态。
每次一批新的WAL数据被写入磁盘时待机发送答复消息，
除非<TT CLASS="VARNAME">wal_receiver_status_interval</TT>在待机状态设置为零。
如果待机是第一个匹配的待机，
在主库上指定<TT CLASS="VARNAME">synchronous_standby_names</TT>，
从待机状态得到的答复信息将被用于唤醒用户的提交记录已被接收的等待确认。
这些参数允许管理员指定哪些备用服务器应同步备用。
注意，同步的配置复制主要针对主服务器。
命名的备用服务器必须直接连接到主库上;主库并不了解下游待机使用级联复制的服务器。</P><P> 设置<TT CLASS="VARNAME">synchronous_commit</TT>到<TT CLASS="LITERAL">remote_write</TT>将
导致每个提交等待确认备库已经收到提交记录并且写入到自己的操作系统，
但不是为了该数据被刷新到磁盘上的备份。
这个设置提供了耐用性较弱保证对比<TT CLASS="LITERAL">on</TT>：
在待机状态下可能会失去操作系统崩溃时的数据，
虽然不是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>崩溃。
然而，这是在实践中有用的设置，因为它可以减少事务响应时间。
如果主库和备库崩溃，并且主库的数据库同时被破坏了，只能发生数据丢失。</P><P> 如果要求快速关机，用户将停止等待。然而，作为使用异步复制的时候，服务器将不完全
关闭直到所有WAL记录转移到目前连接的备用服务器。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SYNCHRONOUS-REPLICATION-PERFORMANCE">25.2.7.2. 规划性能</A></H3><P> 同步复制通常需要仔细规划并且放置备用服务器，确保应用程序执行性能。等待
没有充分利用系统资源，但事务锁继续直到确认转移。作为一个结果，
不小心的使用同步复制会降低数据库应用性能，由于响应时间的增加和更高的竞争。</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许应用程序开发人员通过复制来指定所需的耐久性水平。这可以
对系统的总体说明，虽然它也可以被指定为特定用户或连接，甚至个别交易。</P><P> 例如，一个应用程序的任务可能包括：10%的变化是重要的客户资料，而
90%的变化是不太重要的数据，如果它丢失，企业还可以更好生存，比如用户之间的聊天信息。</P><P> 在应用水平（主库）指定同步复制选项，我们可以为大多数重要的变化提供同步复制
，没有放缓总工作量体积。对于允许同步复制的高性能应用的效益来说，
应用程序级别的选项是一个重要而实用的工具。</P><P> 你应该考虑到网络带宽必须大于WAL数据生成率。</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="SYNCHRONOUS-REPLICATION-HA">25.2.7.3. 高可用性规划</A></H3><P> 当<TT CLASS="VARNAME">synchronous_commit</TT>设置为<TT CLASS="LITERAL">on</TT>
或者<TT CLASS="LITERAL">remote_write</TT>将等待直到同步备用响应，则进行提交。
如果最后，或只发生待机崩溃，则响应不会发生。</P><P> 为避免数据丢失最好的办法是确保你不会失去你最后的同步备份。
这可以通过使用<TT CLASS="VARNAME">synchronous_standby_names</TT>命名多个
潜在的同步备用实现。
第一个命名的备库将作为同步备库使用。如果第一个失败，
则备用列表将接管同步备用角色。</P><P> 当一个备库首先依附在主库时，不能正确地同步。
这是<TT CLASS="LITERAL">catchup</TT>方式所描述的。
一旦备库和主库之间的滞后达到零，第一次我们将实时状态<TT CLASS="LITERAL">流</TT>。
备库被创建后，持续追赶时间可能长。如果备库关闭，
然后追赶时期将随着待机时间长度而增加。
一旦已经达到<TT CLASS="LITERAL">流</TT>状态，备库是唯一能够成为同步备用。</P><P> 如果主库启动而提交等待确认，这些等待事务将被标记为完全提交，一旦主数据库恢复。
没有办法确保在主库崩溃的时候所有备库收到所有优秀的WAL数据。
一些事务可能不会在待机时显示提交，即使他们表现为主库已提交。
我们提供的保障是应用程序将不会接收事务成功提交的明确承认，
直到被备库安全接收WAL数据是已知的。 </P><P> 如果你真的失去了你最后的备用服务器，你应该禁用
<TT CLASS="VARNAME">synchronous_standby_names</TT>并且在主服务器
重新加载配置文件。</P><P> 如果主库是从剩余备用服务器分离的，
你应该故障转移到那些其他剩余备用服务器的最佳人选。</P><P> 如果你需要重新创建备用服务器，当等待事务时，确保pg_start_backup()和
pg_stop_backup()在带有<TT CLASS="VARNAME">synchronous_commit</TT> = <TT CLASS="LITERAL">off</TT>的回话中运行，
否则这些请求将永远等待备库出现。</P></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="different-replication-solutions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="warm-standby-failover.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">不同解决方案的比较</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">失效切换</TD></TR></TABLE></DIV></BODY></HTML>
