<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>使用EXPLAIN</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="性能提升技巧" HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html"><LINK REL="PREVIOUS" TITLE="性能提升技巧" HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html"><LINK REL="NEXT" TITLE="规划器使用的统计信息" HREF="planner-stats.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/perform.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="性能提升技巧" HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 14. 性能提升技巧</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="规划器使用的统计信息" HREF="planner-stats.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="USING-EXPLAIN">14.1. 使用<TT CLASS="COMMAND">EXPLAIN</TT></A></H1><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对每个查询产生一个<I CLASS="FIRSTTERM">查询规划</I>。
为匹配查询结构和数据属性选择正确的规划对性能绝对有关键性的影响。
因此系统包含了一个复杂的规划器用于寻找最优的规划。
你可以使用<A HREF="sql-explain.html">EXPLAIN</A>命令察看规划器为每个查询生成的查询规划是什么。
阅读查询规划是一门值得专门写一厚本教程的学问，但是这部分试图掩盖这些基本信息。</P><P> 本节的例子是从数据库执行<TT CLASS="COMMAND">VACUUM ANALYZE</TT>之后的回归测试中提取的，使用9.3开发源。
如果你尝试自己的例子，你应该可以得到类似结果，但你的估计成本及行数可能会略有不同，因为
<TT CLASS="COMMAND">ANALYZE</TT>的统计数据是随机样本，而不是确切的，并且因为成本本身有点依赖于平台。</P><P> 该示例使用<TT CLASS="COMMAND">EXPLAIN</TT>的缺省<SPAN CLASS="QUOTE">"文本"</SPAN>输出格式，
它结构紧凑，便于人们阅读。如果你想为进一步分析提供<TT CLASS="COMMAND">EXPLAIN</TT>输出给程序，
你应该使用它的机器可读的输出格式之一(XML, JSON, or YAML)来代替。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="USING-EXPLAIN-BASICS">14.1.1. <TT CLASS="COMMAND">EXPLAIN</TT>基础</A></H2><P> 查询规划的结构是一个<I CLASS="FIRSTTERM">规划节点</I>的树。最底层的节点是表扫描节点：
它们从表中返回原始数据行。不同的表访问模式有不同的扫描节点类型：
顺序扫描、索引扫描、位图索引扫描。
也有非表行来源，如<TT CLASS="LITERAL">VALUES</TT>子句和<TT CLASS="LITERAL">FROM</TT>中的设置返回函数，
其中有他们自己的扫描节点类型。
如果查询需要连接、聚集、排序、或者对原始行的其它操作，
那么就会在扫描节点之上有其它额外的节点。并且，做这些操作通常都有多种方法，
因此在这些位置也有可能出现不同的节点类型。<TT CLASS="COMMAND">EXPLAIN</TT>给规划树中每个节点都输出一行，
显示基本的节点类型和规划器为执行这个规划节点预计的开销值。
其他行可能会出现，从节点的汇总行缩进，以显示节点的附加属性。
第一行(最上层的汇总行节点)是对该规划的总执行开销的预计；这个数值就是规划器试图最小化的数值</P><P>
这里是一个简单的例子，只是用来显示输出会有些什么内容：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)</PRE><P>
</P><P>
由于此查询没有<TT CLASS="LITERAL">WHERE</TT>子句，它必须扫描所有表的行，所以规划器已经选择使用一个简单的顺序扫描计划。
括号中引用的数值是（从左到右）:
<P></P></P><UL><LI><P>
预计的启动开销。在输出扫描开始之前消耗的时间，也就是在一个排序节点里执行排序的时间。
</P></LI><LI><P> 预计总开销。这是假设所规定的，计划节点运行完成，即所有可用行被检索。
在实践中一个节点的父节点可能会很快停止读取所有可用的行（参见<TT CLASS="LITERAL">LIMIT</TT>下面的例子）。</P></LI><LI><P> 预计这个规划节点输出的行数。同样，只执行到完成为止。</P></LI><LI><P> 预计这个规划节点的行平均宽度(以字节计算)。</P></LI></UL><P>
</P><P> 开销是用规划器根据成本参数(参见节<A HREF="runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS">第 18.7.2 &#33410;</A>)捏造的单位来衡量的，
习惯上以磁盘页面抓取为单位。
也就是<A HREF="runtime-config-query.html#GUC-SEQ-PAGE-COST">seq_page_cost</A>将被按照习惯设为<TT CLASS="LITERAL">1.0</TT>(一次顺序的磁盘页面抓取)，
其它开销参数将参照它来设置。本节的例子都假定这些参数使用默认值。</P><P> 有一点很重要：一个上层节点的开销包括它的所有子节点的开销。还有一点也很重要：
这个开销只反映规划器关心的东西，尤其是没有把结果行传递给客户端的时间考虑进去，
这个时间可能在实际的总时间里占据相当重要的分量，但是被规划器忽略了，
因为它无法通过修改规划来改变：我们相信，每个正确的规划都将输出同样的记录集。</P><P> <TT CLASS="LITERAL">行</TT>值有一些小技巧，因为它不是规划节点处理/扫描过的行数，
而是节点发射数目。通常会少于扫描数，正如应用于此节点上的任意<TT CLASS="LITERAL">WHERE</TT>子句条件的过滤结果。通常而言，
顶层的行预计会接近于查询实际返回、更新、删除的行数。</P><P>
回到我们的例子：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)</PRE><P>
</P><P>
这些数字的获得非常直截了当。如果你这样做：
</P><PRE CLASS="PROGRAMLISTING">SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';</PRE><P>
你会发现<CODE CLASS="CLASSNAME">tenk1</CODE>有 358 磁盘页面和 10000 行。
估计成本作为（磁盘页面读取*<A HREF="runtime-config-query.html#GUC-SEQ-PAGE-COST">seq_page_cost</A>）+（行扫描*<A HREF="runtime-config-query.html#GUC-CPU-TUPLE-COST">cpu_tuple_cost</A>）被计算。默认情况下，
<TT CLASS="VARNAME">seq_page_cost</TT>是1.0，<TT CLASS="VARNAME">cpu_tuple_cost</TT>是0.01,
因此估计成本为(358 * 1.0) + (10000 * 0.01) = 458。
</P><P>
现在让我们修改查询并增加一个<TT CLASS="LITERAL">WHERE</TT>条件：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000;

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)
   Filter: (unique1 &lt; 7000)</PRE><P>
请注意<TT CLASS="COMMAND">EXPLAIN</TT>输出显示<TT CLASS="LITERAL">WHERE</TT>子句当作一个<SPAN CLASS="QUOTE">"filter"</SPAN>条件附属于顺序扫描计划节点。
这意味着规划节点为它扫描的每一行检查该条件，并且只输出符合条件的行。
预计的输出行数降低了，因为有<TT CLASS="LITERAL">WHERE</TT>子句。不过，扫描仍将必须访问所有 10000 行，
因此开销没有降低；实际上它还增加了一些（确切的说，通过10000 * <A HREF="runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</A>）以反映检查<TT CLASS="LITERAL">WHERE</TT>条件的额外CPU时间。
</P><P> 这条查询实际选择的行数是7000 ，但是预计的<TT CLASS="LITERAL">行数</TT>只是个大概。如果你试图重复这个试验，
那么你很可能得到不同的预计。还有，这个预计会在每次<TT CLASS="COMMAND">ANALYZE</TT>命令之后改变，
因为<TT CLASS="COMMAND">ANALYZE</TT>生成的统计是从该表中随机抽取的样本计算的。</P><P>
把查询限制条件改得更严格一些：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100;

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.07..229.20 rows=101 width=244)
   Recheck Cond: (unique1 &lt; 100)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
         Index Cond: (unique1 &lt; 100)</PRE><P>
这里，规划器决定使用两步的规划：最底层的规划节点访问一个索引，找出匹配索引条件的行的位置，
然后上层规划节点真实地从表中抓取出那些行。独立地抓取数据行比顺序地读取它们的开销高很多，
但是因为并非所有表的页面都被访问了，这么做实际上仍然比一次顺序扫描开销要少。
使用两层规划的原因是因为上层规划节点把索引标识出来的行位置在读取它们之前按照物理位置排序，
这样可以最小化独立抓取的开销。节点名称里面提到的<SPAN CLASS="QUOTE">"bitmap"</SPAN>是进行排序的机制。
</P><P>
现在让我们添加另外一个条件到<TT CLASS="LITERAL">WHERE</TT>子句：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND stringu1 = 'xxx';

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.04..229.43 rows=1 width=244)
   Recheck Cond: (unique1 &lt; 100)
   Filter: (stringu1 = 'xxx'::name)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
         Index Cond: (unique1 &lt; 100)</PRE><P>
新增的条件<TT CLASS="LITERAL">stringu1 = 'xxx'</TT>减少了预计的输出行，但是没有减少开销，
因为我们仍然需要访问相同的行。
请注意，<TT CLASS="LITERAL">stringu1</TT>子句不能当做一个索引条件使用(因为这个索引只是在<TT CLASS="LITERAL">unique1</TT>列上有)。
它被当做一个从索引中检索出的行的过滤器来使用。
因此开销实际上略微增加了一些以反映这个额外的检查。
</P><P>
在某些情况下规划区更加喜欢<SPAN CLASS="QUOTE">"simple"</SPAN>索引扫描规划：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;

                                 QUERY PLAN
-----------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.29..8.30 rows=1 width=244)
   Index Cond: (unique1 = 42)</PRE><P>
在这种规划类型中，表的数据行是以索引顺序抓取的，这样就令读取它们的开销更大，
但是这里的行少得可怜，因此对行位置的额外排序并不值得。最常见的就是看到这种规划类型只抓取一行，
以及那些要求<TT CLASS="LITERAL">ORDER BY</TT>条件匹配索引顺序的查询。因为那时候没有多余的排序步骤是必要的以满足<TT CLASS="LITERAL">ORDER BY</TT>。
</P><P>
如果在<TT CLASS="LITERAL">WHERE</TT>里面使用的好几个字段上都有索引，那么规划器可能会使用索引的AND或OR的组合：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
               Index Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0)
               Index Cond: (unique2 &gt; 9000)</PRE><P>
但是这么做要求访问两个索引，因此与只使用一个索引，而把另外一个条件只当作过滤器相比，
这个方法未必是更优。如果你改变涉及的范围，你会看到规划器相应地发生变化。
</P><P>
下面是一个例子，显示<TT CLASS="LITERAL">LIMIT</TT>的影响：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Limit  (cost=0.29..14.48 rows=2 width=244)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..71.27 rows=10 width=244)
         Index Cond: (unique2 &gt; 9000)
         Filter: (unique1 &lt; 100)</PRE><P>
</P><P> 这是上面相同的查询，但我们增加了<TT CLASS="LITERAL">LIMIT</TT>，以致于不是所有的行需要被检索，并且规划关于该怎么做改变了主意，
请注意，索引扫描节点的总成本和行数被显示，好像它是运行完毕的。然而，限制节点预计在提取这些行的仅仅五分之一后停止，
所以其总成本只有五分之一之多，这就是实际的预算费用查询。该计划优于增加一个限制节点到
先前的计划，因为该限制无法避免支付位图扫描的启动成本，所以总成本将超过使用这种方法的25个单位的东西。</P><P>
让我们试着使用我们上面讨论的字段连接两个表：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..118.62 rows=10 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)</PRE><P>
</P><P> 在这个规划中，我们有两个表扫描的作为输入或者子节点的嵌套循环连接节点，
节点摘要行的缩进反映规划树结构。
连接的第一个，或者<SPAN CLASS="QUOTE">"outer"</SPAN>，子节点就是类似于我们之前看到的位图扫描。
其成本和行数是一样的，正如我们从<TT CLASS="LITERAL">SELECT ... WHERE unique1 &lt; 10</TT>获得。
因为我们只能在那个节点上应用<TT CLASS="LITERAL">WHERE</TT> clause <TT CLASS="LITERAL">unique1 &lt; 10</TT>。<TT CLASS="LITERAL">t1.unique2 = t2.unique2</TT>
子句还没有任何关系。因此它不影响外层扫描的行计数。
嵌套循环连接节点将运行它的第二部分， 或者<SPAN CLASS="QUOTE">"inner"</SPAN>子节点一次从外部子节点获得每一行。
从目前的外层行获得的值可以被插入到内扫描。这儿，从外层行中获得的<TT CLASS="LITERAL">t1.unique2</TT>是可用的。
这样我们就得到一个计划和成本，并且类似于我们上面看到的简单的<TT CLASS="LITERAL">SELECT ... WHERE t2.unique2 = <TT CLASS="REPLACEABLE"><I>constant</I></TT></TT>的情况。
（估计费用实际上比上面看到的低一点，在<TT CLASS="LITERAL">t2</TT>上可重复的索引扫描期间，作为期望发生的高速缓存结果）。
以外层扫描的开销为基础设置循环节点的开销，加上每个外层行的一个重复(这里是10 * 7.87)，
然后再加上连接处理需要的一点点CPU时间。</P><P>
在这个例子里，连接的输出行数与两个扫描的行数的乘积相同，但通常并不是这样的，
因为通常你会有提及两个表的<TT CLASS="LITERAL">WHERE</TT>子句，因此它只能应用于连接(join)点，
而不能影响两个关系的输入扫描。
这里有一个例子：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2.hundred;

                                         QUERY PLAN
---------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..49.46 rows=33 width=488)
   Join Filter: (t1.hundred &lt; t2.hundred)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Materialize  (cost=0.29..8.51 rows=10 width=244)
         -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..8.46 rows=10 width=244)
               Index Cond: (unique2 &lt; 10)</PRE><P>
条件<TT CLASS="LITERAL">t1.hundred &lt; t2.hundred</TT>不能
在<TT CLASS="LITERAL">tenk2_unique2</TT>索引中被测试，因此它被应用在
连接节点。这减少了连接节点的预计输出行数，
但不改变任何一个输入扫描。
</P><P> 注意，这里的规划器已经选择<SPAN CLASS="QUOTE">"具体化"</SPAN>连接内部关系，
通过放在规划节点上面。这也就是说，<TT CLASS="LITERAL">t2</TT>索引扫描将执行一次，尽管
嵌套循环连接节点需要读取数据十次，来自外部关系的每一行。
实现节点将数据保存在存储器中，因为它被读取，然后从存储器每个后续过程中返回每一个数据。</P><P> 当与外部联接时，你可能会看到带有附属<SPAN CLASS="QUOTE">"Join Filter"</SPAN>以及纯<SPAN CLASS="QUOTE">"Filter"</SPAN>条件的连接计划节点。
连接过滤条件来自于外部连接的<TT CLASS="LITERAL">ON</TT>子句，因此
这样的行失败了，连接过滤条件仍然可以作为非扩展行发出。
但一个纯过滤条件可以在外连接规则之后被应用
因此这个行为无条件地删除行。在内连接中
这些过滤器类型之间没有语义差异。</P><P>
如果我们改变查询的选择性，我们可能会得到一个非常不同的连接计划:
</P><PRE CLASS="SCREEN">EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Hash Join  (cost=230.47..713.98 rows=101 width=488)
   Hash Cond: (t2.unique2 = t1.unique2)
   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244)
   -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244)
         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 width=244)
               Recheck Cond: (unique1 &lt; 100)
               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
                     Index Cond: (unique1 &lt; 100)</PRE><P>
</P><P> 在这里，规划器选择使用一个哈希联接，表中的行被输入到内存中的哈希表中，在此之后，其他
表被扫描并且哈希表进行探测以匹配每一行。
再次注意如何缩进来反映规划结构：在<TT CLASS="LITERAL">tenk1</TT>上的位图
扫描是输入到哈希节点，它构造哈希表。这之后返回哈希连接节点，其内容是从它的外部子计划中读取每一行并且搜索每一个哈希表。</P><P>
另一种可能的连接类型是合并连接，在这里说明：
</P><PRE CLASS="SCREEN">EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Merge Join  (cost=198.11..268.19 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 rows=101 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Sort  (cost=197.83..200.33 rows=1000 width=244)
         Sort Key: t2.unique2
         -&gt;  Seq Scan on onek t2  (cost=0.00..148.00 rows=1000 width=244)</PRE><P>
</P><P> 合并连接要求其输入的数据在连接键上进行排序。在这种
规划中<TT CLASS="LITERAL">tenk1</TT>数据是通过使用索引扫描访问正确顺序的行来进行排序。
但顺序扫描和排序是<TT CLASS="LITERAL">onek</TT>的首选，因为有该表上被访问的更多行。
（顺序扫描和排序为排序行数而频繁进行索引扫描，因为通过索引扫描需要不连续的磁盘访问）</P><P>
找另外一个规划的方法是通过设置每种规划类型的允许/禁止开关(在<A HREF="runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE">第 18.7.1 &#33410;</A>里描述)，
强制规划器抛弃它认为优秀的(扫描)策略。这个工具目前比较原始，但很有用。又见<A HREF="explicit-joins.html">第 14.3 &#33410;</A>。
例如，如果我们不相信顺序扫描和排序对于前面例子中处理表<TT CLASS="LITERAL">onek</TT>是最好的方式，我们可以尝试
</P><PRE CLASS="SCREEN">SET enable_sort = off;

EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Merge Join  (cost=0.56..292.65 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 rows=101 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Index Scan using onek_unique2 on onek t2  (cost=0.28..224.79 rows=1000 width=244)</PRE><P>
这表明规划期认为通过索引扫描排序<TT CLASS="LITERAL">onek</TT>比顺序扫描和排序更昂贵约12％。
当然，接下来的问题是它是否是对的。我们可以使用<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>调查，正如下面所讨论的：
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="USING-EXPLAIN-ANALYZE">14.1.2. <TT CLASS="COMMAND">EXPLAIN ANALYZE</TT></A></H2><P>
我们可以用<TT CLASS="COMMAND">EXPLAIN</TT>的<TT CLASS="LITERAL">ANALYZE</TT>检查规划器的估计值的准确性。
这个命令实际上执行该查询然后显示每个规划节点内实际运行时间的和以及单纯<TT CLASS="COMMAND">EXPLAIN</TT>显示的估计开销。
比如，我们可以像下面这样获取一个结果：
</P><PRE CLASS="SCREEN">EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                                           QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual time=0.128..0.377 rows=10 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) (actual time=0.057..0.121 rows=10 loops=1)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.024..0.024 rows=10 loops=1)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)
         Index Cond: (unique2 = t1.unique2)
 Total runtime: 0.501 ms</PRE><P>
请注意<SPAN CLASS="QUOTE">"actual time"</SPAN>数值是以真实时间的毫秒计的，而<TT CLASS="LITERAL">cost</TT>估计值是以任意磁盘抓取的单元计的；
因此它们很可能不一致。我们要关心的事是两组比值是否一致。
通常最重要的事情是看是否估计行数相当接近于现实。在这个例子中，
估计都是完全正确的，但是这是相当不寻常的做法。
</P><P> 在一些查询规划里，一个子规划节点很可能运行多次。比如，在上面的嵌套循环的规划里，
内层的索引扫描对每个外层行执行一次。在这种情况下，<TT CLASS="LITERAL">loops</TT>报告该节点执行的总数目，
而显示的实际时间和行数目是每次执行的平均值。这么做的原因是令这些数字与开销预计显示的数字具有可比性。
要乘以<TT CLASS="LITERAL">loops</TT>值才能获得在该节点花费的总时间。在上面的例子中，我们共需要0.220毫秒来执行<TT CLASS="LITERAL">tenk2</TT>的索引扫描。</P><P>
在某些情况下<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>显示超出规划节点执行时间和行数的额外执行统计数据。
例如，排序和哈希节点提供额外的信息：
</P><PRE CLASS="SCREEN">EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2 ORDER BY t1.fivethous;

                                                                 QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=717.34..717.59 rows=101 width=488) (actual time=7.761..7.774 rows=100 loops=1)
   Sort Key: t1.fivethous
   Sort Method: quicksort  Memory: 77kB
   -&gt;  Hash Join  (cost=230.47..713.98 rows=101 width=488) (actual time=0.711..7.427 rows=100 loops=1)
         Hash Cond: (t2.unique2 = t1.unique2)
         -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244) (actual time=0.007..2.583 rows=10000 loops=1)
         -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244) (actual time=0.659..0.659 rows=100 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 28kB
               -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 width=244) (actual time=0.080..0.526 rows=100 loops=1)
                     Recheck Cond: (unique1 &lt; 100)
                     -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.049..0.049 rows=100 loops=1)
                           Index Cond: (unique1 &lt; 100)
 Total runtime: 8.008 ms</PRE><P>
排序节点显示使用的排序方法（特别是，排序是否在内存或磁盘上）以及所需的内存或磁盘空间量。
哈希节点显示哈希桶数量以及批处理用于哈希表的内存峰值数。
（如果批处理数大于1，也将有参与磁盘空间使用情况，但不在这显示。
</P><P>
另一种类型的附加信息是通过过滤条件删除行数：
</P><PRE CLASS="SCREEN">EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten &lt; 7;

                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7000 width=244) (actual time=0.016..5.107 rows=7000 loops=1)
   Filter: (ten &lt; 7)
   Rows Removed by Filter: 3000
 Total runtime: 5.905 ms</PRE><P>
这些计数对于应用在连接节点的过滤条件特别有价值。
<SPAN CLASS="QUOTE">"删除行"</SPAN>只出现在扫描行，或者连接节点的情况下的潜在连接对，
通过过滤条件被拒绝。
</P><P>
类似的情况，过滤条件产生<SPAN CLASS="QUOTE">"lossy"</SPAN>的索引扫描。
例如，考虑多边形这个搜索包含的具体点：
</P><PRE CLASS="SCREEN">EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)';

                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Seq Scan on polygon_tbl  (cost=0.00..1.05 rows=1 width=32) (actual time=0.044..0.044 rows=0 loops=1)
   Filter: (f1 @&gt; '((0.5,2))'::polygon)
   Rows Removed by Filter: 4
 Total runtime: 0.083 ms</PRE><P>
规划器认为（很正确）这种表太小而干扰索引扫描，所以我们有一个纯顺序扫描，
其中所有行通过过滤条件被拒绝。但是，如果我们强制
使用索引扫描，我们看到：
</P><PRE CLASS="SCREEN">SET enable_seqscan TO off;

EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)';

                                                        QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------
 Index Scan using gpolygonind on polygon_tbl  (cost=0.13..8.15 rows=1 width=32) (actual time=0.062..0.062 rows=0 loops=1)
   Index Cond: (f1 @&gt; '((0.5,2))'::polygon)
   Rows Removed by Index Recheck: 1
 Total runtime: 0.144 ms</PRE><P>
在这里，我们可以看到，索引返回一个候选行，这是
通过索引条件的重新检查被拒绝。这是因为
GiST索引对于多边形封闭测试是<SPAN CLASS="QUOTE">"lossy"</SPAN>：它实际上
返回带有重叠目标多边形的行，然后我们在那些行上进行确切的封闭测试。
</P><P>
<TT CLASS="COMMAND">EXPLAIN</TT>有<TT CLASS="LITERAL">BUFFERS</TT>选项，<TT CLASS="LITERAL">ANALYZE</TT>以获得更多的运行时间统计：
</P><PRE CLASS="SCREEN">EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                                           QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244) (actual time=0.323..0.342 rows=10 loops=1)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   Buffers: shared hit=15
   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0) (actual time=0.309..0.309 rows=0 loops=1)
         Buffers: shared hit=7
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)
               Index Cond: (unique1 &lt; 100)
               Buffers: shared hit=2
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0) (actual time=0.227..0.227 rows=999 loops=1)
               Index Cond: (unique2 &gt; 9000)
               Buffers: shared hit=5
 Total runtime: 0.423 ms</PRE><P>
通过<TT CLASS="LITERAL">BUFFERS</TT>提供的数字帮助辨识查询的哪些部分大多是I/O密集型。
</P><P>
请记住，因为<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>实际运行查询，
任何副作用还是一样会发生，即使无论什么结果查询可能的输出都将被丢弃而
赞成输出<TT CLASS="COMMAND">EXPLAIN</TT>的数据。
如果要分析一个数据修改的查询，而无需改变你的表，你可以回滚命令到后面，例如：
</P><PRE CLASS="SCREEN">BEGIN;

EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 &lt; 100;

                                                           QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------
 Update on tenk1  (cost=5.07..229.46 rows=101 width=250) (actual time=14.628..14.628 rows=0 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1  (cost=5.07..229.46 rows=101 width=250) (actual time=0.101..0.439 rows=100 loops=1)
         Recheck Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)
               Index Cond: (unique1 &lt; 100)
 Total runtime: 14.727 ms

ROLLBACK;</PRE><P>
</P><P> 如该示例中，当查询是<TT CLASS="COMMAND">INSERT</TT>,<TT CLASS="COMMAND">UPDATE</TT>或者<TT CLASS="COMMAND">DELETE</TT>命令时，
申请表变化的实际工作是由顶层插入、更新、或删除规划节点完成的。
这个节点下的规划节点进行定位旧的行和/或计算新数据。
所以上面，我们看到了已经看到的相同排序的位表扫描，
并且其输出被传递给存储更新行的更新节点。
值得一提的是，虽然修改数据的节点可以采取大量的运行时间（在这里，它消耗了大部分的共享的时间），
规划器目前不添加任何东西的成本来估计说明这项工作。这是因为要做的工作是同样为了每一个正确的查询规划，
因此它不影响规划决定。</P><P>
<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>显示的<TT CLASS="LITERAL">Total runtime</TT>包括执行器启动和关闭的时间，
以及被激发的任何触发器运行时间。但它不包括分析、重写、规划的时间。
执行<TT CLASS="LITERAL">BEFORE</TT>触发器花费的时间，如果有的话，包括在为相关插入，更新或删除节点的时间内，
但执行<TT CLASS="LITERAL">AFTER</TT>触发器的时间花费并不计算在内，
因为整个规划完成之后，才触发<TT CLASS="LITERAL">AFTER</TT>触发器。
单独显示每个触发器花费的总时间（<TT CLASS="LITERAL">BEFORE</TT> 或者<TT CLASS="LITERAL">AFTER</TT>）。
需要注意的是延迟约束触发器直到事务结束将不会执行，因而不会通过<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>显示。 </P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="USING-EXPLAIN-CAVEATS">14.1.3. 警告</A></H2><P> 有两个显著方式测量运行时间，通过<TT CLASS="COMMAND"> EXPLAIN ANALYZE</TT>偏离相同查询的正常执行。
首先，由于没有输出行被传递到客户端，
不包含网络传输成本和I/O转换费用。其次，通过<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>增加的测量开销是巨大的，
特别是在慢的<CODE CLASS="FUNCTION">gettimeofday()</CODE>操作系统调用机器上。您可以使用
<A HREF="pgtesttiming.html"><SPAN CLASS="APPLICATION">pg_test_timing</SPAN></A>工具来测量您系统上的定时开销。</P><P> <TT CLASS="COMMAND">EXPLAIN</TT>的结果除了在你实际测试的情况之外不能推导出其它的情况；
比如，在一个小得像玩具的表上的结果不能适用于大表。规划器的开销计算不是线性的，
因此它很可能对大些或者小些的表选择不同的规划。一个极端的例子是一个只占据一个磁盘页面的表，
在这样的表上，不管它有没有索引可以使用，你几乎都总是得到顺序扫描规划。
规划器知道不管在任何情况下它都要进行一个磁盘页面的读取，
所以再扩大几个磁盘页面读取以查找索引是没有意义的。（我们可以从<TT CLASS="LITERAL">polygon_tbl</TT>上面的例子中看到）</P><P>
在某些情况中，实际与估计值不能很好的匹配，但没有什么是真的错了。
出现这样的一个情况，当规划节点执行是由<TT CLASS="LITERAL">LIMIT</TT>或类似效果而短暂停止
。例如，我们以前使用<TT CLASS="LITERAL">LIMIT</TT>查询。
</P><PRE CLASS="SCREEN">EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2;

                                                          QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..14.71 rows=2 width=244) (actual time=0.177..0.249 rows=2 loops=1)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..72.42 rows=10 width=244) (actual time=0.174..0.244 rows=2 loops=1)
         Index Cond: (unique2 &gt; 9000)
         Filter: (unique1 &lt; 100)
         Rows Removed by Filter: 287
 Total runtime: 0.336 ms</PRE><P>
为索引扫描节点的估计成本和行数都被显示。即使它是运行完毕的。但现实是请求行运行两个之后限制节点停止，
所以实际的行数只有2和，并且运行时间低于成本估算。这不是估计错误，由于只有一个差异估计和真实值显示。
</P><P> 合并连接也有可混淆粗心的测量产品。
合并连接将停止读取一个输入，如果它用尽了其他输入，并且输入端的下一个关键值大于其他输入的最后一个关键值；
在这种情况下，就不可能有更多的匹配，所以不需要扫描第一个输入的其余部分。
这会导致无法读取所有子节点，有些像那些提到的<TT CLASS="LITERAL">LIMIT</TT>结果。
此外，如果外部（第一）子节点包含重复键值的行，内部（第二个）子节点被备份并重新扫描行匹配键值的部分。
<TT CLASS="COMMAND">EXPLAIN ANALYZE</TT>计算同一内部行的重复部分，好像他们是真正的附加行。
当有许多外部重复部分，为了内部子规划节点比真实内部关系行数足够大，则报告的实际行数。 </P><P> BitmapAnd和BitmapOr节点总是报告自己的实际行数为零，由于实施限制。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="planner-stats.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">性能提升技巧</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">规划器使用的统计信息</TD></TR></TABLE></DIV></BODY></HTML>
