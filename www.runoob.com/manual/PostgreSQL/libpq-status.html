<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>连接状态函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="数据库连接控制函数" HREF="libpq-connect.html"><LINK REL="NEXT" TITLE="命令执行函数" HREF="libpq-exec.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="数据库连接控制函数" HREF="libpq-connect.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="命令执行函数" HREF="libpq-exec.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-STATUS">31.2. 连接状态函数</A></H1><P>这些函数可以用于询问现存数据库连接对象的状态。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>
<SPAN CLASS="APPLICATION">libpq</SPAN>应用程序员应该仔细维护<TT CLASS="STRUCTNAME">PGconn</TT>结构。
使用下面的访问函数来获取<TT CLASS="STRUCTNAME">PGconn</TT>的内容。不建议使用<TT CLASS="FILENAME">libpq-int.h</TT>
引用<TT CLASS="STRUCTNAME">PGconn</TT>内部的字段，因为这些字段在今后可能被改变。</P></BLOCKQUOTE></DIV><P>下面的函数返回连接建立时的参数值。这些参数在<TT CLASS="STRUCTNAME">PGconn</TT>对象的生命期期间是固定的。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQDB"></A><CODE CLASS="FUNCTION">PQdb</CODE>
</DT><DD><P>返回连接的数据库名。
</P><PRE CLASS="SYNOPSIS">char *PQdb(const PGconn *conn);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQUSER"></A><CODE CLASS="FUNCTION">PQuser</CODE>
</DT><DD><P>返回连接的用户名。
</P><PRE CLASS="SYNOPSIS">char *PQuser(const PGconn *conn);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQPASS"></A><CODE CLASS="FUNCTION">PQpass</CODE>
</DT><DD><P>返回连接的口令。
</P><PRE CLASS="SYNOPSIS">char *PQpass(const PGconn *conn);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQHOST"></A><CODE CLASS="FUNCTION">PQhost</CODE>
</DT><DD><P>返回连接的服务器主机名。
</P><PRE CLASS="SYNOPSIS">char *PQhost(const PGconn *conn);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQPORT"></A><CODE CLASS="FUNCTION">PQport</CODE>
</DT><DD><P>返回连接的端口号。
</P><PRE CLASS="SYNOPSIS">char *PQport(const PGconn *conn);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQTTY"></A><CODE CLASS="FUNCTION">PQtty</CODE>
</DT><DD><P>返回连接的调试控制台<ACRONYM CLASS="ACRONYM">TTY</ACRONYM>。（这个已经过时了，
因为服务器不再注意<ACRONYM CLASS="ACRONYM">TTY</ACRONYM>设置，这个函数的存在是为了向下兼容。）
</P><PRE CLASS="SYNOPSIS">char *PQtty(const PGconn *conn);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQOPTIONS"></A><CODE CLASS="FUNCTION">PQoptions</CODE>
</DT><DD><P>返回连接请求中传递的命令行选项。
</P><PRE CLASS="SYNOPSIS">char *PQoptions(const PGconn *conn);</PRE><P>
</P></DD></DL></DIV><P>
</P><P>下面的函数返回那些在对<TT CLASS="STRUCTNAME">PGconn</TT>对象进行操作的过程中可能变化的状态数据。
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQSTATUS"></A><CODE CLASS="FUNCTION">PQstatus</CODE>
</DT><DD><P>
返回连接的状态。
</P><PRE CLASS="SYNOPSIS">ConnStatusType PQstatus(const PGconn *conn);</PRE><P>
</P><P>这个状态可以是一系列值之一。不过，我们在一个异步连接过程外面只能看到其中的两个：
<TT CLASS="LITERAL">CONNECTION_OK</TT>和<TT CLASS="LITERAL">CONNECTION_BAD</TT>。
成功连接到数据库返回状态<TT CLASS="LITERAL">CONNECTION_OK</TT>。
失败的连接尝试用状态<TT CLASS="LITERAL">CONNECTION_BAD</TT>标识。通常，
一个OK状态将保持到<CODE CLASS="FUNCTION">PQfinish</CODE>，但是一个通讯失败可能会导致状态过早的改变为
<TT CLASS="LITERAL">CONNECTION_BAD</TT>。这时应用可以试着调用<CODE CLASS="FUNCTION">PQreset</CODE>来恢复。</P><P>参阅<CODE CLASS="FUNCTION">PQconnectStartParams</CODE>、<CODE CLASS="FUNCTION">PQconnectStart</CODE>和<CODE CLASS="FUNCTION">PQconnectPoll</CODE>
条目看看可能出现的其他状态码。</P></DD><DT><A NAME="LIBPQ-PQTRANSACTIONSTATUS"></A><CODE CLASS="FUNCTION">PQtransactionStatus</CODE>
</DT><DD><P>返回服务器的当前事务内状态。
</P><PRE CLASS="SYNOPSIS">PGTransactionStatusType PQtransactionStatus(const PGconn *conn);</PRE><P>
状态可以是<TT CLASS="LITERAL">PQTRANS_IDLE</TT>（当前空闲），<TT CLASS="LITERAL">PQTRANS_ACTIVE</TT>
（正在处理一个命令），<TT CLASS="LITERAL">PQTRANS_INTRANS</TT>（空闲，在一个合法的事务块内），
或者<TT CLASS="LITERAL">PQTRANS_INERROR</TT>（空闲，在一个失败的事务块内）。如果连接有问题，
则返回<TT CLASS="LITERAL">PQTRANS_UNKNOWN</TT>。只有在一个查询发送给了服务器并且还没有完成的时候才返回
<TT CLASS="LITERAL">PQTRANS_ACTIVE</TT>。
</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="90%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P>当使用参数<TT CLASS="LITERAL">autocommit</TT>设置为关闭的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 7.3服务器时，
<CODE CLASS="FUNCTION">PQtransactionStatus</CODE>将给出不正确的结果。服务器端自动提交特性已经废弃了，
并且在后来的服务器版本中不再存在。</P></TD></TR></TABLE></DIV></DD><DT><A NAME="LIBPQ-PQPARAMETERSTATUS"></A><CODE CLASS="FUNCTION">PQparameterStatus</CODE>
</DT><DD><P>查找服务器的一个当前参数设置。
</P><PRE CLASS="SYNOPSIS">const char *PQparameterStatus(const PGconn *conn, const char *paramName);</PRE><P>
有些参数值在建立连接或者它们的值改变的时候会由服务器自动报告。
<CODE CLASS="FUNCTION">PQparameterStatus</CODE>可以用查询这些设置。如果参数已知，
那么它返回当前值，否则返回<TT CLASS="SYMBOL">NULL</TT>。
</P><P>当前版本报告的参数有<TT CLASS="VARNAME">server_version</TT>，<TT CLASS="VARNAME">server_encoding</TT>，
<TT CLASS="VARNAME">client_encoding</TT>，<TT CLASS="VARNAME">application_name</TT>，<TT CLASS="VARNAME">is_superuser</TT>，
<TT CLASS="VARNAME">session_authorization</TT>，<TT CLASS="VARNAME">DateStyle</TT>，<TT CLASS="VARNAME">IntervalStyle</TT>，
<TT CLASS="VARNAME">TimeZone</TT>，<TT CLASS="VARNAME">integer_datetimes</TT>和<TT CLASS="VARNAME">standard_conforming_strings</TT>。
（8.0之前的版本不报告<TT CLASS="VARNAME">server_encoding</TT>，<TT CLASS="VARNAME">TimeZone</TT>和
<TT CLASS="VARNAME">integer_datetimes</TT>；8.1之前的版本不报告<TT CLASS="VARNAME">standard_conforming_strings</TT>；
8.4之前的版本不报告<TT CLASS="VARNAME">IntervalStyle</TT>；9.0之前的版本不报告<TT CLASS="VARNAME">application_name</TT>。）
请注意<TT CLASS="VARNAME">server_version</TT>，<TT CLASS="VARNAME">server_encoding</TT>和<TT CLASS="VARNAME">integer_datetimes</TT>
不能再启动后修改。</P><P>协议版本3.0之前的服务器不会报告参数设置，但是<SPAN CLASS="APPLICATION">libpq</SPAN>
里包含一些逻辑用于获取<TT CLASS="VARNAME">server_version</TT>和<TT CLASS="VARNAME">client_encoding</TT>的数值。
我们鼓励应用里面使用<CODE CLASS="FUNCTION">PQparameterStatus</CODE>，而不是使用<I CLASS="FOREIGNPHRASE">ad hoc</I>
代码来检测这些值。（不过要注意，在3.0之前的连接协议里，启动后通过<TT CLASS="COMMAND">SET</TT>
改变了<TT CLASS="VARNAME">client_encoding</TT>将不会被<CODE CLASS="FUNCTION">PQparameterStatus</CODE>反映出来。）
对于<TT CLASS="VARNAME">server_version</TT>，又见<CODE CLASS="FUNCTION">PQserverVersion</CODE>，
它返回数值形式，更容易进行比较。</P><P>如果没有为<TT CLASS="VARNAME">standard_conforming_strings</TT>报告数值，应用可以假设它是<TT CLASS="LITERAL">off</TT>，
也就是说，在字符串文本里，把反斜杠当做转义。同样，如果出现了这个参数，
就可以当作一个指示，表示接受转义字符串(<TT CLASS="LITERAL">E'...'</TT>)的语法。</P><P>尽管返回的指针声明为<TT CLASS="LITERAL">const</TT>，它实际上指向一个和<TT CLASS="LITERAL">PGconn</TT>
结构关联的可变存储区。因此假设这个指针跨查询保持有效是不明智的。</P></DD><DT><A NAME="LIBPQ-PQPROTOCOLVERSION"></A><CODE CLASS="FUNCTION">PQprotocolVersion</CODE>
</DT><DD><P>查询使用的前/后端协议。
</P><PRE CLASS="SYNOPSIS">int PQprotocolVersion(const PGconn *conn);</PRE><P>
应用可能希望使用这个函数来判断某些特性是否被支持。目前，可能的数值是2
（2.0协议），3（3.0协议）或0（连接错误）。在连接启动完成之后，这个数值将不会改变，
但是在连接重置的过程中，理论上是可能改变的。在与<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 7.4
或更高版本沟通时，通常使用3.0协议；7.4以前的服务器只支持协议2.0。
（协议1.0过时了，不被<SPAN CLASS="APPLICATION">libpq</SPAN>支持。）
</P></DD><DT><A NAME="LIBPQ-PQSERVERVERSION"></A><CODE CLASS="FUNCTION">PQserverVersion</CODE>
</DT><DD><P>
返回一个整数，代表后端版本。
</P><PRE CLASS="SYNOPSIS">int PQserverVersion(const PGconn *conn);</PRE><P>
应用可以使用这个函数判断它们连接的数据库服务器的版本。数字是通过把主、
次及版本号转换成两位十进制数并且把它们连接在一起组成的。例如，
版本8.1.5将被返回80105，版本8.2将被返回80200（前导零没有显示）。
如果连接失败，则返回零。
</P></DD><DT><A NAME="LIBPQ-PQERRORMESSAGE"></A><CODE CLASS="FUNCTION">PQerrorMessage</CODE>
</DT><DD><P>返回连接中操作产生的最近的错误信息。
</P><PRE CLASS="SYNOPSIS">char *PQerrorMessage(const PGconn *conn);</PRE><P>
</P><P>几乎所有<SPAN CLASS="APPLICATION">libpq</SPAN>函数在失败时都会为<CODE CLASS="FUNCTION">PQerrorMessage</CODE>
设置一个信息。注意，<SPAN CLASS="APPLICATION">libpq</SPAN>的传统是，一个非空的
<CODE CLASS="FUNCTION">PQerrorMessage</CODE>结果会由多行组成，并且将包含一个结尾的新行。
调用者不应该直接释放结果。结果的释放是在将<TT CLASS="STRUCTNAME">PGconn</TT>句柄传递给
<CODE CLASS="FUNCTION">PQfinish</CODE>的时候自动进行的。我们不能假设在不同的<TT CLASS="LITERAL">PGconn</TT>
结构操作中，结果字串都是一样的。</P></DD><DT><A NAME="LIBPQ-PQSOCKET"></A><CODE CLASS="FUNCTION">PQsocket</CODE></DT><DD><P>获取与服务器连接的套接字的文件描述符编号。一个有效的描述符应该是大于或等于0；
结果为-1表示当前没有与服务器的连接打开。（在正常的操作中，这个结果不会改变，
但是可能在连接启动或者重置的过程中变化。）
</P><PRE CLASS="SYNOPSIS">int PQsocket(const PGconn *conn);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQBACKENDPID"></A><CODE CLASS="FUNCTION">PQbackendPID</CODE></DT><DD><P>返回后端进程处理此连接的进程号<ACRONYM CLASS="ACRONYM">ID</ACRONYM> (PID)
</P><PRE CLASS="SYNOPSIS">int PQbackendPID(const PGconn *conn);</PRE><P>
</P><P>这个后端<ACRONYM CLASS="ACRONYM">PID</ACRONYM>在调试和对比<TT CLASS="COMMAND">NOTIFY</TT>
信息（包括发出通知的后端进程的<ACRONYM CLASS="ACRONYM">PID</ACRONYM>）时很有用。
注意该<ACRONYM CLASS="ACRONYM">PID</ACRONYM>属于运行数据库服务器主机的进程，
而不是本地主机！</P></DD><DT><A NAME="LIBPQ-PQCONNECTIONNEEDSPASSWORD"></A><CODE CLASS="FUNCTION">PQconnectionNeedsPassword</CODE></DT><DD><P>如果连接的认证方法需要一个密码则返回true (1)，但是没有可用的。
如果没有则返回false (0)。
</P><PRE CLASS="SYNOPSIS">int PQconnectionNeedsPassword(const PGconn *conn);</PRE><P>
</P><P>此功能可用于连接尝试失败后决定是否提示用户输入密码。</P></DD><DT><A NAME="LIBPQ-PQCONNECTIONUSEDPASSWORD"></A><CODE CLASS="FUNCTION">PQconnectionUsedPassword</CODE></DT><DD><P>如果连接的认证方法使用密码则返回true (1)。否则返回false (0)。
</P><PRE CLASS="SYNOPSIS">int PQconnectionUsedPassword(const PGconn *conn);</PRE><P>
</P><P>此功能可应用于失败或成功连接后尝试检测服务器是否要求密码。</P></DD><DT><A NAME="LIBPQ-PQGETSSL"></A><CODE CLASS="FUNCTION">PQgetssl</CODE></DT><DD><P>&#13;返回连接中使用的SSL结构，或者没有使用SSL则返回null。
</P><PRE CLASS="SYNOPSIS">void *PQgetssl(const PGconn *conn);</PRE><P>
</P><P>这个结构可以用于核实加密级别，检查服务器认证等信息。参考<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN>
文档获取关于这个结构的更多信息。</P><P>实际返回值的类型是<TT CLASS="TYPE">SSL *</TT>，而<TT CLASS="TYPE">SSL</TT>的类型是由
<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN>库定义的，但是没有用这种方式声明，
以避免请求<SPAN CLASS="PRODUCTNAME">OpenSSL</SPAN>头文件。要使用这个函数，
可以使用下面的代码行：
</P><PRE CLASS="PROGRAMLISTING">#include &#60;libpq-fe.h&#62;
#include &#60;openssl/ssl.h&#62;

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQgetssl(dbconn);
    if (ssl)
    {
        /* use OpenSSL functions to access ssl */
    }</PRE><P>
</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-connect.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-exec.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">数据库连接控制函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">命令执行函数</TD></TR></TABLE></DIV></BODY></HTML>
