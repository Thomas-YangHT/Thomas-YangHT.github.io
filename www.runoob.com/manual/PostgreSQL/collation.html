<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>排序规则支持</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="区域" HREF="http://school.yunwei.edu/manual/PostgreSQL/charset.html"><LINK REL="PREVIOUS" TITLE="区域支持" HREF="locale.html"><LINK REL="NEXT" TITLE="字符集支持" HREF="multibyte.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/charset.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="区域支持" HREF="locale.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/charset.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 22. 区域</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="字符集支持" HREF="multibyte.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="COLLATION">22.2. 排序规则支持</A></H1><P> 排序规则特性允许为每一列数据指定排序顺序和字符分类行为，或者甚至为每个操作指定。
这缓解了<TT CLASS="SYMBOL">LC_COLLATE</TT>和<TT CLASS="SYMBOL">LC_CTYPE</TT>在数据库被创建后不能被修改的限制。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN33133">22.2.1. 概念</A></H2><P> 从概念上讲，collatable数据类型的每个表达式都有一个排序规则。
（内置collatable数据类型有<TT CLASS="TYPE">text</TT>, <TT CLASS="TYPE">varchar</TT>以及<TT CLASS="TYPE">char</TT>。
用户定义的基本类型，也可以标记为collatable，
当然一个collatable数据类型的域也是collatable的）。
如果表达式是一个列引用，该表达式的排序规则是就这个列的排序规则。
如果表达式是一个常数，排序规则是常数数据类型的缺省排序规则。
一个更复杂表达式的排序规则从它的输入端排序规则推导，如下所述。</P><P> 一个表达式的排序规则可以是<SPAN CLASS="QUOTE">"缺省"</SPAN>排序规则，
这意味着为数据库的区域设置。它也可以用于表达式的排序规则是不确定的。
在这种情况下，排序操作符以及其他需要知道排序规则的操作符会在执行时失败。 </P><P> 当数据库系统必须执行排序或字符分类时，它使用输入表达式的排序规则。
这种情况发生，例如，使用<TT CLASS="LITERAL">ORDER BY</TT>子句
以及函数或运算符调用比如<TT CLASS="LITERAL">&lt;</TT>。
应用到<TT CLASS="LITERAL">ORDER BY</TT>子句中的排序规则直接就是排序关键字的排序规则。
应用到函数或操作符调用的排序规则要从参数上派生，
如下文所述。除了比较操作符外，
大小写字母转换函数，如<CODE CLASS="FUNCTION">lower</CODE>, <CODE CLASS="FUNCTION">upper</CODE>和
<CODE CLASS="FUNCTION">initcap</CODE>；模式匹配运算符号；以及
<CODE CLASS="FUNCTION">to_char</CODE>及其相关函数都需要考虑排序规则。</P><P> 对于一个函数或运算符调用，
通过检查用来在运行时执行指定操作的参数排序规则派生出该排序规则。
如果函数或运算符调用结果是collatable数据类型，
并且有需要知道该排序规则的外围表达式，
排序规则也可用于在解析时作为函数或运算符表达式的定义的排序规则。</P><P>
表达式的<I CLASS="FIRSTTERM">排序规则推导</I>可以是
隐式或显式的。当多个不同的排序规则出现在表达式中，这种区别会影响排序规则如何组合，
当使用<TT CLASS="LITERAL">COLLATE</TT>子句的时候，产生显式排序规则推导;所有其他排序规则
推导是隐式的。当多个排序规则必须结合时，例如在一个函数调用中，使用下面的规则：
<P></P></P><OL TYPE="1"><LI><P>
如果任何输入表达式有显式的排序规则推导，那么
输入表达式中所有显式派生的排序规则必须是一样的，
否则将引发错误。如果有任何显式派生的排序规则，这即是排序规则组合的结果。
</P></LI><LI><P> 否则，所有输入表达式必须具有相同的隐式排序规则推导或者缺省排序规则。如果出现任何非缺省的
排序规则，则是这就是排序组合的结果。否则，结果是缺省排序规则。</P></LI><LI><P> 如果在输入的表达式之间非缺省的隐式排序规则有冲突，
那么该组合视为不明确的排序规则。
这不是一个错误情况，除非被调用的那个函数需要知道排序规则。
如果是这样，在运行时将引发一个错误。
</P></LI></OL><P>
比如，考虑这个表定义：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE test1 (
    a text COLLATE "de_DE",
    b text COLLATE "es_ES",
    ...
);</PRE><P>
然后
</P><PRE CLASS="PROGRAMLISTING">SELECT a &lt; 'foo' FROM test1;</PRE><P>
按照<TT CLASS="LITERAL">de_DE</TT>规则，执行<TT CLASS="LITERAL">&lt;</TT>比较，因为表达式
组合隐式推导排序规则与缺省排序规则，但是
</P><PRE CLASS="PROGRAMLISTING">SELECT a &lt; ('foo' COLLATE "fr_FR") FROM test1;</PRE><P>
使用<TT CLASS="LITERAL">fr_FR</TT>规则执行比较，因为显式排序规则覆盖了隐式的。
此外，
</P><PRE CLASS="PROGRAMLISTING">SELECT a &lt; b FROM test1;</PRE><P>
解析器无法确定应该应用哪个排序规则，因为
<TT CLASS="STRUCTFIELD">a</TT>列和<TT CLASS="STRUCTFIELD">b</TT>列拥有冲突的隐式排序规则。
因为<TT CLASS="LITERAL">&lt;</TT>操作符确实需要知道所使用的排序规则，这将导致一个错误。
错误可以通过附加一个明确的排序规则说明符给输入表达式得以解决，如下：
</P><PRE CLASS="PROGRAMLISTING">SELECT a &lt; b COLLATE "de_DE" FROM test1;</PRE><P>
或者等效的，
</P><PRE CLASS="PROGRAMLISTING">SELECT a COLLATE "de_DE" &lt; b FROM test1;</PRE><P>
另一方面，结构上类似的情况
</P><PRE CLASS="PROGRAMLISTING">SELECT a || b FROM test1;</PRE><P>
不会产生错误，因为<TT CLASS="LITERAL">||</TT>操作符并不关心排序规则：
不论什么排序规则结果都是一样的。
</P><P>
如果函数或者操作符的结果还是collatable数据类型,
那么分配给函数或者操作符的组合的输入表达式的排序规则也会应用到函数或者操作符结果上。
因此，
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM test1 ORDER BY a || 'foo';</PRE><P>
按照<TT CLASS="LITERAL">de_DE</TT>规则执行该排序。但是这个查询：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM test1 ORDER BY a || b;</PRE><P>
导致一个错误，因为即使<TT CLASS="LITERAL">||</TT>操作符不需要知道排序规则，而<TT CLASS="LITERAL">ORDER BY</TT>子句
确实需要。和前面一样，可以使用显式的排序规则说明符解决这个冲突。
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM test1 ORDER BY a || b COLLATE "fr_FR";</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN33181">22.2.2. 管理排序规则</A></H2><P> 排序规则是把SQL名称映射到操作系统区域的SQL模式对象。
特别是，它映射到<TT CLASS="SYMBOL">LC_COLLATE</TT>和<TT CLASS="SYMBOL">LC_CTYPE</TT>的组合。
（顾名思义，排序规则的主要目的是设置<TT CLASS="SYMBOL">LC_COLLATE</TT>，
它控制排序顺序。但在实际中很少需要一个和
<TT CLASS="SYMBOL">LC_COLLATE</TT>不同的<TT CLASS="SYMBOL">LC_CTYPE</TT>设置，
所以将它们合在一起，而不是为每个表达式另外创造一个设置
<TT CLASS="SYMBOL">LC_CTYPE</TT>的基础设施，更为方便）。
另外，排序规则和字符集编码（参见<A HREF="multibyte.html">第 22.3 &#33410;</A>）紧密关联。
对不同的编码可能存在同名的排序规则。</P><P> 在所有平台上，名称为<TT CLASS="LITERAL">default</TT>,
<TT CLASS="LITERAL">C</TT>和<TT CLASS="LITERAL">POSIX</TT>排序规则都是可用的。其他可用的排序规则
取决于操作系统支持。<TT CLASS="LITERAL">default</TT>排序规则选择在创建数据库时指定的<TT CLASS="SYMBOL">LC_COLLATE</TT>
和<TT CLASS="SYMBOL">LC_CTYPE</TT>值。
<TT CLASS="LITERAL">C</TT>和<TT CLASS="LITERAL">POSIX</TT>的排序规则都表现为<SPAN CLASS="QUOTE">"传统 C"</SPAN>的行为，
即只有ASCII字母<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">A</TT>"</SPAN>到<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">Z</TT>"</SPAN>
被视为字母，并且严格按照字符的编码字节值进行排序。</P><P> 如果操作系统提供了在一个程序中使用多语言环境的支持
(<CODE CLASS="FUNCTION">newlocale</CODE>以及相关函数)，那么当一个数据库集群初始化的时候，
<TT CLASS="COMMAND">initdb</TT>使用基于当时在操作系统上发现的所有语言环境的排序规则
来填充系统表<TT CLASS="LITERAL">pg_collation</TT>。
例如，操作系统可能提供名为<TT CLASS="LITERAL">de_DE.utf8</TT>的区域。
那么，<TT CLASS="COMMAND">initdb</TT>就可能为编码<TT CLASS="LITERAL">UTF8</TT>创建命名为
<TT CLASS="LITERAL">de_DE.utf8</TT>的排序规则，它的<TT CLASS="SYMBOL">LC_COLLATE</TT>和
<TT CLASS="SYMBOL">LC_CTYPE</TT>都被设置为<TT CLASS="LITERAL">de_DE.utf8</TT>。
它还将创建名称中被剥离了<TT CLASS="LITERAL">.utf8</TT>标签的排序规则。
所以，你也可以使用<TT CLASS="LITERAL">de_DE</TT>名称的排序规则
，这方便于编写并且使得名称较少依赖于编码。然而，需要注意的是，
排序规则名称的初始设置是平台相关的。</P><P> 在需要有不同的<TT CLASS="SYMBOL">LC_COLLATE</TT>和<TT CLASS="SYMBOL">LC_CTYPE</TT>
值的排序规则的情况下，可以使用<A HREF="sql-createcollation.html">CREATE COLLATION</A>
命令创建新的排序规则。
该命令也可以从现有排序规则中创建一个新的，这可能是有用的，以便能够
在应用中使用操作系统无关的排序规则名称。</P><P> 在任何特定的数据库中，只关心使用该数据库编码的排序规则。
<TT CLASS="LITERAL">pg_collation</TT>中的其他项目会被忽略。因此，剥离了编码名的排序规则
名称，如<TT CLASS="LITERAL">de_DE</TT>，在一个给定的数据库中也算是独一无二的，即使它不是全局唯一的。
建议使用剥离过的排序规则名称，因为如果你以后决定改变到另一个数据库编码，可以少改变一样东西。
但是请注意，无论是什么数据库编码，都可以使用<TT CLASS="LITERAL">default</TT>,
<TT CLASS="LITERAL">C</TT>和<TT CLASS="LITERAL">POSIX</TT>排序规则。</P><P>
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>认为不同排序规则
对象是不兼容的，即使他们有相同的属性。
例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT a COLLATE "C" &lt; b COLLATE "POSIX" FROM test1;</PRE><P>
将引起一个错误，即使<TT CLASS="LITERAL">C</TT>和<TT CLASS="LITERAL">POSIX</TT>
排序规则具有完全相同的行为。因此不推荐混合剥离的和非剥离的排序规则名。
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="locale.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="multibyte.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">区域支持</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/charset.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">字符集支持</TD></TR></TABLE></DIV></BODY></HTML>
