<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pg_trgm</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="pgstattuple" HREF="pgstattuple.html"><LINK REL="NEXT" TITLE="postgres_fdw" HREF="postgres-fdw.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/pgtrgm.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pgstattuple" HREF="pgstattuple.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="postgres_fdw" HREF="postgres-fdw.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PGTRGM">F.30. pg_trgm</A></H1><P><TT CLASS="FILENAME">pg_trgm</TT>模块提供函数和操作符测定字母数字文本基于三元模型匹配的相似性，
还有支持快速搜索相似字符串的索引操作符类。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149394">F.30.1. 三元模型概念</A></H2><P>三元模型是一组从一个字符串中获得的三个连续的字符。
我们可以通过计数两个字符串共享的三元模型的数量来测量它们的相似性。
这个简单的想法证明在测量许多自然语言词汇的相似性时是非常有效的。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><TT CLASS="FILENAME">pg_trgm</TT>从一个字符串提取三元模型时忽略非文字字符（非字母）。
当确定包含在字符串中的三元模型集合时，每个单词被认为有两个空格前缀和一个空格后缀。
例如，字符串<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">cat</TT>"</SPAN>中的三元模型的集合是
<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL"> c</TT>"</SPAN>，<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL"> ca</TT>"</SPAN>，
<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">cat</TT>"</SPAN>和<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">at </TT>"</SPAN>。
字符串<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">foo|bar</TT>"</SPAN>中的三元模型的集合是
<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL"> f</TT>"</SPAN>，<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL"> fo</TT>"</SPAN>，
<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">foo</TT>"</SPAN>，<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">oo </TT>"</SPAN>，
<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL"> b</TT>"</SPAN>，<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL"> ba</TT>"</SPAN>，
<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">bar</TT>"</SPAN>和<SPAN CLASS="QUOTE">"<TT CLASS="LITERAL">ar </TT>"</SPAN>。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149428">F.30.2. 函数和操作符</A></H2><P><TT CLASS="FILENAME">pg_trgm</TT>模块提供的函数在<A HREF="pgtrgm.html#PGTRGM-FUNC-TABLE">&#34920; F-22</A>
中显示，提供的操作符在<A HREF="pgtrgm.html#PGTRGM-OP-TABLE">&#34920; F-23</A>中显示。</P><DIV CLASS="TABLE"><A NAME="PGTRGM-FUNC-TABLE"></A><P><B>&#34920; F-22. <TT CLASS="FILENAME">pg_trgm</TT> 函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><CODE CLASS="FUNCTION">similarity(text, text)</CODE></TD><TD><TT CLASS="TYPE">real</TT></TD><TD>
返回一个数字表明两个参数是多么相似。结果的范围是0（表明两个字符串完全不相似）
到1（表明两个字符串是完全相同的）。
</TD></TR><TR><TD><CODE CLASS="FUNCTION">show_trgm(text)</CODE></TD><TD><TT CLASS="TYPE">text[]</TT></TD><TD>
返回一个给定字符串中所有三元模型的数组。（实际上这个除了调试之外很少有用。）
</TD></TR><TR><TD><CODE CLASS="FUNCTION">show_limit()</CODE></TD><TD><TT CLASS="TYPE">real</TT></TD><TD>
返回<TT CLASS="LITERAL">%</TT>操作符使用的当前相似性阈值。例如，这个设置两个单词间的最小相似性，
这两个单词被认为足够相似以致相互之间拼写错误。
</TD></TR><TR><TD><CODE CLASS="FUNCTION">set_limit(real)</CODE></TD><TD><TT CLASS="TYPE">real</TT></TD><TD>
设置<TT CLASS="LITERAL">%</TT>操作符使用的当前相似性阈值。该阈值必须在0和1之间（缺省是0.3）。
返回传递进来的相同的值。
</TD></TR></TBODY></TABLE></DIV><DIV CLASS="TABLE"><A NAME="PGTRGM-OP-TABLE"></A><P><B>&#34920; F-23. <TT CLASS="FILENAME">pg_trgm</TT> 操作符</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>操作符</TH><TH>返回</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="TYPE">text</TT> <TT CLASS="LITERAL">%</TT> <TT CLASS="TYPE">text</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>
如果它的参数的相似性高于<CODE CLASS="FUNCTION">set_limit</CODE>设置的当前相似性阈值则返回<TT CLASS="LITERAL">true</TT>。
</TD></TR><TR><TD><TT CLASS="TYPE">text</TT> <TT CLASS="LITERAL">&lt;-&gt;</TT> <TT CLASS="TYPE">text</TT></TD><TD><TT CLASS="TYPE">real</TT></TD><TD>
返回参数之间的<SPAN CLASS="QUOTE">"距离"</SPAN>，这是1减去<CODE CLASS="FUNCTION">similarity()</CODE>值。
</TD></TR></TBODY></TABLE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149508">F.30.3. 索引支持</A></H2><P><TT CLASS="FILENAME">pg_trgm</TT>模块提供GiST和GIN索引操作符类，
该操作符类允许你为了非常快速的相似性搜索在文本字段上创建一个索引。
这些索引类型支持上面描述的相似性操作符，并且额外支持基于三元模型的索引搜索：
<TT CLASS="LITERAL">LIKE</TT>， <TT CLASS="LITERAL">ILIKE</TT>，<TT CLASS="LITERAL">~</TT> 和 <TT CLASS="LITERAL">~*</TT>查询。
（这些索引并不支持相等也不支持简单的比较操作符，所以你可能也需要一个普通的B-tree索引。）</P><P>
示例：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE test_trgm (t text);
CREATE INDEX trgm_idx ON test_trgm USING gist (t gist_trgm_ops);</PRE><P>
或
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX trgm_idx ON test_trgm USING gin (t gin_trgm_ops);</PRE><P>
</P><P>
在这一点，你将有一个在<TT CLASS="STRUCTFIELD">t</TT>列上的索引，你可以用它来做相似性搜索。
一个典型的查询是：
</P><PRE CLASS="PROGRAMLISTING">SELECT t, similarity(t, '<TT
CLASS="REPLACEABLE"
><I
>word</I
></TT
>') AS sml
  FROM test_trgm
  WHERE t % '<TT
CLASS="REPLACEABLE"
><I
>word</I
></TT
>'
  ORDER BY sml DESC, t;</PRE><P>
这将返回文本列上与<TT CLASS="REPLACEABLE"><I>word</I></TT>足够相似的所有值，从最佳匹配到最坏匹配排序。
该索引将用来做一个快速操作，即使是在非常大的数据集上面。
</P><P>
上面查询的一个变体是：
</P><PRE CLASS="PROGRAMLISTING">SELECT t, t &lt;-&gt; '<TT
CLASS="REPLACEABLE"
><I
>word</I
></TT
>' AS dist
  FROM test_trgm
  ORDER BY dist LIMIT 10;</PRE><P>
这个可以通过GiST索引更有效的实现，而不是GIN索引。当只想要少量最靠近的匹配时，
通常会使用第一个公式。
</P><P>
从<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.1开始，这些索引类型也支持
<TT CLASS="LITERAL">LIKE</TT>和<TT CLASS="LITERAL">ILIKE</TT>索引搜索，例如
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM test_trgm WHERE t LIKE '%foo%bar';</PRE><P>
该索引搜索通过从搜索字符串中提取三元模型然后在索引中查找这些三元模型来工作。
搜索字符串中的三元模型越多，索引搜索越有效率。不像基于B-tree的搜索，
搜索字符串不需要是左边固定的。
</P><P>
从<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.3开始，这些索引类型也支持正则表达式匹配的索引搜索
（<TT CLASS="LITERAL">~</TT>和<TT CLASS="LITERAL">~*</TT>操作符），例如
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM test_trgm WHERE t ~ '(foo|bar)';</PRE><P>
该索引搜索通过从正则表达式中提取三元模型然后在索引中查找这些三元模型来工作。
从正则表达式中提取出来的三元模型越多，索引搜索越有效率。不像基于B-tree的搜索，
搜索字符串不需要是左边固定的。
</P><P>对于<TT CLASS="LITERAL">LIKE</TT>和正则表达式搜索，请记住，没有可提取的三元模型将降级为全文索引搜索。</P><P>选择GiST还是GIN索引取决于GiST和GIN的相对性能特征，这个在别的地方讨论。
一般来说，GIN索引比GiST索引搜索起来要快，但是在建立或更新时要慢；
索引GIN更适合于静态数据而GiST适合于经常更新的数据。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149541">F.30.4. 文本搜索集成</A></H2><P>三元模型匹配在用于与全文本索引相协调时是一个非常有用的工具。
尤其是它可以帮助识别错误拼写的输入单词，这样的单词将不能直接通过全文本搜索机制匹配。</P><P>
第一步是要生成一个包含文档中的所有唯一词的辅助表：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE words AS SELECT word FROM
        ts_stat('SELECT to_tsvector(''simple'', bodytext) FROM documents');</PRE><P>
这里的<TT CLASS="STRUCTNAME">documents</TT>是含有我们希望搜索的文本字段<TT CLASS="STRUCTFIELD">bodytext</TT>的表。
使用<TT CLASS="LITERAL">simple</TT>配置<CODE CLASS="FUNCTION">to_tsvector</CODE>函数的原因，
不是使用一个语言特定的配置，是我们想要一个原始（未修改）词的列表。
</P><P>
下一步，在该词的列上创建一个三元模型索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX words_idx ON words USING gin(word gin_trgm_ops);</PRE><P>
现在，一个类似于之前示例的<TT CLASS="COMMAND">SELECT</TT>
查询可以用来在用户搜索词中建议错误拼写的词的拼写。
需要一个有用的额外的文本，选中的词和错误拼写的词有相似的长度。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>因为<TT CLASS="STRUCTNAME">words</TT>表是作为一个单独的、静态表生成的，它需要定期的重新生成，
这样它才能与文档集合保持合理的更新。通常不需要使它恰好是当前的。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149556">F.30.5. 参考文献</A></H2><P>GiST开发网站
<A HREF="http://www.sai.msu.su/~megera/postgres/gist/" TARGET="_top">http://www.sai.msu.su/~megera/postgres/gist/</A></P><P>Tsearch2开发网站
<A HREF="http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/" TARGET="_top">http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/</A></P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149562">F.30.6. 作者</A></H2><P> Oleg Bartunov <CODE CLASS="EMAIL">&#60;<A HREF="mailto:oleg@sai.msu.su">oleg@sai.msu.su</A>&#62;</CODE>, Moscow, Moscow University, Russia
</P><P> Teodor Sigaev <CODE CLASS="EMAIL">&#60;<A HREF="mailto:teodor@sigaev.ru">teodor@sigaev.ru</A>&#62;</CODE>, Moscow, Delta-Soft Ltd.,Russia
</P><P>文档：Christopher Kings-Lynne</P><P>这个模块是由Delta-Soft Ltd., Moscow, Russia赞助的。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="pgstattuple.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="postgres-fdw.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">pgstattuple</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">postgres_fdw</TD></TR></TABLE></DIV></BODY></HTML>
