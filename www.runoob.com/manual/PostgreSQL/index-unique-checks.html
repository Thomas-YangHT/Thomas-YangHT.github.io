<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>索引唯一性检查</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="索引访问方法接口定义" HREF="http://school.yunwei.edu/manual/PostgreSQL/indexam.html"><LINK REL="PREVIOUS" TITLE="索引锁的考量" HREF="index-locking.html"><LINK REL="NEXT" TITLE="索引开销估计函数" HREF="index-cost-estimation.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/indexam.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="索引锁的考量" HREF="index-locking.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/indexam.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 54. 索引访问方法接口定义</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="索引开销估计函数" HREF="index-cost-estimation.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="INDEX-UNIQUE-CHECKS">54.5. 索引唯一性检查</A></H1><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>使用<I CLASS="FIRSTTERM">唯一索引</I>来强制 SQL 唯一约束，唯一索引实际上是不允许多条记录有相同键值的的索引。
一个支持这个特性的访问方法要设置<TT CLASS="STRUCTNAME">pg_am</TT>.<TT CLASS="STRUCTFIELD">amcanunique</TT>为真。（目前，只有 b-tree 支持它。）
</P><P>因为 MVCC ，必须允许重复的条目物理上存在于索引之中：该条目可能指向某个逻辑行的后面的版本。
实际想强制的行为是，任何 MVCC 快照都不能包含两条相同的索引键字。
这种要求在向一个唯一索引插入新行的时候分解成下面的几种情况：
<P></P></P><UL><LI><P>如果一个有冲突的合法行被当前事务删除，这是可以的。
（特别是因为一个 UPDATE 总是在插入新版本之前删除旧版本，这样就允许一个行上的 UPDATE 不用改变键字进行操作。）
</P></LI><LI><P>如果一个在等待提交的事务插入了一行有冲突的数据，那么准备插入数据的事务必须等待看看改事务是否提交。
如果该事务回滚，那么就没有冲突。如果它没有删除冲突行然后提交，那么就有一个唯一性违例。
（实际上只是等待另外那个事务结束，然后在程序里重做可视性检查。）
</P></LI><LI><P>类似的，如果一个有冲突的有效行被一个准备提交的事务删除，那么另外一个准备提交的插入事务必须等待该事务提交或者退出，然后重做测试。
</P></LI></UL><P>
</P><P>此外，根据上面的规则报告唯一性违反前，访问方法必须重新检查刚被插入的行是否仍然<SPAN CLASS="QUOTE">"活着"</SPAN>。
如果这一行已经因为事务的提交而<SPAN CLASS="QUOTE">"死掉了"</SPAN>，那么不应当发出任何错误。
(这种情况不可能出现在插入一个由当前事务创建的行的普通场景下。
但是在<TT CLASS="COMMAND">CREATE UNIQUE INDEX CONCURRENTLY</TT>的过程中是可能的。）
</P><P>我们要求索引访问方法自己进行这些测试，这就意味着它必须检查堆，以便查看那些根据索引内容表明有重复键字的任意行的提交状态。
这样做毫无疑问地很难看并且也不是模块化的，但是这样可以节约重复的工作：
如果我们实施分离的探测，那么，当查找新行的索引项的插入位置时，必须重复对冲突行的索引查找。
并且，没有很显然的方法来避免竞争条件，除非冲突检查是插入新索引项的整体动作的一部分。
</P><P>如果唯一性约束是可延期的，情况将更加复杂：我们需要能够为新行插入一个新的索引项，
但推迟任何唯一性违反的错误，直到语句结束甚至更晚。
为了避免不必要的重复搜索索引，索引访问方法应该在初始插入时做一个初步的唯一性约束检查。
如果结果明确地显示没有和活着的元组没有冲突，那么事情已经完成了。
否则当需要实施这个约束时，我们需要调度一个再检查。
如果再检查时，被插入的元组和有着相同键的其他元组都还活着，那么必须报告错误。
（为此，<SPAN CLASS="QUOTE">"活着"</SPAN>实际上意味着<SPAN CLASS="QUOTE">"在该索引项的HOT链上的任何一个元组还活着"</SPAN>。）
为了实现这个，<CODE CLASS="FUNCTION">aminsert</CODE>函数被传入拥有下列某一个值的<TT CLASS="LITERAL">checkUnique</TT>参数：
<P></P></P><UL><LI><P><TT CLASS="LITERAL">UNIQUE_CHECK_NO</TT>指示不检查唯一性约束（这是一个非唯一索引）。
</P></LI><LI><P><TT CLASS="LITERAL">UNIQUE_CHECK_YES</TT>指示这是一个非可推迟唯一性约束，并且正如上面描述的必须立即检查唯一性约束。
</P></LI><LI><P><TT CLASS="LITERAL">UNIQUE_CHECK_PARTIAL</TT>指示这个唯一性约束是可延期的。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将使用这种模式插入每一行的索引项。
访问方法必须允许在索引中插入重复的项目，并且通过让<CODE CLASS="FUNCTION">aminsert</CODE>返回FALSE报告任何潜在的重复。
对每一个返回FALSE的行，一个延期的再检查将会被调度。
</P><P>访问方法必须识别任何可能违反唯一性约束的行，但是对它来说把不违反唯一性约束的行报告成可能违反并不是一个错误。
这允许不必等待其他事务完成就可以完成检查；在这里被报告的冲突不被当成错误并且将在以后进行再检查，那时冲突可能已经消失了。
</P></LI><LI><P><TT CLASS="LITERAL">UNIQUE_CHECK_EXISTING</TT>指示这是对一个被报告有潜在唯一性违反的行的被延期的再检查。
尽管是通过调用<CODE CLASS="FUNCTION">aminsert</CODE>函数，这种情况下访问方法必须<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不能</I></SPAN>插入新的索引项。
相应的索引项已经存在了。当然，访问方法必须检查是否有另一个活着的索引项。
如果有并且目标行仍然活着的话报告错误。
</P><P><TT CLASS="LITERAL">UNIQUE_CHECK_EXISTING</TT>被调用时，建议访问方法进一步去确认目标行已经在索引中有一个索引项，如果没有则报错。
这是个好的做法，因为传入<CODE CLASS="FUNCTION">aminsert</CODE>的索引元组的值可能被重新计算。
如果索引定义涉及不是真正不可变（immutable）的函数，我们可能会在索引中错误的区域查找。
检查目标行可以在再检查中被找到确保我们正在扫描原始插入时使用的相同的元组值。
</P></LI></UL><P>
</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="index-locking.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="index-cost-estimation.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">索引锁的考量</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/indexam.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">索引开销估计函数</TD></TR></TABLE></DIV></BODY></HTML>
