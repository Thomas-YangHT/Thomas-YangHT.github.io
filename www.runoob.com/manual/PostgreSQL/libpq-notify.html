<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>异步通知</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="捷径接口" HREF="libpq-fastpath.html"><LINK REL="NEXT" TITLE="与COPY命令相关的函数" HREF="libpq-copy.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="捷径接口" HREF="libpq-fastpath.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="与COPY命令相关的函数" HREF="libpq-copy.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-NOTIFY">31.8. 异步通知</A></H1><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>通过<TT CLASS="COMMAND">LISTEN</TT>和<TT CLASS="COMMAND">NOTIFY</TT>
命令提供对异步通知的支持。一个客户端会话用<TT CLASS="COMMAND">LISTEN</TT>命令注册一个它感兴趣的通知条件
（也可以用<TT CLASS="COMMAND">UNLISTEN</TT>命令停止监听）。所有正在监听某一通知条件的会话在该条件名的
<TT CLASS="COMMAND">NOTIFY</TT>（通知）被任何会话执行后都将被异步地通知。
一个<SPAN CLASS="QUOTE">"payload"</SPAN>可以向听众传达额外的数据。</P><P><SPAN CLASS="APPLICATION">libpq</SPAN>应用把<TT CLASS="COMMAND">LISTEN</TT>，<TT CLASS="COMMAND">UNLISTEN</TT>
和<TT CLASS="COMMAND">NOTIFY</TT>命令作为普通的 SQL 命令提交。随后通过调用
<CODE CLASS="FUNCTION">PQnotifies</CODE>可以侦测到<TT CLASS="COMMAND">NOTIFY</TT>消息的到达。</P><P>函数<CODE CLASS="FUNCTION">PQnotifies</CODE>从一个来自服务器的未处理的通知信息列表中返回下一条通知。
如果没有未处理的信息则返回 NULL 指针。一旦<CODE CLASS="FUNCTION">PQnotifies</CODE>返回一条通知，
该通知会被认为已处理并且将被从通知列表中删除。
</P><PRE CLASS="SYNOPSIS">PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* 通知的通道名字 */
    int  be_pid;                /* 通知服务器进程的进程ID */
    char *extra;                /* 通知负载字符串 */
} PGnotify;</PRE><P>
在处理完<CODE CLASS="FUNCTION">PQnotifies</CODE>返回的<TT CLASS="STRUCTNAME">PGnotify</TT>对象后，
别忘了用<CODE CLASS="FUNCTION">PQfreemem</CODE>把它释放。释放<TT CLASS="STRUCTNAME">PGnotify</TT>
指针就足够了；<TT CLASS="STRUCTFIELD">relname</TT>和<TT CLASS="STRUCTFIELD">extra</TT>
字段并未代表独立分配的内存。（这些领域的名称是历史性的，尤其是频道名称与名称没有什么关系。）
</P><P><A HREF="libpq-example.html#LIBPQ-EXAMPLE-2">&#20363; 31-2</A>给出了一个简单的程序，举例说明异步通知的使用。</P><P><CODE CLASS="FUNCTION">PQnotifies</CODE>实际上并不读取服务器数据；它只是返回被前面的另一个
<SPAN CLASS="APPLICATION">libpq</SPAN>函数吸收的信息。在以前的<SPAN CLASS="APPLICATION">libpq</SPAN>
版本里，周期性的收到<TT CLASS="COMMAND">NOTIFY</TT>信息的唯一方法是持续的提交命令，
即使是空查询也可以，并且在每次<CODE CLASS="FUNCTION">PQexec</CODE>后检查<CODE CLASS="FUNCTION">PQnotifies</CODE>。
现在这个方法也还能工作，不过我们认为它太浪费处理器时间而废弃了它。</P><P>在你没有可用的命令提交时检查<TT CLASS="COMMAND">NOTIFY</TT>消息的更好的方法是调用
<CODE CLASS="FUNCTION">PQconsumeInput</CODE>，然后检查<CODE CLASS="FUNCTION">PQnotifies</CODE>。
你可以使用<CODE CLASS="FUNCTION">select()</CODE>来等待服务器数据的到达，
这样在没有数据可处理时可以不浪费<ACRONYM CLASS="ACRONYM">CPU</ACRONYM>时间。（参阅
<CODE CLASS="FUNCTION">PQsocket</CODE>获取用于<CODE CLASS="FUNCTION">select()</CODE>的文件描述符。）
注意这种方法不管你使用<CODE CLASS="FUNCTION">PQsendQuery</CODE>/<CODE CLASS="FUNCTION">PQgetResult</CODE>
还是简单的<CODE CLASS="FUNCTION">PQexec</CODE>来执行命令都能工作。不过，你应该记住在每次
<CODE CLASS="FUNCTION">PQgetResult</CODE>或<CODE CLASS="FUNCTION">PQexec</CODE>后检查
<CODE CLASS="FUNCTION">PQnotifies</CODE>，看看在处理命令的过程中是否有通知到达。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-fastpath.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-copy.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">捷径接口</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">与<TT CLASS="COMMAND">COPY</TT>命令相关的函数</TD></TR></TABLE></DIV></BODY></HTML>
