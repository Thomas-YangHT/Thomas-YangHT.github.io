<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>基本语句</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PL/pgSQL - SQL过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html"><LINK REL="PREVIOUS" TITLE="表达式" HREF="plpgsql-expressions.html"><LINK REL="NEXT" TITLE="控制结构" HREF="plpgsql-control-structures.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/plpgsql.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="表达式" HREF="plpgsql-expressions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 40. <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN> - <ACRONYM CLASS="ACRONYM">SQL</ACRONYM>过程语言</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="控制结构" HREF="plpgsql-control-structures.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PLPGSQL-STATEMENTS">40.5. 基本语句</A></H1><P> 本节以及随后的一节里，
描述所有<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>明确可以理解的语句类型。
任何无法识别为这样类型的语句将被做为SQL命令看待，
并且被发送到主数据库引擎执行，
正如在节<A HREF="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-NORESULT">第 40.5.2 &#33410;</A>
和<A HREF="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-ONEROW">第 40.5.3 &#33410;</A>中描述的那样。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-STATEMENTS-ASSIGNMENT">40.5.1. 赋值</A></H2><P>
给一个<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量的赋值如下:
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>variable</I
></TT
> := <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>;</PRE><P>
如上所述，语句中的表达式是用一个发送到主数据库引擎的<TT CLASS="COMMAND">SELECT</TT>命令计算的。
该表达式必须生成单一的数值。表达式必须只能生成一个值
（如果变量一个行或者record，那么该值可能是一个行）。
目标变量可以是一个简单的变量（可以用一个block的名字来描述），
行或record变量的字段，或者是一个简单变量或字段的数组元素。
</P><P>如果表达式的结果数据类型和变量数据类型不一致，
或者变量具有已知的尺寸/精度(比如<TT CLASS="TYPE">char(20)</TT>)，
结果值将隐含地被<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>解释器用结果类型的输出
函数和变量类型的输入函数转换。
注意，如果结果数值的字符串形式不是输入函数可以接受的形式，
那么这样做可能导致类型输入函数产生的运行时错误。</P><P>
例子：
</P><PRE CLASS="PROGRAMLISTING">tax := subtotal * 0.06;
my_record.user_id := 20;</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-STATEMENTS-SQL-NORESULT">40.5.2. 执行一个没有结果的查询</A></H2><P> 对于不返回任何行的SQL命令，例如没有<TT CLASS="LITERAL">RETURNING</TT>子句的<TT CLASS="COMMAND">INSERT</TT>，
你可以简单的在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数内写上该语句，
然后执行该函数即可。</P><P>出现在查询文本中的任何<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量名都会被参数符号代替，
并在运行时将参数值替换为变量的当前值。
就像之前描述的表达式进程，可以查看资料<A HREF="plpgsql-implementation.html#PLPGSQL-VAR-SUBST">第 40.10.1 &#33410;</A>。</P><P> 当以这种方式执行一条SQL命令，这条命令在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>
中缓存并且在执行规划中重新使用。
正如在<A HREF="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING">第 40.10.2 &#33410;</A>中讨论的。</P><P>
有时评估一个表达式或<TT CLASS="COMMAND">SELECT</TT>查询但是丢弃其结果也是有用的，
例如，调用一个具有副作用的函数，但对它的结果不感兴趣。
要在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>中这样做，可以使用<TT CLASS="COMMAND">PERFORM</TT>语句:
</P><PRE CLASS="SYNOPSIS">PERFORM <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>;</PRE><P>
这将执行<TT CLASS="REPLACEABLE"><I>query</I></TT>并丢弃其结果。
用<TT CLASS="COMMAND">SELECT</TT>命令重写<TT CLASS="REPLACEABLE"><I>query</I></TT>，并将<TT CLASS="COMMAND">SELECT</TT>
替换为<TT CLASS="COMMAND">PERFORM</TT>，
对于<TT CLASS="COMMAND">WITH</TT>查询，使用<TT CLASS="COMMAND">PERFORM</TT>并且将查询放在括号中（在这种情况下，
查询只仅仅返回一行）。
这样，<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量将会在查询中被照常替换。
另外，如果查询生成至少一行结果的话，
特殊变量<TT CLASS="LITERAL">FOUND</TT>将会被设为真，否则将被设为假。
（查阅<A HREF="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS">第 40.5.5 &#33410;</A>）
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 有些人可能期望直接写<TT CLASS="COMMAND">SELECT</TT>就能同样达到此目的，
但目前确实只有<TT CLASS="COMMAND">PERFORM</TT>一种方法。
诸如<TT CLASS="COMMAND">SELECT</TT>这样返回行的查询将会被当作错误拒绝，
除非其带有一个下面将要讨论的<TT CLASS="LITERAL">INTO</TT>子句。</P></BLOCKQUOTE></DIV><P>
例如：
</P><PRE CLASS="PROGRAMLISTING">PERFORM create_mv('cs_session_page_requests_mv', my_query);</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-STATEMENTS-SQL-ONEROW">40.5.3. 执行一个仅有单行结果的查询</A></H2><P>
如果一个SQL命令的结果是一个单独的行(可能有多个字段)，
那么可以将其赋予一个记录变量、行类型变量、标量变量的列表。
这可以通过在基本SQL命令之后添加一个<TT CLASS="LITERAL">INTO</TT>子句达到。例如：
</P><PRE CLASS="SYNOPSIS">SELECT <TT
CLASS="REPLACEABLE"
><I
>select_expressions</I
></TT
> INTO [<SPAN
CLASS="OPTIONAL"
>STRICT</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> FROM ...;
INSERT ... RETURNING <TT
CLASS="REPLACEABLE"
><I
>expressions</I
></TT
> INTO [<SPAN
CLASS="OPTIONAL"
>STRICT</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>;
UPDATE ... RETURNING <TT
CLASS="REPLACEABLE"
><I
>expressions</I
></TT
> INTO [<SPAN
CLASS="OPTIONAL"
>STRICT</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>;
DELETE ... RETURNING <TT
CLASS="REPLACEABLE"
><I
>expressions</I
></TT
> INTO [<SPAN
CLASS="OPTIONAL"
>STRICT</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>;</PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>target</I></TT>可以是一个记录变量、
行变量、逗号分隔的简单变量列表、逗号分隔记录/行字段列表。
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量将被照常代入查询的其余部分，
适用于带有<TT CLASS="LITERAL">RETURNING</TT>的<TT CLASS="COMMAND">SELECT</TT>,
<TT CLASS="COMMAND">INSERT</TT>/<TT CLASS="COMMAND">UPDATE</TT>/<TT CLASS="COMMAND">DELETE</TT>，
以及返回行集合的命令(比如<TT CLASS="COMMAND">EXPLAIN</TT>)。
除<TT CLASS="LITERAL">INTO</TT>子句外，
SQL命令与其在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>外面时完全相同。
</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B> 请注意，上面带有<TT CLASS="LITERAL">INTO</TT>的<TT CLASS="COMMAND">SELECT</TT>和
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>普通的<TT CLASS="COMMAND">SELECT INTO</TT>命令是不一样的，
后者的<TT CLASS="LITERAL">INTO</TT>目标是一个新创建的表。
如果你想在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数里从一个<TT CLASS="COMMAND">SELECT</TT>结果中创建表，
那么请使用<TT CLASS="COMMAND">CREATE TABLE ... AS SELECT</TT>语法。</P></BLOCKQUOTE></DIV><P>如果将一行或者一个变量列表用做目标，那么查询的结果必需作为数目或者数据类型精确匹配目标的结构，
否则就会产生运行时错误。如果目标是一个记录变量，那么它自动将自己配置成命令结果列的行类型。</P><P> <TT CLASS="LITERAL">INTO</TT>子句几乎可以出现在SQL命令的任何地方。
习惯上把它写在<TT CLASS="COMMAND">SELECT</TT>命令的<TT CLASS="REPLACEABLE"><I>select_expressions</I></TT>列表的之前或之后，
对于其它命令则位于结尾。
我们建议你遵守这个约定，以防万一<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>分析器在未来的版本中变得更加严格。</P><P>
如果没有在INTO指定STRICT，那么target将被设为查询返回结果的第一行或者 NULL(查询返回零行)，
请注意，除非用ORDER BY进行排序，否则"the first row"是不明确的。
第一行之后的所有结果都将被丢弃。
你可以检查特殊变量FOUND(参见Section 39.5.5)来判断查询是否至少返回一行。
</P><PRE CLASS="PROGRAMLISTING">SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;</PRE><P>
如果指定了<TT CLASS="LITERAL">STRICT</TT>选项，
那么查询必须返回恰好一个行或者是运行时的错误，
要么是<TT CLASS="LITERAL">NO_DATA_FOUND</TT>(没有行)，要么是<TT CLASS="LITERAL">TOO_MANY_ROWS</TT>(多于一行)。
可以使用异常块来捕获这些错误。例如：
</P><PRE CLASS="PROGRAMLISTING">BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;</PRE><P>
成功执行了一个带有<TT CLASS="LITERAL">STRICT</TT>的命令之后，<TT CLASS="LITERAL">FOUND</TT>将总是被设为真。
</P><P> 对于带有<TT CLASS="LITERAL">RETURNING</TT>的<TT CLASS="COMMAND">INSERT</TT>/<TT CLASS="COMMAND">UPDATE</TT>/<TT CLASS="COMMAND">DELETE</TT>，
即使没有指定<TT CLASS="LITERAL">STRICT</TT>，<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>也会在返回多行时报错。
这是因为没有<TT CLASS="LITERAL">ORDER BY</TT>之类的选项用于确定究竟返回那一行。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> <TT CLASS="LITERAL">STRICT</TT>兼容 Oracle PL/SQL的<TT CLASS="COMMAND">SELECT INTO</TT>行为以及相关语句。</P></BLOCKQUOTE></DIV><P>对于如何处理一个SQL查询中返回的多行，参见<A HREF="plpgsql-control-structures.html#PLPGSQL-RECORDS-ITERATING">第 40.6.4 &#33410;</A>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-STATEMENTS-EXECUTING-DYN">40.5.4. 执行动态命令</A></H2><P>
你经常会希望在你的<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数里生成动态命令。
也就是那些每次执行的时候都会涉及不同表或不同数据类型的命令。在这样的情况下，
<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>试图为命令(正如<A HREF="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING">第 40.10.2 &#33410;</A>讨论的)
缓冲执行计划的一般企图将不再合适。
为了处理这样的问题，提供了<TT CLASS="COMMAND">EXECUTE</TT>语句：
</P><PRE CLASS="SYNOPSIS">EXECUTE <TT
CLASS="REPLACEABLE"
><I
>command-string</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> INTO [<SPAN
CLASS="OPTIONAL"
>STRICT</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> USING <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ... </SPAN
>] </SPAN
>];</PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>command-string</I></TT>是一个生成字符串(类型为<TT CLASS="TYPE">text</TT>)的表达式，
该字符串包含要执行的命令。
而<TT CLASS="REPLACEABLE"><I>target</I></TT>是一个记录变量、行变量、逗号分隔的简单变量列表、
逗号分隔的记录/行列表，来存储命令的结果。通过使用<TT CLASS="LITERAL">USING</TT>表达式，将参数值插入到命令中。
</P><P>
请特别注意在该命令字符串里将不会发生任何<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量代换。
变量的数值必需在构造的时候插入该字符串的值，或者也可以使用下面介绍的参数。</P><P> 同时，对于通过<TT CLASS="COMMAND">EXECUTE</TT>执行的命令，没有预先设置缓存计划。
相反，在该语句每次运行的时候，命令都准备一次。
命令字符串可以在过程里动态地生成以便于对各种不同的表和字段进行操作。</P><P> <TT CLASS="LITERAL">INTO</TT>子句声明SQL命令的结果应该传递到哪里。
如果提供了一个行变量或者一个变量列表，
那么它必须和查询生成的结果的结构一样(如果使用了记录变量，那么它回自动调整为匹配结果的结构)。
如果返回了多行，那么只有第一行将被赋予<TT CLASS="LITERAL">INTO</TT>变量。
如果返回零行，那么将给<TT CLASS="LITERAL">INTO</TT>变量赋予NULL。
如果没有声明<TT CLASS="LITERAL">INTO</TT>子句，则抛弃查询结果。</P><P> 如果使用了<TT CLASS="LITERAL">STRICT</TT>选项，那么在查询没有恰好返回一个行的情况下将会报错。</P><P>
该命令可以使用那些在命令中被引用为<TT CLASS="LITERAL">$1</TT>, <TT CLASS="LITERAL">$2</TT>等的参数值。
这些标签指向的是在<TT CLASS="LITERAL">USING</TT>子句中使用的值。
这样做可以很好的将数据值以文本类型插入到命令字符串中：
避免了运行期间在数据值和文本类型之间转换的开销，
并且这种方法不是倾向于进行SQL-injection，因为没有进行引用和转义的必要。例如：
</P><PRE CLASS="PROGRAMLISTING">EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</PRE><P>
</P><P>
需要注意的是，参数标签只能用于数据值&mdash;
如果想要使用动态的已知的表或列的名字，
那么必须将它们以文本字符串类型插入到命令中。
例如，当上面那个查询需要在一个动态选择的表上执行时，你可以这么做：
</P><PRE CLASS="PROGRAMLISTING">EXECUTE 'SELECT count(*) FROM '
    || tabname::regclass
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</PRE><P>
另一个关于参数标签的限制是，
它们只能在<TT CLASS="COMMAND">SELECT</TT>, <TT CLASS="COMMAND">INSERT</TT>, <TT CLASS="COMMAND">UPDATE</TT>和
<TT CLASS="COMMAND">DELETE</TT>命令中使用。
在另一种语法类型中，通常称为通用语法中，可以将参数值以文本类型插入，
哪怕它们只是数据值。
</P><P> 如在上面第一个例子中的，带有一个简单常量字符串和<TT CLASS="LITERAL">USING</TT>参数的<TT CLASS="COMMAND">EXECUTE</TT>命令，
它在功能上等同于直接在<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>中写命令，
并且允许<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>变量自动替换。
最重要的不同之处在于，<TT CLASS="COMMAND">EXECUTE</TT>会在每一次执行时，根据当前的参数值更新该命令计划，
在这一点上，<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>可能创建一个命令计划，并将
其放于缓存中以待重新使用。
当命令计划对参数值的依赖性很强时，
对于使用<TT CLASS="COMMAND">EXECUTE</TT>积极确保通用计划不被选择是很有帮助的。</P><P> <TT CLASS="COMMAND">EXECUTE</TT>命令目前不支持<TT CLASS="COMMAND">SELECT INTO</TT>，
但是支持一个纯<TT CLASS="COMMAND">SELECT</TT>命令，并且声明一个<TT CLASS="LITERAL">INTO</TT>作为命令本身的一部分。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> <SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>中的<TT CLASS="COMMAND">EXECUTE</TT>语法与
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器支持的<A HREF="sql-execute.html">EXECUTE</A>语法无关。
服务器支持的<TT CLASS="COMMAND">EXECUTE</TT>语法不能
被<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数直接使用（并且也没有必要）。</P></BLOCKQUOTE></DIV><DIV CLASS="EXAMPLE"><A NAME="PLPGSQL-QUOTE-LITERAL-EXAMPLE"></A><P><B>&#20363; 40-1. 动态查询中的引用值</B></P><P> 使用动态命令的时候经常需要转义单引号。
建议使用美元符界定函数体内的固定文本。
如果你有没有使用美元符界定的老代码，请参考<A HREF="plpgsql-development-tips.html#PLPGSQL-QUOTE-TIPS">第 40.11.1 &#33410;</A>，
这样在把老代码转换成更合理的结构时，会节省你的一些精力。</P><P>
插入到构造出来的查询中的动态数值也需要特殊处理，
因为他们自己可能包含引号字符。
一个例子(这里都假设你使用了美元符作为整体，所以引号标记不需要加倍)：
</P><PRE CLASS="PROGRAMLISTING">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);</PRE><P>
</P><P> 这个例子显示了<CODE CLASS="FUNCTION">quote_ident</CODE>和<CODE CLASS="FUNCTION">quote_literal</CODE>
函数的使用（参阅<A HREF="functions-string.html">第 9.4 &#33410;</A>）。
为了安全，包含字段和表标识符的变量应该传递给<CODE CLASS="FUNCTION">quote_ident</CODE>函数。
那些包含数值的表达式，如果中的数值在构造出来的命令字符串里是文本字符串，
那么应该传递给<CODE CLASS="FUNCTION">quote_literal</CODE>。
它们俩都会采取合适的步骤把输入文本包围在单或双引号里，
并且对任何嵌入其中的特殊字符进行合适的转义处理。</P><P>
因为<CODE CLASS="FUNCTION">quote_literal</CODE>被标记为<TT CLASS="LITERAL">STRICT</TT>，
当发出带有null参数的请求时，
往往会返回一个null。在上面的例子中，如果<TT CLASS="LITERAL">newvalue</TT>或者
<TT CLASS="LITERAL">keyvalue</TT>是null，
整个动态查询字符串会变成null，最终<TT CLASS="COMMAND">EXECUTE</TT>会报错。
可以通过使用<CODE CLASS="FUNCTION">quote_nullable</CODE>函数来避免该错误，
除了当发出带有null参数的请求时，往往会返回一个字符串NULL之外，
该函数与<CODE CLASS="FUNCTION">quote_literal</CODE>一样工作。例如：
</P><PRE CLASS="PROGRAMLISTING">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);</PRE><P>
如果处理的参数值是null，那么应该用<CODE CLASS="FUNCTION">quote_nullable</CODE>来代替<CODE CLASS="FUNCTION">quote_literal</CODE>。
</P><P>
通常，应该注意确保查询中的null值返回意料之外的结果。例如：
</P><PRE CLASS="PROGRAMLISTING">'WHERE key = ' || quote_nullable(keyvalue)</PRE><P>
如果<TT CLASS="LITERAL">keyvalue</TT>是null，那么该<TT CLASS="LITERAL">WHERE</TT>子句永远不会成功，
因为当<TT CLASS="LITERAL">=</TT>操作符带有null操作数，操作返回的结果往往是null。
如果想让null同普通关键字一样使用，那么将上面的命令修改如下：
</P><PRE CLASS="PROGRAMLISTING">'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)</PRE><P>
目前，<TT CLASS="LITERAL">IS NOT DISTINCT FROM</TT>处理效率不如<TT CLASS="LITERAL">=</TT>，因此如非必要，
不用这么做。关于null和<TT CLASS="LITERAL">IS DISTINCT</TT>的资料可参阅<A HREF="functions-comparison.html">第 9.2 &#33410;</A>。
</P><P>
请注意美元符界定只对包围固定文本有用。如果想像下面这样做上面的例子，那就太糟糕了:
</P><PRE CLASS="PROGRAMLISTING">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);</PRE><P>
因为如果<TT CLASS="LITERAL">newvalue</TT>的内容碰巧含有<TT CLASS="LITERAL">$$</TT>，那么这段代码就有毛病了。
同样的问题可能出现在你选用的任何美元符界定分隔符上。
因此，要想安全地包围事先不知道的文本，
<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必须</I></SPAN>恰当的使用<CODE CLASS="FUNCTION">quote_literal</CODE>，
<CODE CLASS="FUNCTION">quote_nullable</CODE>或者<CODE CLASS="FUNCTION">quote_ident</CODE>。
</P><P>
动态SQL语句可以使用<CODE CLASS="FUNCTION">format</CODE>函数安全构建
（参阅<A HREF="functions-string.html">第 9.4 &#33410;</A>）。比如：
</P><PRE CLASS="PROGRAMLISTING">EXECUTE format('UPDATE tbl SET %I = %L WHERE key = %L', colname, newvalue, keyvalue);</PRE><P>
在<TT CLASS="LITERAL">USING</TT>子句连接中使用<CODE CLASS="FUNCTION">format</CODE>函数：
</P><PRE CLASS="PROGRAMLISTING">EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;</PRE><P>
这种形式更有效，因为参数<TT CLASS="LITERAL">newvalue</TT> and <TT CLASS="LITERAL">keyvalue</TT>
不转换为文本。
</P></DIV><P>关于动态命令和<TT CLASS="COMMAND">EXECUTE</TT>的另一个例子
是<A HREF="plpgsql-porting.html#PLPGSQL-PORTING-EX2">&#20363; 40-9</A>，
这个例子制作并执行了一个定义新函数的<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-STATEMENTS-DIAGNOSTICS">40.5.5. 获取结果状态</A></H2><P>
有好几种方法可以判断一条命令的效果。
第一个方法是使用<TT CLASS="COMMAND">GET DIAGNOSTICS</TT>，它的形式如下：
</P><PRE CLASS="SYNOPSIS">GET [<SPAN
CLASS="OPTIONAL"
> CURRENT </SPAN
>] DIAGNOSTICS <TT
CLASS="REPLACEABLE"
><I
>variable</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> , ... </SPAN
>];</PRE><P>
这条命令允许检索系统状态标识符。每个<TT CLASS="REPLACEABLE"><I>item</I></TT>是一个关键字，
表示一个将要赋予该特定变量的状态值(该变量应该和要接收的数值类型相同)。
当前可用的状态项有<TT CLASS="VARNAME">ROW_COUNT</TT>、最后一个<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命
令发送到<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>引擎处理的行数量、<TT CLASS="VARNAME">RESULT_OID</TT>，
最后一条<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令插入的最后一行的OID。
请注意<TT CLASS="VARNAME">RESULT_OID</TT>只有在一个向包含OID的表中<TT CLASS="COMMAND">INSERT</TT>
的命令之后才有用。
</P><P>
例如：
</P><PRE CLASS="PROGRAMLISTING">GET DIAGNOSTICS integer_var = ROW_COUNT;</PRE><P>
</P><P>
另外一个判断命令效果的方法是一个<TT CLASS="TYPE">boolean</TT>类型的特殊变量<TT CLASS="LITERAL">FOUND</TT>，
它在每个<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>函数调用中<TT CLASS="LITERAL">FOUND</TT>开始都为假。
并被下列语句设置：
<P></P></P><UL><LI><P>
一个<TT CLASS="COMMAND">SELECT INTO</TT>语句如果返回一行则将<TT CLASS="LITERAL">FOUND</TT>设置为真，
如果没有返回行则设置为假。
</P></LI><LI><P> 一个<TT CLASS="COMMAND">PERFORM</TT>语句如果生成(或抛弃)一行，则将<TT CLASS="LITERAL">FOUND</TT>设置为真，
如果没有生成行则为假。</P></LI><LI><P> 如果至少影响了一行，那么<TT CLASS="COMMAND">UPDATE</TT>, <TT CLASS="COMMAND">INSERT</TT>和<TT CLASS="COMMAND">DELETE</TT>语句
设置FOUND为真，如果没有行受影响则为假。</P></LI><LI><P> 一个<TT CLASS="COMMAND">FETCH</TT>语句如果返回行则设置<TT CLASS="LITERAL">FOUND</TT>为真，如果不返回行则为假</P></LI><LI><P>当成功定位游标的位置时，<TT CLASS="COMMAND">MOVE</TT>将<TT CLASS="LITERAL">FOUND</TT>设为真，反之为假。</P></LI><LI><P> 一个<TT CLASS="COMMAND">FOR</TT>或者<TT CLASS="COMMAND">FOREACH</TT>语句如果迭代了一次或多次，
则设置<TT CLASS="LITERAL">FOUND</TT>真，否则为假。
只有在循环退出的时候才设置<TT CLASS="LITERAL">FOUND</TT>；
在循环执行的内部，<TT CLASS="LITERAL">FOUND</TT>不被循环语句修改，
但是在循环体里它可能被其它语句的执行而修改。</P></LI><LI><P> 如果查询结果返回至少一个行，
<TT CLASS="COMMAND">RETURN QUERY</TT> and <TT CLASS="COMMAND">RETURN QUERY EXECUTE</TT>声明
将<TT CLASS="LITERAL">FOUND</TT>设为真，
反之如果没有返回行，则为假。</P></LI></UL><P>
其他的<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>声明不会改变<TT CLASS="LITERAL">FOUND</TT>的位置。
尤其需要注意的一点是：<TT CLASS="COMMAND">EXECUTE</TT>会修改<TT CLASS="COMMAND">GET DIAGNOSTICS</TT>的输出，
但不会修改<TT CLASS="LITERAL">FOUND</TT>的输出。
</P><P> <TT CLASS="LITERAL">FOUND</TT>是每个<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>里的局部变量；
任何对它的任何修改只影响当前的函数。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPGSQL-STATEMENTS-NULL">40.5.6. 什么也不做</A></H2><P>
有时一个什么也不做的占位语句也是很有用的。
例如，用于if/then/else 的空分支。
可以使用<TT CLASS="COMMAND">NULL</TT>语句达到这个目的。
</P><PRE CLASS="SYNOPSIS">NULL;</PRE><P>
</P><P>
比如，下面的两段代码是相等的：
</P><PRE CLASS="PROGRAMLISTING">BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- ignore the error
END;</PRE><P>
</P><PRE CLASS="PROGRAMLISTING">BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- ignore the error
END;</PRE><P>
究竟使用哪一个取决于个人的喜好。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 在Oracle的PL/SQL中，不允许出现空语句列，
所以在这种情况下必须使用<TT CLASS="COMMAND">NULL</TT>语句，
而<SPAN CLASS="APPLICATION">PL/pgSQL</SPAN>允许你什么也不写。</P></BLOCKQUOTE></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="plpgsql-expressions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="plpgsql-control-structures.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">表达式</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpgsql.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">控制结构</TD></TR></TABLE></DIV></BODY></HTML>
