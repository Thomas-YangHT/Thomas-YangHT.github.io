<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>CREATE SEQUENCE</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="CREATE SCHEMA" HREF="sql-createschema.html"><LINK REL="NEXT" TITLE="CREATE SERVER" HREF="sql-createserver.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/create_sequence.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="CREATE SCHEMA" HREF="sql-createschema.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="CREATE SERVER" HREF="sql-createserver.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-CREATESEQUENCE"></A>CREATE SEQUENCE</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN72054"></A><H2>&#21517;&#31216;</H2>CREATE SEQUENCE&nbsp;--&nbsp;定义一个新序列发生器</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN72059"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">CREATE [ TEMPORARY | TEMP ] SEQUENCE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ INCREMENT [ BY ] <TT
CLASS="REPLACEABLE"
><I
>increment</I
></TT
> ]
    [ MINVALUE <TT
CLASS="REPLACEABLE"
><I
>minvalue</I
></TT
> | NO MINVALUE ] [ MAXVALUE <TT
CLASS="REPLACEABLE"
><I
>maxvalue</I
></TT
> | NO MAXVALUE ]
    [ START [ WITH ] <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
> ] [ CACHE <TT
CLASS="REPLACEABLE"
><I
>cache</I
></TT
> ] [ [ NO ] CYCLE ]
    [ OWNED BY { <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> | NONE } ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72069"></A><H2>描述</H2><P><TT CLASS="COMMAND">CREATE SEQUENCE</TT>将向当前数据库里增加一个新的序列号生成器。
包括创建和初始化一个新的名为<TT CLASS="REPLACEABLE"><I>name</I></TT>
的单行表。生成器将被使用此命令的用户所有。</P><P>如果给出了一个模式名，那么该序列就在给定的模式中创建的。
否则它会在当前模式中创建。临时序列存在于一个特殊的模式中，
因此创建临时序列的时候不能给出模式名。序列名必需和同一模式中的其它序列、
表、索引、视图或外表的名字不同。</P><P>在创建序列后，你可以使用<CODE CLASS="FUNCTION">nextval</CODE>、
<CODE CLASS="FUNCTION">currval</CODE>和<CODE CLASS="FUNCTION">setval</CODE>函数操作序列。
这些函数在<A HREF="functions-sequence.html">第 9.16 &#33410;</A>中有详细文档。</P><P>尽管你不能直接更新一个序列，但你可以使用：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>;</PRE><P>
检查一个序列的参数和当前状态。特别是序列的<TT CLASS="LITERAL">last_value</TT>
字段显示了任意会话最后分配的数值。（当然，如果其它会话正积极地使用
<CODE CLASS="FUNCTION">nextval</CODE>，这些值在被打印出来的时候可能就已经过时了。）</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72085"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">TEMPORARY</TT> 或 <TT CLASS="LITERAL">TEMP</TT></DT><DD><P>如果声明了这个修饰词，那么该序列对象只为这个会话创建，
并且在会话结束的时候自动删除。在临时序列存在的时候，
除非用模式修饰的名字引用，否则同名永久序列是不可见的(在同一会话里)。</P></DD><DT><TT CLASS="REPLACEABLE"><I>name</I></TT></DT><DD><P>将要创建的序列名(可以用模式修饰)</P></DD><DT><TT CLASS="REPLACEABLE"><I>increment</I></TT></DT><DD><P>可选子句<TT CLASS="LITERAL">INCREMENT BY <TT CLASS="REPLACEABLE"><I>increment</I></TT></TT>指定序列的步长。
一个正数将生成一个递增的序列，一个负数将生成一个递减的序列。缺省值是 1 。</P></DD><DT><TT CLASS="REPLACEABLE"><I>minvalue</I></TT><BR><TT CLASS="LITERAL">NO MINVALUE</TT></DT><DD><P>可选的子句<TT CLASS="LITERAL">MINVALUE <TT CLASS="REPLACEABLE"><I>minvalue</I></TT></TT>
指定序列的最小值。如果没有声明这个子句或者声明了<TT CLASS="OPTION">NO MINVALUE</TT>，
那么递增序列的缺省为 1 ，递减序列的缺省为-2<SUP>63</SUP>-1。</P></DD><DT><TT CLASS="REPLACEABLE"><I>maxvalue</I></TT><BR><TT CLASS="LITERAL">NO MAXVALUE</TT></DT><DD><P>可选的子句<TT CLASS="LITERAL">MAXVALUE <TT CLASS="REPLACEABLE"><I>maxvalue</I></TT></TT>
指定序列的最大值。如果没有声明这个子句或者声明了<TT CLASS="OPTION">NO MAXVALUE</TT>，
那么递增序列的缺省为2<SUP>63</SUP>-1，递减序列的缺省为 -1 。</P></DD><DT><TT CLASS="REPLACEABLE"><I>start</I></TT></DT><DD><P>可选的子句<TT CLASS="LITERAL">START WITH <TT CLASS="REPLACEABLE"><I>start</I></TT> </TT>
指定序列的起点。缺省初始值对于递增序列为<TT CLASS="REPLACEABLE"><I>minvalue</I></TT>，
对于递减序列为<TT CLASS="REPLACEABLE"><I>maxvalue</I></TT>。</P></DD><DT><TT CLASS="REPLACEABLE"><I>cache</I></TT></DT><DD><P>可选的子句<TT CLASS="LITERAL">CACHE <TT CLASS="REPLACEABLE"><I>cache</I></TT></TT>
为快速访问而在内存里预先存储多少个序列号。最小值(也是缺省值)是 1 ，
表示一次只能生成一个值，也就是说没有缓存。</P></DD><DT><TT CLASS="LITERAL">CYCLE</TT><BR><TT CLASS="LITERAL">NO CYCLE</TT></DT><DD><P><TT CLASS="LITERAL">CYCLE</TT>选项可用于使序列到达
<TT CLASS="REPLACEABLE"><I>maxvalue</I></TT>或
<TT CLASS="REPLACEABLE"><I>minvalue</I></TT>时可循环并继续下去。
也就是如果达到极限，生成的下一个数据将分别是
<TT CLASS="REPLACEABLE"><I>minvalue</I></TT>
或<TT CLASS="REPLACEABLE"><I>maxvalue</I></TT>。</P><P>如果声明了<TT CLASS="LITERAL">NO CYCLE</TT>，那么在序列达到其最大值之后任何对
<CODE CLASS="FUNCTION">nextval</CODE>的调用都将返回一个错误。
如果既没有声明<TT CLASS="LITERAL">CYCLE</TT>也没有声明<TT CLASS="LITERAL">NO CYCLE</TT>，
那么<TT CLASS="LITERAL">NO CYCLE</TT>是缺省。</P></DD><DT><TT CLASS="LITERAL">OWNED BY</TT> <TT CLASS="REPLACEABLE"><I>table_name</I></TT>.<TT CLASS="REPLACEABLE"><I>column_name</I></TT><BR><TT CLASS="LITERAL">OWNED BY NONE</TT></DT><DD><P><TT CLASS="LITERAL">OWNED BY</TT>选项将序列关联到一个特定的表字段上。这样，
在删除那个字段或其所在表的时候将自动删除绑定的序列。
指定的表和序列必须被同一个用户所拥有，并且在在同一个模式中。
默认的<TT CLASS="LITERAL">OWNED BY NONE</TT>表示不存在这样的关联。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72173"></A><H2>注意</H2><P>使用<TT CLASS="COMMAND">DROP SEQUENCE</TT>删除一个序列。</P><P>序列是基于<TT CLASS="TYPE">bigint</TT>运算的，因此其范围不能超过八字节的整数范围
(-9223372036854775808 到 9223372036854775807)。
在一些古老的平台上可能没有对八字节整数的编译器支持，
这种情况下序列使用普通的<TT CLASS="TYPE">integer</TT>运算范围(-2147483648 到 +2147483647)。</P><P>如果<TT CLASS="REPLACEABLE"><I>cache</I></TT>大于一，
并且这个序列对象将被用于多会话并发的场合，那么可能会有不可预料的结果发生。
每个会话在每次访问序列对象的过程中都将分配并缓存随后的序列值，
并且相应增加序列对象的<TT CLASS="LITERAL">last_value</TT>。这样，
同一个事务中的随后的<TT CLASS="REPLACEABLE"><I>cache</I></TT>-1
次<CODE CLASS="FUNCTION">nextval</CODE>将只是返回预先分配的数值，而不是使用序列对象。
因此，任何在会话中分配了却没有使用的数字都将在会话结束时丢失，
从而导致序列里面出现<SPAN CLASS="QUOTE">"空洞"</SPAN>。</P><P>另外，尽管系统保证为多个会话分配独立的序列值，但是如果考虑所有会话，
那么这个数值可能会丢失顺序。比如，如果<TT CLASS="REPLACEABLE"><I>cache</I></TT>
为 10 ，那么会话 A 保留了 1..10 并且返回<CODE CLASS="FUNCTION">nextval</CODE>=1，
然后会话 B 可能会保留 11..20 然后在会话 A 生成<TT CLASS="LITERAL">nextval</TT>=2
之前返回<CODE CLASS="FUNCTION">nextval</CODE>=11。因此，对于
<TT CLASS="REPLACEABLE"><I>cache</I></TT>等于一的情况，
可以安全地假设<CODE CLASS="FUNCTION">nextval</CODE>值是顺序生成的；而如果把
<TT CLASS="REPLACEABLE"><I>cache</I></TT>设置为大于一，
那么你只能假设<CODE CLASS="FUNCTION">nextval</CODE>值总是不同的，却不按顺序生成。
同样，<TT CLASS="LITERAL">last_value</TT>将反映任何会话保留的最后数值，
不管它是否曾被<CODE CLASS="FUNCTION">nextval</CODE>返回。</P><P>另外一个考虑是在这样的序列上执行的<CODE CLASS="FUNCTION">setval</CODE>
将不会被其它会话注意到，直到它们用光他们自己缓存的数值。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72199"></A><H2>例子</H2><P>创建一个叫<TT CLASS="LITERAL">serial</TT>的递增序列，从 101 开始：
</P><PRE CLASS="PROGRAMLISTING">CREATE SEQUENCE serial START 101;</PRE><P>
</P><P>从此序列中选出下一个数字：
</P><PRE CLASS="PROGRAMLISTING">SELECT nextval('serial');

 nextval
---------
     101</PRE><P>
</P><P>从此序列中选出下一个数字：
</P><PRE CLASS="PROGRAMLISTING">SELECT nextval('serial');

 nextval
---------
     102</PRE><P>
</P><P>在一个<TT CLASS="COMMAND">INSERT</TT>中使用此序列：
</P><PRE CLASS="PROGRAMLISTING">INSERT INTO distributors VALUES (nextval('serial'), 'nothing');</PRE><P>
</P><P>在一个<TT CLASS="COMMAND">COPY FROM</TT>后更新序列：
</P><PRE CLASS="PROGRAMLISTING">BEGIN;
COPY distributors FROM 'input_file';
SELECT setval('serial', max(id)) FROM distributors;
END;</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72214"></A><H2>兼容性</H2><P><TT CLASS="COMMAND">CREATE SEQUENCE</TT>遵循<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准，
只有下面的例外：
<P></P></P><UL><LI><P>还不支持标准的<TT CLASS="LITERAL">AS &lt;数据类型&gt;</TT>表达式。</P></LI><LI><P>使用<CODE CLASS="FUNCTION">nextval()</CODE>函数而不是标准的
<TT CLASS="COMMAND">NEXT VALUE FOR</TT>表达式获取下一个数值。</P></LI><LI><P><TT CLASS="LITERAL">OWNED BY</TT>子句是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的扩展。</P></LI></UL><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN72231"></A><H2>又见</H2><A HREF="sql-altersequence.html">ALTER SEQUENCE</A>, <A HREF="sql-dropsequence.html">DROP SEQUENCE</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-createschema.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-createserver.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">CREATE SCHEMA</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">CREATE SERVER</TD></TR></TABLE></DIV></BODY></HTML>
