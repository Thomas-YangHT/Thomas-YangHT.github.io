<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>行和数组比较</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="函数和操作符" HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html"><LINK REL="PREVIOUS" TITLE="子查询表达式" HREF="functions-subquery.html"><LINK REL="NEXT" TITLE="返回集合的函数" HREF="functions-srf.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/func.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="子查询表达式" HREF="functions-subquery.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 9. 函数和操作符</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="返回集合的函数" HREF="functions-srf.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FUNCTIONS-COMPARISONS">9.23. 行和数组比较</A></H1><P>本节描述几个特殊的构造，用于在多组值之间进行多重比较。
这些形式语法上和上一节的子查询形式相关，但是不涉及子查询。
这种形式涉及的数组子表达式是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的扩展；
其它的是<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>兼容的。所有本节记录的表达式形式都返回布尔值(真/假)。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN18415">9.23.1. <TT CLASS="LITERAL">IN</TT></A></H2><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> IN (<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>])</PRE><P>右边是一个圆括弧包围的标量列表。如果左边的表达式结果等于任何右边表达式中的一个，
结果为<SPAN CLASS="QUOTE">"真"</SPAN>。它是下面这种方式的缩写
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value1</I
></TT
>
OR
<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value2</I
></TT
>
OR
...</PRE><P>
</P><P>请注意，如果左边表达式的值为 NULL ，或者没有相等的右边值并且至少有一个右边表达式的值为 NULL ，
那么<TT CLASS="TOKEN">IN</TT>的结果将是 NULL ，而不是假。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN18431">9.23.2. <TT CLASS="LITERAL">NOT IN</TT></A></H2><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> NOT IN (<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>])</PRE><P>
右边是一个圆括弧包围的标量列表。如果左边的表达式结果不等于任何右边表达式，结果为<SPAN CLASS="QUOTE">"真"</SPAN>。
它是下面这种方式的缩写
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> &lt;&gt; <TT
CLASS="REPLACEABLE"
><I
>value1</I
></TT
>
AND
<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> &lt;&gt; <TT
CLASS="REPLACEABLE"
><I
>value2</I
></TT
>
AND
...</PRE><P>
</P><P>请注意，如果左边表达式的值为 NULL ，或者没有相等的右边值并且至少有一个右边表达式的值为 NULL ，
那么<TT CLASS="TOKEN">NOT IN</TT>的结果将是 NULL ，而不是真。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B><TT CLASS="LITERAL">x NOT IN y</TT>在所有场合都等价于<TT CLASS="LITERAL">NOT (x IN y)</TT>。
但是，在处理 NULL 的时候，用<TT CLASS="TOKEN">NOT IN</TT>比用<TT CLASS="TOKEN">IN</TT>更容易迷惑新手。
最好用正逻辑来表达你的条件。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN18453">9.23.3. <TT CLASS="LITERAL">ANY</TT>/<TT CLASS="LITERAL">SOME</TT> (array)</A></H2><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ANY (<TT
CLASS="REPLACEABLE"
><I
>array expression</I
></TT
>)
<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> SOME (<TT
CLASS="REPLACEABLE"
><I
>array expression</I
></TT
>)</PRE><P>右边是一个圆括弧包围的表达式，它必须生成一个数组值。左边表达式使用<TT CLASS="REPLACEABLE"><I>operator</I></TT>
对数组的每一个元素进行一次计算和比较，其结果必须是布尔值。如果至少获得一个真值，
则<TT CLASS="TOKEN">ANY</TT>结果为<SPAN CLASS="QUOTE">"真"</SPAN>。如果全部获得假值，则结果是<SPAN CLASS="QUOTE">"假"</SPAN>
(包括数组不含任何元素的情况)。</P><P>如果数组表达式的值为 NULL ，那么<TT CLASS="TOKEN">ANY</TT>的结果也为 NULL 。
如果左边表达式的值为 NULL ，那么<TT CLASS="TOKEN">ANY</TT>的结果通常也为 NULL
(某些不严格的比较操作符可能得到不同的结果)。另外，
如果右边的数组表达式中包含 NULL 元素并且没有为真的比较结果，
那么<TT CLASS="TOKEN">ANY</TT>的结果将是 NULL(某些不严格的比较操作符可能得到不同的结果)，
而不是假。这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。</P><P><TT CLASS="TOKEN">SOME</TT>是<TT CLASS="TOKEN">ANY</TT>的同意词。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN18476">9.23.4. <TT CLASS="LITERAL">ALL</TT> (array)</A></H2><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ALL (<TT
CLASS="REPLACEABLE"
><I
>array expression</I
></TT
>)</PRE><P>右边是一个圆括弧包围的表达式，它必须生成一个数组值。左边表达式使用<TT CLASS="REPLACEABLE"><I>operator</I></TT>
对数组的每一个元素进行一次计算和比较，其结果必须是布尔值。如果全部获得真值，<TT CLASS="TOKEN">ALL</TT>
结果为<SPAN CLASS="QUOTE">"真"</SPAN>(包括数组不含任何元素的情况)。如果至少获得一个假值，则结果是<SPAN CLASS="QUOTE">"假"</SPAN>。</P><P>如果数组表达式的值为 NULL ，那么<TT CLASS="TOKEN">ALL</TT>的结果也为 NULL 。
如果左边表达式的值为 NULL ，那么<TT CLASS="TOKEN">ALL</TT>的结果通常也为 NULL
(某些不严格的比较操作符可能得到不同的结果)。另外，
如果右边的数组表达式中包含 NULL 元素并且没有为假的比较结果，那么<TT CLASS="TOKEN">ALL</TT>
的结果将是 NULL(某些不严格的比较操作符可能得到不同的结果)，而不是真。
这个行为遵照 SQL 处理布尔值和 NULL 组合时的规则。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ROW-WISE-COMPARISON">9.23.5. 逐行比较</A></H2><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
></PRE><P>两边都是一个<A HREF="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS">第 4.2.13 &#33410;</A>所述的行构造器；
两个行的字段数必须相同。两边都被计算并且逐行比较。目前，用于比较的
<TT CLASS="REPLACEABLE"><I>operator</I></TT>操作符仅允许为 <TT CLASS="LITERAL">=</TT>, <TT CLASS="LITERAL">&lt;&gt;</TT>,
<TT CLASS="LITERAL">&lt;</TT>, <TT CLASS="LITERAL">&lt;=</TT>, <TT CLASS="LITERAL">&gt;</TT>, <TT CLASS="LITERAL">&gt;=</TT>或与其具有相似的语意。
特别地，如果一个操作符属于 B-tree 操作符类，那么该操作符可以是一个行比较操作符或除<TT CLASS="LITERAL">=</TT>
之外的 B-tree 操作符类。</P><P><TT CLASS="LITERAL">=</TT>和<TT CLASS="LITERAL">&lt;&gt;</TT>与其它操作符稍有区别。如果两行对应的元素全都非空且相等，
那么这两行就被认为是相等的；如果两行对应的元素中有任意一对非空且不等，
那么这两行就被认为是不等的；否则这两行的比较结果是未知(NULL)。</P><P>对于 <TT CLASS="LITERAL">&lt;</TT>, <TT CLASS="LITERAL">&lt;=</TT>, <TT CLASS="LITERAL">&gt;</TT>, <TT CLASS="LITERAL">&gt;=</TT>操作符，
行中的元素将按照从左到右的顺序依次进行比较，直到遇见一对不相等的元素或者一对 NULL 值。
如果这对元素中存在至少一个 NULL 值，那么比较的结果是 NULL ；
否则这对元素的比较结果就是最终的比较结果。例如，<TT CLASS="LITERAL">ROW(1,2,NULL) &lt; ROW(1,3,0)</TT>
的结果是真而不是 NULL ，因为比较到第二对元素的时候就已经得到了最终结果，不需要对第三对元素进行比较了。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.2之前，<TT CLASS="LITERAL">&lt;</TT>, <TT CLASS="LITERAL">&lt;=</TT>,
<TT CLASS="LITERAL">&gt;</TT>, <TT CLASS="LITERAL">&gt;=</TT>并不遵守 SQL 标准。比如，<TT CLASS="LITERAL">ROW(a,b) &lt; ROW(c,d)</TT>
将等价于<TT CLASS="LITERAL">a &lt; c AND b &lt; d</TT>，而正确的做法应当是等价于<TT CLASS="LITERAL">a &lt; c OR (a = c AND b &lt; d)</TT>。</P></BLOCKQUOTE></DIV><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
> IS DISTINCT FROM <TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
></PRE><P>这个构造类似于<TT CLASS="LITERAL">&lt;&gt;</TT>行比较，但是它对 NULL 输入不生成 NULL ，
而是认为任何 NULL 都不等于任何非 NULL ，并且 NULL 之间是相等的。因此，
结果要么是真要么是假，而绝不会是未知(NULL)。</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
> IS NOT DISTINCT FROM <TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
></PRE><P>这个构造类似于<TT CLASS="LITERAL">=</TT>行比较，但是它对 NULL 输入不生成 NULL ，
而是认为任何 NULL 都不等于任何非 NULL ，并且 NULL 之间是相等的。
因此，结果要么是真要么是假，而绝不会是未知(NULL)。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>如果结果依赖于比较两个NULL值或一个NULL值和一个非NULL值，SQL 规范要求逐行比较返回 NULL。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>仅当比较两个行构造的结果或一个行构造器和子查询的输出时这样做
(就像<A HREF="functions-subquery.html">第 9.22 &#33410;</A>描述的那样)。在其它情况下，两个复合类型的值进行比较，
认为两个NULL字段值是相等的，并且NULL大于非NULL。这是必要的，如此才能有一致的排序和复合类型的索引行为。</P></BLOCKQUOTE></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="functions-subquery.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="functions-srf.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">子查询表达式</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">返回集合的函数</TD></TR></TABLE></DIV></BODY></HTML>
