<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>CREATE INDEX</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="CREATE GROUP" HREF="sql-creategroup.html"><LINK REL="NEXT" TITLE="CREATE LANGUAGE" HREF="sql-createlanguage.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/create_index.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="CREATE GROUP" HREF="sql-creategroup.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="CREATE LANGUAGE" HREF="sql-createlanguage.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-CREATEINDEX"></A>CREATE INDEX</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN70574"></A><H2>&#21517;&#31216;</H2>CREATE INDEX&nbsp;--&nbsp;创建一个索引</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN70579"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ] ON <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ USING <TT
CLASS="REPLACEABLE"
><I
>method</I
></TT
> ]
    ( { <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ) } [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] ) ]
    [ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>tablespace_name</I
></TT
> ]
    [ WHERE <TT
CLASS="REPLACEABLE"
><I
>predicate</I
></TT
> ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN70592"></A><H2>描述</H2><P> <TT CLASS="COMMAND">CREATE INDEX</TT> 在一个指定表或者物化视图的指定列上创建一个索引,索引主要用来提高数据库的效率(尽管不合理的使用将导致较慢的效率)
</P><P>索引的键字是用列名来声明的,或者在括号里面写一个表达式 .如果索引支持多列索引,我们也可以指定多个字段. </P><P>
一个索引域可以是一个使用表的一个或多个字段进行计算的表达式。 这个特性可以快速访问一些基础数据的变形.例如,一个在<TT CLASS="LITERAL">upper(col)</TT>上计算的索引允许<TT CLASS="LITERAL">WHERE upper(col) = 'JIM'</TT>字句使用这个索引.</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>提供的索引类型包括B-tree, hash, GiST, SP-GiST, 和 GIN.用户也可以自己定义索引类型,但这是相当复杂的.</P><P>当使用<TT CLASS="LITERAL">WHERE</TT>字句,将会创建一个<I CLASS="FIRSTTERM">partial index</I>.一个部分索引是仅包括表的一部分记录的索引,通常是比表中其他部分更有用的记录.
例如,如果你有一个包含了记账和不记账的订单,不记帐的订单只占了表的一小部分,并且是经常使用的部分.你可以在这部分上建立一个索引来提高效率.另一个应用是使用<TT CLASS="LITERAL">WHERE</TT> 和<TT CLASS="LITERAL">UNIQUE</TT> 来强制保证表的一个子集的唯一性.更多的信息见:<A HREF="indexes-partial.html">第 11.8 &#33410;</A></P><P> <TT CLASS="LITERAL">WHERE</TT> 字句的表达式可以使用底层表的列,并且可以是用它的所有列,而不仅仅建立索引的列.目前子查询和聚合表达式时禁止出现在<TT CLASS="LITERAL">WHERE</TT>字句的,这个限制同样适用于索引.</P><P> 在索引定义中使用的所有函数和操作符必须是<SPAN CLASS="QUOTE">"immutable"</SPAN>,即他们的结果依赖与他们的参数,而不受任何外部的数据的影响(例如另一个表的内容,或当前时间).这个限制保证了索引的定义完整性.在一个索引或<TT CLASS="LITERAL">WHERE</TT>子句中使用用户自定义的函数时,确保在定义这些函数时标记他们是不可变的.</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN70614"></A><H2>Parameters</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">UNIQUE</TT></DT><DD><P>当索引被创建时使系统检查表的重复值(如果已经有数据),并且当有数据插入时检查唯一性.当插入数据或更新数据导致重复记录时将会产生一个错误.
</P></DD><DT><TT CLASS="LITERAL">CONCURRENTLY</TT></DT><DD><P>当使用这个选项时, <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>在生成索引时将不会在表上加任何锁阻止并发的插入,更新,删除.而标准的建立一个索引将产生一个阻止写(不包括读)的锁直到索引建立完毕.当使用这个选项时有一些问题需要注意,详见:<A HREF="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY"><I>并发建立索引</I></A>.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>name</I></TT></DT><DD><P>
被创建索引的名字.这里不需要包括模式的名字,索引总是在同一个模式中作为其父表创建的.如果忽略这个选项,<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>基于父表的名字和建立索引的列选择一个合适的名字.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>table_name</I></TT></DT><DD><P>要建立索引的表名(可能有模式修饰)
</P></DD><DT><TT CLASS="REPLACEABLE"><I>method</I></TT></DT><DD><P>
建立索引使用的方法名字. 可选的方法有<TT CLASS="LITERAL">btree</TT>, <TT CLASS="LITERAL">hash</TT>,
<TT CLASS="LITERAL">gist</TT>, <TT CLASS="LITERAL">spgist</TT> and <TT CLASS="LITERAL">gin</TT>.默认方法是<TT CLASS="LITERAL">btree</TT>.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>column_name</I></TT></DT><DD><P> 表中 要建立索引的列名.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>expression</I></TT></DT><DD><P>基于表中一列或多列的表达式.在上面的语法中,表达式必须在园括号中.如果表达式有函数调用的格式则圆括号可以省略.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>collation</I></TT></DT><DD><P> 索引使用排序方式的名字,默认索引使用创建索引列中声明的排序方式,创建索引的表达式结果的排序方式.对于使用指定排序方式的表达式查询,索引使用指定的排序是高效的.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>opclass</I></TT></DT><DD><P>操作符类的名字,详细内容见下面.
</P></DD><DT><TT CLASS="LITERAL">ASC</TT></DT><DD><P> 指定升序排序(默认).
</P></DD><DT><TT CLASS="LITERAL">DESC</TT></DT><DD><P>指定降序排序.
</P></DD><DT><TT CLASS="LITERAL">NULLS FIRST</TT></DT><DD><P>指定null排在非null值前面,在 <TT CLASS="LITERAL">DESC</TT> 中时默认的.
</P></DD><DT><TT CLASS="LITERAL">NULLS LAST</TT></DT><DD><P>指定null排在非null值后面, 默认在 <TT CLASS="LITERAL">DESC</TT>没有指定.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>storage_parameter</I></TT></DT><DD><P> index-method-specific 存储参数的名字.详细见:<A HREF="sql-createindex.html#SQL-CREATEINDEX-STORAGE-PARAMETERS"><I>索引存储参数</I></A>.
</P></DD><DT><TT CLASS="REPLACEABLE"><I>tablespace_name</I></TT></DT><DD><P>在哪个表空间建立索引,如果不指定,将使用<A HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</A> ,或者临时表的索引将使用<A HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</A> . </P></DD><DT><TT CLASS="REPLACEABLE"><I>predicate</I></TT></DT><DD><P>部分索引的约束表达式.
</P></DD></DL></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-CREATEINDEX-STORAGE-PARAMETERS"></A><H3>索引存储参数</H3><P> 可选的<TT CLASS="LITERAL">WITH</TT>子句指定了索引的<I CLASS="FIRSTTERM">storage
parameters</I>.每个索引方式有它自己的存储参数.B-tree, hash, GiST and SP-GiST索引都可以带这个参数.</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">FILLFACTOR</TT></DT><DD><P> 填充因子是一个索引实际数据的百分比,它决定索引方法占用页的空间的比率.对于B-trees,在索引创建时叶子页填充这个百分比的数据.其余的用来扩展索引(添加一个新的最大的键值).如果接下来页占用100%,它将会分页,这将导致索引效率的逐渐下降.B-tree使用一个90做为默认填充比,但是可以选择10到100的任何值.如果是一个静态表,填充比使用100将会最大的减小索引所占的物理空间.但是对于有大量更新的表一个较小的填充比将会尽可能的减少分页.其他的索引方法使用填充比是不同的但是大致方法是相同;
方法之间的默认填充比不是一致的.</P></DD></DL></DIV><P>
GiST索引额外接受这个参数:</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">BUFFERING</TT></DT><DD><P> 在使用<A HREF="gist-implementation.html#GIST-BUFFERING-BUILD">第 55.3.1 &#33410;</A>建立索引时决定是否缓存建立的方法.使用<TT CLASS="LITERAL">OFF</TT> 关闭这个功能,<TT CLASS="LITERAL">ON</TT> 打开这个功能.
使用<TT CLASS="LITERAL">AUTO</TT> 它初始化时是关闭的,但是当索引的达到<A HREF="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE">effective_cache_size</A>将会打开.默认使用<TT CLASS="LITERAL">AUTO</TT>.</P></DD></DL></DIV><P>GIN索引接受一个不同的参数: </P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">FASTUPDATE</TT></DT><DD><P> 这个设置用来控制在 <A HREF="gin-implementation.html#GIN-FAST-UPDATE">第 57.3.1 &#33410;</A>中描述的快速更新技术.它是一个布尔类型参数:<TT CLASS="LITERAL">ON</TT>使能快速更新,<TT CLASS="LITERAL">OFF</TT>关闭这个功能.(在<A HREF="config-setting.html">第 18.1 &#33410;</A>中描述了允许可选的拼写 <TT CLASS="LITERAL">ON</TT> and <TT CLASS="LITERAL">OFF</TT>.)默认是<TT CLASS="LITERAL">ON</TT>.&#13;</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> 通过<TT CLASS="COMMAND">ALTER INDEX</TT>关闭<TT CLASS="LITERAL">FASTUPDATE</TT>防止将来数据插入到待建立的索引记录中,但是它自己不写之前的记录到磁盘.你可以使用<TT CLASS="COMMAND">VACUUM</TT> 表来确保待建立索引空.</P></BLOCKQUOTE></DIV></DD></DL></DIV></DIV><DIV CLASS="REFSECT2"><A NAME="SQL-CREATEINDEX-CONCURRENTLY"></A><H3>并发建立索引</H3><P>
建立一个索引将影响正常的数据库操作.一般的 <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>锁住建立索引的表防止写，然后通过扫描表来建立整个索引.其他的事物可以读表,但是插入,更新,删除操作将被锁住直到索引建立完成.如果这是一个线上的生成库将会有较严重的影响.非常大的表将使用数个小时来建立索引,即使一个较小的表,对于生产库也会在一个不可接受的时间内锁住该表的写操作.</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>支持建立索引时不锁写操作.这个方法通过<TT CLASS="COMMAND">CREATE INDEX</TT>时指定<TT CLASS="LITERAL">CONCURRENTLY</TT>选项,当使用这个选项时, <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>必须扫描表2次,它必须等待所有的将要使用该索引的事物结束.所以这个方法比标准的建立索引需要更多的工作并且花费更多的时间.然而,在建立索引的时候它允许正常的操作所以对于生产环境它是非常有用的.当然在建立索引时额外的CPU和I/o开销可能会降低其他操作的效率.</P><P> 在并发创建索引中，索引在一个事物中进入系统表，然后两表扫描发生在另外的事物中．在第二遍扫描时任何活跃的事物（在该表上）将会阻塞并发索引的建立直到事物完成．甚至在第二遍表扫描时事物仅仅涉及到该表．并发建立索引使用<A HREF="view-pg-locks.html">第 47.59 &#33410;</A>中的方法等待每一个发生的事物完成．</P><P>当扫描表时发生了问题，例如一个唯一索引违反了唯一性，<TT CLASS="COMMAND">CREATE INDEX</TT>将会失败并且留下一个 <SPAN CLASS="QUOTE">"invalid"</SPAN>索引．在查询时这个索引将会被忽略因为他是不完整的；然而它仍然会增加更新的开销．<SPAN CLASS="APPLICATION">psql</SPAN><TT CLASS="COMMAND">\d</TT>命令将列出带 <TT CLASS="LITERAL">INVALID</TT>的索引．
</P><PRE CLASS="PROGRAMLISTING">postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers 
--------+---------+-----------
 col    | integer | 
Indexes:
    "idx" btree (col) INVALID</PRE><P>
这种情况推荐的恢复方法是删除掉索引并且再次执行<TT CLASS="COMMAND">CREATE INDEX CONCURRENTLY</TT>. （另一种重建索引的方法是使用<TT CLASS="COMMAND">REINDEX</TT>.然而，因为<TT CLASS="COMMAND">REINDEX</TT>不支持并发建立索引，所以这种方式可用性不高．）
</P><P>另一个缺点是当并发建立唯一索引第二遍扫描表后唯一性将会约束其他事物．这意味着在索引建立完成前在其他查询中违反了该索引将会报违反约束错误，即使最后索引建立失败．如果在第二遍扫描发生了错误，在后续的操作中<SPAN CLASS="QUOTE">"invalid"</SPAN>索引也会（在相关列上）保持该唯一性．</P><P> 支持建立并发索引和部分索引．在这些语句中出现错误将会产生和前面违反唯一性约束相似的错误．</P><P>标准建立索引允许并行的执行其他标准的建立索引语句，但是在一个表上一次仅可以有一个并发建立索引语句．在这两种情况下，建立索引的同时不允许有其他模式类型的修改．另一个不同点是 <TT CLASS="COMMAND">CREATE INDEX</TT>可以在一个阻塞的事物里执行，而 <TT CLASS="COMMAND">CREATE INDEX CONCURRENTLY</TT>不可以．</P></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN70784"></A><H2>Notes</H2><P>在<A HREF="http://school.yunwei.edu/manual/PostgreSQL/indexes.html">第 11 &#31456;</A>中描述了什么时候会使用索引，什么时候不使用索引，以及在什么情况下索引是有用的．</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P>哈希索引不记录到WAL日志中，所以当系统崩溃有未写入磁盘的数据时哈希索引需要使用<TT CLASS="COMMAND">REINDEX</TT>重新建立．哈希索引的变化不能在恢复一个基础备份后通过流复制或者文件复制来重写．所以接下来在查询中使用他们将会给出错误的结果．因为这些原因使用哈希索引是有阻碍的．</P></TD></TR></TABLE></DIV><P>现在只有B-tree, GiST 和 GIN支持多列索引．默认支持最多32列．（当编译<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>时可以改变这个限制）．现在只有B-tree支持唯一索引．</P><P> 对于索引的每一列可以指定一个<I CLASS="FIRSTTERM">operator class</I>．<I CLASS="FIRSTTERM">operator class</I>标识了索引那一列的使用的操作符．例如一个B-tree索引在一个四字节整数上可以使用<TT CLASS="LITERAL">int4_ops</TT>；这个操作符类包括四字节整数的比较函数．实际上对于列上的数据类型默认的操作符类时足够用的．操作符类主要用于一些有多种排序的数据．例如，我们想按照绝对值或者实数部分排序一个复数．我们能通过定义两个操作符类然后当建立索引时选择合适的类．详细的操作符类信息请参考：<A HREF="indexes-opclass.html">第 11.9 &#33410;</A>和<A HREF="xindex.html">第 35.14 &#33410;</A>.</P><P>索引（现在只有B-tree）中支持有序扫描的字句中可以制定<TT CLASS="LITERAL">ASC</TT>, <TT CLASS="LITERAL">DESC</TT>, <TT CLASS="LITERAL">NULLS
FIRST</TT>, 和 <TT CLASS="LITERAL">NULLS LAST</TT>修改索引的排序方式．因为一个有序的索引能被从前向后或者从后向前扫描．建立一个单列的<TT CLASS="LITERAL">DESC</TT>索引是没有意义的．因为在一个标准的索引是已经排序的．在创建多列索引时使用这些选项值来匹配一些复合查询的排序请求，例如<TT CLASS="LITERAL">SELECT ... ORDER BY x ASC, y DESC</TT>.如果你在查询中需要支持 <SPAN CLASS="QUOTE">"nulls sort low"</SPAN>特性<TT CLASS="LITERAL">NULLS</TT>选项是很有用的，而不是默认的<SPAN CLASS="QUOTE">"nulls sort high"</SPAN>,</P><P>对于大多数索引，创建索引的速度依赖于<A HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</A>的设置．只要你没有使他超过可得到内存而进入swap分区，较大的值将会减少索引创建的时间．对于创建哈希索引的时间与<A HREF="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE">effective_cache_size</A>值相关,<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将使用两种不同的哈希索引创建方法，主要取决于索引的大小比<TT CLASS="VARNAME">effective_cache_size</TT>大还是小．为了得到较好的结果，确保这个参数的设置考虑到可用内存，并且注意<TT CLASS="VARNAME">maintenance_work_mem</TT>和<TT CLASS="VARNAME">effective_cache_size</TT>的和小于其他程序所需要的内存空间．</P><P>使用 <A HREF="sql-dropindex.html">DROP INDEX</A>删除一个索引．</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>之前的版本有一个R-tree索引方法．这个方法已经被删除因为它对于GiST索引没有明显的优势．如果指定<TT CLASS="LITERAL">USING rtree</TT>，<TT CLASS="COMMAND">CREATE INDEX</TT>会将他翻译为<TT CLASS="LITERAL">USING gist</TT>，去转换老的数据库版本到GiST.</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN70823"></A><H2>Examples</H2><P>在表<TT CLASS="LITERAL">films</TT>的<TT CLASS="LITERAL">title</TT>列上建立B-tree索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE UNIQUE INDEX title_idx ON films (title);</PRE><P>
</P><P>允许大小写无关查询在 <TT CLASS="LITERAL">lower(title)</TT>表达式上建立索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX ON films ((lower(title)));</PRE><P>
(在这个例子中我们可以选在忽略索引名字，系统将给出一个名字，典型的是<TT CLASS="LITERAL">films_lower_idx</TT>.)
</P><P>创建一个使用非默认排序方式的索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");</PRE><P>
</P><P>创建一个null值的非默认排序的索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);</PRE><P>
</P><P>创建一个非默认填充因子的索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);</PRE><P>
</P><P>创建一个将快速更新关闭的<ACRONYM CLASS="ACRONYM">GIN</ACRONYM>索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX gin_idx ON documents_table USING gin (locations) WITH (fastupdate = off);</PRE><P>
</P><P>创建一个在<TT CLASS="LITERAL">films</TT>的<TT CLASS="LITERAL">code</TT>列的索引，并且使索引建立在<TT CLASS="LITERAL">indexspace</TT>表空间中：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;</PRE><P>
</P><P>在一个点属性上创建GiST索引，让我们在转换函数的结果上高效的使用box操作符：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;</PRE><P>
</P><P>创建一个在表上不加写锁的索引：
</P><PRE CLASS="PROGRAMLISTING">CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN70851"></A><H2>Compatibility</H2><P>
<TT CLASS="COMMAND">CREATE INDEX</TT>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>语言的扩展．在SQL标准中没有索引的规定．</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN70856"></A><H2>See Also</H2><A HREF="sql-alterindex.html">ALTER INDEX</A>, <A HREF="sql-dropindex.html">DROP INDEX</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-creategroup.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-createlanguage.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">CREATE GROUP</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">CREATE LANGUAGE</TD></TR></TABLE></DIV></BODY></HTML>
