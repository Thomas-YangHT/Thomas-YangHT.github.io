<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>JSON 函数和操作符</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="函数和操作符" HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html"><LINK REL="PREVIOUS" TITLE="XML 函数" HREF="functions-xml.html"><LINK REL="NEXT" TITLE="序列操作函数" HREF="functions-sequence.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/func.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="XML 函数" HREF="functions-xml.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 9. 函数和操作符</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="序列操作函数" HREF="functions-sequence.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FUNCTIONS-JSON">9.15. JSON 函数和操作符</A></H1><P><A HREF="functions-json.html#FUNCTIONS-JSON-OP-TABLE">&#34920; 9-39</A>显示了可以用于JSON
（参阅<A HREF="datatype-json.html">第 8.14 &#33410;</A>）数据的操作符。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-JSON-OP-TABLE"></A><P><B>&#34920; 9-39. JSON 操作符</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><THEAD><TR><TH>操作符</TH><TH>右操作数的类型</TH><TH>描述</TH><TH>示例</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">-&gt;</TT></TD><TD>int</TD><TD>获取JSON数组元素</TD><TD><TT CLASS="LITERAL">'[1,2,3]'::json-&gt;2</TT></TD></TR><TR><TD><TT CLASS="LITERAL">-&gt;</TT></TD><TD>text</TD><TD>获取JSON对象字段</TD><TD><TT CLASS="LITERAL">'{"a":1,"b":2}'::json-&gt;'b'</TT></TD></TR><TR><TD><TT CLASS="LITERAL">-&gt;&gt;</TT></TD><TD>int</TD><TD>获取JSON数组元素为文本</TD><TD><TT CLASS="LITERAL">'[1,2,3]'::json-&gt;&gt;2</TT></TD></TR><TR><TD><TT CLASS="LITERAL">-&gt;&gt;</TT></TD><TD>text</TD><TD>获取JSON对象字段为文本</TD><TD><TT CLASS="LITERAL">'{"a":1,"b":2}'::json-&gt;&gt;'b'</TT></TD></TR><TR><TD><TT CLASS="LITERAL">#&gt;</TT></TD><TD>array of text</TD><TD>在指定的路径获取JSON对象</TD><TD><TT CLASS="LITERAL">'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;'{a,2}'</TT></TD></TR><TR><TD><TT CLASS="LITERAL">#&gt;&gt;</TT></TD><TD>array of text</TD><TD>在指定的路径获取JSON对象为文本</TD><TD><TT CLASS="LITERAL">'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</TT></TD></TR></TBODY></TABLE></DIV><P><A HREF="functions-json.html#FUNCTIONS-JSON-TABLE">&#34920; 9-40</A>显示了可以用于创建和操作JSON
（参阅<A HREF="datatype-json.html">第 8.14 &#33410;</A>）数据的函数。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-JSON-TABLE"></A><P><B>&#34920; 9-40. JSON 支持函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回类型</TH><TH>描述</TH><TH>示例</TH><TH>示例结果</TH></TR></THEAD><TBODY><TR><TD>
<TT CLASS="LITERAL">array_to_json(anyarray [, pretty_bool])</TT>
</TD><TD><TT CLASS="TYPE">json</TT></TD><TD> 作为JSON返回数组。一个PostgreSQL多维数组成为一个JSON数组的数组。
如果<TT CLASS="PARAMETER">pretty_bool</TT>为 true，将在维度1的元素之间添加换行符。
</TD><TD><TT CLASS="LITERAL">array_to_json('{{1,5},{99,100}}'::int[])</TT></TD><TD><TT CLASS="LITERAL">[[1,5],[99,100]]</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL">row_to_json(record [, pretty_bool])</TT>
</TD><TD><TT CLASS="TYPE">json</TT></TD><TD> 作为JSON返回行。如果<TT CLASS="PARAMETER">pretty_bool</TT>为 true，将在第一级元素之间添加换行符。
</TD><TD><TT CLASS="LITERAL">row_to_json(row(1,'foo'))</TT></TD><TD><TT CLASS="LITERAL">{"f1":1,"f2":"foo"}</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL">to_json(anyelement)</TT>
</TD><TD><TT CLASS="TYPE">json</TT></TD><TD> 作为JSON返回值。如果不是内建的数组类型，那么将会把这个类型转换为<TT CLASS="TYPE">json</TT>类型，
转换函数将用于实现这个转换。否则，除了数字，布尔值或空值，其他的任何值将用文本表示，
并且使用转义和双引号以使其是合法的JSON类型。
</TD><TD><TT CLASS="LITERAL">to_json('Fred said "Hi."'::text)</TT></TD><TD><TT CLASS="LITERAL">"Fred said \"Hi.\""</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL">json_array_length(json)</TT>
</TD><TD><TT CLASS="TYPE">int</TT></TD><TD> 返回最外层的JSON数组元素的数量。
</TD><TD><TT CLASS="LITERAL">json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</TT></TD><TD><TT CLASS="LITERAL">5</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL">json_each(json)</TT>
</TD><TD><TT CLASS="TYPE">SETOF key text, value json</TT></TD><TD> 扩展最外层的JSON对象为一组键/值对。
</TD><TD><TT CLASS="LITERAL">select * from json_each('{"a":"foo", "b":"bar"}')</TT></TD><TD><PRE CLASS="PROGRAMLISTING"> key | value
-----+-------
 a   | "foo"
 b   | "bar"
 </PRE>
</TD></TR><TR><TD>
<TT CLASS="LITERAL">json_each_text(from_json json)</TT>
</TD><TD><TT CLASS="TYPE">SETOF key text, value text</TT></TD><TD> 扩展最外层的JSON对象为一组键/值对。返回值为text类型。
</TD><TD><TT CLASS="LITERAL">select * from json_each_text('{"a":"foo", "b":"bar"}')</TT></TD><TD><PRE CLASS="PROGRAMLISTING"> key | value
-----+-------
 a   | foo
 b   | bar
 </PRE>
</TD></TR><TR><TD>
<TT CLASS="LITERAL">json_extract_path(from_json json, VARIADIC path_elems text[])</TT>
</TD><TD><TT CLASS="TYPE">json</TT></TD><TD> 返回由<TT CLASS="PARAMETER">path_elems</TT>指出的JSON对象。
</TD><TD><TT CLASS="LITERAL">json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</TT></TD><TD><TT CLASS="LITERAL">{"f5":99,"f6":"foo"}</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL">json_extract_path_text(from_json json, VARIADIC path_elems text[])</TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD> 返回由<TT CLASS="PARAMETER">path_elems</TT>指出的JSON对象。
</TD><TD><TT CLASS="LITERAL">json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</TT></TD><TD><TT CLASS="LITERAL">foo</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL">json_object_keys(json)</TT>
</TD><TD><TT CLASS="TYPE">SETOF text</TT></TD><TD> 返回JSON对象中的一组键。只显示<SPAN CLASS="QUOTE">"外部"</SPAN>对象。
</TD><TD><TT CLASS="LITERAL">json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</TT></TD><TD><PRE CLASS="PROGRAMLISTING"> json_object_keys
------------------
 f1
 f2</PRE>
</TD></TR><TR><TD>
<TT CLASS="LITERAL">json_populate_record(base anyelement, from_json json, [, use_json_as_text bool=false]</TT>
</TD><TD><TT CLASS="TYPE">anyelement</TT></TD><TD> 扩展<TT CLASS="REPLACEABLE"><I>from_json</I></TT>里的对象到一行，这行的字段匹配基础定义的记录类型。
转换将会很好的进行；没有与<TT CLASS="REPLACEABLE"><I>from_json</I></TT>里的键对应的基础字段将会缺省为null。
如果一个字段指定了多次，那么将使用最后一个值。
</TD><TD><TT CLASS="LITERAL">select * from json_populate_record(null::x, '{"a":1,"b":2}')</TT></TD><TD><PRE CLASS="PROGRAMLISTING"> a | b
---+---
 1 | 2</PRE>
</TD></TR><TR><TD>
<TT CLASS="LITERAL">json_populate_recordset(base anyelement, from_json json, [, use_json_as_text bool=false]</TT>
</TD><TD><TT CLASS="TYPE">SETOF anyelement</TT></TD><TD> 扩展<TT CLASS="REPLACEABLE"><I>from_json</I></TT>里面最外层的对象集到一个集合，
这个集合的字段匹配基本定义的记录类型。转换将会很好的进行；
没有与<TT CLASS="REPLACEABLE"><I>from_json</I></TT>里的键对应的基础字段将会缺省为null。
如果一个字段指定了多次，那么将使用最后一个值。
</TD><TD><TT CLASS="LITERAL">select * from json_populate_recordset(null::x, '[{"a":1,"b":2},{"a":3,"b":4}]')</TT></TD><TD><PRE CLASS="PROGRAMLISTING"> a | b
---+---
 1 | 2
 3 | 4
 </PRE>
</TD></TR><TR><TD>
<TT CLASS="LITERAL">json_array_elements(json)</TT>
</TD><TD><TT CLASS="TYPE">SETOF json</TT></TD><TD> 扩展一个JSON数组到一组JSON元素的集合。
</TD><TD><TT CLASS="LITERAL">json_array_elements('[1,true, [2,false]]')</TT></TD><TD><PRE CLASS="PROGRAMLISTING">   value
-----------
 1
 true
 [2,false]</PRE>
</TD></TR></TBODY></TABLE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><TT CLASS="TYPE">json</TT>函数和操作符比输入函数类型可以实施更加严格的有效性需求。特别的，他们的检查更为紧密，
任何使用Unicode代理对到Unicode基本多文种平面以外的指定字符是正确的。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这些函数和操作符中的许多将转换JSON文本中的Unicode转义到相应的UTF8字符（当数据库编码为UTF8时）。
在其他编码模式下，转义序列必须是ASCII字符，任何其他在Unicode转义序列中的代码点将导致一个错误。
通常，如果可能的话，最好避免JSON中Unicode转义和非UTF8数据库编码混合。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><A HREF="hstore.html">hstore</A>扩展从<TT CLASS="TYPE">hstore</TT>转换到<TT CLASS="TYPE">json</TT>，所以转换了的<TT CLASS="TYPE">hstore</TT>
值作为JSON对象显示，而不是字符串值。</P></BLOCKQUOTE></DIV><P>参阅<A HREF="functions-aggregate.html">第 9.20 &#33410;</A>获取有关聚集函数<CODE CLASS="FUNCTION">json_agg</CODE>
的信息，<CODE CLASS="FUNCTION">json_agg</CODE>有效的聚合记录值为JSON。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="functions-xml.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="functions-sequence.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">XML 函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">序列操作函数</TD></TR></TABLE></DIV></BODY></HTML>
