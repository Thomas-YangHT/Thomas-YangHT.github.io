<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>扩展性</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SP-GiST索引" HREF="http://school.yunwei.edu/manual/PostgreSQL/spgist.html"><LINK REL="PREVIOUS" TITLE="介绍" HREF="spgist-intro.html"><LINK REL="NEXT" TITLE="实现" HREF="spgist-implementation.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/spgist.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="介绍" HREF="spgist-intro.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/spgist.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 56. SP-GiST索引</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="实现" HREF="spgist-implementation.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="SPGIST-EXTENSIBILITY">56.2. 扩展性</A></H1><P><ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>提供了一个高度抽象的接口,只需要访问方法开发人员实现特定于给定数据类型的方法。<ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>核心负责高效的磁盘映射和搜索树结构。它还负责考虑并发性和日志记录。
</P><P><ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>树的叶元组包含和被索引列相同数据类型的值。
在根层级的叶元组总是包含原来的索引数据值,但是低层级的叶元组可能只包含一个压缩表示,如一个后缀。
在这种情况下,操作符类支持函数必须能够，通过利用从到达叶元组所经过的内部元组中收集到的信息，重建原始值。
</P><P>内部元组更为复杂,因为它们是搜索树中的分支点。
每个内部元组包含由一个或多个<I CLASS="FIRSTTERM">节点</I>组成的集合,表示一组类似的叶元组值。
一个节点包含一个链接指向另一个低级内部元组,或指向一个短的叶元组的列表，这些叶元组存储在相同的索引页面中。
每个节点都有一个用来描述它的<I CLASS="FIRSTTERM">标签</I>。例如,在一个基数树中节点标签可以是字符串值的下一个字符。
可选地,一个内部元组可以有一个<I CLASS="FIRSTTERM">前缀</I>值,描述了它的所有成员。
在基数树中这可能是其所代表的字符串的共同前缀。
前缀值不一定真的是一个前缀,可以是操作符类所要求的任何数据。
例如,在四叉树中它可以存储可度量四个象限的中心点，四叉树的内部元组也就会相应的存储四个节点，每个代表了这个中心点周围的一个象限。
</P><P>一些树算法需要知道当前元组的层级(或深度),所以<ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>核心为操作符类提供了在向下访问树时管理层级计数的能力。
并且也支持在需要时递增地重建所代表的值。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>核心代码考虑了null条目。
尽管<ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>索引为被索引列中的null值存储了的条目,但这对索引操作符类代码是隐藏的:null索引条目或搜索条件不会被传递给操作符类的方法。
(假定<ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>操作符是严格的,因此不能在null值上匹配成功。)因此后面也就不会再讨论null值的问题了。
</P></BLOCKQUOTE></DIV><P>一个用于<ACRONYM CLASS="ACRONYM">SP-GiST</ACRONYM>的索引操作符类必须提供五个用户定义的方法。
所有五个方法按照约定接受两个<TT CLASS="TYPE">internal</TT>参数，第一个参数是一个指向包含了支持方法的输入值的C结构体的指针，而第二个参数是一个指向放置输出值的C结构体的指针。其中四个方法只是返回void,因为它们所有的结果都出现在输出结构体里;但<CODE CLASS="FUNCTION">leaf_consistent</CODE>返回一个布尔结果。这些方法不能修改输入结构体中的任何域。在所有情况下，在调用用户定义的方法之前，输出结构体的内容被用初始化为0。
</P><P>五个用户定义的方法如下：
</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><CODE CLASS="FUNCTION">config</CODE></DT><DD><P>返回关于索引实现的静态信息,包括前缀的数据类型OID和节点标签的数据类型。
</P><P>函数的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>声明必须看起来像这样:
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION my_config(internal, internal) RETURNS void ...</PRE><P>
第一个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgConfigIn</TT>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgConfigOut</TT>的指针,该函数必须填充结果数据到里面。
</P><PRE CLASS="PROGRAMLISTING">typedef struct spgConfigIn
{
    Oid         attType;        /* Data type to be indexed */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* Data type of inner-tuple prefixes */
    Oid         labelType;      /* Data type of inner-tuple node labels */
    bool        canReturnData;  /* Opclass can reconstruct original data */
    bool        longValuesOK;   /* Opclass can cope with values &gt; 1 page */
} spgConfigOut;</PRE><P>
传递<TT CLASS="STRUCTFIELD">attType</TT>是为了支持多态索引操作符类。
对普通固定数据类型操作符类,它将总是有相同的值,因此可以忽略。
</P><P>对于不使用前缀的操作符类,<TT CLASS="STRUCTFIELD">prefixType</TT>可以被设置成<TT CLASS="LITERAL">VOIDOID</TT>。
同样,对不使用节点标签的操作符类，<TT CLASS="STRUCTFIELD">labelType</TT>可以被设置成<TT CLASS="LITERAL">VOIDOID</TT>。
如果操作符类能够重建最初提供的索引值，<TT CLASS="STRUCTFIELD">canReturnData</TT>应设置为true。
只有当<TT CLASS="STRUCTFIELD">attType</TT>是可变长类型并且操作符类能够通过反复的添加后缀分割很长的值的时候，<TT CLASS="STRUCTFIELD">longValuesOK</TT>才应该被设置为true(参见<A HREF="spgist-implementation.html#SPGIST-LIMITS">第 56.3.1 &#33410;</A>)。
</P></DD><DT><CODE CLASS="FUNCTION">choose</CODE></DT><DD><P>选择一种方法将一个新值插入到一个内部元组。
</P><P>函数的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>声明必须看起来像这样:
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION my_choose(internal, internal) RETURNS void ...</PRE><P>
第一个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgChooseIn</TT>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgChooseOut</TT>的指针,该函数必须填充结果数据到里面。
</P><PRE CLASS="PROGRAMLISTING">typedef struct spgChooseIn
{
    Datum       datum;          /* original datum to be indexed */
    Datum       leafDatum;      /* current datum to be stored at leaf */
    int         level;          /* current level (counting from zero) */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* descend into existing node */
    spgAddNode,                 /* add a node to the inner tuple */
    spgSplitTuple               /* split inner tuple (change its prefix) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* action code, see above */
    union
    {
        struct                  /* results for spgMatchNode */
        {
            int         nodeN;      /* descend to this node (index from 0) */
            int         levelAdd;   /* increment level by this much */
            Datum       restDatum;  /* new leaf datum */
        }           matchNode;
        struct                  /* results for spgAddNode */
        {
            Datum       nodeLabel;  /* new node's label */
            int         nodeN;      /* where to insert it (index from 0) */
        }           addNode;
        struct                  /* results for spgSplitTuple */
        {
            /* Info to form new inner tuple with one node */
            bool        prefixHasPrefix;    /* tuple should have a prefix? */
            Datum       prefixPrefixDatum;  /* if so, its value */
            Datum       nodeLabel;          /* node's label */

            /* Info to form new lower-level inner tuple with all old nodes */
            bool        postfixHasPrefix;   /* tuple should have a prefix? */
            Datum       postfixPrefixDatum; /* if so, its value */
        }           splitTuple;
    }           result;
} spgChooseOut;</PRE><P>
<TT CLASS="STRUCTFIELD">datum</TT>是被插入到索引的原始数据。
<TT CLASS="STRUCTFIELD">leafDatum</TT>最初和<TT CLASS="STRUCTFIELD">datum</TT>是一样的，如果函数<CODE CLASS="FUNCTION">choose</CODE>或者<CODE CLASS="FUNCTION">picksplit</CODE>把它修改了，在树的低层级可能会不同。
当插入搜索到达叶页面，当前的<TT CLASS="STRUCTFIELD">leafDatum</TT>值就是存储到新生成的叶元组中的值。
<TT CLASS="STRUCTFIELD">level</TT>是当前内部元组的层级，从0，也就是根的层级，开始计数。
如果当前内部元组包含多个等价节点，<TT CLASS="STRUCTFIELD">allTheSame</TT>为true(参见<A HREF="spgist-implementation.html#SPGIST-ALL-THE-SAME">第 56.3.3 &#33410;</A>)。
如果当前内部元组包含前缀，<TT CLASS="STRUCTFIELD">hasPrefix</TT>为true。
此时，<TT CLASS="STRUCTFIELD">prefixDatum</TT>是前缀值。
<TT CLASS="STRUCTFIELD">nNodes</TT>是内部元组中包含子节点的数量，<TT CLASS="STRUCTFIELD">nodeLabels</TT>是它们的标签值的数组,或者是NULL如果没有标签的话。
</P><P><CODE CLASS="FUNCTION">choose</CODE>函数可以确定新值匹配一个现有的子节点,或者必须添加一个新的子节点,或者新值与元组前缀不一致,所以内部元组必须分裂开以创建一个限制较少的前缀。
</P><P>如果新值匹配的一个现有的子节点,把<TT CLASS="STRUCTFIELD">resultType</TT>设置为<TT CLASS="LITERAL">spgMatchNode</TT>。
把<TT CLASS="STRUCTFIELD">nodeN</TT>设置为那个索引节点在节点数组中的索引(从0开始)。
把<TT CLASS="STRUCTFIELD">levelAdd</TT>设置为，由下降到那个节点导致的<TT CLASS="STRUCTFIELD">level</TT>增量；
或者为0如果操作符类不使用层级。
把<TT CLASS="STRUCTFIELD">restDatum</TT>设置为和<TT CLASS="STRUCTFIELD">datum</TT>相等的值，如果操作符类从一个层级到下一个层级不会修改数据值；否则将其设置为修改后的值，它在下一个层级被用作<TT CLASS="STRUCTFIELD">leafDatum</TT>。
</P><P>如果必须添加一个新的子节点,把<TT CLASS="STRUCTFIELD">resultType</TT>设置为<TT CLASS="LITERAL">spgAddNode</TT>。
设置<TT CLASS="STRUCTFIELD">nodeLabel</TT>为新节点的标签,并设置<TT CLASS="STRUCTFIELD">nodeN</TT>为插入位置在节点数组中的索引(从0开始)。
添加了节点后,<CODE CLASS="FUNCTION">choose</CODE>函数将再次与被修改的内部元组一起被调用，那次调用应该导致一个<TT CLASS="LITERAL">spgMatchNode</TT>结果。
</P><P>如果新值与元组前缀是不一致的,把<TT CLASS="STRUCTFIELD">resultType</TT>设置为<TT CLASS="LITERAL">spgSplitTuple</TT>。
这一动作把所有现有的节点移动到一个新的低层级的内部元组,并把现有内部元组替换为一个只有一个链接到新的低层级内部元组的单个节点的元组。
设定<TT CLASS="STRUCTFIELD">prefixHasPrefix</TT>表明是否新的较高的元组应该有一个前缀,如果是的话，设置<TT CLASS="STRUCTFIELD">prefixPrefixDatum</TT>为前缀值。
这个新的前缀值必须比原来的限制足够小以接受新的被索引值,而且应当不超过原前缀的长度。
设置<TT CLASS="STRUCTFIELD">nodeLabel</TT>为指向新的低层级内部元组的节点的标签值。
设定<TT CLASS="STRUCTFIELD">postfixHasPrefix</TT>表明是否新的较低的元组应该有一个前缀,如果是的话，设置<TT CLASS="STRUCTFIELD">postfixPrefixDatum</TT>为前缀值。
这两个前缀和额外的标签的组合必须与原始前缀具有相同的含义,因为没有机会改变被移动到新的低层级元组中的节点标签，也不能改变任何子索引条目。
节点被分裂后,<CODE CLASS="FUNCTION">choose</CODE>会被再次调用，针对替换的内部元组。那个调用通常会导致<TT CLASS="LITERAL">spgAddNode</TT>结果,因为分裂步骤添加的节点标签可能不会匹配新值；所以在那之后,还会有第三次调用,最后的调用返回<TT CLASS="LITERAL">spgMatchNode</TT>,允许插入操作下去到叶层级。
</P></DD><DT><CODE CLASS="FUNCTION">picksplit</CODE></DT><DD><P>决定如何在一组叶元组之上创建一个新的内部元组。
</P><P>函数的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>声明必须看起来像这样:
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...</PRE><P>
第一个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgPickSplitIn</TT>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgPickSplitOut</TT>的指针,该函数必须填充结果数据到里面。
</P><PRE CLASS="PROGRAMLISTING">typedef struct spgPickSplitIn
{
    int         nTuples;        /* number of leaf tuples */
    Datum      *datums;         /* their datums (array of length nTuples) */
    int         level;          /* current level (counting from zero) */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* new inner tuple should have a prefix? */
    Datum       prefixDatum;    /* if so, its value */

    int         nNodes;         /* number of nodes for new inner tuple */
    Datum      *nodeLabels;     /* their labels (or NULL for no labels) */

    int        *mapTuplesToNodes;   /* node index for each leaf tuple */
    Datum      *leafTupleDatums;    /* datum to store in each new leaf tuple */
} spgPickSplitOut;</PRE><P>
<TT CLASS="STRUCTFIELD">nTuples</TT>是提供的叶元组的数量。
<TT CLASS="STRUCTFIELD">datums</TT>是数据值的数组。
<TT CLASS="STRUCTFIELD">level</TT>是所有的叶元组共享的当前层级,这将成为新的内部元组的层级。
</P><P><TT CLASS="STRUCTFIELD">hasPrefix</TT>表明是否新的内部元组应该有一个前缀,如果是的话设置prefixDatum前缀值。
<TT CLASS="STRUCTFIELD">nNodes</TT>表明新内部元组将包含的节点数量,并设置<TT CLASS="STRUCTFIELD">nodeLabels</TT>为它们的标签值的数组。
(如果节点不需要标签,设置<TT CLASS="STRUCTFIELD">nodeLabels</TT>为NULL;有关详细信息,请参见<A HREF="spgist-implementation.html#SPGIST-NULL-LABELS">第 56.3.2 &#33410;</A>。)
设置<TT CLASS="STRUCTFIELD">mapTuplesToNodes</TT>为各个叶元组应该被分配的节点的索引(从0开始)的数组。
设置<TT CLASS="STRUCTFIELD">leafTupleDatums</TT>为存储在新的叶元组的值的数组(如果操作符类从一个层级到下一个层级不修改数据,它们将和输入数据相同)。
注意,<CODE CLASS="FUNCTION">picksplit</CODE>函数负责分配(palloc) <TT CLASS="STRUCTFIELD">nodeLabels</TT>, <TT CLASS="STRUCTFIELD">mapTuplesToNodes</TT>和<TT CLASS="STRUCTFIELD">leafTupleDatums</TT>数组。
</P><P>如果提供了不止一个叶元组,预计<CODE CLASS="FUNCTION">picksplit</CODE>函数会把它们分类到多个节点,否则不可能把叶元组分裂到多个页面,这是这个操作的最终目的。
因此,如果<CODE CLASS="FUNCTION">picksplit</CODE>函数最终把所有叶元组放在同一节点,核心SP-GiST代码将覆盖这一决定并生成一个内部元组，这些叶元组会被随机分配到这个内部元组的几个有等价标签(identically-labeled)的节点上。
这样的元组被设置了<TT CLASS="LITERAL">allTheSame</TT>标志，以表示发生这样的事情了。
<CODE CLASS="FUNCTION">choose</CODE>和<CODE CLASS="FUNCTION">inner_consistent</CODE>函数必须小心对待这样的内部元组。
有关更多信息,请参见<A HREF="spgist-implementation.html#SPGIST-ALL-THE-SAME">第 56.3.3 &#33410;</A>。
</P><P>只有当<CODE CLASS="FUNCTION">config</CODE>函数设置<TT CLASS="STRUCTFIELD">longValuesOK</TT>为true,并且提供了大于一页面的输入值时，
<CODE CLASS="FUNCTION">picksplit</CODE>才可以被应用到单个叶元组。
在这种情况下操作的要点是剥离前缀并产生一个新的、更短的叶数据值。
这个调用将被反复执行，直到叶数据已经短到可以放到一个被生成的页面上。
有关更多信息,请参见<A HREF="spgist-implementation.html#SPGIST-LIMITS">第 56.3.1 &#33410;</A>。
</P></DD><DT><CODE CLASS="FUNCTION">inner_consistent</CODE></DT><DD><P>返回树搜索需要继续访问的节点集合(分支)。
</P><P>函数的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>声明必须看起来像这样:
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...</PRE><P>
第一个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgInnerConsistentIn</TT>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgInnerConsistentOut</TT>的指针,该函数必须填充结果数据到里面。
</P><PRE CLASS="PROGRAMLISTING">typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    int         nkeys;          /* length of array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* number of child nodes to be visited */
    int        *nodeNumbers;    /* their indexes in the node array */
    int        *levelAdds;      /* increment level by this much for each */
    Datum      *reconstructedValues;    /* associated reconstructed values */
} spgInnerConsistentOut;</PRE><P>
长度为<TT CLASS="STRUCTFIELD">nkeys</TT>的<TT CLASS="STRUCTFIELD">scankeys</TT>数组描述了索引搜索条件。
这些条件以"AND"联接在一起，即，只有满足所有条件的索引条目才能匹配这个查询。
(注意,如果<TT CLASS="STRUCTFIELD">nkeys</TT>为0意味着所有索引条目都满足查询。)
通常这个函数只关心每个数组项目的<TT CLASS="STRUCTFIELD">sk_strategy</TT>和<TT CLASS="STRUCTFIELD">sk_argument</TT>字段,它们分别给出了可索引的操作符和比较值。
特别是没有必要看<TT CLASS="STRUCTFIELD">sk_flags</TT>以检查比较值是否为NULL,因为SP-GiST核心代码会过滤掉这样的条件。
<TT CLASS="STRUCTFIELD">reconstructedValue</TT>是为父元组重建的值；如果在根层级或<CODE CLASS="FUNCTION">inner_consistent</CODE>函数在父层级没有提供一个值，它会是0。
<TT CLASS="STRUCTFIELD">level</TT>是当前内部元组的层级，从0，也就是根的层级，开始计数。
<TT CLASS="STRUCTFIELD">returnData</TT>为<TT CLASS="LITERAL">true</TT>，如果这个查询需要重建数据的话；只有<CODE CLASS="FUNCTION">config</CODE>函数声明了<TT CLASS="STRUCTFIELD">canReturnData</TT>时，才有可能是这样。
<TT CLASS="STRUCTFIELD">allTheSame</TT>是true，如果当前内部元组标记<SPAN CLASS="QUOTE">"all-the-same"</SPAN>;在这种情况下的所有节点具有相同的标签(如果有的话),所以要么全部要么没有一个匹配这个查询(参见<A HREF="spgist-implementation.html#SPGIST-ALL-THE-SAME">第 56.3.3 &#33410;</A>)。
如果当前内部元组包含前缀，<TT CLASS="STRUCTFIELD">hasPrefix</TT>为true。
此时，<TT CLASS="STRUCTFIELD">prefixDatum</TT>是前缀值。
<TT CLASS="STRUCTFIELD">nNodes</TT>是内部元组中包含子节点的数量，<TT CLASS="STRUCTFIELD">nodeLabels</TT>是它们的标签值的数组,或者是NULL如果节点没有标签。
</P><P><TT CLASS="STRUCTFIELD">nNodes</TT>必须被设置为搜索需要访问的子节点的数量,
并且<TT CLASS="STRUCTFIELD">nodeNumbers</TT>必须被设置的它们的索引的数组。
如果操作符类跟踪层级,设置<TT CLASS="STRUCTFIELD">levelAdds</TT>为向下访问到每个节点时层级增量的数组。
(通常这些增量对所有节点是相同的,但这并不一定是这样,所以使用一个数组)。
如果需要重建数据值,设置<TT CLASS="STRUCTFIELD">reconstructedValues</TT>为每个要访问的子节点的重建值的数组;否则,保持<TT CLASS="STRUCTFIELD">reconstructedValues</TT>为NULL。
注意,<CODE CLASS="FUNCTION">inner_consistent</CODE>函数负责分配(palloc) <TT CLASS="STRUCTFIELD">nodeNumbers</TT>, <TT CLASS="STRUCTFIELD">levelAdds</TT>和<TT CLASS="STRUCTFIELD">reconstructedValues</TT>数组。
</P></DD><DT><CODE CLASS="FUNCTION">leaf_consistent</CODE></DT><DD><P>如果叶元组满足查询返回true。
</P><P>函数的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>声明必须看起来像这样:
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...</PRE><P>
第一个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgLeafConsistentIn</TT>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<TT CLASS="STRUCTNAME">spgLeafConsistentOut</TT>的指针,该函数必须填充结果数据到里面。
</P><PRE CLASS="PROGRAMLISTING">typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    int         nkeys;          /* length of array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    Datum       leafDatum;      /* datum in leaf tuple */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;      /* reconstructed original data, if any */
    bool        recheck;        /* set true if operator must be rechecked */
} spgLeafConsistentOut;</PRE><P>
长度为<TT CLASS="STRUCTFIELD">nkeys</TT>的<TT CLASS="STRUCTFIELD">scankeys</TT>数组描述了索引搜索条件。
这些条件以"AND"联接在一起，即，只有满足所有条件的索引条目才能匹配这个查询。
(注意,如果<TT CLASS="STRUCTFIELD">nkeys</TT>为0意味着所有索引条目都满足查询。)
通常这个函数只关心每个数组项目的<TT CLASS="STRUCTFIELD">sk_strategy</TT>和<TT CLASS="STRUCTFIELD">sk_argument</TT>字段,它们分别给出了可索引的操作符和比较值。
特别是没有必要看<TT CLASS="STRUCTFIELD">sk_flags</TT>以检查比较值是否为NULL,因为SP-GiST核心代码会过滤掉这样的条件。
<TT CLASS="STRUCTFIELD">reconstructedValue</TT>是父元组重建的值；如果在根层级或<CODE CLASS="FUNCTION">inner_consistent</CODE>函数在父层级没有提供一个值，它会是0。
<TT CLASS="STRUCTFIELD">level</TT>是当前叶元组的层级，从0，也就是根的层级，开始计数。
<TT CLASS="STRUCTFIELD">returnData</TT>为<TT CLASS="LITERAL">true</TT>，如果这个查询需要重建数据的话；只有<CODE CLASS="FUNCTION">config</CODE>函数声明了<TT CLASS="STRUCTFIELD">canReturnData</TT>时，才有可能是这样。
<TT CLASS="STRUCTFIELD">leafDatum</TT>是存储在当前叶元组中的键值。
</P><P>如果这个叶元组匹配查询，这个函数必须返回<TT CLASS="LITERAL">true</TT>,否则返回<TT CLASS="LITERAL">false</TT>。
在<TT CLASS="LITERAL">true</TT>的情况下,如果<TT CLASS="STRUCTFIELD">returnData</TT>是<TT CLASS="LITERAL">true</TT>，
那么<TT CLASS="STRUCTFIELD">leafValue</TT>必须被设置为最初提供的这个叶元组索引的值。
如果匹配是不确定的,<TT CLASS="STRUCTFIELD">recheck</TT>也被设置为<TT CLASS="LITERAL">true</TT>，因此操作符必须被重新应用到实际的堆元组上以验证匹配。
</P></DD></DL></DIV><P>所有SP-GiST支持方法通常在一个短期的内存上下文中被调用;也就是说,
在处理每一个元组后<TT CLASS="VARNAME">CurrentMemoryContext</TT>将被重置。
因此不太需要担心地去pfree你palloc出来的所有东西。
（<CODE CLASS="FUNCTION">config</CODE>方法是一个例外:它应该尽量避免内存泄露。
但通常<CODE CLASS="FUNCTION">config</CODE>方法除了把常数赋值到传递过来的结构体中外，其它什么也不需要做。）
</P><P>如果被索引列是一个collatable数据类型,该索引排序规则将被传递给所有的支持方法,使用标准的<CODE CLASS="FUNCTION">PG_GET_COLLATION()</CODE> 机制。
</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="spgist-intro.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="spgist-implementation.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">介绍</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/spgist.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">实现</TD></TR></TABLE></DIV></BODY></HTML>
