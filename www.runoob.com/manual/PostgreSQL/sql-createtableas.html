<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>CREATE TABLE AS</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="CREATE TABLE" HREF="sql-createtable.html"><LINK REL="NEXT" TITLE="CREATE TABLESPACE" HREF="sql-createtablespace.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/create_table_as.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="CREATE TABLE" HREF="sql-createtable.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="CREATE TABLESPACE" HREF="sql-createtablespace.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-CREATETABLEAS"></A>CREATE TABLE AS</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN73059"></A><H2>&#21517;&#31216;</H2>CREATE TABLE AS&nbsp;--&nbsp;从一条查询的结果中定义一个新表</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN73064"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>
    [ (<TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) ]
    [ WITH ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> [= <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
    [ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
    [ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>tablespace_name</I
></TT
> ]
    AS <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>
    [ WITH [ NO ] DATA ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73072"></A><H2>描述</H2><P><TT CLASS="COMMAND">CREATE TABLE AS</TT>创建一个表并且用来自
<TT CLASS="COMMAND">SELECT</TT>命令的结果填充该表。该表的字段和
<TT CLASS="COMMAND">SELECT</TT>输出字段的名字及数据类型相关。
（不过你可以通过明确地给出一个字段名字列表来覆盖 SELECT 输出字段的名字。）</P><P><TT CLASS="COMMAND">CREATE TABLE AS</TT>和创建视图有点像，
不过两者之间实在是差异很大：它创建一个新表并且只对查询计算一次来填充这个新表。
新表不能跟踪源表的变化。相比之下，每次做查询的时候，
视图都重新计算定义它的<TT CLASS="COMMAND">SELECT</TT>语句。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73081"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">GLOBAL</TT> 或 <TT CLASS="LITERAL">LOCAL</TT></DT><DD><P>忽略，仅仅为了兼容性而存在。这些关键字的使用已经废弃了；
请参考<A HREF="sql-createtable.html">CREATE TABLE</A>获取细节。</P></DD></DL></DIV><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">TEMPORARY</TT> 或 <TT CLASS="LITERAL">TEMP</TT></DT><DD><P>如果声明了这个选项，则该表作为临时表创建。
参阅<A HREF="sql-createtable.html">CREATE TABLE</A>获取细节。</P></DD><DT><TT CLASS="LITERAL">UNLOGGED</TT></DT><DD><P>如果声明了这个选项，则该表作为非日志表创建。
参阅<A HREF="sql-createtable.html">CREATE TABLE</A>获取细节。</P></DD><DT><TT CLASS="REPLACEABLE"><I>table_name</I></TT></DT><DD><P>要创建的表名(可以用模式修饰)。</P></DD><DT><TT CLASS="REPLACEABLE"><I>column_name</I></TT></DT><DD><P>新表中字段的名称。如果没有提供字段名字，那么就从查询的输出字段名中获取。</P></DD><DT><TT CLASS="LITERAL">WITH ( <TT CLASS="REPLACEABLE"><I>storage_parameter</I></TT> [= <TT CLASS="REPLACEABLE"><I>value</I></TT>] [, ... ] )</TT></DT><DD><P>这个子句为新表指定了可选的存储参数；参见<A HREF="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS"><I>存储参数</I></A>获取更多信息。
<TT CLASS="LITERAL">WITH</TT>子句还可以包含<TT CLASS="LITERAL">OIDS=TRUE</TT>（或只是<TT CLASS="LITERAL">OIDS</TT>）
来为新表中的行分配和存储 OID(对象表示符)；或者用<TT CLASS="LITERAL">OIDS=FALSE</TT>
表示不分配 OID 。参见<A HREF="sql-createtable.html">CREATE TABLE</A>获取更多信息。</P></DD><DT><TT CLASS="LITERAL">WITH OIDS</TT><BR><TT CLASS="LITERAL">WITHOUT OIDS</TT></DT><DD><P>这些是反对使用的、分别等价于<TT CLASS="LITERAL">WITH (OIDS)</TT>和
<TT CLASS="LITERAL">WITH (OIDS=FALSE)</TT>的语法。如果你希望同时给出<TT CLASS="LITERAL">OIDS</TT>
设置和存储参数，必须使用<TT CLASS="LITERAL">WITH ( ... )</TT>语法；见下文。</P></DD><DT><TT CLASS="LITERAL">ON COMMIT</TT></DT><DD><P>可以使用<TT CLASS="LITERAL">ON COMMIT</TT>控制临时表在事务块结尾的行为。
三个选项是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">PRESERVE ROWS</TT></DT><DD><P>在事务的结尾不采取任何特别的动作，这是缺省。</P></DD><DT><TT CLASS="LITERAL">DELETE ROWS</TT></DT><DD><P>在每个事务块的结尾都删除临时表中的所有行。
本质上是在每次提交事务后自动执行一个<A HREF="sql-truncate.html">TRUNCATE</A>命令。</P></DD><DT><TT CLASS="LITERAL">DROP</TT></DT><DD><P>在当前事务块的结尾将删除临时表。</P></DD></DL></DIV><P></P></DD><DT><TT CLASS="LITERAL">TABLESPACE <TT CLASS="REPLACEABLE"><I>tablespace_name</I></TT></TT></DT><DD><P>指定新表将要在<TT CLASS="REPLACEABLE"><I>tablespace_name</I></TT>
表空间内创建。如果没有声明，将咨询<A HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</A>，
或如果该表为临时表，那么将使用<A HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</A>。</P></DD><DT><TT CLASS="REPLACEABLE"><I>query</I></TT></DT><DD><P>一个<A HREF="sql-select.html">SELECT</A>、<A HREF="sql-select.html#SQL-TABLE">TABLE</A>
或<A HREF="sql-values.html">VALUES</A>命令，或者一个运行预备好的
<TT CLASS="COMMAND">SELECT</TT>、<TT CLASS="COMMAND">TABLE</TT>或<TT CLASS="COMMAND">VALUES</TT>
查询的<A HREF="sql-execute.html">EXECUTE</A>命令。</P></DD><DT><TT CLASS="LITERAL">WITH [ NO ] DATA</TT></DT><DD><P>这个子句指定查询产生的数据是否应该拷贝到新表中。如果不，那么只拷贝表结构。
缺省是拷贝数据。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73188"></A><H2>注意</H2><P>这条命令在功能上等效于<A HREF="sql-selectinto.html">SELECT INTO</A>，但是更建议你用这个命令，
因为它不太可能和<TT CLASS="COMMAND">SELECT INTO</TT>语法的其它方面混淆。另外，
<TT CLASS="COMMAND">CREATE TABLE AS</TT>提供了<TT CLASS="COMMAND">SELECT INTO</TT>功能的超集。</P><P>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.0 之前，
<TT CLASS="COMMAND">CREATE TABLE AS</TT>总是在它创建的表中包含 OID ，
而在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.0 里，<TT CLASS="COMMAND">CREATE TABLE AS</TT>
命令允许明确声明是否应该包含 OID 。如果没有明确声明是否应该包含 OID ，
那么使用配置变量<A HREF="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS">default_with_oids</A>的设置。
到了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>这个变量缺省为假，
缺省行为和 8.0 之前的版本不同。因此，那些要求<TT CLASS="COMMAND">CREATE TABLE AS</TT>
创建的表包含 OID 的应用应该明确声明<TT CLASS="LITERAL">WITH (OIDS)</TT>以确保要求的行为。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73204"></A><H2>例子</H2><P>创建一个只包含表<TT CLASS="LITERAL">films</TT>中最近的记录的新表<TT CLASS="LITERAL">films_recent</TT>：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE films_recent AS
  SELECT * FROM films WHERE date_prod &gt;= '2002-01-01';</PRE><P>
</P><P>要完整的拷贝一个表，也可以使用<TT CLASS="LITERAL">TABLE</TT>命令的简易形式：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE films2 AS
  TABLE films;</PRE><P>
</P><P>使用预备语句创建一个只包含表<TT CLASS="LITERAL">films</TT>中最近的记录的新临时表
<TT CLASS="LITERAL">films_recent</TT>，该临时表包含 OID 并且在事务结束时将被删除：
</P><PRE CLASS="PROGRAMLISTING">PREPARE recentfilms(date) AS
  SELECT * FROM films WHERE date_prod &gt; $1;
CREATE TEMP TABLE films_recent WITH (OIDS) ON COMMIT DROP AS
  EXECUTE recentfilms('2002-01-01');</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73217"></A><H2>兼容性</H2><P><TT CLASS="COMMAND">CREATE TABLE AS</TT>兼容<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准，
下面是非标准的扩展：
<P></P></P><UL COMPACT="COMPACT"><LI><P>标准要求在子查询子句周围有圆括弧，在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
里，这些圆括弧是可选的。</P></LI><LI><P>在标准中，<TT CLASS="LITERAL">WITH [ NO ] DATA</TT>子句是必选的；
在PostgreSQL中，它是可选的。</P></LI><LI><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>处理临时表的方法和标准相差较大；
参阅<A HREF="sql-createtable.html">CREATE TABLE</A>获取细节。</P></LI><LI><P><TT CLASS="LITERAL">WITH</TT>子句是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扩展，
并且 SQL 标准中也没有存储参数和 OID 。</P></LI><LI><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>表空间的概念也不是标准的一部分。
因此<TT CLASS="LITERAL">TABLESPACE</TT>子句也是扩展。</P></LI></UL><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN73241"></A><H2>又见</H2><A HREF="sql-creatematerializedview.html">CREATE MATERIALIZED VIEW</A>, <A HREF="sql-createtable.html">CREATE TABLE</A>, <A HREF="sql-execute.html">EXECUTE</A>, <A HREF="sql-select.html">SELECT</A>, <A HREF="sql-selectinto.html">SELECT INTO</A>, <A HREF="sql-values.html">VALUES</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-createtable.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-createtablespace.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">CREATE TABLE</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">CREATE TABLESPACE</TD></TR></TABLE></DIV></BODY></HTML>
