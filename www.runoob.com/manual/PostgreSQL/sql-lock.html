<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>LOCK</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="LOAD" HREF="sql-load.html"><LINK REL="NEXT" TITLE="MOVE" HREF="sql-move.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/lock.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="LOAD" HREF="sql-load.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="MOVE" HREF="sql-move.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-LOCK"></A>LOCK</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN78323"></A><H2>&#21517;&#31216;</H2>LOCK&nbsp;--&nbsp;锁定一个表</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN78328"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">LOCK [ TABLE ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ * ] [, ...] [ IN <TT
CLASS="REPLACEABLE"
><I
>lockmode</I
></TT
> MODE ] [ NOWAIT ]

 <SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>这里的<TT
CLASS="REPLACEABLE"
><I
>lockmode</I
></TT
>可以是下列之一：</SPAN
></SPAN
>

    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78334"></A><H2>描述</H2><P><TT CLASS="COMMAND">LOCK TABLE</TT>获取一个表级锁，必要时等待任何冲突的锁释放。
如果声明了<TT CLASS="LITERAL">NOWAIT</TT>，那么<TT CLASS="COMMAND">LOCK TABLE</TT>
并不等待它所需要的锁：如果无法立即获取该锁，那么该命令退出并且发出一个错误信息。
如果成功获取了这个锁，那么它就会在当前事务的余下部分一直保持。
没有<TT CLASS="COMMAND">UNLOCK TABLE</TT>命令；锁总是在事务结尾释放。</P><P>在为那些引用了表的命令自动请求锁的时候，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
总是尽可能使用最小限制的锁模式。<TT CLASS="COMMAND">LOCK TABLE</TT>是为你在需要更严格的锁的场合提供的。
例如，假设一个应用在"读已提交"隔离级别上运行事务，并且它需要保证在表中的数据在事务的运行过程中都存在。
要实现这个目的，你可以在查询之前对表使用<TT CLASS="LITERAL">SHARE</TT>锁模式进行锁定。
这样将保护数据不被并发修改并且为任何更进一步的对表的读操作提供实际的当前状态的数据，
因为<TT CLASS="LITERAL">SHARE</TT>锁模式与任何写操作需要的<TT CLASS="LITERAL">ROW EXCLUSIVE</TT>模式冲突，
并且你的<TT CLASS="COMMAND">LOCK TABLE <TT CLASS="REPLACEABLE"><I>name</I></TT> IN SHARE MODE</TT>
语句将等到所有当前持有<TT CLASS="LITERAL">ROW EXCLUSIVE</TT>模式的锁提交或回卷后才执行。因此，
一旦你获得该锁，那么就不会存在未提交的写操作，并且其他人只能在你释放锁之后才能再次获取锁。</P><P>如果运行在<TT CLASS="LITERAL">可重复读</TT>或<TT CLASS="LITERAL">可串行化</TT>隔离级别实现类似的效果的时候，
你必须在执行任何<TT CLASS="COMMAND">SELECT</TT>或数据修改语句之前运行一个<TT CLASS="COMMAND">LOCK TABLE</TT>语句。
一个<TT CLASS="LITERAL">可重复读</TT>或<TT CLASS="LITERAL">可串行化</TT>事务的数据图像将在其第一个<TT CLASS="COMMAND">SELECT</TT>
或者数据修改语句开始的时候冻结住。稍后的<TT CLASS="COMMAND">LOCK TABLE</TT>将仍然阻止并发的写，
但它不能保证事务读取的东西对应最近提交的数值。</P><P>如果一个此类的事务准备修改一个表中的数据，那么应该使用<TT CLASS="LITERAL">SHARE ROW EXCLUSIVE</TT>锁模式，
而不是<TT CLASS="LITERAL">SHARE</TT>模式。这样就保证任意时刻只有一个此类的事务运行。不这样做就可能会死锁：
当两个并发的事务可能都请求<TT CLASS="LITERAL">SHARE</TT>模式，然后试图更改表中的数据时，
两个事务在实际执行更新的时候都需要<TT CLASS="LITERAL">ROW EXCLUSIVE</TT>锁模式，但是它们无法再次获取这个锁。
请注意，一个事务自己的锁是从不冲突的，因此一个事务可以在持有<TT CLASS="LITERAL">SHARE</TT>
模式的锁的时候请求<TT CLASS="LITERAL">ROW EXCLUSIVE</TT>模式(但是不能在任何其它事务持有<TT CLASS="LITERAL">SHARE</TT>
模式的时候请求)。为了避免死锁，所有事务应该保证以相同的顺序对相同的对象请求锁，
并且，如果涉及多种锁模式，那么事务应该总是最先请求最严格的锁模式。</P><P>有关锁模式和锁定策略的更多信息，请参考<A HREF="explicit-locking.html">第 13.3 &#33410;</A>。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78369"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>name</I></TT></DT><DD><P>要锁定的现存表的名字(可以有模式修饰)。如果在表名前声明了<TT CLASS="LITERAL">ONLY</TT>，那么只有那一个表被锁定。
如果没有声明<TT CLASS="LITERAL">ONLY</TT>，那么该表和它的所有后代表（如果有）都被锁定。可选的，<TT CLASS="LITERAL">*</TT>
可以在表名后面指定，明确表明包含后代表。</P><P>命令<TT CLASS="LITERAL">LOCK TABLE a, b;</TT>等效于<TT CLASS="LITERAL">LOCK TABLE a; LOCK TABLE b;</TT>。
表是按照<TT CLASS="COMMAND">LOCK TABLE</TT>命令中声明的顺序一个接一个顺序上锁的。</P></DD><DT><TT CLASS="REPLACEABLE"><I>lockmode</I></TT></DT><DD><P>锁模式声明这个锁和哪些锁冲突。锁模式在<A HREF="explicit-locking.html">第 13.3 &#33410;</A>里描述。</P><P>如果没有声明锁模式，那么使用最严格的模式<TT CLASS="LITERAL">ACCESS EXCLUSIVE</TT>模式。</P></DD><DT><TT CLASS="LITERAL">NOWAIT</TT></DT><DD><P>声明<TT CLASS="COMMAND">LOCK TABLE</TT>不去等待任何冲突的锁释放：
如果无法不等待立即获取所要求的锁，那么事务退出。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78398"></A><H2>注意</H2><P><TT CLASS="LITERAL">LOCK TABLE ... IN ACCESS SHARE MODE</TT>需要在目标表上有<TT CLASS="LITERAL">SELECT</TT>权限。
所有其它形式的<TT CLASS="COMMAND">LOCK</TT>需要表级别的<TT CLASS="LITERAL">UPDATE</TT>，<TT CLASS="LITERAL">DELETE</TT>
或<TT CLASS="LITERAL">TRUNCATE</TT>权限。</P><P><TT CLASS="COMMAND">LOCK TABLE</TT>在事务块的外部没什么用：锁依然被持有直到声明结束。
因此如果<TT CLASS="COMMAND">LOCK</TT>在一个事务块外面使用，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>会报告一个错误。
使用<A HREF="sql-begin.html">BEGIN</A>和<A HREF="sql-commit.html">COMMIT</A>（或<A HREF="sql-rollback.html">ROLLBACK</A>)
定义一个事务块。</P><P><TT CLASS="COMMAND">LOCK TABLE</TT>只处理表级的锁，因此那些有<TT CLASS="LITERAL">ROW</TT>字样的锁都是用词不当。
这些模式名字通常应该理解为用户试图在一个被锁定的表中获取行级的锁。同样，
<TT CLASS="LITERAL">ROW EXCLUSIVE</TT>模式也是一个可共享的表级锁。一定要记住，
只要是涉及到<TT CLASS="COMMAND">LOCK TABLE</TT>，那么所有锁模式都有相同的语意，
区别只是它们与哪种锁冲突的规则。有关如何获取一个行级锁的信息，请参阅
<A HREF="explicit-locking.html#LOCKING-ROWS">第 13.3.2 &#33410;</A>和<TT CLASS="COMMAND">SELECT</TT>命令参考页的
<A HREF="sql-select.html#SQL-FOR-UPDATE-SHARE"><I>锁定子句</I></A>子句信息。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78422"></A><H2>例子</H2><P>演示在往一个外键表上插入时在有主键的表上使用<TT CLASS="LITERAL">SHARE</TT>的锁：
</P><PRE CLASS="PROGRAMLISTING">BEGIN WORK;
LOCK TABLE films IN SHARE MODE;
SELECT id FROM films
    WHERE name = 'Star Wars: Episode I - The Phantom Menace';
-- 如果记录没有返回则 ROLLBACK 
INSERT INTO films_user_comments VALUES
    (_id_, 'GREAT! I was waiting for it for so long!');
COMMIT WORK;</PRE><P></P><P>在执行删除操作时对一个有主键的表进行<TT CLASS="LITERAL">SHARE ROW EXCLUSIVE</TT>锁：
</P><PRE CLASS="PROGRAMLISTING">BEGIN WORK;
LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM films_user_comments WHERE id IN
    (SELECT id FROM films WHERE rating &lt; 5);
DELETE FROM films WHERE rating &lt; 5;
COMMIT WORK;</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78430"></A><H2>兼容性</H2><P>在 SQL 标准里面没有<TT CLASS="COMMAND">LOCK TABLE</TT>，可以使用<TT CLASS="COMMAND">SET TRANSACTION</TT>
来声明当前事务的级别。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>也支持这个，
参阅<A HREF="sql-set-transaction.html">SET TRANSACTION</A>获取详细信息。</P><P>除了<TT CLASS="LITERAL">ACCESS SHARE</TT>, <TT CLASS="LITERAL">ACCESS EXCLUSIVE</TT>, <TT CLASS="LITERAL">SHARE UPDATE EXCLUSIVE</TT>
锁模式外，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>锁模式和<TT CLASS="COMMAND">LOCK TABLE</TT>
语句都与那些在<SPAN CLASS="PRODUCTNAME">Oracle</SPAN>里面的兼容。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-load.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-move.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">LOAD</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">MOVE</TD></TR></TABLE></DIV></BODY></HTML>
