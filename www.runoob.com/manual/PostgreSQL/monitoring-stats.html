<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>统计收集器</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="监控数据库的活动" HREF="http://school.yunwei.edu/manual/PostgreSQL/monitoring.html"><LINK REL="PREVIOUS" TITLE="标准Unix工具" HREF="monitoring-ps.html"><LINK REL="NEXT" TITLE="查看锁" HREF="monitoring-locks.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/monitoring.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="标准Unix工具" HREF="monitoring-ps.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/monitoring.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 27. 监控数据库的活动</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="查看锁" HREF="monitoring-locks.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="MONITORING-STATS">27.2. 统计收集器</A></H1><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的统计收集器是一个支持收集和报告服务器活跃性信息的子系统。
目前，这个收集器可以给出对表和索引的访问计数，
包括磁盘块的数量和独立行的项。它还跟踪每个表中的行的总数，
每个表的过去的清理和分析时间。它也可以计算用户定义的函数的调用，
以及每个人的总花费的时间。</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>还可以判断当前其它服务器进程正在执行的命令是什么。
这是一个收集过程中的独立设施。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="MONITORING-STATS-SETUP">27.2.1. 统计收集器配置</A></H2><P> 因为统计收集给查询处理增加了一些开销，所以该系统可以配置为启用或禁用统计收集。
这是由配置参数控制的，通常在<TT CLASS="FILENAME">postgresql.conf</TT>里设置
(参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html">第 18 &#31456;</A>获取有关设置配置参数的细节)。</P><P> 参数<A HREF="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES">track_activities</A>启动监测任何服务器进程执行的当前命令。</P><P> 参数<A HREF="runtime-config-statistics.html#GUC-TRACK-COUNTS">track_counts</A>控制关于表和索引是否被统计。</P><P> 参数<A HREF="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS">track_functions</A>实现了对用户定义的函数用法的追踪。</P><P> 参数<A HREF="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</A>启动监控块读写次数。</P><P> 通常这些参数在<TT CLASS="FILENAME">postgresql.conf</TT>中设置，因此它们作用于所有服务器进程，
但是我们也可以在独立的会话里用<A HREF="sql-set.html">SET</A>命令把它们打开或者关闭。
为避免普通用户把它们的活跃性隐藏不给管理员看，
只有超级用户允许用<TT CLASS="COMMAND">SET</TT>命令修改这些参数。 </P><P> 统计收集器通过临时文件将采集到的信息传递给其他的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>进程。
这些文件存放在<A HREF="runtime-config-statistics.html#GUC-STATS-TEMP-DIRECTORY">stats_temp_directory</A>参数命名的目录中。
缺省是<TT CLASS="FILENAME">pg_stat_tmp</TT>。
为了提高性能，<TT CLASS="VARNAME">stats_temp_directory</TT>参数可以指向一个基于RAM的文件系统，
降低物理I/O需求。当服务器关闭时，
统计数据的永久复本存储在<TT CLASS="FILENAME">global</TT>子目录中，
所以统计数据可以在服务器重新启动时保留。 </P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="MONITORING-STATS-VIEWS">27.2.2. 查看收集到的统计信息</A></H2><P> 有一些预定义的视图可以用于显示统计收集的结果，
在<A HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE">&#34920; 27-1</A>里列出。
另外，我们可以使用底层的统计函数制作自定义的视图。
正如<A HREF="monitoring-stats.html#MONITORING-STATS-FUNCTIONS">第 27.2.3 &#33410;</A>中讨论的。</P><P> 在使用统计观察当前活跃性的时候，你必须意识到这些信息并不是实时更新的。
每个独立的服务器进程只是在准备进入空闲状态的时候才向收集器传送新的块和行访问计数；
因此正在处理的查询或者事务并不影响显示出来的总数。同样，
收集器本身也最多每<TT CLASS="VARNAME">PGSTAT_STAT_INTERVAL</TT>毫秒
(缺省500，除非在编译服务器的时候修改过)
发送一次新的报告。因此显示总是落后于实际活动。
但是由<TT CLASS="VARNAME">track_activities</TT>收集的当前查询信息总是实时更新的。</P><P> 另外一个需要着重指出的是，在请求服务器进程显示任何这些统计信息的时候，
它首先抓取收集器进程发出的最新报告，然后就拿这些数据作为所有统计视图和函数的快照，
直到它当前的事务结束。因此统计信息在当前事务的持续期间内显示静态信息。类似的，
每个进程的当前查询信息在该查询首次出现在事务中的时候就被收集了，
并且在整个事务过程中都显示相同的信息。这是一个特性，而不是一个Bug，
因为这样就允许你在统计上执行几个查询并且对结果进行相关性检查而又不用担心这些数字会悄悄的变化。
但是如果你想看每个查询的最新结果，那么就要记住在事务块外面处理这些查询。
另外，你可以调用<CODE CLASS="FUNCTION">pg_stat_clear_snapshot</CODE>()，
这将丢弃目前事务的统计数据快照（如有）。
下次使用统计信息将导致获取一个新的快照。</P><P> 在视图<TT CLASS="STRUCTNAME">pg_stat_xact_all_tables</TT>，
<TT CLASS="STRUCTNAME">pg_stat_xact_sys_tables</TT>，
<TT CLASS="STRUCTNAME">pg_stat_xact_user_tables</TT>和
<TT CLASS="STRUCTNAME">pg_stat_xact_user_functions</TT>上事务也可以看到自己的统计（未传送到收集器）。
这些数字不能作为上面所说的；相反他们在整个事务中不断更新。</P><DIV CLASS="TABLE"><A NAME="MONITORING-STATS-VIEWS-TABLE"></A><P><B>&#34920; 27-1. 标准统计视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>视图名称</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="STRUCTNAME">pg_stat_activity</TT>
</TD><TD>
每个服务器进程一行，显示进程当前活动相关的信息，比如状态和当前查询。
参阅<A HREF="monitoring-stats.html#PG-STAT-ACTIVITY-VIEW">pg_stat_activity</A>获取更多详情。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_bgwriter</TT></TD><TD> 只有一行，显示关于后端写进程活动的统计信息。参阅<A HREF="monitoring-stats.html#PG-STAT-BGWRITER-VIEW">pg_stat_bgwriter</A>
获取更多详细信息。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_database</TT></TD><TD> 每个数据库一行，显示数据库广泛的统计。参阅<A HREF="monitoring-stats.html#PG-STAT-DATABASE-VIEW">pg_stat_database</A>获取更多详情。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_all_tables</TT></TD><TD>
当前数据库每个表一行，显示关于访问特定表的统计。参阅<A HREF="monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW">pg_stat_all_tables</A>
获取更多详细信息。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_sys_tables</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_stat_all_tables</TT>一样，除了只显示系统表之外。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_user_tables</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_stat_all_tables</TT>一样，除了只显示用户表。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_xact_all_tables</TT></TD><TD>类似<TT CLASS="STRUCTNAME">pg_stat_all_tables</TT>，
但是到目前为止当前事务中计算采取的行动
（这<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不</I></SPAN>包含在<TT CLASS="STRUCTNAME">pg_stat_all_tables</TT>中以及相关视图中。）
活的列数以及死行和清理以及分析操作不在此视图中出现。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_xact_sys_tables</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_stat_xact_all_tables</TT>相同，除了只显示系统表。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_xact_user_tables</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_stat_xact_all_tables</TT>相同，除了只显示用户表。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_all_indexes</TT></TD><TD>
当前数据库中的每个索引的每一行，显示关于访问特定索引的统计。
参见<A HREF="monitoring-stats.html#PG-STAT-ALL-INDEXES-VIEW">pg_stat_all_indexes</A>获取更多详情。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_sys_indexes</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_stat_all_indexes</TT>一样，但只显示系统表上的索引。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_user_indexes</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_stat_all_indexes</TT>一样，但只显示用户表上的索引。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_all_tables</TT></TD><TD>
当前数据库每个表一行，显示特定表关于I/O的统计，
参阅<A HREF="monitoring-stats.html#PG-STATIO-ALL-TABLES-VIEW">pg_statio_all_tables</A>
获取更多细节。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_sys_tables</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_statio_all_tables</TT>一样，但只显示系统表</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_user_tables</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_statio_all_tables</TT>一样，但只显示用户表。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_all_indexes</TT></TD><TD>
当前数据库每个索引一行，显示特定索引关于I/O的统计。
参阅<A HREF="monitoring-stats.html#PG-STATIO-ALL-INDEXES-VIEW">pg_statio_all_indexes</A>获取更多细节。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_sys_indexes</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_statio_all_indexes</TT>一样的，但是只显示系统表上的索引。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_user_indexes</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_statio_all_indexes</TT>一样，但只显示用户表上的索引。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_all_sequences</TT></TD><TD>
当前数据库每个序列一行，显示特定序列关于I/O的统计。参阅
<A HREF="monitoring-stats.html#PG-STATIO-ALL-SEQUENCES-VIEW">pg_statio_all_sequences</A>获取更多细节。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_sys_sequences</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_statio_all_sequences</TT>一样，
但只显示系统序列。因为目前没有定义系统序列，所以这个视图总是空的。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_statio_user_sequences</TT></TD><TD>和<TT CLASS="STRUCTNAME">pg_statio_all_sequences</TT>一样，但只显示用户序列。</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_user_functions</TT></TD><TD>
每一个跟踪函数一行，显示关于执行这个函数的统计。
参阅<A HREF="monitoring-stats.html#PG-STAT-USER-FUNCTIONS-VIEW">pg_stat_user_functions</A>
获取更多详情。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_xact_user_functions</TT></TD><TD> 类似于<TT CLASS="STRUCTNAME">pg_stat_user_functions</TT>，但是在当前事务中只调用计数
（这不包含在<TT CLASS="STRUCTNAME">pg_stat_user_functions</TT>中）。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_replication</TT></TD><TD> 每WAL发送进程一行，显示关于复制到发送端的链接备用服务器的统计信息。
参阅<A HREF="monitoring-stats.html#PG-STAT-REPLICATION-VIEW">pg_stat_replication</A>获取更多细节。
</TD></TR><TR><TD><TT CLASS="STRUCTNAME">pg_stat_database_conflicts</TT></TD><TD>
每个数据库一行，显示关于备用服务器恢复冲突取消查询的统计信息。
参阅<A HREF="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW">pg_stat_database_conflicts</A>获取更多信息。
</TD></TR></TBODY></TABLE></DIV><P> 针对每个索引的统计有利于判断哪个索引得到使用以及它们的效果。</P><P> <TT CLASS="STRUCTNAME">pg_statio_</TT>视图有利于决定缓冲区高速缓存的有效性。
当实际的磁盘数读取比缓冲区的数目小得多的时候，
然后缓存满足大多数读请求而没有调用内核调用。
然而，这些统计数据不提供整个过程：由于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
处理磁盘I/O的方式，不在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>缓冲区缓存中的数据可能仍然位于
内核I/O缓存中，因此可能仍然被取出而不需要物理读。
对获得更多<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的I/O行为的详细信息感兴趣的用户
建议使用与操作系统工具结合的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>统计收集，
允许洞察I/O的内核处理。</P><DIV CLASS="TABLE"><A NAME="PG-STAT-ACTIVITY-VIEW"></A><P><B>&#34920; 27-2. <TT CLASS="STRUCTNAME">pg_stat_activity</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">datid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>连接后端的数据库OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">datname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>连接后端的数据库名称</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">pid</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>后端进程ID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">usesysid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>登陆后端的用户OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">usename</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>登陆到该后端的用户名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">application_name</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>连接到后端的应用名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">client_addr</TT></TD><TD><TT CLASS="TYPE">inet</TT></TD><TD>连接到后端的客户端的IP地址。
如果此字段是null，
它表明通过服务器机器上UNIX套接字连接客户端或者这是内部进程如autovacuum</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">client_hostname</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>连接客户端的主机名，通过<TT CLASS="STRUCTFIELD">client_addr</TT>的反向DNS查找报告。
这个字段将只是非空的IP连接，并且仅仅当启动<A HREF="runtime-config-logging.html#GUC-LOG-HOSTNAME">log_hostname</A>的时候。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">client_port</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>客户端用于与后端通讯的TCP端口号，或者如果使用Unix套接字，则为<TT CLASS="LITERAL">-1</TT>。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">backend_start</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>该过程开始的时间，比如当客户端连接服务器时。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">xact_start</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>启动当前事务的时间，如果没有事务是活的，则为null。如果当前查询是
首个事务，则这列等同于<TT CLASS="STRUCTFIELD">query_start</TT>列。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">query_start</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>开始当前活跃查询的时间，
或者如果<TT CLASS="STRUCTFIELD">state</TT>是非<TT CLASS="LITERAL">活跃的</TT>，
当开始最后查询时。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">state_change</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>上次<TT CLASS="STRUCTFIELD">状态</TT>改变的时间</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">waiting</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>如果后端当前正等待锁则为真</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">state</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>
该后端当前总体状态。可能值是：
<P></P><UL><LI><P>
<TT CLASS="LITERAL">活跃的</TT>:后端正在执行一个查询。
</P></LI><LI><P>
<TT CLASS="LITERAL">空闲的</TT>:后端正在等待一个新的客户端命令。
</P></LI><LI><P>
<TT CLASS="LITERAL">空闲事务</TT>：后端在事务中，但是目前无法执行查询。
</P></LI><LI><P>
<TT CLASS="LITERAL">空闲事务(被终止)</TT>:这个情况类似于<TT CLASS="LITERAL">空闲事务</TT>，除了事务导致错误的一个语句之一。
</P></LI><LI><P>
<TT CLASS="LITERAL">快速路径函数调用</TT>:后端正在执行一个快速路径函数。
</P></LI><LI><P>
<TT CLASS="LITERAL">禁用</TT>:如果后端禁用<A HREF="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES">track_activities</A>，则报告这个状态。
</P></LI></UL>
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">query</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>该后端的最新查询文本。如果<TT CLASS="STRUCTFIELD">状态</TT>是<TT CLASS="LITERAL">活跃的</TT>,
此字段显示当前正在执行的查询。在所有其他情况中，这表明执行过去的查询。
</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_activity</TT>每个服务器进程有一行，显示进程当前活动的相关信息。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> <TT CLASS="STRUCTFIELD">waiting</TT>和<TT CLASS="STRUCTFIELD">state</TT>列是独立的。
如果一个后端处于<TT CLASS="LITERAL">活跃</TT>状态，它可能会或可能不会<TT CLASS="LITERAL">waiting</TT>。
如果这种情况是<TT CLASS="LITERAL">活跃的</TT>并且<TT CLASS="STRUCTFIELD">waiting</TT>是真，
它意味着正在执行一个查询，但在该系统中的某个地方被锁阻塞。</P></BLOCKQUOTE></DIV><DIV CLASS="TABLE"><A NAME="PG-STAT-BGWRITER-VIEW"></A><P><B>&#34920; 27-3. <TT CLASS="STRUCTNAME">pg_stat_bgwriter</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">checkpoints_timed</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>执行的定期检查点数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">checkpoints_req</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>执行的需求检查点数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">checkpoint_write_time</TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>
花费在检查点处理部分的时间总量，其中文件被写入到磁盘，以毫秒为单位。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">checkpoint_sync_time</TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>
花费在检查点处理部分的时间总量，其中文件被同步到磁盘，以毫秒为单位。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">buffers_checkpoint</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>检查点写缓冲区数量</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">buffers_clean</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>后端写进程写缓冲区数量</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">maxwritten_clean</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>后端写进程停止清理扫描时间数，因为它写了太多缓冲区</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">buffers_backend</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过后端直接写缓冲区数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">buffers_backend_fsync</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>
后端不得不执行自己的<CODE CLASS="FUNCTION">fsync</CODE>调用的时间数
（通常后端写进程处理这些即使后端确实自己写）
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">buffers_alloc</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>分配的缓冲区数量</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">stats_reset</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>这些统计被重置的时间</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_bgwriter</TT>视图总是有独立行，包含集群的全局数据。</P><DIV CLASS="TABLE"><A NAME="PG-STAT-DATABASE-VIEW"></A><P><B>&#34920; 27-4. <TT CLASS="STRUCTNAME">pg_stat_database</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">datid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>数据库的OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">datname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>这个数据库的名字</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">numbackends</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>当前连接到该数据库的后端数。
这是在返回一个反映目前状态值的视图中唯一的列；自
上次重置所有其他列返回累积值。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">xact_commit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此数据库中已经提交的事务数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">xact_rollback</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此数据库中已经回滚的事务数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">blks_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>在这个数据库中读取的磁盘块的数量</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">blks_hit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>高速缓存中已经发现的磁盘块的次数，
这样读取是不必要的（这只包括PostgreSQL缓冲区高速缓存，没有操作系统的文件系统缓存。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tup_returned</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过数据库查询返回的行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tup_fetched</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过数据库查询抓取的行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tup_inserted</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过数据库查询插入的行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tup_updated</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过数据库查询更新的行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tup_deleted</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过数据库查询删除的行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">conflicts</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>由于数据库恢复冲突取消的查询数量。（只在备用服务器发生的冲突）；参阅
<A HREF="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW">pg_stat_database_conflicts</A>获取更多信息。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">temp_files</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD> 通过数据库查询创建的临时文件数量。计算所有临时文件，
不论为什么创建临时文件（比如排序或者哈希），
而且不管<A HREF="runtime-config-logging.html#GUC-LOG-TEMP-FILES">log_temp_files</A>设置。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">temp_bytes</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过数据库查询写入临时文件的数据总量。计算所有临时文件，
不论为什么创建临时文件，
而且不管<A HREF="runtime-config-logging.html#GUC-LOG-TEMP-FILES">log_temp_files</A>设置</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">deadlocks</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>在该数据库中检索的死锁数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">blk_read_time</TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>通过数据库后端读取数据文件块花费的时间，以毫秒计算。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">blk_write_time</TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>通过数据库后端写入数据文件块花费的时间，以毫秒计算。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">stats_reset</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>这些统计最后被重置的时间</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_database</TT>视图将包含集群中每个数据库的每一行，
显示数据库统计。</P><DIV CLASS="TABLE"><A NAME="PG-STAT-ALL-TABLES-VIEW"></A><P><B>&#34920; 27-5. <TT CLASS="STRUCTNAME">pg_stat_all_tables</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">relid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>表的OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">schemaname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>此表的模式名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">relname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>表名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">seq_scan</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此表发起的顺序扫描数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">seq_tup_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>顺序扫描抓取的活跃行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_scan</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此表发起的索引扫描数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_tup_fetch</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>索引扫描抓取的活跃行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">n_tup_ins</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>插入行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">n_tup_upd</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>更新行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">n_tup_del</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>删除行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">n_tup_hot_upd</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>HOT更新行数（比如没有更新所需的单独索引）</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">n_live_tup</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>估计活跃行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">n_dead_tup</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>估计死行数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">last_vacuum</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>最后一次此表是手动清理的（不计算<TT CLASS="COMMAND">VACUUM FULL</TT>）</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">last_autovacuum</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>上次被autovacuum守护进程清理的表</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">last_analyze</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>上次手动分析这个表</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">last_autoanalyze</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>上次被autovacuum守护进程分析的表</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">vacuum_count</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>这个表被手动清理的次数（不计算<TT CLASS="COMMAND">VACUUM FULL</TT>）</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">autovacuum_count</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>这个表被autovacuum清理的次数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">analyze_count</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>这个表被手动分析的次数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">autoanalyze_count</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>这个表被autovacuum守护进程分析的次数</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_all_tables</TT>视图将包含
当前数据库中每个表的一行（包括TOAST表），显示访问特定表的统计信息。
<TT CLASS="STRUCTNAME">pg_stat_user_tables</TT>和
<TT CLASS="STRUCTNAME">pg_stat_sys_tables</TT>视图
包含相同的信息，但是过滤只分别显示用户和系统表。</P><DIV CLASS="TABLE"><A NAME="PG-STAT-ALL-INDEXES-VIEW"></A><P><B>&#34920; 27-6. <TT CLASS="STRUCTNAME">pg_stat_all_indexes</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">relid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>这个索引的表的OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">indexrelid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>索引的OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">schemaname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>索引中模式名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">relname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>索引的表名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">indexrelname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>索引名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_scan</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>索引上开始的索引扫描数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_tup_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过索引上扫描返回的索引项数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_tup_fetch</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>通过使用索引的简单索引扫描抓取的活表行数</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_all_indexes</TT>视图将包含
当前数据库中的每个索引行，显示访问特定索引的统计。
<TT CLASS="STRUCTNAME">pg_stat_user_indexes</TT>和
<TT CLASS="STRUCTNAME">pg_stat_sys_indexes</TT>视图包含相同的信息，
但是过滤只是分别显示用户和系统索引。</P><P> 索引可以通过简单的索引扫描或<SPAN CLASS="QUOTE">"位图"</SPAN>索引扫描进行使用。位图扫描中
几个索引的输出可以通过AND或者OR规则进行组合，
因此当使用位图扫描的时候，很难将独立堆行抓取与特定索引进行组合，
因此，一个位图扫描增加<TT CLASS="STRUCTNAME">pg_stat_all_indexes</TT>.<TT CLASS="STRUCTFIELD">idx_tup_read</TT>
使用索引计数，并且增加<TT CLASS="STRUCTNAME">pg_stat_all_tables</TT>.<TT CLASS="STRUCTFIELD">idx_tup_fetch</TT>
表计数，但不影响<TT CLASS="STRUCTNAME">pg_stat_all_indexes</TT>.<TT CLASS="STRUCTFIELD">idx_tup_fetch</TT>。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> <TT CLASS="STRUCTFIELD">idx_tup_read</TT>和<TT CLASS="STRUCTFIELD">idx_tup_fetch</TT>计算不同甚至没有任何可使用的位图扫描。
因为<TT CLASS="STRUCTFIELD">idx_tup_read</TT>计算从索引检索的索引项而<TT CLASS="STRUCTFIELD">idx_tup_fetch</TT>
计算从表抓取的活的行。如果任何死的或尚未提交的行使用索引进行抓取，
或通过唯一索引扫描避免任何堆抓取，则后者较小。</P></BLOCKQUOTE></DIV><DIV CLASS="TABLE"><A NAME="PG-STATIO-ALL-TABLES-VIEW"></A><P><B>&#34920; 27-7. <TT CLASS="STRUCTNAME">pg_statio_all_tables</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">relid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>表OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">schemaname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>该表模式名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">relname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>表名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">heap_blks_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>从该表中读取的磁盘块数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">heap_blks_hit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此表缓存命中数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_blks_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>从表中所有索引读取的磁盘块数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_blks_hit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>表中所有索引命中缓存数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">toast_blks_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此表的TOAST表读取的磁盘块数（如果存在）</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">toast_blks_hit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此表的TOAST表命中缓冲区数（如果存在）</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tidx_blks_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此表的TOAST表索引读取的磁盘块数（如果存在）</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">tidx_blks_hit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>此表的TOAST表索引命中缓冲区数（如果存在）</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_statio_all_tables</TT>视图将包含
当前数据库中每个表的一行（包括TOAST表），
显示出特定表I/O的统计。<TT CLASS="STRUCTNAME">pg_statio_user_tables</TT>和
<TT CLASS="STRUCTNAME">pg_statio_sys_tables</TT>视图包含相同的信息，
但是过滤分别只显示用户和系统表。</P><DIV CLASS="TABLE"><A NAME="PG-STATIO-ALL-INDEXES-VIEW"></A><P><B>&#34920; 27-8. <TT CLASS="STRUCTNAME">pg_statio_all_indexes</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">relid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>索引的表的OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">indexrelid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>该索引的OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">schemaname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>该索引的模式名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">relname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>该索引的表名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">indexrelname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>索引名称</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_blks_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>从索引中读取的磁盘块数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">idx_blks_hit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>索引命中缓存数</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_statio_all_indexes</TT>视图将包含当前数据库中的每个索引行，
显示特定索引的I/O的统计。<TT CLASS="STRUCTNAME">pg_statio_user_indexes</TT>和
<TT CLASS="STRUCTNAME">pg_statio_sys_indexes</TT>视图包含相同的信息，
但是过滤分别只显示用户和系统索引。</P><DIV CLASS="TABLE"><A NAME="PG-STATIO-ALL-SEQUENCES-VIEW"></A><P><B>&#34920; 27-9. <TT CLASS="STRUCTNAME">pg_statio_all_sequences</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">relid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>序列OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">schemaname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>序列中模式名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">relname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>序列名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">blks_read</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>从序列中读取的磁盘块数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">blks_hit</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>序列中缓存命中数</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_statio_all_sequences</TT>视图包含当前数据库中每个序列的每一行，
显示特定序列关于I/O的统计。</P><DIV CLASS="TABLE"><A NAME="PG-STAT-USER-FUNCTIONS-VIEW"></A><P><B>&#34920; 27-10. <TT CLASS="STRUCTNAME">pg_stat_user_functions</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">funcid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>函数OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">schemaname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>此函数中的模式名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">funcname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>函数名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">calls</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>被调用的函数次数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">total_time</TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>在这个函数以及调用的其他函数的总时间，以毫秒为单位。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">self_time</TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>在这个函数本身上用的总时间，不包含调用其他函数的，以毫秒为单位</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_user_functions</TT>视图包含每个跟踪函数的行，显示关于函数执行的统计。
<A HREF="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS">track_functions</A>参数控制真正跟踪的函数。</P><DIV CLASS="TABLE"><A NAME="PG-STAT-REPLICATION-VIEW"></A><P><B>&#34920; 27-11. <TT CLASS="STRUCTNAME">pg_stat_replication</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">pid</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>WAL发送进程的ID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">usesysid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>登陆到这个WAL发送进程的用户OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">usename</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>登陆到WAL发送进程的用户名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">application_name</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>连接到这个WAL发送端的应用名</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">client_addr</TT></TD><TD><TT CLASS="TYPE">inet</TT></TD><TD>客户端连接到这个WAL发送端的IP地址，如果这个字段为null，它表明通过
服务器上Unix套接字连接客户端。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">client_hostname</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>连接客户端的主机名，通过<TT CLASS="STRUCTFIELD">client_addr</TT>的反向DNS查找报告。
并且当启用<A HREF="runtime-config-logging.html#GUC-LOG-HOSTNAME">log_hostname</A>时，这个字段对于IP连接是非空的。
</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">client_port</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>客户端正在使用与WAL发送端连接的TCP端口号，或者如果使用Unix套接字则为<TT CLASS="LITERAL">-1</TT>。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">backend_start</TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>这个进程开始时的时间，比如当客户端连接到这个WAL发送端时。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">state</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>当前WAL发送端状态</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">sent_location</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>在这次连接上发送的上次事务日志位置</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">write_location</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>通过备用服务器写入到磁盘的上次事务日志位置。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">flush_location</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>通过备用服务器刷新到磁盘的上次事务日志位置。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">replay_location</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>备用服务器上重播到数据库的上次事务日志位置。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">sync_priority</TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>这个备用服务器被选为同步备用的优先级。</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">sync_state</TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>该备用服务器的同步状态</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_replication</TT>视图包含每个WAL发送进程的每一行，
显示发送端连接备用服务器有关复制的统计。列出只直接连接的备用；
没有可用的下游备用服务器的信息。 </P><DIV CLASS="TABLE"><A NAME="PG-STAT-DATABASE-CONFLICTS-VIEW"></A><P><B>&#34920; 27-12. <TT CLASS="STRUCTNAME">pg_stat_database_conflicts</TT>视图</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>列</TH><TH>类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="STRUCTFIELD">datid</TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>数据库的OID</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">datname</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>数据库名称</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">confl_tablespace</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>由于删除的表空间，已经取消的数据库中的查询数量</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">confl_lock</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>由于锁超时，已经取消的数据库中的查询数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">confl_snapshot</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>由于旧快照，已经取消的数据库查询数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">confl_bufferpin</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>由于保留区而取消的数据库查询数</TD></TR><TR><TD><TT CLASS="STRUCTFIELD">confl_deadlock</TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>由于死锁已经被取消的数据库中的查询数</TD></TR></TBODY></TABLE></DIV><P> <TT CLASS="STRUCTNAME">pg_stat_database_conflicts</TT>视图将包含
每个数据库的一行，显示由于备用服务器恢复发生的冲突而取消查询的数据库范围统计信息。
这种视图将只包含备用服务器的信息，因为在主服务器上不会发生冲突。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="MONITORING-STATS-FUNCTIONS">27.2.3. 统计函数</A></H2><P> 查看统计的其他方式可以通过写查询设置，它使用相同的底层统计访问功能用于
上面显示的标准视图。函数名称的详细信息，请参考标准的视图定义。（例如，
在<SPAN CLASS="APPLICATION">psql</SPAN>中你可以发出<TT CLASS="LITERAL">\d+ pg_stat_activity</TT>。）
每个数据库统计的访问函数以数据库OID作为参数识别报告给数据库。
每个表和索引函数看成表或索引的OID。每个函数统计采取一个函数OID。
请注意，只有当前数据库中的表，索引，和函数可以看出这些功能。</P><P> 统计收集相关的附加函数列在<A HREF="monitoring-stats.html#MONITORING-STATS-FUNCS-TABLE">&#34920; 27-13</A>中。</P><DIV CLASS="TABLE"><A NAME="MONITORING-STATS-FUNCS-TABLE"></A><P><B>&#34920; 27-13. 附加统计函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_backend_pid()</CODE></TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>
服务器进程处理当前会话的进程ID
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_activity</CODE>(<TT CLASS="TYPE">integer</TT>)</TT></TD><TD><TT CLASS="TYPE">setof record</TT></TD><TD>
如果声明为<TT CLASS="SYMBOL">NULL</TT>，则返回特定PID后端信息记录，或者系统中每个活动后端的记录。
返回的字段是<TT CLASS="STRUCTNAME">pg_stat_activity</TT>视图中的子集。
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_clear_snapshot()</CODE></TT></TD><TD><TT CLASS="TYPE">void</TT></TD><TD> 丢弃当前数据库快照
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_reset()</CODE></TT></TD><TD><TT CLASS="TYPE">void</TT></TD><TD>
所有当前数据库统计计数器重置为零（需要超级用户权限）
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_reset_shared</CODE>(text)</TT></TD><TD><TT CLASS="TYPE">void</TT></TD><TD>
重置一些集群范围统计计数为零，依赖于参数（需要超级用户权限）。
所有显示在<TT CLASS="STRUCTNAME">pg_stat_bgwriter</TT>视图中的计数器调用<TT CLASS="LITERAL">pg_stat_reset_shared('bgwriter')</TT>将归零。
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_reset_single_table_counters</CODE>(oid)</TT></TD><TD><TT CLASS="TYPE">void</TT></TD><TD>
为当前数据库中单一表或者索引重置统计为零（需要超级用户权限）
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_reset_single_function_counters</CODE>(oid)</TT></TD><TD><TT CLASS="TYPE">void</TT></TD><TD>
当前数据库中单一功能重置统计为零（需要超级用户权限）
</TD></TR></TBODY></TABLE></DIV><P>
<CODE CLASS="FUNCTION">pg_stat_get_activity</CODE>，<TT CLASS="STRUCTNAME">pg_stat_activity</TT>视图的基本功能返回
包含每个后端进程的所有可用信息的记录集。有时获取这些信息的子集更方便。
在这种情况下，可以使用每个后端统计访问函数的旧设置。这些都显示在
<A HREF="monitoring-stats.html#MONITORING-STATS-BACKEND-FUNCS-TABLE">&#34920; 27-14</A>中。这些访问函数使用后端ID号，
其范围从一到当前活动后端数。
函数<CODE CLASS="FUNCTION">pg_stat_get_backend_idset</CODE>提供便利方式产生调用这些函数的每个活动后端的每一行。
比如，显示<ACRONYM CLASS="ACRONYM">PID</ACRONYM>以及所有后端的当前查询：
</P><PRE CLASS="PROGRAMLISTING">SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;</PRE><P>
</P><DIV CLASS="TABLE"><A NAME="MONITORING-STATS-BACKEND-FUNCS-TABLE"></A><P><B>&#34920; 27-14. 每个后端统计函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_idset()</CODE></TT></TD><TD><TT CLASS="TYPE">setof integer</TT></TD><TD>设置当前活动的后端ID号（从1到活动后端数）</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_activity(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>后端最近查询文本</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_activity_start(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>最近查询开始时间</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_client_addr(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">inet</TT></TD><TD>连接后端的客户端IP地址</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_client_port(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>客户端用于通讯的TCP端口号</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_dbid(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>连接后端的数据库OID</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_pid(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">integer</TT></TD><TD>后端进程ID</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_start(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>进程开始时间</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_userid(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>登陆到后端的用户OID</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_waiting(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>如果后端正等待锁则为真</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_stat_get_backend_xact_start(integer)</CODE></TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>当前事务的开始时间</TD></TR></TBODY></TABLE></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="monitoring-ps.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="monitoring-locks.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">标准Unix工具</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/monitoring.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">查看锁</TD></TR></TABLE></DIV></BODY></HTML>
