<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>BKI 命令</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="BKI后端接口" HREF="http://school.yunwei.edu/manual/PostgreSQL/bki.html"><LINK REL="PREVIOUS" TITLE="BKI 文件格式" HREF="bki-format.html"><LINK REL="NEXT" TITLE="系统初始化的BKI文件的结构" HREF="bki-structure.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/bki.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="BKI 文件格式" HREF="bki-format.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/bki.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 59. <ACRONYM CLASS="ACRONYM">BKI</ACRONYM>后端接口</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="系统初始化的BKI文件的结构" HREF="bki-structure.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="BKI-COMMANDS">59.2. <ACRONYM CLASS="ACRONYM">BKI</ACRONYM> 命令</A></H1><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">create</TT>
<TT CLASS="REPLACEABLE"><I>tablename</I></TT>
<TT CLASS="REPLACEABLE"><I>tableoid</I></TT>
[<SPAN CLASS="OPTIONAL"><TT CLASS="LITERAL">bootstrap</TT></SPAN>]
[<SPAN CLASS="OPTIONAL"><TT CLASS="LITERAL">shared_relation</TT></SPAN>]
[<SPAN CLASS="OPTIONAL"><TT CLASS="LITERAL">without_oids</TT></SPAN>]
[<SPAN CLASS="OPTIONAL"><TT CLASS="LITERAL">rowtype_oid</TT> <TT CLASS="REPLACEABLE"><I>oid</I></TT></SPAN>]
(<TT CLASS="REPLACEABLE"><I>name1</I></TT> =
<TT CLASS="REPLACEABLE"><I>type1</I></TT> [<SPAN CLASS="OPTIONAL">,
<TT CLASS="REPLACEABLE"><I>name2</I></TT> = <TT CLASS="REPLACEABLE"><I>type2</I></TT>, ...</SPAN>])</DT><DD><P>创建一个名为<TT CLASS="REPLACEABLE"><I>tablename</I></TT>并且 OID 为
<TT CLASS="REPLACEABLE"><I>tableoid</I></TT>的表，表字段在圆括弧中给出。</P><P><TT CLASS="FILENAME">bootstrap.c</TT>直接支持下列字段类型：<TT CLASS="TYPE">bool</TT>,<TT CLASS="TYPE">bytea</TT>, <TT CLASS="TYPE">char</TT> (1 字节),
<TT CLASS="TYPE">name</TT>, <TT CLASS="TYPE">int2</TT>,<TT CLASS="TYPE">int4</TT>, <TT CLASS="TYPE">regproc</TT>, <TT CLASS="TYPE">regclass</TT>,
<TT CLASS="TYPE">regtype</TT>, <TT CLASS="TYPE">text</TT>,<TT CLASS="TYPE">oid</TT>, <TT CLASS="TYPE">tid</TT>, <TT CLASS="TYPE">xid</TT>,
<TT CLASS="TYPE">cid</TT>, <TT CLASS="TYPE">int2vector</TT>, <TT CLASS="TYPE">oidvector</TT>, <TT CLASS="TYPE">_int4</TT>(数组),
<TT CLASS="TYPE">_text</TT>(数组),<TT CLASS="TYPE">_oid</TT>(数组),<TT CLASS="TYPE">_char</TT>(数组),<TT CLASS="TYPE">_aclitem</TT>(数组)。
尽管可以创建包含其它类型字段的表，但是只有在创建完<TT CLASS="STRUCTNAME">pg_type</TT>并且填充了合适的记录之后才行。
这实际上就意味着在系统初始化表中，只能使用这些字段类型，而非系统初始化表可以使用任意内置类型。</P><P>如果声明了<TT CLASS="LITERAL">bootstrap</TT>，那么将只在磁盘上创建表；不会向<TT CLASS="STRUCTNAME">pg_class</TT>,
<TT CLASS="STRUCTNAME">pg_attribute</TT>等系统表里输入任何东西。因此这样的表将无法被普通的 SQL 操作访问，
直到那些记录用硬办法(用<TT CLASS="LITERAL">insert</TT>命令)填入。这个选项用于创建<TT CLASS="STRUCTNAME">pg_class</TT>等自身。</P><P>如果声明了<TT CLASS="LITERAL">shared_relation</TT>，那么表就作为共享表创建。除非声明了<TT CLASS="LITERAL">without_oids</TT>，
否则将会有 OID 。表的行类型OID（(<TT CLASS="STRUCTNAME">pg_type</TT> OID）可以可选的通过<TT CLASS="LITERAL">rowtype_oid</TT>
子句声明；如果没有声明，会自动为表生成一个OID。（如果声明了<TT CLASS="LITERAL">bootstrap</TT>，那么
<TT CLASS="LITERAL">rowtype_oid</TT>子句是没有用的，但是它可以在文档中给出。）</P></DD><DT><TT CLASS="LITERAL">open</TT> <TT CLASS="REPLACEABLE"><I>tablename</I></TT></DT><DD><P>打开一个名为<TT CLASS="REPLACEABLE"><I>tablename</I></TT>的表，准备插入数据。
任何当前已经打开的表都会被关闭。</P></DD><DT><TT CLASS="LITERAL">close</TT> [<SPAN CLASS="OPTIONAL"><TT CLASS="REPLACEABLE"><I>tablename</I></TT></SPAN>]</DT><DD><P>关闭打开的表。给出的表名用于交叉检查，并不是必须的。</P></DD><DT><TT CLASS="LITERAL">insert</TT> [<SPAN CLASS="OPTIONAL"><TT CLASS="LITERAL">OID =</TT> <TT CLASS="REPLACEABLE"><I>oid_value</I></TT></SPAN>] <TT CLASS="LITERAL">(</TT> <TT CLASS="REPLACEABLE"><I>value1</I></TT> <TT CLASS="REPLACEABLE"><I>value2</I></TT> ... <TT CLASS="LITERAL">)</TT></DT><DD><P>如果<TT CLASS="REPLACEABLE"><I>oid_value</I></TT>为零，那么用
<TT CLASS="REPLACEABLE"><I>value1</I></TT>,
<TT CLASS="REPLACEABLE"><I>value2</I></TT>等作为字段值以及
<TT CLASS="REPLACEABLE"><I>oid_value</I></TT>作为其 OID(对象标识)向打开的表插入一条新记录，
否则省略子句，而表则拥有 OID ，并赋予下一个可用的 OID 数值。</P><P>NULL 可以用特殊的关键字<TT CLASS="LITERAL">_null_</TT>声明。包含空白的值必须用双引号栝起。</P></DD><DT><TT CLASS="LITERAL">declare</TT> [<SPAN CLASS="OPTIONAL"><TT CLASS="LITERAL">unique</TT></SPAN>]
<TT CLASS="LITERAL">index</TT> <TT CLASS="REPLACEABLE"><I>indexname</I></TT>
<TT CLASS="REPLACEABLE"><I>indexoid</I></TT>
<TT CLASS="LITERAL">on</TT> <TT CLASS="REPLACEABLE"><I>tablename</I></TT>
<TT CLASS="LITERAL">using</TT> <TT CLASS="REPLACEABLE"><I>amname</I></TT>
<TT CLASS="LITERAL">(</TT> <TT CLASS="REPLACEABLE"><I>opclass1</I></TT>
<TT CLASS="REPLACEABLE"><I>name1</I></TT>
[<SPAN CLASS="OPTIONAL">, ...</SPAN>] <TT CLASS="LITERAL">)</TT></DT><DD><P>在一个叫<TT CLASS="REPLACEABLE"><I>tablename</I></TT>的表上用
<TT CLASS="REPLACEABLE"><I>amname</I></TT>访问方法创建一个 OID 是
<TT CLASS="REPLACEABLE"><I>indexoid</I></TT>的叫做
<TT CLASS="REPLACEABLE"><I>indexname</I></TT>的索引。索引的字段为
<TT CLASS="REPLACEABLE"><I>name1</I></TT>, <TT CLASS="REPLACEABLE"><I>name2</I></TT>
等，而使用的操作符类分别是<TT CLASS="REPLACEABLE"><I>opclass1</I></TT>,
<TT CLASS="REPLACEABLE"><I>opclass2</I></TT>等。将会创建索引文件和恰当的系统表记录，
但是索引内容不会由此命令初始化。</P></DD><DT><TT CLASS="LITERAL">declare toast</TT>
<TT CLASS="REPLACEABLE"><I>toasttableoid</I></TT>
<TT CLASS="REPLACEABLE"><I>toastindexoid</I></TT>
<TT CLASS="LITERAL">on</TT> <TT CLASS="REPLACEABLE"><I>tablename</I></TT></DT><DD><P>为名为<TT CLASS="REPLACEABLE"><I>tablename</I></TT>的表创建一个 TOAST 表。
这个 TOAST 的 OID 是<TT CLASS="REPLACEABLE"><I>toasttableoid</I></TT>，
其索引的 OID 是<TT CLASS="REPLACEABLE"><I>toastindexoid</I></TT>。
与<TT CLASS="LITERAL">declare index</TT>一样，索引的填充会被推迟。</P></DD><DT><TT CLASS="LITERAL">build indices</TT></DT><DD><P>填充前面声明的索引。</P></DD></DL></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="bki-format.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="bki-structure.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><ACRONYM CLASS="ACRONYM">BKI</ACRONYM> 文件格式</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/bki.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">系统初始化的<ACRONYM CLASS="ACRONYM">BKI</ACRONYM>文件的结构</TD></TR></TABLE></DIV></BODY></HTML>
