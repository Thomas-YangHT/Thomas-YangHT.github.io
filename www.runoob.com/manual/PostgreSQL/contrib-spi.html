<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>spi</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="sepgsql" HREF="sepgsql.html"><LINK REL="NEXT" TITLE="sslinfo" HREF="sslinfo.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/contrib-spi.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="sepgsql" HREF="sepgsql.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="sslinfo" HREF="sslinfo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="CONTRIB-SPI">F.34. spi</A></H1><P><SPAN CLASS="APPLICATION">spi</SPAN>模块提供几个使用SPI和触发器的可行的示例。
当这些函数是它们自己正确的某些值时，它们对于你自己的目的是更有用的修改的例子。
该函数一般足够任意的表使用，但是你在创建一个触发器时必须指定表和字段名（正如下面描述）。</P><P>下面描述的每一组函数都是作为一个独立可安装的扩展提供的。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN150288">F.34.1. refint &mdash; 实现参照完整性的函数</A></H2><P><CODE CLASS="FUNCTION">check_primary_key()</CODE>和<CODE CLASS="FUNCTION">check_foreign_key()</CODE>
用来检查外键约束。（这个功能早已被内置的外键机制取代，但是该模块作为一个例子仍然是有用的。）</P><P><CODE CLASS="FUNCTION">check_primary_key()</CODE>检查引用表。为了使用该函数，创建一个
<TT CLASS="LITERAL">BEFORE INSERT OR UPDATE</TT>触发器，该触发器在一个表上使用这个函数引用另一个表。
作为触发器参数指定：来自外键的引用表的字段名，被引用的表名，来自主/唯一键的被引用表的字段名。
要处理多个外键，为每个引用创建一个外键。</P><P><CODE CLASS="FUNCTION">check_foreign_key()</CODE>检查被引用的表。为了使用该函数，创建一个
<TT CLASS="LITERAL">BEFORE DELETE OR UPDATE</TT>触发器，
该触发器在一个表上使用这个函数被另外一个表引用。作为触发器参数指定：
该函数必须执行检查的引用表的数量，如果发现一个引用键的动作
（<TT CLASS="LITERAL">cascade</TT> &mdash; 删除引用行，<TT CLASS="LITERAL">restrict</TT> &mdash;
如果引用键退出则退出事务，<TT CLASS="LITERAL">setnull</TT> &mdash; 设置引用键字段为空），
来自主/唯一键的被触发表的字段名，然后是引用表名和字段名
（重复引用表的次数和第一个参数指定的一样多）。请注意，
主/唯一键字段应该标记为NOT NULL并且应该有一个唯一索引。</P><P>示例在<TT CLASS="FILENAME">refint.example</TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN150304">F.34.2. timetravel &mdash; 实现时间行程的函数</A></H2><P>
很久以前，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>有一个内置的时间行程特性，
保持为每个元组插入和删除时间。这个特性可以使用这些函数模仿。
要使用这些函数，必须添加两个<TT CLASS="TYPE">abstime</TT>类型的字段到一个表，
用来存储一个元组插入(start_date)和更改/删除(stop_date)的日期：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE mytab (
        ...             ...
        start_date      abstime,
        stop_date       abstime
        ...             ...
);</PRE><P>
该字段可以随你喜欢任意命名，但是在这个讨论中我们将它们称作start_date和stop_date。
</P><P>当插入一个新行时，start_date通常设置为当前时间，stop_date设置为<TT CLASS="LITERAL">infinity</TT>。
如果插入的数据在这些字段中包含空，那么触发器将自动的替换这些值。
通常只应该在重新加载转储的数据时在这些字段中明确的插入非空数据。</P><P>stop_date等于<TT CLASS="LITERAL">infinity</TT>的元组是<SPAN CLASS="QUOTE">"现在有效的"</SPAN>，可以修改。
带有限定的stop_date的元组不能再被修改&mdash;触发器将阻止修改。
（如果需要修改，可以像下面显示的那样关闭时间行程。）</P><P>对于可修改的行，在更新时只有被更新的元组内的stop_date被更改（为当前时间）
并且插入一个带有修改数据的新的元组。在这个新元组内的Start_date设置为当前时间，
stop_date设置为<TT CLASS="LITERAL">infinity</TT>。</P><P>删除并不实际删除元组，只是设置它的stop_date为当前时间。</P><P>要查询元组的<SPAN CLASS="QUOTE">"现在有效"</SPAN>，在查询的WHERE条件中包括
<TT CLASS="LITERAL">stop_date = 'infinity'</TT>。（你可能希望体现到一个视图中。）
相似的，你可以用合适的start_date和stop_date条件查询任意过去时间的元组有效性。</P><P><CODE CLASS="FUNCTION">timetravel()</CODE>是支持这个行为的常规触发器函数。
在每个时间行程表上创建一个使用这个函数的
<TT CLASS="LITERAL">BEFORE INSERT OR UPDATE OR DELETE</TT>触发器。
指定两个触发器参数：start_date和stop_date字段的实际名字。
可选的，你可以再指定一到三个参数，这些参数必须引用类型为<TT CLASS="TYPE">text</TT>的字段。
触发器将存储当前用户名到这些字段中，在INSERT期间存储到第一个中，
在UPDATE期间存储到第二个中，在DELETE期间存储到第三个中。</P><P><CODE CLASS="FUNCTION">set_timetravel()</CODE>允许为一个表打开或关闭时间行程。<TT CLASS="LITERAL">set_timetravel('mytab', 1)</TT>
将为表<TT CLASS="LITERAL">mytab</TT>返回TT ON。<TT CLASS="LITERAL">set_timetravel('mytab', 0)</TT>将为表<TT CLASS="LITERAL">mytab</TT>
返回TT OFF。两种情况下都报道老的状态。当TT为off是，可以自由修改start_date和stop_date字段。
请注意，on/off状态对于当前数据库会话来说是局部的&mdash;新的会话将对于所有表来说总是以TT ON开始。</P><P><CODE CLASS="FUNCTION">get_timetravel()</CODE>为一个表返回TT的状态而不会改变这个表。</P><P>在<TT CLASS="FILENAME">timetravel.example</TT>中有一个示例。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN150335">F.34.3. autoinc &mdash; 自增字段函数</A></H2><P><CODE CLASS="FUNCTION">autoinc()</CODE>是一个存储序列的下一个值到一个整数字段的触发器。
与内置的<SPAN CLASS="QUOTE">"序列字段"</SPAN>特性有些重叠，但是并不相同：<CODE CLASS="FUNCTION">autoinc()</CODE>
在插入时重写替代一个不同的字段值的尝试，并且可选择的，
它也可以用于在更新时增加字段。</P><P>要使用该函数，创建一个使用该函数的<TT CLASS="LITERAL">BEFORE INSERT</TT>
(或者可选择的<TT CLASS="LITERAL">BEFORE INSERT OR UPDATE</TT>) 触发器。
指定两个触发器参数：要被修改的整数字段的名字，和将要填充值的序列对象名。
（实际上，可以指定任意数量的这样的名字对，如果想要更新多个自增字段。）</P><P>在<TT CLASS="FILENAME">autoinc.example</TT>中有一个示例。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN150346">F.34.4. insert_username &mdash; 追踪谁改变了表的函数</A></H2><P><CODE CLASS="FUNCTION">insert_username()</CODE>是一个存储当前用户名到一个文本字段的触发器。
这对于追踪谁最后修改了表中指定的行是有用的。</P><P>要使用该函数，创建一个使用该函数的<TT CLASS="LITERAL">BEFORE INSERT</TT>和/或<TT CLASS="LITERAL">UPDATE</TT>触发器。
指定一个触发器参数：要修改的文本字段名。</P><P>在<TT CLASS="FILENAME">insert_username.example</TT>中有一个示例。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN150355">F.34.5. moddatetime &mdash; 追踪最后修改时间的函数</A></H2><P><CODE CLASS="FUNCTION">moddatetime()</CODE>是一个存储当前时间到<TT CLASS="TYPE">timestamp</TT>字段的触发器。
这对于追踪一个表中指定的行的最后修改时间是有用的。</P><P>要使用该函数，创建一个使用这个函数的<TT CLASS="LITERAL">BEFORE UPDATE</TT>触发器。
指定一个触发器参数：要修改的字段名。该字段必须是<TT CLASS="TYPE">timestamp</TT>
或<TT CLASS="TYPE">timestamp with time zone</TT>类型。</P><P>在<TT CLASS="FILENAME">moddatetime.example</TT>中有一个示例。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sepgsql.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sslinfo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">sepgsql</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">sslinfo</TD></TR></TABLE></DIV></BODY></HTML>
