<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>概述</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="类型转换" HREF="http://school.yunwei.edu/manual/PostgreSQL/typeconv.html"><LINK REL="PREVIOUS" TITLE="类型转换" HREF="http://school.yunwei.edu/manual/PostgreSQL/typeconv.html"><LINK REL="NEXT" TITLE="操作符" HREF="typeconv-oper.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/typeconv.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="类型转换" HREF="http://school.yunwei.edu/manual/PostgreSQL/typeconv.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/typeconv.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 10. 类型转换</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="操作符" HREF="typeconv-oper.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="TYPECONV-OVERVIEW">10.1. 概述</A></H1><P><ACRONYM CLASS="ACRONYM">SQL</ACRONYM>是强类型语言。也就是说，每个数据都与一个决定其行为和用法的数据类型相关联。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>有一个可扩展的数据类型系统，
该系统比其它<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>实现更具通用性和灵活性。因而，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>中大多数类型转换是由通用规则来管理的，
而不是由专门的试探法分析的，这种做法允许使用混合类型的表达式，
即便是其中包含用户定义的类型也如此。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扫描/分析器只将词法元素分解成五个基本种类：
整数、浮点数、字符串、标识符、关键字。大多数非数字类型首先表征为字符串，
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>语言的定义允许将类型名声明为字符串，
这个机制被<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>用于保证分析器沿着正确的方向运行。
例如，下面查询：
</P><PRE CLASS="SCREEN">SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)</PRE><P>
有两个文本常量，类型分别为<TT CLASS="TYPE">text</TT>和<TT CLASS="TYPE">point</TT>。
如果没有为字符串文本声明类型，该文本先被初始化成一个拥有存储空间的
<TT CLASS="TYPE">unknown</TT>类型，该类型将在后面描述的晚期阶段分析。</P><P>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>分析器里，
有四种基本的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>元素需要独立的类型转换规则：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT>函数调用</DT><DD><P>多数<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>类型系统是建筑在一套丰富的函数上的。
函数调用可以有一个或多个参数。因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许函数重载，
所以函数名自身并不唯一地标识将要调用的函数，
分析器必须根据函数提供的参数类型选择正确的函数。</P></DD><DT>操作符</DT><DD><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>允许在表达式上使用前缀或后缀(单目)操作符，
也允许表达式内部使用双目操作符(两个参数)。像函数一样，操作符也可以被重载，
因此操作符的选择也和函数一样取决于参数类型。</P></DD><DT>值存储</DT><DD><P><TT CLASS="COMMAND">INSERT</TT>和<TT CLASS="COMMAND">UPDATE</TT>语句将表达式结果放入表中。
语句中的表达式类型必须和目标字段的类型一致或者可以转换为一致。</P></DD><DT><TT CLASS="LITERAL">UNION</TT>, <TT CLASS="LITERAL">CASE</TT>和相关构造</DT><DD><P>因为联合<TT CLASS="COMMAND">SELECT</TT>语句中的所有查询结果必须在一列里显示出来，
所以每个<TT CLASS="COMMAND">SELECT</TT>子句中的元素类型必须相互匹配并转换成一套统一类型。
类似地，一个<TT CLASS="LITERAL">CASE</TT>构造的结果表达式必须转换成统一的类型，
这样<TT CLASS="LITERAL">CASE</TT>表达式自身作为整体有一种已知输出类型。
同样的要求也存在于<TT CLASS="LITERAL">ARRAY</TT>构造以及<CODE CLASS="FUNCTION">GREATEST</CODE>和<CODE CLASS="FUNCTION">LEAST</CODE>函数中。</P></DD></DL></DIV><P></P><P>系统表<I CLASS="FIRSTTERM">casts</I>存储有关哪种数据类型之间存在哪种转换以及如何执行这些转换的信息。
额外的转换可以由用户通过<A HREF="sql-createcast.html">CREATE CAST</A>命令增加。
这个通常和定义一种新的数据类型一起完成。内置的类型转换集已经经过仔细的雕琢了，
因此最好不要去更改它们。</P><P>分析器中还提供了一个额外的搜索器，允许提高对有隐含转换的类型组之间的适当的转换行为的决断。
数据类型分成了几个基本<I CLASS="FIRSTTERM">类型分类</I>，包括：<TT CLASS="TYPE">boolean</TT>,
<TT CLASS="TYPE">numeric</TT>, <TT CLASS="TYPE">string</TT>, <TT CLASS="TYPE">bitstring</TT>, <TT CLASS="TYPE">datetime</TT>,
<TT CLASS="TYPE">timespan</TT>, <TT CLASS="TYPE">geometric</TT>, <TT CLASS="TYPE">network</TT>, user-defined(用户定义)。
（参阅列表<A HREF="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE">&#34920; 47-52</A>；
但是要注意的是创建自定义的类型分类也是可能的。）
每种类型都有一种或多种<I CLASS="FIRSTTERM">首选类型</I>用于解决类型选择的问题。
小心的选择首选类型和可用的隐含转换，就有可能保证有歧义的表达式（那些有多个候选解析方案的）
可以用有效的方式解决。</P><P>所有类型转换规则都是建立在下面几个基本原则上的：
<P></P></P><UL><LI><P>隐含转换决不能有奇怪的或不可预见的输出。</P></LI><LI><P>如果一个查询不需要隐含的类型转换，分析器或执行器不应该进行更多的额外操作。
这就是说，任何一个类型匹配、格式清晰的查询不应该在分析器里耗费更多的时间，
也不应该向查询中引入任何不必要的隐含类型转换调用。</P><P>另外，如果一个查询通常使用某个函数进行隐含类型转换，而用户定义了一个有正确参数的函数，
解释器应该使用新函数取代原先旧函数的隐含操作。</P></LI></UL><P></P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/typeconv.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="typeconv-oper.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">类型转换</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/typeconv.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">操作符</TD></TR></TABLE></DIV></BODY></HTML>
