<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>C-语言函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="扩展SQL" HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html"><LINK REL="PREVIOUS" TITLE="内部函数" HREF="xfunc-internal.html"><LINK REL="NEXT" TITLE="用户定义聚集" HREF="xaggr.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/xfunc.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="内部函数" HREF="xfunc-internal.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 35. 扩展<ACRONYM CLASS="ACRONYM">SQL</ACRONYM></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="用户定义聚集" HREF="xaggr.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="XFUNC-C">35.9. C-语言函数</A></H1><P> 用户定义的函数可以用 C 写(或者是与C兼容的语言，比如C++)。
这样的函数被编译进动态加载对象(共享库)并且由服务器根据需要加载。
动态加载的特性是<SPAN CLASS="QUOTE">"C 语言函数"</SPAN>和<SPAN CLASS="QUOTE">"内部函数"</SPAN>之间的区别&mdash;不过，
实际的编码习惯在两者之间实际上是一样的。因此，
标准的内部函数库为写用户定义C函数提供了大量最好的样例。&#13;</P><P> 目前对 C 函数有两种调用约定。新的<SPAN CLASS="QUOTE">"版本-1"</SPAN>的调用约定是通过为该函数书写一个
<TT CLASS="LITERAL">PG_FUNCTION_INFO_V1()</TT>宏来标识的，像下面演示的那样。缺少这个宏表示一个
老风格的(<SPAN CLASS="QUOTE">"版本-0"</SPAN>)函数。两种风格里在<TT CLASS="COMMAND">CREATE FUNCTION</TT>里声明的都是<TT CLASS="LITERAL">C</TT>。
现在老风格的函数已经废弃了，主要是因为移植性原因和缺乏功能，
不过出于兼容性原因，系统仍然支持它。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="XFUNC-C-DYNLOAD">35.9.1. 动态加载</A></H2><P> 当用户定义的函数第一次被服务器会话调用时，
动态加载器才把可加载对象文件里的函数目标码加载进内存。
因此，用于用户定义 C 函数的<TT CLASS="COMMAND">CREATE FUNCTION</TT>必须为函数声明两个信息：
可加载对象文件名、在目标文件里调用的 C 函数名(连接符号)。
如果没有明确声明 C 函数名，那么就假设它与 SQL 函数名相同。</P><P>
基于在<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令中给出的名字，
下面的算法用于定位共享对象文件：
<P></P></P><OL TYPE="1"><LI><P>
如果名字是一个绝对路径，则加载给出的文件。
</P></LI><LI><P> 如果名字以字符串<TT CLASS="LITERAL">$libdir</TT>开头，
那么该部分将被<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>库目录名代替，
该目录是在编译时确定的。</P></LI><LI><P> 如果名字不包含目录部分，
那么在配置参数<A HREF="runtime-config-client.html#GUC-DYNAMIC-LIBRARY-PATH">dynamic_library_path</A>.
声明的路径里查找。</P></LI><LI><P> 如果没有在路径里找到该文件，或者它包含一个非绝对目录部分，
那么动态加载器就会试图直接拿这个名字来加载，
这样几乎可以肯定是要失败的(依靠当前工作目录是不可靠的)。</P></LI></OL><P>
如果这个顺序不管用，那么就给这个名字加上平台相关的共享库文件扩展名(通常是<TT CLASS="FILENAME">.so</TT>)，
然后再重新按照上面的过程找一遍。如果还是失败，那么加载失败。
</P><P> 建议使用相对于<TT CLASS="LITERAL">$libdir</TT>的目录或者通过动态库路径定位共享库。
这样，如果新版本安装在一个不同的位置，那么就可以简化版本升级。
<TT CLASS="LITERAL">$libdir</TT>的实际目录位置可以
用<TT CLASS="LITERAL">pg_config --pkglibdir</TT>命令找到。</P><P> 运行<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器的用户ID
必须可以遍历路径到达想加载的文件。
一个常见的错误就是把该文件或者一个高层目
录的权限设置为<SPAN CLASS="SYSTEMITEM">postgres</SPAN>用户不可读和/或不能执行。&#13;</P><P> 在任何情况下，在<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令里给出的文件
名是在系统表里按照文本记录的，
因此，如果需要再次加载，那么会再次运行这个过程。&#13;</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不会自动编译 C 函数；
在使用<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令之前你必须编译它。
参阅<A HREF="xfunc-c.html#DFUNC">第 35.9.6 &#33410;</A>获取更多信息。</P></BLOCKQUOTE></DIV><P>
为了确保不会错误加载共享库文件，从<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
开始将检查那个文件的<SPAN CLASS="QUOTE">"magic block"</SPAN>，这允许服务器以检查明显的不兼容性。
比如不同版本<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的编译代码。
magic block需要被作为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.2。
为了包含<SPAN CLASS="QUOTE">"magic block"</SPAN>，
请在包含了<TT CLASS="FILENAME">fmgr.h</TT>头文件之后，
将下面的内容写进一个(也只能是一个)模块的源代码文件中：
</P><PRE CLASS="PROGRAMLISTING">#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif</PRE><P>
如果不打算兼容8.2 <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>之前的版本，
<TT CLASS="LITERAL">#ifdef</TT>测试也可以省略。
</P><P> 动态加载对象文件在首次使用之后将一直滞留在内存中。
在同一个会话中的下一次调用将只需查找符号表的很小开销。
如果你想强制重新加载(比如重新编译之后)，
可以重新开始一个新的会话。&#13;</P><P> 动态加载文件也可以包含初始化函数和结束函数。
如果包含一个名为<CODE CLASS="FUNCTION">_PG_init</CODE>的函数，那么该函数将在该文件被加载后立即执行，
该函数不能接受任何参数并且必须返回 void 。
如果包含一个名为<CODE CLASS="FUNCTION">_PG_fini</CODE>的函数，那么该函数将在该文件即将被卸载前执行，
同样，该函数不能接受任何参数并且必须返回 void 。
需要注意的是<CODE CLASS="FUNCTION">_PG_fini</CODE>仅在该文件即将被卸载前执行而不是在会话结束的时候执行。
目前，卸载被禁止并且将不会发生，但是这可能在将来改变。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="XFUNC-C-BASETYPE">35.9.2. 基本类型的C语言函数</A></H2><P> 要知道如何写C语言函数，就必须知道<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>在
内部如何表现基本数据类型以及如何传入及传出函数。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>内部把基本类型当作<SPAN CLASS="QUOTE">"一块内存"</SPAN>看待。
定义在某种类型上的用户定义函数实际上定义了
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>对该数据类型可能的操作。也就是说，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>只是从磁盘读取和存储该数据
类型并使用你定义的函数来输入、处理、输出数据。&#13;</P><P>
基本类型可以有下面三种内部形态(格式)之一：
<P></P></P><UL><LI><P>
传递数值，定长
</P></LI><LI><P> 传递引用，定长</P></LI><LI><P> 传递引用，变长</P></LI></UL><P>
</P><P>
传递数值的类型长度只能是1, 2, 4字节。如果<TT CLASS="LITERAL">sizeof(Datum)</TT>
在你的机器上是8的话，那么还有8字节。你要仔细定义你的类型，
确保它们在任何体系平台上都是相同尺寸(字节)。例如，<TT CLASS="LITERAL">long</TT>
是一个危险的类型，
因为在一些机器上它是4字节而在另外一些机器上是8字节，
而<TT CLASS="TYPE">int</TT>在大多数Unix机器上都是4字节的。
在一个Unix机器上的<TT CLASS="TYPE">int4</TT>
合理实现可能是：
</P><PRE CLASS="PROGRAMLISTING">/* 4-byte integer, passed by value */
typedef int int4;</PRE><P>
实际PostgreSQL C代码调用此<TT CLASS="TYPE">int32</TT>类型，
因为它是C中的惯例，<TT CLASS="TYPE">int<TT CLASS="REPLACEABLE"><I>XX</I></TT></TT>
意味着<TT CLASS="REPLACEABLE"><I>XX</I></TT> <SPAN CLASS="emphasis"><I CLASS="EMPHASIS">bits</I></SPAN>。
注意因此C类型<TT CLASS="TYPE">int8</TT>的大小是1字节。SQL类型<TT CLASS="TYPE">int8</TT>被称为C中<TT CLASS="TYPE">int64</TT>。参见
<A HREF="xfunc-c.html#XFUNC-C-TYPE-TABLE">&#34920; 35-1</A>。
</P><P>
另外，任何尺寸的定长类型都可以是传递引用型。例如，
下面是一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>类型的实现：
</P><PRE CLASS="PROGRAMLISTING">/* 16-byte structure, passed by reference */
typedef struct
{
    double  x, y;
} Point;</PRE><P>
只能使用指向这些类型的指针在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>函数里传入和传出数据。
要返回这样类型的值，用<TT CLASS="LITERAL">palloc</TT>分配正确数量的内存，填充这些内存，
然后返回一个指向它的指针。如果只是想返回和输入参数类型与数值都相同的数值，
可以忽略额外的<TT CLASS="LITERAL">palloc</TT>，只要返回指向输入数值的指针就行。
</P><P> 最后，所有变长类型同样也只能通过引用来传递。
所有变长类型必须以一个4字节的长度域开始，通过<TT CLASS="SYMBOL">SET_VARSIZE</TT>设置，
没有直接设置这个字段！
所有存储在该类型中的数据必须放在紧接着长度域的存储空间里。
长度域是结构的全长，也就是说，包括长度域本身的长度。</P><P> 另外一个重要的点是避免数据类型值中留下未初始化的位；比如，请注意任何对齐填充字节
溢出的零可能出现在结构体中。没有这些，你的数据类型的逻辑上等价常量可能被规划器看做是
不平等的，导致低效（虽然是不正确的）规划。</P><DIV CLASS="WARNING"><P></P><TABLE CLASS="WARNING" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#35686;&#21578;</B></TD></TR><TR><TD ALIGN="LEFT"><P> <SPAN CLASS="emphasis"><I CLASS="EMPHASIS">绝对不要</I></SPAN>修改一个引用传递的输入值，否则很可能破坏磁盘上的数据。
因为指针很可能直接指向一个磁盘缓冲区。
这条规则的唯一例外在<A HREF="xaggr.html">第 35.10 &#33410;</A>里。</P></TD></TR></TABLE></DIV><P>
比如，我们可以用下面的方法定义一个<TT CLASS="TYPE">text</TT>类型:
</P><PRE CLASS="PROGRAMLISTING">typedef struct {
    int32 length;
    char data[1];
} text;</PRE><P>
显然，上面声明的数据域长度不足以存储任何可能的字符串。
因为在<ACRONYM CLASS="ACRONYM">C</ACRONYM>中不可能声明变长结构，所以我们倚赖这样的知识：
<ACRONYM CLASS="ACRONYM">C</ACRONYM>编译器不会对数组下标进行范围检查。只需要分配足够的空间，
然后把数组当做已经声明为合适长度的变量访问。这是一个常用的技巧，
你可以在许多C教科书中读到。
</P><P>
当处理变长类型时，必须仔细分配正确的内存数量并正确设置长度域。
例如，如果想在一个<TT CLASS="STRUCTNAME">text</TT>结构里存储40字节，
我们可能会使用像下面的代码片段：
</P><PRE CLASS="PROGRAMLISTING">#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination-&#62;data, buffer, 40);
...</PRE><P>
<TT CLASS="LITERAL">VARHDRSZ</TT>等价于<TT CLASS="LITERAL">sizeof(int32)</TT>，
但是我们认为用宏<TT CLASS="LITERAL">VARHDRSZ</TT>表示附加尺寸是用于变长类型的更好风格。
同时，该长度字段<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必须</I></SPAN>使用<TT CLASS="LITERAL">SET_VARSIZE</TT>宏设置，
而不是简单的赋值。
</P><P> <A HREF="xfunc-c.html#XFUNC-C-TYPE-TABLE">&#34920; 35-1</A>列出了书写
使用<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>内置类型的 C 函数里需要知道的
SQL 类型与 C 类型的对应关系。<SPAN CLASS="QUOTE">"定义在"</SPAN>
列给出了需要包含以获取该类型定义的头文件。
实际定义可能在列表文件中包含的不同文件中。我们建议用户坚持定义的接口。
注意，你应该总是首先包括<TT CLASS="FILENAME">postgres.h</TT>，
因为它声明了许多你需要的东西。&#13;</P><DIV CLASS="TABLE"><A NAME="XFUNC-C-TYPE-TABLE"></A><P><B>&#34920; 35-1. 与内建SQL类型等效的C类型</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH> SQL Type
</TH><TH> C Type
</TH><TH> Defined In
</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="TYPE">abstime</TT></TD><TD><TT CLASS="TYPE">AbsoluteTime</TT></TD><TD><TT CLASS="FILENAME">utils/nabstime.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">boolean</TT></TD><TD><TT CLASS="TYPE">bool</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT> (可能编译器内置)</TD></TR><TR><TD><TT CLASS="TYPE">box</TT></TD><TD><TT CLASS="TYPE">BOX*</TT></TD><TD><TT CLASS="FILENAME">utils/geo_decls.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">bytea</TT></TD><TD><TT CLASS="TYPE">bytea*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">"char"</TT></TD><TD><TT CLASS="TYPE">char</TT></TD><TD>(编译器内置)</TD></TR><TR><TD><TT CLASS="TYPE">character</TT></TD><TD><TT CLASS="TYPE">BpChar*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">cid</TT></TD><TD><TT CLASS="TYPE">CommandId</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">date</TT></TD><TD><TT CLASS="TYPE">DateADT</TT></TD><TD><TT CLASS="FILENAME">utils/date.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">smallint</TT> (<TT CLASS="TYPE">int2</TT>)</TD><TD><TT CLASS="TYPE">int16</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">int2vector</TT></TD><TD><TT CLASS="TYPE">int2vector*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">integer</TT> (<TT CLASS="TYPE">int4</TT>)</TD><TD><TT CLASS="TYPE">int32</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">real</TT> (<TT CLASS="TYPE">float4</TT>)</TD><TD><TT CLASS="TYPE">float4*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">double precision</TT> (<TT CLASS="TYPE">float8</TT>)</TD><TD><TT CLASS="TYPE">float8*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">interval</TT></TD><TD><TT CLASS="TYPE">Interval*</TT></TD><TD><TT CLASS="FILENAME">datatype/timestamp.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">lseg</TT></TD><TD><TT CLASS="TYPE">LSEG*</TT></TD><TD><TT CLASS="FILENAME">utils/geo_decls.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">name</TT></TD><TD><TT CLASS="TYPE">Name</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">oid</TT></TD><TD><TT CLASS="TYPE">Oid</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">oidvector</TT></TD><TD><TT CLASS="TYPE">oidvector*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">path</TT></TD><TD><TT CLASS="TYPE">PATH*</TT></TD><TD><TT CLASS="FILENAME">utils/geo_decls.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">point</TT></TD><TD><TT CLASS="TYPE">POINT*</TT></TD><TD><TT CLASS="FILENAME">utils/geo_decls.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">regproc</TT></TD><TD><TT CLASS="TYPE">regproc</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">reltime</TT></TD><TD><TT CLASS="TYPE">RelativeTime</TT></TD><TD><TT CLASS="FILENAME">utils/nabstime.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">text</TT></TD><TD><TT CLASS="TYPE">text*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">tid</TT></TD><TD><TT CLASS="TYPE">ItemPointer</TT></TD><TD><TT CLASS="FILENAME">storage/itemptr.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">time</TT></TD><TD><TT CLASS="TYPE">TimeADT</TT></TD><TD><TT CLASS="FILENAME">utils/date.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">time with time zone</TT></TD><TD><TT CLASS="TYPE">TimeTzADT</TT></TD><TD><TT CLASS="FILENAME">utils/date.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">timestamp</TT></TD><TD><TT CLASS="TYPE">Timestamp*</TT></TD><TD><TT CLASS="FILENAME">datatype/timestamp.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">tinterval</TT></TD><TD><TT CLASS="TYPE">TimeInterval</TT></TD><TD><TT CLASS="FILENAME">utils/nabstime.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">varchar</TT></TD><TD><TT CLASS="TYPE">VarChar*</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR><TR><TD><TT CLASS="TYPE">xid</TT></TD><TD><TT CLASS="TYPE">TransactionId</TT></TD><TD><TT CLASS="FILENAME">postgres.h</TT></TD></TR></TBODY></TABLE></DIV><P> 既然我们已经讨论了基本类型所有可能的结构，
我们便可以用实际的函数举一些例子。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN53393">35.9.3. 版本-0调用约定</A></H2><P> 先提供现在已经不提倡了的<SPAN CLASS="QUOTE">"老风格"</SPAN>&mdash;因为比较容易迈出第一步。
在版本-0方法中，此风格 C 函数的参数和结果用普通 C 风格声明，
但是要小心使用上面显示的 SQL
数据类型的 C 表现形式。&#13;</P><P>
下面是一些例子：
</P><PRE CLASS="PROGRAMLISTING">#include "postgres.h"
#include &#60;string.h&#62;
#include "utils/geo_decls.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* 传递数值 */
int
add_one(int arg)
{
    return arg + 1;
}

/* 传递引用，定长 */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;

    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;

    return new_point;
}

/* 传递引用，变长*/

text *
copytext(text *t)
{
 /*
     * VARSIZE是结构以字节计的总长度。
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    SET_VARSIZE(new_t, VARSIZE(t));

/*
     * VARDATA是结构中一个指向数据区的指针。
     */

    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t) - VARHDRSZ);  /* how many bytes */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    return new_text;
}</PRE><P>
</P><P>
假设上面的代码放在<TT CLASS="FILENAME">funcs.c</TT>文件中并且编译成了共享目标，
我们可以用下面的命令为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>定义这些函数:
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one'
     LANGUAGE C STRICT;
--注意：重载了名字为"add_one"的 SQL 函数

CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'concat_text'
     LANGUAGE C STRICT;</PRE><P>
</P><P> 这里的<TT CLASS="REPLACEABLE"><I>DIRECTORY</I></TT>代表共享库文件的目录，
比如包含本节示例代码的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>教程目录。
更好的风格应该是将<TT CLASS="REPLACEABLE"><I>DIRECTORY</I></TT>加到搜索路径之后，
在<TT CLASS="LITERAL">AS</TT>子句里只使用<TT CLASS="LITERAL">'funcs'</TT>，不管怎样，
我们都可以省略和系统相关的共享库扩展，
通常是<TT CLASS="LITERAL">.so</TT>或者<TT CLASS="LITERAL">.sl</TT>。</P><P> 请注意我们把函数声明为<SPAN CLASS="QUOTE">"strict"</SPAN>(严格)，意思是说如果任何输入值为NULL，
那么系统应该自动假设一个NULL的结果。这样处理可以让我们避免在函数代码里面检查
NULL输入。如果不这样处理，我们就得明确检查NULL，
比如为每个传递引用的参数检查空指针。对于传值类型的参数，我们甚至没有办法检查！</P><P> 尽管这种老调用风格用起来简单，但它却不太容易移植；
在一些系统上，用这种方法传递比<TT CLASS="TYPE">int</TT>小的数据类型就会碰到困难。
而且，我们没有很好的返回NULL结果的办法，也没有除了把函数严格化以外的处理
NULL参数的方法。版本-1约定，下面要讲的新方法则解决了这些问题。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN53420">35.9.4. 版本1调用约定</A></H2><P>
版本-1调用约定使用宏消除大多数传递参数和结果的复杂性。版本-1风格函数的C定义总是下面这样:
</P><PRE CLASS="PROGRAMLISTING">Datum funcname(PG_FUNCTION_ARGS)</PRE><P>
另外，宏调用：
</P><PRE CLASS="PROGRAMLISTING">PG_FUNCTION_INFO_V1(funcname);</PRE><P>
也必须出现在同一个源文件里(通常就可以写在函数自身前面)。
对那些<TT CLASS="LITERAL">internal</TT>语言函数而言，不需要调用这个宏，
因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>目前假设内部函数都是版本-1。不过，对于动态加载的函数，
它是必须的。
</P><P> 在版本-1 函数里，每个实际参数都是用一个对应该参数的数据类型的
<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>()</CODE>宏抓取的，
用返回类型的<CODE CLASS="FUNCTION">PG_RETURN_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>()</CODE>宏返回结果。
<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>()</CODE>接受要抓取的函数参数的编号
(从 0 开始)作为其参数。<CODE CLASS="FUNCTION">PG_RETURN_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>()</CODE>
接受实际要返回的数值为自身的参数。&#13;</P><P>
下面是和上面一样的函数，但是使用版本-1风格编写的：
</P><PRE CLASS="PROGRAMLISTING">#include "postgres.h"
#include &#60;string.h&#62;
#include "fmgr.h"
#include "utils/geo_decls.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/*传递数值*/

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/*传递引用，定长*/ 

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
 /*用于FLOAT8的宏，隐藏其传递引用的本质。*/
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
 /* 这里，我们没有隐藏Point的传递引用的本质*/
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;

    PG_RETURN_POINT_P(new_point);
}

/*传递引用，变长*/

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);

 /*
     * VARSIZE是结构以字节计的总长度。
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    SET_VARSIZE(new_t, VARSIZE(t));

 /*
     * VARDATA是结构中指向数据区的一个指针。
     */
    
memcpy((void *) VARDATA(new_t), /* 目的*/
           (void *) VARDATA(t),     /* 源 */
           VARSIZE(t) - VARHDRSZ);  /* 多少字节 */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}</PRE><P>
</P><P> 用到的<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令和版本-0等效命令一样。</P><P> 猛一看，版本-1的编码好像只是无目的地蒙人。但是它的确给我们许多改进，
因为宏可以隐藏许多不必要的细节。一个例子在<CODE CLASS="FUNCTION">add_one_float8</CODE>的编码里，
这里我们不再需要不停叮嘱自己<TT CLASS="TYPE">float8</TT>是传递引用类型。
另外一个例子是用于变长类型的宏<TT CLASS="LITERAL">GETARG</TT>隐藏了抓取
<SPAN CLASS="QUOTE">"非常规"</SPAN>(压缩的或者超长的)值需要做的处理。</P><P> 版本-1的函数另一个巨大的改进是对NULL输入和结果的处理。
宏<CODE CLASS="FUNCTION">PG_ARGISNULL(<TT CLASS="REPLACEABLE"><I>n</I></TT>)</CODE>允许一个函数测试每个输入是否为NULL，
当然，这只是对那些没有声明为<SPAN CLASS="QUOTE">"strict"</SPAN>的函数有必要。
因为如果有<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>()</CODE>宏，
输入参数是从零开始计算的。
请注意我们不应该执行<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>()</CODE>，
除非有人声明了参数不是NULL。
要返回一个NULL结果，可以执行一个<CODE CLASS="FUNCTION">PG_RETURN_NULL()</CODE>，
这样对严格的和不严格的函数都有效。</P><P> 在新风格的接口中提供的其它选项是<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>()</CODE>宏的两个变种。
第一个变体<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>_COPY()</CODE>
保证返回一个指定参数的副本，该副本是可以安全地写入的。普通的宏有时候会返回一个指向物理存储在表中的某值的指针，
因此我们不能写入该指针。用<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>_COPY()</CODE>宏保证获取一个可写的结果。
第二个变体由<CODE CLASS="FUNCTION">PG_GETARG_<TT CLASS="REPLACEABLE"><I>xxx</I></TT>_SLICE()</CODE>宏组成，
它接受三个参数。第一个是参数的个数(与上同)。第二个和第三个是要返回的偏移量和数据段的长度。
偏移是从零开始计算的，一个负数的长度则要求返回该值的剩余长度的数据。
这些过程提供了访问大数据值的中一部分的更有效方法，
特别是数据的存储类型是<SPAN CLASS="QUOTE">"external"</SPAN>的时候。
一个字段的存储类型可以用<TT CLASS="LITERAL">ALTER TABLE <TT CLASS="REPLACEABLE"><I>tablename</I></TT> ALTER
COLUMN <TT CLASS="REPLACEABLE"><I>colname</I></TT> SET STORAGE
<TT CLASS="REPLACEABLE"><I>storagetype</I></TT></TT>指定。
<TT CLASS="REPLACEABLE"><I>storagetype</I></TT>是<TT CLASS="LITERAL">plain</TT>，<TT CLASS="LITERAL">external</TT>，
<TT CLASS="LITERAL">extended</TT>，或者<TT CLASS="LITERAL">main</TT>之一。&#13;</P><P> 版本-1 的函数调用风格也令我们可能返回一"套"结果(<A HREF="xfunc-c.html#XFUNC-C-RETURN-SET">第 35.9.9 &#33410;</A>)
并且实现触发器函数(<A HREF="http://school.yunwei.edu/manual/PostgreSQL/triggers.html">第 36 &#31456;</A>)和过程语言调用处理器
(<A HREF="http://school.yunwei.edu/manual/PostgreSQL/plhandler.html">第 51 &#31456;</A>)。
版本-1的代码也更容易移植，因为它没有违反C标准对函数调用协议的限制。
更多的细节请参阅源程序中的<TT CLASS="FILENAME">src/backend/utils/fmgr/README</TT>文件。&#13;</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN53478">35.9.5. 书写代码</A></H2><P> 在转到更深的话题之前，先要讨论一些<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> C语言函数的编码规则。
虽然可以用C以外的其它语言书写用于
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的共享函数，
但通常都很麻烦（当它可能的时候），因为其他语言，
比如C++, FORTRAN或者Pascal并不遵循C的调用习惯。
也就是说，其它语言在函数之间的传递参数和返回值的方式不一样。
因此假设你的C-编程语言函数是用C写的。&#13;</P><P>
书写和编译C函数的基本规则如下：
<P></P></P><UL><LI><P>
使用<TT CLASS="LITERAL">pg_config
--includedir-server</TT>
找出<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器的头文件安装在你的系统上的
（或者你的用户正在运行）的位置。
</P></LI><LI><P> 把你的代码编译成可以动态装入<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
的库文件总是需要一些特殊的标记。参阅<A HREF="xfunc-c.html#DFUNC">第 35.9.6 &#33410;</A>获取如何在你的平台上做这件事的详细说明。</P></LI><LI><P> 按照<A HREF="xfunc-c.html#XFUNC-C-DYNLOAD">第 35.9.1 &#33410;</A>的指示为你的共享库定义一个<SPAN CLASS="QUOTE">"magic block"</SPAN>。</P></LI><LI><P> 当分配内存时，用<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的<CODE CLASS="FUNCTION">palloc</CODE>和
<CODE CLASS="FUNCTION">pfree</CODE>函数取代相应的C库函数
<CODE CLASS="FUNCTION">malloc</CODE>和<CODE CLASS="FUNCTION">free</CODE>。
用<CODE CLASS="FUNCTION">palloc</CODE>分配的内存在每个事务结束时会自动释放，避免了内存泄露。</P></LI><LI><P> 使用<CODE CLASS="FUNCTION">memset</CODE>（或者在第一个位置分配<CODE CLASS="FUNCTION">palloc0</CODE>）的你的结构字节总是零。
即使你给结构分配每个字段，可能有对齐填充（结构中含有孔）包含垃圾值。如果没有这一点，
很难支持散列索引和哈希连接，你必须只挑出你的数据结构中重要的位来计算一个散列。
规划器有时也依赖于通过位平等比较常数，所以如果逻辑等效值不是按位平等，
则你可能得到不良的规划结果。</P></LI><LI><P> 大多数的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>内部类型定义在<TT CLASS="FILENAME">postgres.h</TT>中，
而函数管理器接口(<TT CLASS="SYMBOL">PG_FUNCTION_ARGS</TT>等等)都在<TT CLASS="FILENAME">fmgr.h</TT>中，
所以你至少应该包括这两个文件。出于移植性原因，
最好<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">先</I></SPAN>包括<TT CLASS="FILENAME">postgres.h</TT>再包含其它系统或者用户头文件。
包含<TT CLASS="FILENAME">postgres.h</TT>将自动包含<TT CLASS="FILENAME">elog.h</TT>和<TT CLASS="FILENAME">palloc.h</TT>。</P></LI><LI><P> 在目标文件里定义的符号一定不能相互冲突，
也不能和定义在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器可执行代码中的符号名字冲突。
如果你看到了与此相关的错误信息，那么必须重命名你的函数或者变量。</P></LI></UL><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DFUNC">35.9.6. 编译和链接动态加载的函数</A></H2><P>在能够使用由 C 写的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扩展函数之前，
必须用一种特殊的方法编译和链接它们，这样才能生成可以被服务器动态加载的文件。
准确地说是需要创建一个<I CLASS="FIRSTTERM">共享库</I>。</P><P>如果需要更多信息，那么你应该阅读操作系统的文档，特别是 C 编译器(<TT CLASS="COMMAND">cc</TT>)
和连接器(<TT CLASS="COMMAND">ld</TT>)的文档。另外，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
源代码里包含几个可以运行的例子，它们在<TT CLASS="FILENAME">contrib</TT>目录里。不过，
如果你依赖这些例子，那么你的模块将依赖于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>源代码的可用性。</P><P>创建共享库和链接可执行文件类似：首先把源代码编译成目标文件，然后把目标文件链接起来。
目标文件需要创建成<I CLASS="FIRSTTERM">位置无关码</I>(<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>)，
也就是在可执行程序加载它们的时候，
它们可以被放在可执行程序内存里的任何地方(用于可执行文件的目标文件通常不是用这个方式编译的)，
链接动态库的命令包含特殊标志，与链接可执行文件的命令是有区别的(至少理论上如此，不过现实未必)。</P><P>在下面的例子里，假设你的源程序代码在<TT CLASS="FILENAME">foo.c</TT>文件里，并且我们要创建
<TT CLASS="FILENAME">foo.so</TT>的共享库。中介的对象文件将叫做<TT CLASS="FILENAME">foo.o</TT>
(除非另外注明)。虽然一个共享库可以包含多个对象文件，但是在这里只用一个。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><SPAN CLASS="SYSTEMITEM">FreeBSD</SPAN></DT><DD><P>创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">-fpic</TT>。创建共享库的链接器标志是<TT CLASS="OPTION">-shared</TT>。
</P><PRE CLASS="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE><P>
上面方法适用于 3.0 版本的<SPAN CLASS="SYSTEMITEM">FreeBSD</SPAN>。</P></DD><DT><SPAN CLASS="SYSTEMITEM">HP-UX</SPAN></DT><DD><P>创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">+z</TT> 。如果使用<SPAN CLASS="APPLICATION">GCC</SPAN>
则是<TT CLASS="OPTION">-fpic</TT>。创建共享库的链接器标志是<TT CLASS="OPTION">-b</TT>。因此：
</P><PRE CLASS="PROGRAMLISTING">cc +z -c foo.c</PRE><P>
或：
</P><PRE CLASS="PROGRAMLISTING">gcc -fpic -c foo.c</PRE><P>
然后：
</P><PRE CLASS="PROGRAMLISTING">ld -b -o foo.sl foo.o</PRE><P>
<SPAN CLASS="SYSTEMITEM">HP-UX</SPAN>使用<TT CLASS="FILENAME">.sl</TT>作为共享库扩展名，和其它大部分系统不同。</P></DD><DT><SPAN CLASS="SYSTEMITEM">IRIX</SPAN></DT><DD><P><ACRONYM CLASS="ACRONYM">PIC</ACRONYM>是缺省，不需要使用特殊的编译器选项。创建共享库的链接器标志是<TT CLASS="OPTION">-shared</TT>。
</P><PRE CLASS="PROGRAMLISTING">cc -c foo.c
ld -shared -o foo.so foo.o</PRE><P></P></DD><DT><SPAN CLASS="SYSTEMITEM">Linux</SPAN></DT><DD><P>创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">-fpic</TT>。在某些平台上如果<TT CLASS="OPTION">-fpic</TT>
不工作则必须使用<TT CLASS="OPTION">-fPIC</TT>。
参考 GCC 手册获取更多信息。创建共享库的编译器标志是<TT CLASS="OPTION">-shared</TT>。一个完整的例子看起来像：
</P><PRE CLASS="PROGRAMLISTING">cc -fpic -c foo.c
cc -shared -o foo.so foo.o</PRE><P></P></DD><DT><SPAN CLASS="SYSTEMITEM">Mac OS X</SPAN></DT><DD><P>这里是一个例子。假设开发工具已经安装好了。
</P><PRE CLASS="PROGRAMLISTING">cc -c foo.c
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o</PRE><P></P></DD><DT><SPAN CLASS="SYSTEMITEM">NetBSD</SPAN></DT><DD><P>创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">-fpic</TT>。对于<ACRONYM CLASS="ACRONYM">ELF</ACRONYM>系统，
带<TT CLASS="OPTION">-shared</TT>标志的编译命令用于链接共享库。在老的非 ELF 系统里，
则使用<TT CLASS="LITERAL">ld -Bshareable</TT>。
</P><PRE CLASS="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE><P></P></DD><DT><SPAN CLASS="SYSTEMITEM">OpenBSD</SPAN></DT><DD><P>创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">-fpic</TT>。而
<TT CLASS="LITERAL">ld -Bshareable</TT>用于链接共享库。
</P><PRE CLASS="PROGRAMLISTING">gcc -fpic -c foo.c
ld -Bshareable -o foo.so foo.o</PRE><P></P></DD><DT><SPAN CLASS="SYSTEMITEM">Solaris</SPAN></DT><DD><P>用 Sun 编译器时创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">-KPIC</TT>；
用<SPAN CLASS="APPLICATION">GCC</SPAN>编译器时创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">-fpic</TT>。
链接共享库时两个编译器都可以用<TT CLASS="OPTION">-G</TT>，此外<SPAN CLASS="APPLICATION">GCC</SPAN>还可以用<TT CLASS="OPTION">-shared</TT>。
</P><PRE CLASS="PROGRAMLISTING">cc -KPIC -c foo.c
cc -G -o foo.so foo.o</PRE><P>
或
</P><PRE CLASS="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -G -o foo.so foo.o</PRE><P></P></DD><DT><SPAN CLASS="SYSTEMITEM">Tru64 UNIX</SPAN></DT><DD><P><ACRONYM CLASS="ACRONYM">PIC</ACRONYM>是缺省，不需要使用特殊的编译器选项。带特殊选项的<TT CLASS="COMMAND">ld</TT>用于链接：
</P><PRE CLASS="PROGRAMLISTING">cc -c foo.c
ld -shared -expect_unresolved '*' -o foo.so foo.o</PRE><P>
用 GCC 代替系统编译器时的过程是一样的；不需要特殊的选项。</P></DD><DT><SPAN CLASS="SYSTEMITEM">UnixWare</SPAN></DT><DD><P>用 SCO 编译器时创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是<TT CLASS="OPTION">-K PIC</TT>；
用<SPAN CLASS="PRODUCTNAME">GCC</SPAN>编译器时创建<ACRONYM CLASS="ACRONYM">PIC</ACRONYM>的编译器标志是
<TT CLASS="OPTION">-fpic</TT>。链接共享库时 SCO 编译器用<TT CLASS="OPTION">-G</TT>而<SPAN CLASS="PRODUCTNAME">GCC</SPAN>
使用<TT CLASS="OPTION">-shared</TT>。
</P><PRE CLASS="PROGRAMLISTING">cc -K PIC -c foo.c
cc -G -o foo.so foo.o</PRE><P>
或
</P><PRE CLASS="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE><P></P></DD></DL></DIV><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>如果你觉得这些步骤实在太复杂，那么你应该考虑使用<A HREF="http://www.gnu.org/software/libtool/" TARGET="_top"><SPAN CLASS="PRODUCTNAME">GNU Libtool</SPAN></A>，它把平台的差异隐藏在了一个统一的接口里。</P></BLOCKQUOTE></DIV><P>生成的共享库文件然后就可以加载到<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里面去了。
在给<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令声明文件名的时候，
必须声明共享库文件的名字而不是中间目标文件的名字。
请注意你可以在<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令上忽略系统标准的共享库扩展名(通常是
<TT CLASS="LITERAL">.so</TT>或<TT CLASS="LITERAL">.sl</TT>)，并且出于最佳的兼容性考虑也应该忽略。</P><P>回头看看<A HREF="xfunc-c.html#XFUNC-C-DYNLOAD">第 35.9.1 &#33410;</A>获取有关服务器预期在哪里找到共享库的信息。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN53706">35.9.7. 复合类型参数</A></H2><P> 复合类型不像 C 结构那样有固定的布局。复合类型的实例可能包含空(NULL)字段。另外，
一个属于继承层次一部分的复合类型可能和同一继承范畴的其它成员有不同的域/字段。
因此，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>提供一个过程接口用于从C中访问复合类型。</P><P>
假设为下面查询写一个函数:
</P><PRE CLASS="PROGRAMLISTING">SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';</PRE><P>
使用调用约定版本0，可以这样定义<CODE CLASS="FUNCTION">c_overpaid</CODE>：
</P><PRE CLASS="PROGRAMLISTING">#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

bool
c_overpaid(HeapTupleHeader t, /* the current row of emp */
           int32 limit)
{
    bool isnull;
    int32 salary;

    salary = DatumGetInt32(GetAttributeByName(t, "salary", &#38;isnull));
    if (isnull)
        return false;
    return salary &#62; limit;
}</PRE><P>
如果用版本-1则会写成下面这样:
</P><PRE CLASS="PROGRAMLISTING">#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &#38;isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
&#60;!--
    /* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */
--&#62;

    /*另外，可能更希望将PG_RETURN_NULL()用在null薪水上*/

    PG_RETURN_BOOL(DatumGetInt32(salary) &#62; limit);
}</PRE><P>
</P><P> <CODE CLASS="FUNCTION">GetAttributeByName</CODE>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>系统函数，
用来返回当前记录的字段。它有三个参数：类型为<TT CLASS="TYPE">HeapTupleHeader</TT>的传入函数的参数、你想要的字段名称、
一个确定字段是否为 NULL 的返回参数。<CODE CLASS="FUNCTION">GetAttributeByName</CODE>函数返回一个
<TT CLASS="TYPE">Datum</TT>值，你可以用对应的<CODE CLASS="FUNCTION">DatumGet<TT CLASS="REPLACEABLE"><I>XXX</I></TT>()</CODE>宏把它转换成合适的数据类型。
请注意，如果设置了NULL标志，那么返回值是无意义的，在准备对结果做任何处理之前，
总是要先检查NULL标志。</P><P> 还有一个<CODE CLASS="FUNCTION">GetAttributeByNum</CODE>用字段编号而不是字段名选取目标字段。</P><P>
下面的命令在SQL里声明<CODE CLASS="FUNCTION">c_overpaid</CODE>函数：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;</PRE><P>
请注意使用<TT CLASS="LITERAL">STRICT</TT>后就不需要检查输入参数是否有NULL。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN53730">35.9.8. 返回行(复合类型)</A></H2><P>
要从一个C语言函数里返回一个行或复合类型的数值，
可以使用一个特殊的API，它提供了许多宏和函数来消除大多数制作复合数据类型的复杂性。
要使用该API，源代码必须包含：
</P><PRE CLASS="PROGRAMLISTING">#include "funcapi.h"</PRE><P>
</P><P> 制作一个复合类型数据值(也就是一个<SPAN CLASS="QUOTE">"行"</SPAN>)有两种方法：
你可以从一个 Datum 值数组里制作，也可以从一个可以传递给该行的字段类型的输入转换函数的
C 字符串数组里制作。不管是哪种方式，你首先都需要为行结构获取或者制作一个
<TT CLASS="STRUCTNAME">TupleDesc</TT>描述符。在使用 Datums 的时候，你给<CODE CLASS="FUNCTION">BlessTupleDesc</CODE>传递这个<TT CLASS="STRUCTNAME">TupleDesc</TT>
然后为每行调用<CODE CLASS="FUNCTION">heap_form_tuple</CODE>。在使用C字符串的时候，
你给<CODE CLASS="FUNCTION">TupleDescGetAttInMetadata</CODE>
传递<TT CLASS="STRUCTNAME">TupleDesc</TT>，然后为每行调用<CODE CLASS="FUNCTION">BuildTupleFromCStrings</CODE>。
如果是返回一个行集合的场合，所有设置步骤都可以在第一次调用该函数的时候一次性完成。&#13;</P><P>
有几个便利函数可以用于设置所需要的<TT CLASS="STRUCTNAME">TupleDesc</TT>。
在大多数返回复合类型给调用者的函数里建议的做法是这样的：
</P><PRE CLASS="PROGRAMLISTING">TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)</PRE><P>
把传递给调用函数自己的<TT CLASS="LITERAL">fcinfo</TT>传递给它(要求使用版本-1 的调用习惯)。
<TT CLASS="VARNAME">resultTypeId</TT>可以声明为<TT CLASS="LITERAL">NULL</TT>或者
接收函数的结果类型OID的局部变量地址(指针)。
<TT CLASS="VARNAME">resultTupleDesc</TT>应该是一个局部的<TT CLASS="STRUCTNAME">TupleDesc</TT>变量地址(指针)。
检查结果是否<TT CLASS="LITERAL">TYPEFUNC_COMPOSITE</TT>；如是，
<TT CLASS="VARNAME">resultTupleDesc</TT>就已经填充好需要的<TT CLASS="STRUCTNAME">TupleDesc</TT>了。
如果不是，你可以报告一个类似<SPAN CLASS="QUOTE">"返回记录的函数在一个不接受记录的环境中被调用"</SPAN>的错误。
</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B> <CODE CLASS="FUNCTION">get_call_result_type</CODE>可以把一个多态的函数结果解析为实际类型；
因此它在返回多态的标量结果的函数里也很有用，而不仅仅是返回复合类型的函数里。
<TT CLASS="VARNAME">resultTypeId</TT>输出主要用于那些返回多态的标量类型的函数。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B> <CODE CLASS="FUNCTION">get_call_result_type</CODE>有一个同胞弟兄<CODE CLASS="FUNCTION">get_expr_result_type</CODE>
可以用于给一个用表达式树表示的函数调用解析输出，
它可以用于视图从函数本身外边判断结果类型的场合。
还有一个<CODE CLASS="FUNCTION">get_func_result_type</CODE>可以用在只能拿到函数OID的场合。
不过，这些函数不能处理那些声明为返回<TT CLASS="STRUCTNAME">record</TT>的函数，
并且<CODE CLASS="FUNCTION">get_func_result_type</CODE>不能解析多态的类型，
因此你最好还是使用<CODE CLASS="FUNCTION">get_call_result_type</CODE>。</P></BLOCKQUOTE></DIV><P>
旧的，现在已经废弃的获取<TT CLASS="STRUCTNAME">TupleDesc</TT>的函数是:
</P><PRE CLASS="PROGRAMLISTING">TupleDesc RelationNameGetTupleDesc(const char *relname)</PRE><P>
它可以从一个命名的关系里为行类型获取一个<TT CLASS="STRUCTNAME">TupleDesc</TT>，还有:
</P><PRE CLASS="PROGRAMLISTING">TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)</PRE><P>
可以基于类型 OID 获取一个<TT CLASS="STRUCTNAME">TupleDesc</TT>。
它可以用于给一个基本类型或者一个复合类型获取<TT CLASS="STRUCTNAME">TupleDesc</TT>。
不过它不能处理返回<TT CLASS="STRUCTNAME">record</TT>的函数，并且不能解析多态的类型。
</P><P>
一旦你有了一个<TT CLASS="STRUCTNAME">TupleDesc</TT>，那么调用:
</P><PRE CLASS="PROGRAMLISTING">TupleDesc BlessTupleDesc(TupleDesc tupdesc)</PRE><P>
如果你想使用Datum，或者：
</P><PRE CLASS="PROGRAMLISTING">AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)</PRE><P>
如果你想使用C字符串。如果你在写一个返回集合的函数，
那么你可以把这些函数的结果保存在<TT CLASS="STRUCTNAME">FuncCallContext</TT>结构里
(分别使用<TT CLASS="STRUCTFIELD">tuple_desc</TT>或者<TT CLASS="STRUCTFIELD">attinmeta</TT>字段)。
</P><P>
在使用Datum的时候，使用：
</P><PRE CLASS="PROGRAMLISTING">HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)</PRE><P>
制作一个<TT CLASS="STRUCTNAME">HeapTuple</TT>，它把数据以Datum的形式交给用户。
</P><P>
当使用C字符串时，使用：
</P><PRE CLASS="PROGRAMLISTING">HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)</PRE><P>
制作一个<TT CLASS="STRUCTNAME">HeapTuple</TT>，以C字符串的形式给出用户数据。
<TT CLASS="LITERAL">values</TT>是一个 C 字符串的数组，返回行的每个字段对应其中一个。
每个 C 字符串都应该是字段数据类型的输入函数预期的形式。
为了从其中一个字段中返回一个NULL，
<TT CLASS="PARAMETER">values</TT>数组中对应的指针应该设置为<TT CLASS="SYMBOL">NULL</TT>。
这个函数将会需要为你返回的每个行调用一次。
</P><P>
一旦你制作了一个从你的函数中返回的行，那么该行必须转换成一个<TT CLASS="TYPE">Datum</TT>。使用:
</P><PRE CLASS="PROGRAMLISTING">HeapTupleGetDatum(HeapTuple tuple)</PRE><P>
把一个<TT CLASS="STRUCTNAME">HeapTuple</TT>转换为一个有效的<TT CLASS="TYPE">Datum</TT>。
如果你想只返回一行，那么这个 Datum 可以用于直接返回，
或者是它可以用作在一个返回集合的函数里的当前返回值。
</P><P>
例子在下面给出。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="XFUNC-C-RETURN-SET">35.9.9. 返回集合</A></H2><P> 还有一个特殊的API用于提供从C语言函数中返回集合(多行)。
一个返回集合的函数必须遵循版本-1的调用方式。
同样，源代码必须包含<TT CLASS="FILENAME">funcapi.h</TT>，就像上面说的那样。</P><P>
一个返回集合的函数(<ACRONYM CLASS="ACRONYM">SRF</ACRONYM>)通常为它返回的每个项都调用一次。
因此<ACRONYM CLASS="ACRONYM">SRF</ACRONYM>必须保存足够的状态用于记住它正在做的事情以及在每次调用的时候返回下一个项。
表函数 API 提供了<TT CLASS="STRUCTNAME">FuncCallContext</TT>结构用于帮助控制这个过程。
<TT CLASS="LITERAL">fcinfo-&gt;flinfo-&gt;fn_extra</TT>
用于保存一个跨越多次调用的指向<TT CLASS="STRUCTNAME">FuncCallContext</TT>的指针。
</P><PRE CLASS="PROGRAMLISTING">typedef struct
{
    
 /*
     * 前面已经被调用的次数
     * 初始的时候，call_cntr 被 SRF_FIRSTCALL_INIT() 置为 0，
 *并且每次你调用 SRF_RETURN_NEXT() 的时候都递增
     */
    uint32 call_cntr;
    
/*
     * 可选的最大调用数量
     * 这里的 max_calls 只是为了方便，设置它也是可选的。
     * 如果没有设置，你必须提供可选的方法来知道函数何时结束。
     */ 
    uint32 max_calls;
     
/*
     * 指向结果槽位的可选指针
     * 这个数据类型已经过时，只用于向下兼容。也就是那些使用已废弃的TupleDescGetSlot()的用户定义 SRF
     */
    TupleTableSlot *slot;

/*
     * 可选的指向用户提供的杂项环境信息的指针
     * user_fctx 用做一个指向你自己的结构的指针，包含任意提供给你的函数的调用间的环境信息
     */
    void *user_fctx;
    
 
 /*
     * 可选的指向包含属性类型输入元信息的结构数组的指针
     * attinmeta 用于在返回行的时候(也就是说返回复合数据类型)
     * 在只返回基本(也就是标量)数据类型的时候并不需要。
     * 只有在你准备用 BuildTupleFromCStrings() 创建返回行的时候才需要它。
     */
 
    AttInMetadata *attinmeta;

 /*
     * 用于必须在多次调用间存活的结构的内存环境
     * multi_call_memory_ctx 是由 SRF_FIRSTCALL_INIT() 为你设置的，并且由 SRF_RETURN_DONE() 用于清理。
     * 它是用于存放任何需要跨越多次调用 SRF 之间重复使用的内存。
     */
    MemoryContext multi_call_memory_ctx;
    
/*
     * 可选的指针，指向包含行描述的结构
     * tuple_desc 用于返回行(也就是说复合数据类型)并且只是在你想使用 heap_form_tuple() 而不是 BuildTupleFromCStrings() 制作行的时候需要。
     * 请注意这里存储的 TupleDesc 指针通常应该先用 BlessTupleDesc() 处理。
     */
    TupleDesc tuple_desc;

} FuncCallContext;</PRE><P>
</P><P>
一个<ACRONYM CLASS="ACRONYM">SRF</ACRONYM>使用自动操作<TT CLASS="STRUCTNAME">FuncCallContext</TT>结构
(可以通过<TT CLASS="LITERAL">fn_extra</TT>找到)的若干个函数和宏。使用：
</P><PRE CLASS="PROGRAMLISTING">SRF_IS_FIRSTCALL()</PRE><P>
来判断你的函数是第一次调用还是后继的调用。只有在第一次调用的时候，使用：
</P><PRE CLASS="PROGRAMLISTING">SRF_FIRSTCALL_INIT()</PRE><P>
初始化<TT CLASS="STRUCTNAME">FuncCallContext</TT>。在每次函数调用时(包括第一次)，使用：
</P><PRE CLASS="PROGRAMLISTING">SRF_PERCALL_SETUP()</PRE><P>
为使用<TT CLASS="STRUCTNAME">FuncCallContext</TT>做恰当的设置以及清理任何前面的轮回里面剩下的已返回的数据。
</P><P>
如果你的函数有数据要返回，使用:
</P><PRE CLASS="PROGRAMLISTING">SRF_RETURN_NEXT(funcctx, result)</PRE><P>
返回给调用者(<TT CLASS="LITERAL">result</TT>必须是个<TT CLASS="TYPE">Datum</TT>，要么是单个值，
要么是像前面介绍的那样准备的行)。
最后，如果你的函数结束了数据返回，使用:
</P><PRE CLASS="PROGRAMLISTING">SRF_RETURN_DONE(funcctx)</PRE><P>
清理并结束<ACRONYM CLASS="ACRONYM">SRF</ACRONYM>。
</P><P> 在<ACRONYM CLASS="ACRONYM">SRF</ACRONYM>被调用时的内存环境是一个临时环境，
在调用之间将会被清理掉。
这意味着你不需要<CODE CLASS="FUNCTION">pfree</CODE>所有你<CODE CLASS="FUNCTION">palloc</CODE>的东西；它会自动消失的。
不过，如果你想分配任何跨越调用存在的数据结构，
那你就需要把它们放在其它什么地方。
被<TT CLASS="STRUCTFIELD">multi_call_memory_ctx</TT>引用的环境适合用于保存那些需要直到
<ACRONYM CLASS="ACRONYM">SRF</ACRONYM>结束前都存活的数据。在大多数情况下，
这意味着你在第一次调用设置的时候应该切换到<TT CLASS="STRUCTFIELD">multi_call_memory_ctx</TT>。</P><P>
一个完整的伪代码例子看起来像下面这样：
</P><PRE CLASS="PROGRAMLISTING">Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    
<TT
CLASS="REPLACEABLE"
><I
>更多的声明</I
></TT
>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
/* 这里放出现一次的设置代码: */
        <TT
CLASS="REPLACEABLE"
><I
>用户代码</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>if 返回复合</I
></TT
>
            <TT
CLASS="REPLACEABLE"
><I
>制作 TupleDesc 以及可能还有 AttInMetadata</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>endif 返回复合</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>用户定义代码</I
></TT
>
        MemoryContextSwitchTo(oldcontext);
    }

 
/* 每次都执行的设置代码在这里出现: */
    <TT
CLASS="REPLACEABLE"
><I
>用户定义代码</I
></TT
>
    funcctx = SRF_PERCALL_SETUP();
    <TT
CLASS="REPLACEABLE"
><I
>用户定义代码</I
></TT
>
    /* 这里只是用来测试是否完成的一个方法: */

    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
    

/* 这里想返回另外一个条目: */
        <TT
CLASS="REPLACEABLE"
><I
>用户代码</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>获取结果</I
></TT
>

        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
    

/* 这里完成返回条目的工作了，只需要清理就OK了: */
        <TT
CLASS="REPLACEABLE"
><I
>用户代码</I
></TT
>

        SRF_RETURN_DONE(funcctx);
    }
}</PRE><P>
</P><P>
一个返回复合类型的完整<ACRONYM CLASS="ACRONYM">SRF</ACRONYM>例子看起来像这样：
</P><PRE CLASS="PROGRAMLISTING">PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

/* 只是在第一次调用函数的时候干的事情 */

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

/*创建一个函数环境，用于在调用间保持住*/
        funcctx = SRF_FIRSTCALL_INIT();

/* 切换到适合多次函数调用的内存环境 */
        oldcontext = MemoryContextSwitchTo(funcctx-&#62;multi_call_memory_ctx);

/* 要返回的行总数 */
        funcctx-&#62;max_calls = PG_GETARG_UINT32(0);

 /* 为了结果类型制作一个行描述 */
        if (get_call_result_type(fcinfo, NULL, &#38;tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));
        
 /*
         * 生成稍后从裸 C 字符串生成行的属性元数据
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&#62;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

/* 每次函数调用都要做的事情 */

    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&#62;call_cntr;
    max_calls = funcctx-&#62;max_calls;
    attinmeta = funcctx-&#62;attinmeta;
  
if (call_cntr &#60; max_calls)    /* 在还有需要发送的东西时继续处理 */

    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

/*
         * 准备一个数值数组用于版本的返回行
         * 它应该是一个C字符串数组，稍后可以被合适的类型输入函数处理。
         */

        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

/* 制作一个行 */
        tuple = BuildTupleFromCStrings(attinmeta, values);

/* 把行做成 datum  */
        result = HeapTupleGetDatum(tuple);

/* 清理(这些实际上并非必要) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }

 else    /* 在没有数据残留的时候干的事情 */
    {
        SRF_RETURN_DONE(funcctx);
    }
}</PRE><P>
在 SQL 里声明这个函数的一个方法是：
</P><PRE CLASS="PROGRAMLISTING">CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE><P>
另外一个方法是使用 OUT 参数：
</P><PRE CLASS="PROGRAMLISTING">CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE><P>
请注意在这个方法里，函数的输出类型实际上是匿名的<TT CLASS="STRUCTNAME">record</TT>类型。
</P><P> 参阅源码发布包里的<A HREF="tablefunc.html">contrib/tablefunc</A>
获取更多有关返回集合的函数的例子。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN53853">35.9.10. 多态参数和返回类型</A></H2><P> C 语言函数可以声明为接受和返回多态的类型<TT CLASS="TYPE">anyelement</TT>，<TT CLASS="TYPE">anyarray</TT>，
<TT CLASS="TYPE">anynonarray</TT>,
<TT CLASS="TYPE">anyenum</TT>和<TT CLASS="TYPE">anyrange</TT>。
参阅<A HREF="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC">第 35.2.5 &#33410;</A>获取有关多态函数的更详细解释。
如果函数参数或者返回类型定义为多态类型，
那么函数的作者就无法预先知道他将收到的参数，以及需要返回的数据。
在<TT CLASS="FILENAME">fmgr.h</TT>里有两个过程，可以让版本-1 的 C 函数知道它的参数的确切数据类型以及
它需要返回的数据类型。这两个过程叫<TT CLASS="LITERAL">get_fn_expr_rettype(FmgrInfo *flinfo)</TT>和
<TT CLASS="LITERAL">get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</TT>。
它们返回结果或者参数的类型 OID，如果这些信息不可获取，则返回 InvalidOid 。
结构<TT CLASS="LITERAL">flinfo</TT>通常是以<TT CLASS="LITERAL">fcinfo-&gt;flinfo</TT>进行访问的。
参数<TT CLASS="LITERAL">argnum</TT>是以 0 为基的。
<CODE CLASS="FUNCTION">get_call_result_type</CODE>也可以替代<CODE CLASS="FUNCTION">get_fn_expr_rettype</CODE>。
还有<CODE CLASS="FUNCTION">get_fn_expr_variadic</CODE>用于找出是否调用包含明确的<TT CLASS="LITERAL">VARIADIC</TT>关键字。
对于<TT CLASS="LITERAL">VARIADIC "any"</TT>函数是最有用的，正如下面所述。</P><P>
比如，假设想写一个函数接受任意类型的一个元素，并且返回该类型的一个一维数组:
</P><PRE CLASS="PROGRAMLISTING">PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    

/* 获取提供的元素(要小心其为NULL的情况) */

    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);
    
/* 维数是1 */

    ndims = 1;
/* 有1个元素 */

    dims[0] = 1;
/* 数组下界是1 */

    lbs[0] = 1;


/* 获取有关元素类型需要的信息 */

    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);


 /* 然后制作数组 */ 

    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}</PRE><P>
</P><P>
下面的命令用SQL声明<CODE CLASS="FUNCTION">make_array</CODE>函数：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;</PRE><P>
</P><P> 有一个变种多态性，仅适用于C语言函数：他们可以声明采取类型
<TT CLASS="LITERAL">"any"</TT>的参数。（注意：这个类型名称必须是双引号，
因为它同时也是一个SQL的保留字）。类似于<TT CLASS="TYPE">anyelement</TT>除了它并不限制不同<TT CLASS="LITERAL">"any"</TT>
参数是相同类型，也没有帮助确定该函数的结果类型。一个C语言的函数也可以声明最后的参数为<TT CLASS="LITERAL">VARIADIC "any"</TT>。
这将匹配一个或多个任意类型的实参（不一定是相同的类型）。
这些参数<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不</I></SPAN>被收集到一个数组中如发生正常的可变参数函数；
他们会分别被传递到函数中。<CODE CLASS="FUNCTION">PG_NARGS()</CODE>宏和
上面描述的方法必须被用来确定实际参数数目
以及使用此功能时的类型。同时，这个函数的用户可能希望在函数调用中使用<TT CLASS="LITERAL">VARIADIC</TT>关键字，
以期望函数把数组元素看作单独的参数。函数本身必须实现
想要的操作，使用<CODE CLASS="FUNCTION">get_fn_expr_variadic</CODE>之后
检测实际参数被标记为<TT CLASS="LITERAL">VARIADIC</TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="XFUNC-TRANSFORM-FUNCTIONS">35.9.11. 转换函数</A></H2><P> 一些函数的调用可以在规划中基于函数的属性特性被简化。比如，
<TT CLASS="LITERAL">int4mul(n, 1)</TT>可简化为<TT CLASS="LITERAL">n</TT>。
为了定义函数-特定优化，写<I CLASS="FIRSTTERM">transform function</I>并将其OID放入
基函数的<TT CLASS="STRUCTNAME">pg_proc</TT>项的<TT CLASS="STRUCTFIELD">protransform</TT>字段中，
转换函数必须有SQL签名<TT CLASS="LITERAL">protransform(internal) RETURNS internal</TT>。
参数，其实<TT CLASS="TYPE">FuncExpr *</TT>是代表调用基函数的一个虚拟节点。
如果表达式树的变换函数的研究证明简化的表达式树可以替代所有
可能的具体调用其表示建立并且返回简单的表达式。
否则，返回<TT CLASS="LITERAL">NULL</TT>指针(<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不是</I></SPAN>SQL null)。</P><P> 我们不做任何保证，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不会调用这种情况下的主要函数以简化转换函数。
确保在简化的表达式以及实际调用主要函数之间的严格等价性。</P><P>
当前，这个设施在SQL水平上不暴露给用户，出于安全考虑。因此只有实践中用于优化内置函数。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN53904">35.9.12. 共享内存和LWLocks</A></H2><P>
插件可能保留 LWLocks 并在服务器启动时分配共享内存。
插件的共享库必须通过指定<A HREF="runtime-config-resource.html#GUC-SHARED-PRELOAD-LIBRARIES">shared_preload_libraries</A>的方法预先加载。
</P><PRE CLASS="PROGRAMLISTING">void RequestAddinShmemSpace(int size)</PRE><P>
共享内存可以通过在<CODE CLASS="FUNCTION">_PG_init</CODE>函数中调用。
</P><P>
LWLocks通过调用进行预留：
</P><PRE CLASS="PROGRAMLISTING">void RequestAddinLWLocks(int n)</PRE><P>
来自<CODE CLASS="FUNCTION">_PG_init</CODE>。
</P><P>
为了避免可能的竞争条件，当连接并且初始化共享内存分配时，
每个后端应该使用LWLock <CODE CLASS="FUNCTION">AddinShmemInitLock</CODE>，如下所示：
</P><PRE CLASS="PROGRAMLISTING">static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr-&#62;mylockid = LWLockAssign();
        }
        LWLockRelease(AddinShmemInitLock);
}</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="EXTEND-CPP">35.9.13. 使用C++的可扩展性</A></H2><P>
尽管<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>后端以C写入，如果伴随这些准则，
在C++中写入扩展是可能的：
<P></P></P><UL><LI><P>
所有被后端访问的函数必须提供到后端的C接口；
这些C函数然后调用C++函数。比如，<TT CLASS="LITERAL">extern C</TT>联系
</P></LI><LI><P> 使用合适的存储单元分配方法释放内存。比如，使用<CODE CLASS="FUNCTION">palloc()</CODE>分配大部分后端内存，
因此使用<CODE CLASS="FUNCTION">pfree()</CODE>释放它。在这种情况下使用C++ <CODE CLASS="FUNCTION">delete</CODE>将失败。</P></LI><LI><P> 防止异常传播到C代码（使用捕获所有<TT CLASS="LITERAL">extern C</TT>函数的最高水平上的块）。
即使是C++代码没有明确地抛出异常，这是必要的，由于事件比如内存不足仍然可以抛出异常。
任何异常必须被捕获，并且将适当的错误传递给C接口。如果可能的话，编译C++
<TT CLASS="OPTION">-fno-exceptions</TT>以完全消除异常；在这样的案例中，
你必须检查你的C++代码的错误，比如检查通过<CODE CLASS="FUNCTION">new()</CODE>返回的NULL。</P></LI><LI><P> 如果从C++代码中调用后端函数，确保C++调用堆栈中只包含纯旧的数据结构(<ACRONYM CLASS="ACRONYM">POD</ACRONYM>)。
这是必要的因为后端错误产生一个遥远的<CODE CLASS="FUNCTION">longjmp()</CODE>，不适当的展开与非-POD对象的C++
调用堆栈。</P></LI></UL><P>
</P><P> 总之，把C++代码放在与后端接口的<TT CLASS="LITERAL">extern C</TT>函数之后是最好的，
并且避免异常，内存以及调用堆栈泄露。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="xfunc-internal.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="xaggr.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">内部函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">用户定义聚集</TD></TR></TABLE></DIV></BODY></HTML>
