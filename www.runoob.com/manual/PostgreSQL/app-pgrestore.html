<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pg_restore</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PostgreSQL 客户端应用程序" HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html"><LINK REL="PREVIOUS" TITLE="pg_receivexlog" HREF="app-pgreceivexlog.html"><LINK REL="NEXT" TITLE="psql" HREF="app-psql.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/pg_restore.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_receivexlog" HREF="app-pgreceivexlog.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="psql" HREF="app-psql.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="APP-PGRESTORE"></A>pg_restore</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN85757"></A><H2>&#21517;&#31216;</H2>pg_restore&nbsp;--&nbsp;
从<SPAN CLASS="APPLICATION">pg_dump</SPAN>创建的备份文件中恢复<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>数据库
</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN85764"></A><H2>&#22823;&#32434;</H2><P><TT CLASS="COMMAND">pg_restore</TT> [<TT CLASS="REPLACEABLE"><I>connection-option</I></TT>...] [<TT CLASS="REPLACEABLE"><I>option</I></TT>...] [<TT CLASS="REPLACEABLE"><I>filename</I></TT>]</P></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PGRESTORE-DESCRIPTION"></A><H2>描述</H2><P><SPAN CLASS="APPLICATION">pg_restore</SPAN>用于恢复由<A HREF="app-pgdump.html">pg_dump</A>
转储的任何非纯文本格式中的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>数据库。
它将发出必要的命令重建数据库，并把它恢复成转储时的样子。
归档(备份)文件还允许<SPAN CLASS="APPLICATION">pg_restore</SPAN>有选择地进行恢复，
甚至在恢复前重新排列条目的顺序。归档的文件设计成可以在不同的硬件体系之间移植。</P><P><SPAN CLASS="APPLICATION">pg_restore</SPAN>可以按照两种模式操作。如果声明了数据库名字，
那么<SPAN CLASS="APPLICATION">pg_restore</SPAN>连接到那个数据库并直接恢复归档内容到数据库里。
否则，先创建一个包含重建数据库所必须的 SQL 命令的脚本，并且写入到一个文件或者标准输出。
这个脚本输出等效于<SPAN CLASS="APPLICATION">pg_dump</SPAN>的纯文本输出格式。因此，
一些控制输出的选项就是模拟<SPAN CLASS="APPLICATION">pg_dump</SPAN>的选项设置的。</P><P>显然，<SPAN CLASS="APPLICATION">pg_restore</SPAN>无法恢复那些不存在归档文件中的信息；比如，
如果归档是用<SPAN CLASS="QUOTE">"把数据转储为<TT CLASS="COMMAND">INSERT</TT>命令"</SPAN>选项制作的，
那么<SPAN CLASS="APPLICATION">pg_restore</SPAN>将不能使用<TT CLASS="COMMAND">COPY</TT>语句加载数据。</P></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PGRESTORE-OPTIONS"></A><H2>选项</H2><P><SPAN CLASS="APPLICATION">pg_restore</SPAN>接受下列命令行参数：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>filename</I></TT></DT><DD><P>要恢复的备份文件（或目录，对于目录格式归档）的位置。如果没有声明，则使用标准输入。</P></DD><DT><TT CLASS="OPTION">-a</TT><BR><TT CLASS="OPTION">--data-only</TT></DT><DD><P>只恢复数据，而不恢复表模式(数据定义)。恢复表数据、大对象和序列值，如果在档案中存在。</P><P>这个选项类似于，但是由于历史原因不等于声明<TT CLASS="OPTION">--section=data</TT>。</P></DD><DT><TT CLASS="OPTION">-c</TT><BR><TT CLASS="OPTION">--clean</TT></DT><DD><P>创建数据库对象前先清理(删除)它们。（如果任一对象不在目标数据库中，
这可能会产生一些无害的错误信息。）</P></DD><DT><TT CLASS="OPTION">-C</TT><BR><TT CLASS="OPTION">--create</TT></DT><DD><P>在恢复数据库之前先创建它。如果也声明了<TT CLASS="OPTION">--clean</TT>，
那么在连接到数据库之前删除并重建目标数据库。</P><P>如果出现了这个选项，和<TT CLASS="OPTION">-d</TT>在一起的数据库名只是用于发出最初的
<TT CLASS="COMMAND">DROP DATABASE</TT>和<TT CLASS="COMMAND">CREATE DATABASE</TT>命令。
所有数据都恢复到名字出现在归档中的数据库中去。</P></DD><DT><TT CLASS="OPTION">-d <TT CLASS="REPLACEABLE"><I>dbname</I></TT></TT><BR><TT CLASS="OPTION">--dbname=<TT CLASS="REPLACEABLE"><I>dbname</I></TT></TT></DT><DD><P>与数据库<TT CLASS="REPLACEABLE"><I>dbname</I></TT>连接并且直接恢复到该数据库中。</P></DD><DT><TT CLASS="OPTION">-e</TT><BR><TT CLASS="OPTION">--exit-on-error</TT></DT><DD><P>如果在向数据库发送 SQL 命令的时候碰到错误，则退出。
缺省是继续执行并且在恢复结束时显示一个错误计数。</P></DD><DT><TT CLASS="OPTION">-f <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT><BR><TT CLASS="OPTION">--file=<TT CLASS="REPLACEABLE"><I>filename</I></TT></TT></DT><DD><P>指定生成的脚本的输出文件，或者出现<TT CLASS="OPTION">-l</TT>选项时用于列表的文件，
缺省是标准输出。</P></DD><DT><TT CLASS="OPTION">-F <TT CLASS="REPLACEABLE"><I>format</I></TT></TT><BR><TT CLASS="OPTION">--format=<TT CLASS="REPLACEABLE"><I>format</I></TT></TT></DT><DD><P>指定备份文件的格式。因为<SPAN CLASS="APPLICATION">pg_restore</SPAN>会自动判断格式，
所以如果一定要指定的话，它可以是下面之一：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">c</TT><BR><TT CLASS="LITERAL">custom</TT></DT><DD><P>备份的格式是来自<SPAN CLASS="APPLICATION">pg_dump</SPAN>的自定义格式。</P></DD><DT><TT CLASS="LITERAL">d</TT><BR><TT CLASS="LITERAL">directory</TT></DT><DD><P>备份是一个目录归档。</P></DD><DT><TT CLASS="LITERAL">t</TT><BR><TT CLASS="LITERAL">tar</TT></DT><DD><P>备份是一个<TT CLASS="COMMAND">tar</TT>归档。</P></DD></DL></DIV><P></P></DD><DT><TT CLASS="OPTION">-i</TT><BR><TT CLASS="OPTION">--ignore-version</TT></DT><DD><P>一个现在已经忽略了的已废弃的选项。</P></DD><DT><TT CLASS="OPTION">-I <TT CLASS="REPLACEABLE"><I>index</I></TT></TT><BR><TT CLASS="OPTION">--index=<TT CLASS="REPLACEABLE"><I>index</I></TT></TT></DT><DD><P>只恢复命名的索引。</P></DD><DT><TT CLASS="OPTION">-j <TT CLASS="REPLACEABLE"><I>number-of-jobs</I></TT></TT><BR><TT CLASS="OPTION">--jobs=<TT CLASS="REPLACEABLE"><I>number-of-jobs</I></TT></TT></DT><DD><P>运行<SPAN CLASS="APPLICATION">pg_restore</SPAN>耗时最多的部分，该部分使用多重并发工作加载数据、
创建索引或创建约束。这个选项可以显著的减少恢复一个大数据库到一个运行多重处理器服务器的时间。</P><P>每个工作是一个过程或一个线程，取决于操作系统，并使用一个单独到服务器的连接。</P><P>该选项的最佳值依赖于服务器、客户端和网络的硬件设置。因素包含CPU内核的数量和磁盘设置。
良好的开端是服务器上CPU内核的数量，但是较大的值在许多情况下也可以更快的恢复。
当然，太高的值因为超负荷将会导致性能降低。</P><P>该选项只支持自定义和目录归档格式。输入必须是有规律的文件或目录（例如不是通道）。
发出一个脚本而不是连接目录到一个数据库服务器时忽略该选项。还有，
多重工作不能与<TT CLASS="OPTION">--single-transaction</TT>选项一起使用。</P></DD><DT><TT CLASS="OPTION">-l</TT><BR><TT CLASS="OPTION">--list</TT></DT><DD><P>列出备份的内容。这个操作的输出可以用作<TT CLASS="OPTION">-L</TT>选项的输入。
请注意，如果过滤开关如<TT CLASS="OPTION">-n</TT>或<TT CLASS="OPTION">-t</TT>和<TT CLASS="OPTION">-l</TT>一起使用，
它们将限制列出的条目。</P></DD><DT><TT CLASS="OPTION">-L <TT CLASS="REPLACEABLE"><I>list-file</I></TT></TT><BR><TT CLASS="OPTION">--use-list=<TT CLASS="REPLACEABLE"><I>list-file</I></TT></TT></DT><DD><P>以它们在文件中出现的顺序只恢复在<TT CLASS="REPLACEABLE"><I>list-file</I></TT>里面的元素。
请注意，如果过滤开关如<TT CLASS="OPTION">-n</TT>或<TT CLASS="OPTION">-t</TT>和<TT CLASS="OPTION">-l</TT>一起使用，
它们将进一步的限制恢复的条目。</P><P><TT CLASS="REPLACEABLE"><I>list-file</I></TT>通常通过编辑先前<TT CLASS="OPTION">-l</TT>
操作的输出来创建。你可以移动或删除各个行并且也可以通过在行开头放置分号
(<TT CLASS="LITERAL">;</TT>)的方式注释。例子见下文。</P></DD><DT><TT CLASS="OPTION">-n <TT CLASS="REPLACEABLE"><I>namespace</I></TT></TT><BR><TT CLASS="OPTION">--schema=<TT CLASS="REPLACEABLE"><I>schema</I></TT></TT></DT><DD><P>只恢复指定名字的模式里面的对象。这个选项可以和<TT CLASS="OPTION">-t</TT>选项一起使用，
实现只转储一个表的数据。</P></DD><DT><TT CLASS="OPTION">-O</TT><BR><TT CLASS="OPTION">--no-owner</TT></DT><DD><P>不要输出设置对象权限与最初数据库匹配的命令。缺省时，<SPAN CLASS="APPLICATION">pg_restore</SPAN>
发出<TT CLASS="COMMAND">ALTER OWNER</TT>或<TT CLASS="COMMAND">SET SESSION AUTHORIZATION</TT>
语句设置创建出来的模式元素的所有者权限。如果最初的数据库连接不是由超级用户
(或者是拥有所有创建出来的对象的同一个用户)发起的，那么这些语句将失败。
如果使用<TT CLASS="OPTION">-O</TT>，那么任何用户都可以用于初始的连接，
并且这个用户将拥有所有创建出来的对象。</P></DD><DT><TT CLASS="OPTION">-P <TT CLASS="REPLACEABLE"><I>function-name(argtype [, ...])</I></TT></TT><BR><TT CLASS="OPTION">--function=<TT CLASS="REPLACEABLE"><I>function-name(argtype [, ...])</I></TT></TT></DT><DD><P>只恢复指定的命名函数。请注意仔细拼写函数名及其参数，应该和转储的内容列表中的完全一样。</P></DD><DT><TT CLASS="OPTION">-R</TT><BR><TT CLASS="OPTION">--no-reconnect</TT></DT><DD><P>这个选项已经废弃了，但是为了保持向下兼容仍然接受。</P></DD><DT><TT CLASS="OPTION">-s</TT><BR><TT CLASS="OPTION">--schema-only</TT></DT><DD><P>只恢复表结构(数据定义)，不恢复数据，在这个意义上来说在归档里有模式的记录。</P><P>这个选项是<TT CLASS="OPTION">--data-only</TT>的相反。它类似于，但是因为历史原因不等于声明
<TT CLASS="OPTION">--section=pre-data --section=post-data</TT>。</P><P>请不要和<TT CLASS="OPTION">--schema</TT>选项混淆，那里使用了<SPAN CLASS="QUOTE">"模式"</SPAN>(schema)的其它含义。</P></DD><DT><TT CLASS="OPTION">-S <TT CLASS="REPLACEABLE"><I>username</I></TT></TT><BR><TT CLASS="OPTION">--superuser=<TT CLASS="REPLACEABLE"><I>username</I></TT></TT></DT><DD><P>设置关闭触发器时使用的超级用户的用户名。只有在设置了<TT CLASS="OPTION">--disable-triggers</TT>
的时候才有用。</P></DD><DT><TT CLASS="OPTION">-t <TT CLASS="REPLACEABLE"><I>table</I></TT></TT><BR><TT CLASS="OPTION">--table=<TT CLASS="REPLACEABLE"><I>table</I></TT></TT></DT><DD><P>只恢复指定的表的定义和/或数据。可以声明多个<TT CLASS="OPTION">-t</TT>指定多个表。
可以和<TT CLASS="OPTION">-n</TT>选项组合以声明一个模式。</P></DD><DT><TT CLASS="OPTION">-T <TT CLASS="REPLACEABLE"><I>trigger</I></TT></TT><BR><TT CLASS="OPTION">--trigger=<TT CLASS="REPLACEABLE"><I>trigger</I></TT></TT></DT><DD><P>只恢复指定的触发器。</P></DD><DT><TT CLASS="OPTION">-v</TT><BR><TT CLASS="OPTION">--verbose</TT></DT><DD><P>声明冗余模式。</P></DD><DT><TT CLASS="OPTION">-V</TT><BR><TT CLASS="OPTION">--version</TT></DT><DD><P>打印<SPAN CLASS="APPLICATION">pg_restore</SPAN>的版本然后退出。</P></DD><DT><TT CLASS="OPTION">-x</TT><BR><TT CLASS="OPTION">--no-privileges</TT><BR><TT CLASS="OPTION">--no-acl</TT></DT><DD><P>禁止恢复访问权限(grant/revoke 命令)。</P></DD><DT><TT CLASS="OPTION">-1</TT><BR><TT CLASS="OPTION">--single-transaction</TT></DT><DD><P>将整个恢复过程作为一个完整的事务来执行，也就是将所有恢复命令放在
<TT CLASS="COMMAND">BEGIN</TT>/<TT CLASS="COMMAND">COMMIT</TT>之间。这将保证恢复要么全部成功要么没有任何影响。
该选项隐含<TT CLASS="OPTION">--exit-on-error</TT>。</P></DD><DT><TT CLASS="OPTION">--disable-triggers</TT></DT><DD><P>这个选项只有在执行仅恢复数据的时候才相关。它告诉<SPAN CLASS="APPLICATION">pg_restore</SPAN>
在加载数据的时候执行一些命令临时关闭在目标表上的触发器。
如果你在表上有完整性检查或者其它触发器，而你又不希望在加载数据的时候激活它们，
那么可以使用这个选项。</P><P>目前，为<TT CLASS="OPTION">--disable-triggers</TT>发出的命令必须以超级用户发出。因此，
你应该也要用<TT CLASS="OPTION">-S</TT>声明一个超级用户名，或者更好是以超级用户身份运行
<SPAN CLASS="APPLICATION">pg_restore</SPAN>。</P></DD><DT><TT CLASS="OPTION">--no-data-for-failed-tables</TT></DT><DD><P>缺省时，即使创建表的命令因为该表已经存在而失败了，表中的数据仍将被恢复。
使用这个选项之后，这些表的数据就将跳过恢复操作。
如果目标数据库已经包含所需恢复的某些表的内容时，该选项就很有用处了。
比如，用于<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扩展的辅助表(例如<SPAN CLASS="PRODUCTNAME">PostGIS</SPAN>)
就可能已经在目标数据库中恢复过了，
使用该选项就可以防止多次恢复以致重复或者覆盖了已经恢复的数据。</P><P>该选项仅在直接向一个数据库中恢复的时候有效，在生成 SQL 脚本输出时无效。</P></DD><DT><TT CLASS="OPTION">--no-security-labels</TT></DT><DD><P>不要输出恢复安全标签的命令，即使归档包含它们。</P></DD><DT><TT CLASS="OPTION">--no-tablespaces</TT></DT><DD><P>不要输出选择表空间的命令。有这个选项，在恢复期间所有的对象都将在缺省表空间中创建。</P></DD><DT><TT CLASS="OPTION">--section=<TT CLASS="REPLACEABLE"><I>sectionname</I></TT></TT></DT><DD><P>值恢复指定的章节。章节名可以是<TT CLASS="OPTION">pre-data</TT>, <TT CLASS="OPTION">data</TT>, 或
<TT CLASS="OPTION">post-data</TT>。可以多次声明这个选项以选择多个章节。缺省是恢复所有章节。</P><P>数据章节包含实际的表数据和大对象定义。原始数据项包含索引、触发器、规则和约束
（除了验证检查约束）的定义。先前的数据项包含所有其他数据定义项。</P></DD><DT><TT CLASS="OPTION">--use-set-session-authorization</TT></DT><DD><P>输出 SQL 标准的<TT CLASS="COMMAND">SET SESSION AUTHORIZATION</TT>命令，而不是
<TT CLASS="COMMAND">ALTER OWNER</TT>命令来确定对象的所有权。这样令转储与标准兼容的更好，
但是根据转储中对象的历史，这个转储可能不能恰当地恢复。</P></DD><DT><TT CLASS="OPTION">-?</TT><BR><TT CLASS="OPTION">--help</TT></DT><DD><P>显示关于<SPAN CLASS="APPLICATION">pg_restore</SPAN>命令行参数的帮助然后退出。</P></DD></DL></DIV><P>
</P><P><SPAN CLASS="APPLICATION">pg_restore</SPAN>还接受下面的命令行参数做为连接参数：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-h <TT CLASS="REPLACEABLE"><I>host</I></TT></TT><BR><TT CLASS="OPTION">--host=<TT CLASS="REPLACEABLE"><I>host</I></TT></TT></DT><DD><P>指定运行服务器的主机名。如果数值以斜杠开头，则被用作到 Unix 域套接字的路径。
缺省从<TT CLASS="ENVAR">PGHOST</TT>环境变量中获取(如果设置了的话)，否则，
尝试一个 Unix 域套接字连接。</P></DD><DT><TT CLASS="OPTION">-p <TT CLASS="REPLACEABLE"><I>port</I></TT></TT><BR><TT CLASS="OPTION">--port=<TT CLASS="REPLACEABLE"><I>port</I></TT></TT></DT><DD><P>指定服务器正在侦听的 TCP 端口或本地 Unix 域套接字文件的扩展(描述符)。
缺省使用<TT CLASS="ENVAR">PGPORT</TT>环境变量(如果设置了的话)，否则，编译时的缺省值。</P></DD><DT><TT CLASS="OPTION">-U <TT CLASS="REPLACEABLE"><I>username</I></TT></TT><BR><TT CLASS="OPTION">--username=<TT CLASS="REPLACEABLE"><I>username</I></TT></TT></DT><DD><P>要连接的用户名。</P></DD><DT><TT CLASS="OPTION">-w</TT><BR><TT CLASS="OPTION">--no-password</TT></DT><DD><P>从不发出密码提示问题。如果服务器要求密码认证并且密码不可用于其他意思如
<TT CLASS="FILENAME">.pgpass</TT>文件，则连接尝试将会失败。
该选项在批量工作和不存在用户输入密码的脚本中很有帮助。</P></DD><DT><TT CLASS="OPTION">-W</TT><BR><TT CLASS="OPTION">--password</TT></DT><DD><P>强制<SPAN CLASS="APPLICATION">pg_restore</SPAN>在连接到数据库之前提示一个密码。</P><P>这个选项从来不是至关重要的，因为如果服务器需求密码认证，则<SPAN CLASS="APPLICATION">pg_restore</SPAN>
自动提示一个密码。不过，<SPAN CLASS="APPLICATION">pg_restore</SPAN>
将在找出服务器想要一个密码上浪费一个连接尝试。在某些情况下，值得输入<TT CLASS="OPTION">-W</TT>
以避免额外的连接尝试。</P></DD><DT><TT CLASS="OPTION">--role=<TT CLASS="REPLACEABLE"><I>rolename</I></TT></TT></DT><DD><P>指定执行转储的角色名。这个选项导致连接到数据库之后<SPAN CLASS="APPLICATION">pg_restore</SPAN>
发出一个<TT CLASS="COMMAND">SET ROLE</TT> <TT CLASS="REPLACEABLE"><I>rolename</I></TT>命令。
当认证的用户（通过<TT CLASS="OPTION">-U</TT>指定）缺乏<SPAN CLASS="APPLICATION">pg_restore</SPAN>所需的权限时是很有用的，
可以转变成有所需权限的角色。一些安装有反对作为超级用户直接登录的政策，
使用这个选项允许转储不违反该政策。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN86178"></A><H2>环境变量</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="ENVAR">PGHOST</TT><BR><TT CLASS="ENVAR">PGOPTIONS</TT><BR><TT CLASS="ENVAR">PGPORT</TT><BR><TT CLASS="ENVAR">PGUSER</TT></DT><DD><P>缺省连接参数。</P></DD></DL></DIV><P>这个功用，类似大多数其他<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>实用工具，
也使用由<SPAN CLASS="APPLICATION">libpq</SPAN>支持的环境变量（参阅<A HREF="libpq-envars.html">第 31.14 &#33410;</A>）。
不过，当没有提供数据库名字时，并不读取<TT CLASS="ENVAR">PGDATABASE</TT>。</P></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PGRESTORE-DIAGNOSTICS"></A><H2>诊断</H2><P>当使用<TT CLASS="OPTION">-d</TT>选项声明了直接数据库连接时，
<SPAN CLASS="APPLICATION">pg_restore</SPAN>在内部执行<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>语句。
如果你运行<SPAN CLASS="APPLICATION">pg_restore</SPAN>出了毛病，
请确保你能用类似<A HREF="app-psql.html"><SPAN CLASS="APPLICATION">psql</SPAN></A>这样的东西从数据库中选取信息。
还有，将会应用<SPAN CLASS="APPLICATION">libpq</SPAN>前端库使用的任何缺省连接设置和环境变量。</P></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PGRESTORE-NOTES"></A><H2>注意</H2><P>如果你的安装给<TT CLASS="LITERAL">template1</TT>数据库增加了任何你自己的东西，
那么请注意把<SPAN CLASS="APPLICATION">pg_restore</SPAN>的输出恢复到一个真正空的数据库中；
否则你可能会收到因为重复定义所追加的对象而造成的错误信息。
要制作一个没有任何本地附属物的数据库，可以从<TT CLASS="LITERAL">template0</TT>而不是
<TT CLASS="LITERAL">template1</TT>拷贝，比如：
</P><PRE CLASS="PROGRAMLISTING">CREATE DATABASE foo WITH TEMPLATE template0;</PRE><P></P><P><SPAN CLASS="APPLICATION">pg_restore</SPAN>的局限如下：
<P></P></P><UL><LI><P>当向一个已经存在的表恢复数据，并且还使用了<TT CLASS="OPTION">--disable-triggers</TT>选项时，
<SPAN CLASS="APPLICATION">pg_restore</SPAN>在插入数据前放出一些查询关闭用户表上的触发器，
在数据插入完成后重新打开它们。如果恢复的中途停止，那么系统表可能处于错误状态。</P></LI><LI><P><SPAN CLASS="APPLICATION">pg_restore</SPAN>不能选择性的的恢复大对象。
例如，只恢复指定的表。如果一个归档包含大对象，那么所有大对象都将被恢复，
或如果他们通过<TT CLASS="OPTION">-L</TT>、<TT CLASS="OPTION">-t</TT>或其他选项排除则一个也不恢复。</P></LI></UL><P>
</P><P>参阅<A HREF="app-pgdump.html">pg_dump</A>的文挡获取有关<SPAN CLASS="APPLICATION">pg_dump</SPAN>的局限的细节。</P><P>一旦完成恢复，最好在每个恢复的对象上运行<TT CLASS="COMMAND">ANALYZE</TT>，
以便给优化器有用的统计。参阅<A HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS">第 23.1.3 &#33410;</A>
和<A HREF="routine-vacuuming.html#AUTOVACUUM">第 23.1.6 &#33410;</A>获取更多信息。</P></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PGRESTORE-EXAMPLES"></A><H2>例子</H2><P>假定我们已经转储了<TT CLASS="LITERAL">mydb</TT>数据库到一个自定义格式的文件中：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_dump -Fc mydb &gt; db.dump</KBD
></PRE><P></P><P>删除该数据库并从转储中重建：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>dropdb mydb</KBD
>
<SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_restore -C -d postgres db.dump</KBD
></PRE><P>
在<TT CLASS="OPTION">-d</TT>中指定的数据库可以是当前集群中的任意数据库；<SPAN CLASS="APPLICATION">pg_restore</SPAN>
仅用该名字来为<TT CLASS="LITERAL">mydb</TT>发出<TT CLASS="COMMAND">CREATE DATABASE</TT>命令。
使用<TT CLASS="OPTION">-C</TT>可以确保数据总是会被恢复到转储文件中指定名字的数据库里面。</P><P>将转储出来的数据重新加载到一个新建的数据库<TT CLASS="LITERAL">newdb</TT>中：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>createdb -T template0 newdb</KBD
>
<SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_restore -d newdb db.dump</KBD
></PRE><P>
注意，这里没有使用<TT CLASS="OPTION">-C</TT>选项，而是直接链接到将要恢复的数据库上。
还要注意的是，我们从<TT CLASS="LITERAL">template0</TT>而不是<TT CLASS="LITERAL">template1</TT>
创建了新数据库以确保干净。</P><P>要对项目重新排序，首先必须转储归档的目录：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_restore -l db.dump &gt; db.list</KBD
></PRE><P>
这个文件由一行头和每个条目一行组成，比如：
</P><PRE CLASS="PROGRAMLISTING">;
; Archive created at Mon Sep 14 13:55:39 2009
;     dbname: DBDEMOS
;     TOC Entries: 81
;     Compression: 9
;     Dump Version: 1.10-0
;     Format: CUSTOM
;     Integer: 4 bytes
;     Offset: 8 bytes
;     Dumped from database version: 8.3.5
;     Dumped by pg_dump version: 8.3.8
;
;
; Selected TOC Entries:
;
3; 2615 2200 SCHEMA - public pasha
1861; 0 0 COMMENT - SCHEMA public pasha
1862; 0 0 ACL - public pasha
317; 1247 17715 TYPE public composite pasha
319; 1247 25899 DOMAIN public domain0 pasha</PRE><P>
这里分号是注释分隔符，而行开头的数字代表赋给每个项目的内部归档 ID 。
</P><P>文件内的行可以注释、删除和/或重新排列。比如：
</P><PRE CLASS="PROGRAMLISTING">10; 145433 TABLE map_resolutions postgres
;2; 145344 TABLE species postgres
;4; 145359 TABLE nt_header postgres
6; 145402 TABLE species_records postgres
;8; 145416 TABLE ss_old postgres</PRE><P>
可以用做<SPAN CLASS="APPLICATION">pg_restore</SPAN>的输入并且只会恢复项目 10 和 6 (以这个顺序)：
</P><PRE CLASS="SCREEN"><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>pg_restore -L db.list db.dump</KBD
></PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN86272"></A><H2>又见</H2><A HREF="app-pgdump.html">pg_dump</A>, <A HREF="app-pg-dumpall.html"><SPAN CLASS="APPLICATION">pg_dumpall</SPAN></A>, <A HREF="app-psql.html"><SPAN CLASS="APPLICATION">psql</SPAN></A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="app-pgreceivexlog.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="app-psql.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">pg_receivexlog</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><SPAN CLASS="APPLICATION">psql</SPAN></TD></TR></TABLE></DIV></BODY></HTML>
