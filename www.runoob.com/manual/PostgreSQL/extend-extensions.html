<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>包装相关对象到一个扩展</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="扩展SQL" HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html"><LINK REL="PREVIOUS" TITLE="扩展索引接口" HREF="xindex.html"><LINK REL="NEXT" TITLE="扩展基础设施建设" HREF="extend-pgxs.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/extend.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="扩展索引接口" HREF="xindex.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 35. 扩展<ACRONYM CLASS="ACRONYM">SQL</ACRONYM></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="扩展基础设施建设" HREF="extend-pgxs.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="EXTEND-EXTENSIONS">35.15. 包装相关对象到一个扩展</A></H1><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的一个有用扩展通常包括
多个SQL对象；例如，一个新的数据类型将需要新的函数，新的操作符，以及可能的新的索引操作类。
为了简化数据库管理有助于收集所有这些对象到一个单一的包。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>调用这样的包如<I CLASS="FIRSTTERM">extension</I>。为了定义一个扩展，
你至少需要一个<I CLASS="FIRSTTERM">脚本文件</I>包含<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令以创建扩展的对象，并且
<I CLASS="FIRSTTERM">控制文件</I>指定扩展本身的几个基本性质。如果扩展包括C代码，
通常也是一个共享库文件的已经编译的C代码。
一旦你有了这些文件，一个简单的<A HREF="sql-createextension.html">CREATE EXTENSION</A>命令加载对象到你的数据库。</P><P> 使用一个扩展的主要优点，不是运行
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>脚本加载一组<SPAN CLASS="QUOTE">"loose"</SPAN>对象到
你的数据库，而是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将一起了解扩展的对象。
你可以删除使用单独<A HREF="sql-dropextension.html">DROP EXTENSION</A>命令的
所有的对象（不需要维护一个单独的<SPAN CLASS="QUOTE">"卸载"</SPAN>脚本）。
更有用的，<SPAN CLASS="APPLICATION">pg_dump</SPAN>知道
它不应该转储扩展的单个成员对象&mdash;；
它会只包括<TT CLASS="COMMAND">CREATE EXTENSION</TT>命令创建扩展。
这大大简化了迁移到一个新的扩展版本，
可能含有比旧版本更多的或不同的对象。
但是请注意，当装载转储到一个新的数据库的时候，你必须有扩展的控制，脚本，以及
其他可用的文件。</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不会让你删除
包含在扩展中的单独的对象，除了减少整个扩展。
同时，虽然你可以改变扩展成员对象的定义
（例如，通过<TT CLASS="COMMAND">CREATE OR REPLACE FUNCTION</TT>函数），记住修改后的定义将不会
通过<SPAN CLASS="APPLICATION">pg_dump</SPAN>被转储。这种变化通常是唯一明智的，如果
你同时在扩展的脚本文件中有相同的变化。
（但对包含配置数据的表有特殊规定；见下文。）</P><P> 扩展机制也为包装修改脚本制定规定，它调整包含扩展的SQL对象的定义。
例如，如果扩展的版本1.1增加了一个功能并且
改变相比较于1.0的另一个函数的主体，扩展可以提供一个<I CLASS="FIRSTTERM">更新脚本</I>，只是那两个改变。
<TT CLASS="COMMAND">ALTER EXTENSION UPDATE</TT>命令可以用于应用这些变化，并且
跟踪扩展的版本，实际上是安装在一个给定的数据库中。</P><P> 一些SQL对象是显示在<A HREF="sql-alterextension.html">ALTER EXTENSION</A>的描述中的扩展对象。
值得注意的是，对象是数据库集群范围，如数据库，角色，和表空间，
无法扩展成员，因为扩展在一个数据库中是唯一已知的。
（虽然并不禁止扩展脚本创建这样的对象，如果它这样做，
他们将不会作为跟踪扩展。）也注意到，当一个表可以是扩展成员时，
其子对象如索引不直接考虑扩展成员。
另外重要的一点是，模式可以属于扩展，但非
反之亦然：扩展这样有一个不合格的名称并且不
存在任何模式<SPAN CLASS="QUOTE">"内部"</SPAN>。
扩展的成员对象，然而，将属于模式，
只要适合他们的对象类型。它可能或可能不适合拥有模式成员对象的一个扩展。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN54808">35.15.1. 扩展文件</A></H2><P> <A HREF="sql-createextension.html">CREATE EXTENSION</A>命令依赖于每个扩展的控制文件，
它必须被命名为和带有<TT CLASS="LITERAL">.control</TT>后缀的扩展相同。并且被放置在安装的
<TT CLASS="LITERAL">SHAREDIR/extension</TT>目录中。必须至少有一个<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>脚本文件，
遵循命名模式<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>extension</I></TT>--<TT CLASS="REPLACEABLE"><I>version</I></TT>.sql</TT>
（比如，扩展<TT CLASS="LITERAL">foo</TT>的版本<TT CLASS="LITERAL">1.0</TT>是<TT CLASS="LITERAL">foo--1.0.sql</TT>）。
缺省，脚本文件也被放置在<TT CLASS="LITERAL">SHAREDIR/extension</TT>目录中；
但是控制文件可以为脚本文件声明不同的目录。</P><P> 扩展控制文件的文件格式与<TT CLASS="FILENAME">postgresql.conf</TT>文件相同，
<TT CLASS="REPLACEABLE"><I>parameter_name</I></TT> <TT CLASS="LITERAL">=</TT> <TT CLASS="REPLACEABLE"><I>value</I></TT>
任务列表，每行一个。通过允许<TT CLASS="LITERAL">#</TT>引进空行和注释。
确保引用任何值，不是单词或者数字。</P><P> 控制文件可以设置以下参数：</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="VARNAME">directory</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 该目录包含扩展的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>脚本文件。
除非给定绝对路径名，名字是相对于安装的<TT CLASS="LITERAL">SHAREDIR</TT>目录。
默认操作相当于指定<TT CLASS="LITERAL">directory = 'extension'</TT>。</P></DD><DT><TT CLASS="VARNAME">default_version</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 扩展的默认版本（如果在<TT CLASS="COMMAND">CREATE EXTENSION</TT>中没有声明版本，则一个将被安装）。
虽然这可以被省略，如果没有<TT CLASS="LITERAL">VERSION</TT>选项，这将导致<TT CLASS="COMMAND">CREATE EXTENSION</TT>
失败，所以你通常不想这样做。</P></DD><DT><TT CLASS="VARNAME">comment</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 关于扩展的注释（任何字符串）。另外，注释可以通过脚本文件中的<A HREF="sql-comment.html">COMMENT</A>
命令进行设置。</P></DD><DT><TT CLASS="VARNAME">encoding</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 通过脚本文件使用字符集编码。如果脚本文件包含任何非-ASCII字符，则被声明。
否则这些文件被认为数据库编码。</P></DD><DT><TT CLASS="VARNAME">module_pathname</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 这个参数的值将
为了每个发生在脚本文件中的<TT CLASS="LITERAL">MODULE_PATHNAME</TT>被替换。如果它不被设置，
则没有替代。通常情况下，这是设置为
<TT CLASS="LITERAL">$libdir/<TT CLASS="REPLACEABLE"><I>shared_library_name</I></TT></TT>并且
<TT CLASS="LITERAL">MODULE_PATHNAME</TT>在<TT CLASS="COMMAND">CREATE FUNCTION</TT>命令中为C语言函数被使用，
因此脚本文件不需要硬线共享库的名字。 </P></DD><DT><TT CLASS="VARNAME">requires</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 这个扩展取决于扩展名列表，比如<TT CLASS="LITERAL">requires = 'foo, bar'</TT>。
这些扩展必须在可以被安装前被安装。</P></DD><DT><TT CLASS="VARNAME">superuser</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果这个参数是<TT CLASS="LITERAL">true</TT>（缺省），只有超级用户可以创建扩展或者更新它到一个新版本。
如果它被设置为<TT CLASS="LITERAL">false</TT>，仅仅需要安装过程中执行命令所需的权限或者更新脚本。</P></DD><DT><TT CLASS="VARNAME">relocatable</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 如果扩展初始化创建之后可能移动所包含的对象到不同的模式中，
则扩展是<I CLASS="FIRSTTERM">浮动的</I>。缺省是<TT CLASS="LITERAL">false</TT>等，这个扩展是不浮动的。
参见下文获取更多信息。</P></DD><DT><TT CLASS="VARNAME">schema</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 这个参数只能设置为非-浮动的扩展。它强制扩展被加载到精确的命名模式中，并且
没有任何其他的。参见下文获取更多信息。</P></DD></DL></DIV><P> 除了初步控制文件<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>extension</I></TT>.control</TT>，
扩展有在形式<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>extension</I></TT>--<TT CLASS="REPLACEABLE"><I>version</I></TT>.control</TT>
中命名的二级控制文件。如果被提供，这些必须位于脚本文件目录中。
二级控制文件遵循同样格式作为初步控制文件。
当安装或者更新扩展版本的时候，在二级控制文件中设置的任何参数覆盖初步控制文件，
然而，不能在二级控制文件中设置参数<TT CLASS="VARNAME">directory</TT>和
<TT CLASS="VARNAME">default_version</TT>。</P><P> 扩展的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>脚本文件可以包含任何SQL命令，除了事务控制命令
(<TT CLASS="COMMAND">BEGIN</TT>，<TT CLASS="COMMAND">COMMIT</TT>等)以及不能在一个事务块中执行的命令（比如<TT CLASS="COMMAND">VACUUM</TT>）。
这是因为脚本文件在事务块中是隐式执行的。</P><P> 扩展的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>脚本文件也可以包含以<TT CLASS="LITERAL">\echo</TT>开头的行，
这被扩展机制忽略（作为注释）。如果脚本文件给<SPAN CLASS="APPLICATION">psql</SPAN>而不是通过<TT CLASS="COMMAND">CREATE EXTENSION</TT>
（参见下文例子脚本）被加载，则这个规定往往抛出错误。
没有那些，用户可能无意中加载扩展内容作为<SPAN CLASS="QUOTE">"loose"</SPAN>对象而不是作为扩展，
从中恢复的事态有点繁琐。</P><P> 当脚本文件可以包含指定编码允许的任何字符时，则控制文件应该包含纯ASCII，
因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不知道控制文件中的编码方式。
实践中如果你想在扩展注释中使用非-ASCII字符，这个是一个问题。
在这种情况下推荐做法是不使用控制文件<TT CLASS="VARNAME">comment</TT>参数，但是代替使用
脚本文件中的<TT CLASS="COMMAND">COMMENT ON EXTENSION</TT>设置comment。 </P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN54926">35.15.2. 扩展浮动</A></H2><P> 用户通常希望加载包含在扩展中的对象到一个扩展者考虑到的不同的模式中。
有浮动的三种支持级别。</P><P></P><UL><LI><P> 一个完全可浮动扩展可移动到任何时间下的另一个模式，
即使它被加载到数据库之后。
这是执行了<TT CLASS="COMMAND">ALTER EXTENSION SET SCHEMA</TT>命令，
它可以自动重命名所有成员对象到新模式中，
通常情况下，这是唯一可能的扩展，如果扩展包含关于任何对象在什么模式中的非内部假设。
同时，扩展的对象都必须在一个模式中（忽略不属于任何模式的对象，如程序语言）。
通过设置控制文件中<TT CLASS="LITERAL">relocatable = true</TT>标记完全的浮动扩展。</P></LI><LI><P> 一个扩展可能会在安装过程中被重定位，但不是之后。
这是通常的情况，如果扩展的脚本文件需要参考明确的目标模式，例如
在为SQL函数设置<TT CLASS="LITERAL">search_path</TT>属性时。对于这种扩展，
在控制文件中设置<TT CLASS="LITERAL">relocatable = false</TT>，
并且使用<TT CLASS="LITERAL">@extschema@</TT>指向脚本文件中的目标模式。
在执行脚本前该字符串的所有出现将被实际的目标模式的名字取代。
用户可以使用<TT CLASS="COMMAND">CREATE EXTENSION</TT>
的<TT CLASS="LITERAL">SCHEMA</TT>选项设置目标模式。 </P></LI><LI><P> 如果扩展不支持重定位，则在控制文件中设置
<TT CLASS="LITERAL">relocatable = false</TT>，并且设置
<TT CLASS="LITERAL">schema</TT>到目标模式名。
这将防止使用<TT CLASS="COMMAND">CREATE EXTENSION</TT>的<TT CLASS="LITERAL">SCHEMA</TT>选项，
除非指定了控制文件命名的相同模式。
如果扩展包含关于模式名不能被<TT CLASS="LITERAL">@extschema@</TT>替代的内部假设，
这种选择通常是必要的。在这种情况下<TT CLASS="LITERAL">@extschema@</TT>替代机制可用，尽管
它是有限的使用，因为模式名称是由控制文件确定的。</P></LI></UL><P>
在所有情况下，脚本文件与<A HREF="runtime-config-client.html#GUC-SEARCH-PATH">search_path</A>初始设置指向
目标模式一起被执行；也就是说，<TT CLASS="COMMAND">CREATE EXTENSION</TT>相当于：
</P><PRE CLASS="PROGRAMLISTING">SET LOCAL search_path TO @extschema@;</PRE><P>
这允许通过脚本文件创建的对象到目标模式。如果它希望，则脚本文件可以改变<TT CLASS="VARNAME">search_path</TT>。
但是这通常是不可取的，<TT CLASS="VARNAME">search_path</TT>被存储到<TT CLASS="COMMAND">CREATE EXTENSION</TT>的
先前设置完成。
</P><P> 如果它被给定，目标模式是由控制文件中的<TT CLASS="VARNAME">schema</TT>参数决定的。
否则由<TT CLASS="COMMAND">CREATE EXTENSION</TT>的<TT CLASS="LITERAL">SCHEMA</TT>选项决定。
否则当前的默认对象创建模式（调用者<TT CLASS="VARNAME">search_path</TT>的第一个）。
当使用控制文件<TT CLASS="VARNAME">schema</TT>，如果它不存在，则创建目标模式，
但是在其他两种情况下，它必须已经存在。</P><P> 如果任何先决条件扩展列在控制文件的<TT CLASS="VARNAME">requires</TT>中，目标模式附加到
<TT CLASS="VARNAME">search_path</TT>的初始设置中。这允许对象对于新的扩展脚本文件时可见的。</P><P> 尽管非可重定位扩展可以通过多个模式包含对象，为了外部使用把所有的对象放到一个单独模式中是可取的，
这被认为是扩展的目标模式。在相关扩展创建过程中，这样的安排方便<TT CLASS="VARNAME">search_path</TT>的缺省设置。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN54967">35.15.3. 扩展配置表</A></H2><P> 一些扩展包含配置表，
其中包含的数据可能安装扩展之后被用户添加或更改。
通常，如果一个表是扩展部分，既不是表的定义，
也不是被<SPAN CLASS="APPLICATION">pg_dump</SPAN>备份的内容，
但这样的行为对配置表是不需要的；
用户修改的任何数据需要包含到备份中，
或备份和重载之后扩展会有不同的表现。</P><P>
为了解决这个问题，扩展的脚本文件可以标记表，它已经作为配置表被创建，其中
将导致<SPAN CLASS="APPLICATION">pg_dump</SPAN>包含转储中表的内容（不是定义）。要做到这一点，
在创建表之后调用<CODE CLASS="FUNCTION">pg_extension_config_dump(regclass, text)</CODE>，比如：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE my_config (key text, value text);

SELECT pg_catalog.pg_extension_config_dump('my_config', '');</PRE><P>
这种方式可以标记任何数量表。
</P><P>
当<CODE CLASS="FUNCTION">pg_extension_config_dump</CODE>的第二个参数是空字符串时，
该表的所有内容都被<SPAN CLASS="APPLICATION">pg_dump</SPAN>备份。如果表
最初扩展脚本创建为空，通常是唯一正确的。如果有
一个初始数据和用户表中提供的数据的混合，则<CODE CLASS="FUNCTION">pg_extension_config_dump</CODE>的
第二个参数提供了<TT CLASS="LITERAL">WHERE</TT>条件选择被备份的数据。比如，你可能做
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');</PRE><P>
并且确保通过扩展脚本创建的行<TT CLASS="STRUCTFIELD">standard_entry</TT>为真。
</P><P> 更加复杂的情况，比如初始化提供的行可能通过用户被修改，通过在配置表上创建触发器被处理
以确保正确标记修改的行。</P><P> 你可以通过再次调用<CODE CLASS="FUNCTION">pg_extension_config_dump</CODE>修改与配置表相关的过滤条件。
这在扩展更新脚本中通常是有用的。
标记表不再为配置表的唯一方法是从带有<TT CLASS="COMMAND">ALTER EXTENSION ... DROP TABLE</TT>
的扩展中分离出来。&#13;</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN54988">35.15.4. 扩展更新</A></H2><P> 扩展机制的一个优点是，它提供了方便管理更新定义一个扩展对象的SQL命令的方式。
这是通过将版本的名称或号链接扩展的安装脚本的每个发布版本做到的。
此外，如果您希望用户可以动态的从一个版本到下一个更新他们的数据库
，你应该提供<I CLASS="FIRSTTERM">update scripts</I>执行一个版本到下一个做出必要的改变。
以下模式<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>extension</I></TT>--<TT CLASS="REPLACEABLE"><I>oldversion</I></TT>--<TT CLASS="REPLACEABLE"><I>newversion</I></TT>.sql</TT>
更新脚本的名字。（比如，<TT CLASS="LITERAL">foo--1.0--1.1.sql</TT>使用命令修改扩展<TT CLASS="LITERAL">foo</TT>
的版本<TT CLASS="LITERAL">1.0</TT>到版本<TT CLASS="LITERAL">1.1</TT>）。</P><P> 给定一个可用的合适更新脚本，
命令<TT CLASS="COMMAND">ALTER EXTENSION UPDATE</TT>将更新已安装扩展到指定的新版本。
运行在相同环境中的更新脚本，<TT CLASS="COMMAND">CREATE EXTENSION</TT>
提供了安装环境脚本：特别是，<TT CLASS="VARNAME">search_path</TT>以相同
方式进行设置，并通过脚本创建任何新的对象被自动添加到扩展中。</P><P> 如果扩展有二次控制文件，控制参数用于与脚本目标（新）版本联系的更新脚本。</P><P> 更新机制可以用来解决一个重要的特殊情况：
将转变<SPAN CLASS="QUOTE">"松散"</SPAN>对象的集合到一个扩展。
在扩展机制被添加到<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>(9.1中)之前，
许多人写的扩展模块简化了已创建的各式各样的未包装的对象。
给定包含这样对象的现有数据库，我们怎么能转换
对象到适当成套扩展？删除它们然后执行纯<TT CLASS="COMMAND">CREATE EXTENSION</TT>是一种方式，
但它不是可取的，如果对象有依赖关系（例如，如果有扩展创建的数据类型的表列）。
修复这种情况的方式是创建一个空的扩展，然后使用<TT CLASS="COMMAND">ALTER EXTENSION ADD</TT>
把每个预先存在的对象附属在扩展中，
最后在当前扩展版本中创建任何新的对象，
但不在未包装发布中。<TT CLASS="COMMAND">CREATE EXTENSION</TT>
支持带有<TT CLASS="LITERAL">FROM</TT> <TT CLASS="REPLACEABLE"><I>old_version</I></TT>选项的情况。
这导致它不运行目标版本的正常安装脚本，而是更新脚本命名
<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>extension</I></TT>--<TT CLASS="REPLACEABLE"><I>old_version</I></TT>--<TT CLASS="REPLACEABLE"><I>target_version</I></TT>.sql</TT>。
虚拟版本名称选择使用<TT CLASS="REPLACEABLE"><I>old_version</I></TT>胜任扩展发起者，
尽管<TT CLASS="LITERAL">未包装</TT>是一种常见的公约。如果你有多个以前的版本，你需要能够更新扩展风格，
使用多个虚拟版本名称来识别它们。</P><P> <TT CLASS="COMMAND">ALTER EXTENSION</TT>能够执行更新
脚本文件序列以实现请求更新。例如，如果只有
<TT CLASS="LITERAL">foo--1.0--1.1.sql</TT>和<TT CLASS="LITERAL">foo--1.1--2.0.sql</TT>可用，
当目前安装的是<TT CLASS="LITERAL">1.0</TT>时，
如果需要更新到版本<TT CLASS="LITERAL">2.0</TT>，
<TT CLASS="COMMAND">ALTER EXTENSION</TT>将在序列中应用它们。</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不假定任何有关版本名称的属性：
例如，它不知道<TT CLASS="LITERAL">1.1</TT>遵循<TT CLASS="LITERAL">1.0</TT>。
它只匹配可用的版本名称并且
遵循路径要求应用最新的更新脚本。
（一个版本的名称可以是不包含
<TT CLASS="LITERAL">--</TT>或前导或尾随<TT CLASS="LITERAL">-</TT>的任意字符串。）</P><P> 有时提供<SPAN CLASS="QUOTE">"downgrade"</SPAN>脚本是非常有用的，
例如<TT CLASS="LITERAL">foo--1.1--1.0.sql</TT>允许恢复与版本<TT CLASS="LITERAL">1.1</TT>相关的变化。
如果你这样做了，小心downgrade脚本可能会意外地
因它产生一个较短的路径而得以应用的可能性。
风险情况下有一个<SPAN CLASS="QUOTE">"快速路径"</SPAN>更新脚本，向前跳几个版本
以及降级脚本到快速路径的起点。
这可能需要较少的步骤应用降级，然后快速路径向前一次移动一个版本。
如果降级脚本删除任何不可替代的对象，这将产生不良的结果。&#13;</P><P>
为了检查意外的更新路径，使用这个命令：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM pg_extension_update_paths('<TT
CLASS="REPLACEABLE"
><I
>extension_name</I
></TT
>');</PRE><P>
这显示了已指定扩展的每对不同已知的版本名称，
以及更新路径序列将采取从源版本到目标版本，
或者如果没有可用的更新路径，则为<TT CLASS="LITERAL">NULL</TT>。
路径以带有<TT CLASS="LITERAL">--</TT>分隔符的文本形式显示。
如果你喜欢数组形式，则可以使用<TT CLASS="LITERAL">regexp_split_to_array(path,'--')</TT>。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN55043">35.15.5. 扩展实例</A></H2><P> 这是一个<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>扩展的完整实例，二元复合类型可以存储插槽中的任何类型的值，
被命名为<SPAN CLASS="QUOTE">"k"</SPAN>和<SPAN CLASS="QUOTE">"v"</SPAN>。非-文本值自动强制转换为文本存储。</P><P>
脚本文件<TT CLASS="FILENAME">pair--1.0.sql</TT>看起来像：
</P><PRE CLASS="PROGRAMLISTING">-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~&#62; (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~&#62; (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~&#62; (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~&#62; (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);</PRE><P>
</P><P>
控制文件<TT CLASS="FILENAME">pair.control</TT>看起来像：
</P><PRE CLASS="PROGRAMLISTING"># pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = true</PRE><P>
</P><P>
当你几乎不需要makefile安装这两个文件到正确目录时，你可以使用
包含下面内容的<TT CLASS="FILENAME">Makefile</TT>：
</P><PRE CLASS="PROGRAMLISTING">EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</PRE><P>
这个makefile依赖于<ACRONYM CLASS="ACRONYM">PGXS</ACRONYM>，在<A HREF="extend-pgxs.html">第 35.16 &#33410;</A>中描述。
命令<TT CLASS="LITERAL">make install</TT>将安装控制和脚本文件到正确目录，通过<SPAN CLASS="APPLICATION">pg_config</SPAN>
报告。
</P><P> 一旦安装了这些文件，使用<A HREF="sql-createextension.html">CREATE EXTENSION</A>命令加载对象到
任何特定数据库。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="xindex.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="extend-pgxs.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">扩展索引接口</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/extend.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">扩展基础设施建设</TD></TR></TABLE></DIV></BODY></HTML>
