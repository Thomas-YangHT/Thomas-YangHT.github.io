<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>数据值</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PL/Python - Python 过程语言" HREF="http://school.yunwei.edu/manual/PostgreSQL/plpython.html"><LINK REL="PREVIOUS" TITLE="PL/Python 函数" HREF="plpython-funcs.html"><LINK REL="NEXT" TITLE="共享数据" HREF="plpython-sharing.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/plpython.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="PL/Python 函数" HREF="plpython-funcs.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpython.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 43. PL/Python - Python 过程语言</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="共享数据" HREF="plpython-sharing.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="PLPYTHON-DATA">43.3. 数据值</A></H1><P>一般来说，PL/Python的目的是提供PostgreSQL和Python世界之间的<SPAN CLASS="QUOTE">"自然"</SPAN>映射。
如下面描述的数据映射规则。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN60723">43.3.1. 数据类型映射</A></H2><P>函数参数是从他们的PostgreSQL类型转换为相应的Python类型：
<P></P></P><UL><LI><P>PostgreSQL <TT CLASS="TYPE">boolean</TT>转换成Python <TT CLASS="TYPE">bool</TT>。</P></LI><LI><P>PostgreSQL <TT CLASS="TYPE">smallint</TT>和<TT CLASS="TYPE">int</TT>转换成Python <TT CLASS="TYPE">int</TT>。
PostgreSQL <TT CLASS="TYPE">bigint</TT>和<TT CLASS="TYPE">oid</TT>在Python 2中转换成<TT CLASS="TYPE">long</TT>，
在Python 3中转换成<TT CLASS="TYPE">int</TT>。</P></LI><LI><P>PostgreSQL <TT CLASS="TYPE">real</TT>，<TT CLASS="TYPE">double</TT>和<TT CLASS="TYPE">numeric</TT>
转换成Python <TT CLASS="TYPE">float</TT>。请注意，<TT CLASS="TYPE">numeric</TT>
可能丢失信息并且导致不正确的结果。这可能在未来的版本中固定。</P></LI><LI><P>PostgreSQL <TT CLASS="TYPE">bytea</TT>在Python 2中转换成Python <TT CLASS="TYPE">str</TT>，
在Python 3中转换成<TT CLASS="TYPE">bytes</TT>。在Python 2 中，字符串应被视为没有任何字符编码的字节序列。</P></LI><LI><P>所有其他数据类型，包括PostgreSQL字符串类型，转换为Python <TT CLASS="TYPE">str</TT>。
在Python 2中，这个字符串将以PostgreSQL服务器编码；在Python 3中，它是一个Unicode字符串，和所有的字符串一样。</P></LI><LI><P>对于非标量数据类型，见下文。</P></LI></UL><P>
</P><P>函数的返回值被转换为声明的PostgreSQL返回数据类型，如下：
<P></P></P><UL><LI><P>当PostgreSQL返回类型是<TT CLASS="TYPE">boolean</TT>，按照<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">Python</I></SPAN>
规则返回值估计为真。也就是说，0和空字符串是假，但值得注意的是<TT CLASS="LITERAL">'f'</TT>是真。</P></LI><LI><P>当postgreSQL返回类型是<TT CLASS="TYPE">bytea</TT>时，返回值将使用各自的Python内建被转换成字符串
（Python 2）或者字节(Python 3)，其结果被转换成<TT CLASS="TYPE">bytea</TT>。</P></LI><LI><P>对于所有其他PostgreSQL返回类型，返回的Python值使用Python内建<TT CLASS="LITERAL">str</TT>
转换成字符串，结果传递到PostgreSQL数据类型的输入函数。</P><P>当在Python 2中的字符串要传递到PostgreSQL时，要求它们是以PostgreSQL服务器编码。
在当前服务器编码中无效的字符串将引发错误，但不是所有的编码不匹配都可以被检测到，
因此当做的不正确时，仍然会产生垃圾数据。Unicode字符串自动转换为正确的编码，
所以它可以更安全，更方便的使用。在Python 3中，所有的字符串都是Unicode字符串。</P></LI><LI><P>对于非标量数据类型，见下文。</P></LI></UL><P>
请注意，PostgreSQL声明的返回类型和实际返回对象的Python数据类型之间的逻辑不匹配是不标记的；
该值将在任何情况下被转换。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN60774">43.3.2. Null, None</A></H2><P>如果向函数传递了一个SQL null值，参数值在Python中将会显示为
<TT CLASS="SYMBOL">None</TT>。比如，在<A HREF="plpython-funcs.html">第 43.2 &#33410;</A>中显示的
<CODE CLASS="FUNCTION">pymax</CODE>的函数定义对于null输入将返回错误结果。
我们可以添加<TT CLASS="LITERAL">STRICT</TT>到函数定义，使得<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
进行更加合理的操作：如果传入null值，函数将根本不会被调用，而是立即自动返回null。或者，
也可以在函数体中检查输入参数是否为null:
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;</PRE><P>
如上所示，要从PL/Python函数中返回一个SQL null 值，返回<TT CLASS="SYMBOL">None</TT>即可。
无论函数是否严格，这样做都有效。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="PLPYTHON-ARRAYS">43.3.3. Arrays, Lists</A></H2><P>SQL数组值作为Python列表传递给PL/Python。要从PL/Python函数返回一个SQL数组值，
只需返回一个Python序列，例如一个列表或元组：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return (1, 2, 3, 4, 5)
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-------------
 {1,2,3,4,5}
(1 row)</PRE><P>
注意:在Python中，字符串是序列，这可能有不良影响，这可能是Python程序员熟悉的：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN60792">43.3.4. 复合类型</A></H2><P>复合类型参数将作为Python映射传递给函数。映射的元素名是复合类型的属性名。
如果被传递行的某个属性是null值，那么它在映射中的值是<TT CLASS="SYMBOL">None</TT>。下面是例子：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;</PRE><P>
</P><P>有多种从Python函数返回行或复合类型的方法。下面的例子假定我们有：
</P><PRE CLASS="PROGRAMLISTING">CREATE TYPE named_value AS (
  name   text,
  value  integer
);</PRE><P>
一个复合类型结果可以作为下列之一返回：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT>序列类型（一个元组或列表，但不是一个集合，因为集合是不可以被索引的）</DT><DD><P>
返回的序列对象必须与复合结果类型字段数相同。索引为0的项将被分配给复合类型的第一个字段，
索引为1的项分配给第2个字段，以此类推。比如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return [ name, value ]
  # or alternatively, as tuple: return ( name, value )
$$ LANGUAGE plpythonu;</PRE><P>
要为任何字段返回SQL null，就在相应的位置插入<TT CLASS="SYMBOL">None</TT>。
</P></DD><DT>映射（字典）</DT><DD><P>每个结果类型字段的值从映射中使用字段名作为键检索，例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpythonu;</PRE><P>
任何额外的字典键/值对被忽略。丢失的键将被当作错误。要为任何字段返回SQL null值，
就以相应的字段名作为键插入<TT CLASS="SYMBOL">None</TT>。
</P></DD><DT>对象(任何提供<TT CLASS="LITERAL">__getattr__</TT>方法的对象)</DT><DD><P>它的工作方式和映射一样，例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # or simply
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpythonu;</PRE><P>
</P></DD></DL></DIV><P>
</P><P>
也支持带有<TT CLASS="LITERAL">OUT</TT>参数的函数。例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple();</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN60821">43.3.5. 设置返回函数</A></H2><P><SPAN CLASS="APPLICATION">PL/Python</SPAN>函数也可以返回标量或者复合类型的集合。
有多种方法可以达到这个目的，因为返回对象在内部被转换成一个迭代器。
下面的例子假定我们有一个复合类型：
</P><PRE CLASS="PROGRAMLISTING">CREATE TYPE greeting AS (
  how text,
  who text
);</PRE><P>
一个集合结果可以从下列之一返回：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT>序列类型（元组、列表、集合）</DT><DD><P></P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # return tuple containing lists as composite types
  # all other combinations work also
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;</PRE><P>
</P></DD><DT>迭代器（任何提供<TT CLASS="SYMBOL">__iter__</TT>和<TT CLASS="SYMBOL">next</TT>方法的对象）</DT><DD><P></P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;</PRE><P>
</P></DD><DT>生成器(<TT CLASS="LITERAL">yield</TT>)</DT><DD><P></P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;</PRE><P>
<DIV CLASS="WARNING"><P></P><TABLE CLASS="WARNING" BORDER="1" WIDTH="90%"><TR><TD ALIGN="CENTER"><B>&#35686;&#21578;</B></TD></TR><TR><TD ALIGN="LEFT"><P>由于Python <A HREF="http://bugs.python.org/issue1483133" TARGET="_top">bug #1483133</A>的原因，
一些Python 2.4的调试版本(使用<TT CLASS="LITERAL">--with-pydebug</TT>选项配置和编译)
已知会让<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器在使用迭代器返回集合时崩溃。
Fedora 4的应用补丁版本包含这个臭虫。但是在生产版本的Python或已经修补的Fedora 4上没有这个问题。</P></TD></TR></TABLE></DIV>
</P></DD></DL></DIV><P>
</P><P>也支持带有<TT CLASS="LITERAL">OUT</TT>参数的设置返回函数（使用<TT CLASS="LITERAL">RETURNS SETOF记录</TT>）。
例如：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple_setof(3);</PRE><P>
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="plpython-funcs.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="plpython-sharing.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">PL/Python 函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/plpython.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">共享数据</TD></TR></TABLE></DIV></BODY></HTML>
