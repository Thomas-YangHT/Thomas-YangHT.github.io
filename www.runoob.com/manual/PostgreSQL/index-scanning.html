<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>索引扫描</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="索引访问方法接口定义" HREF="http://school.yunwei.edu/manual/PostgreSQL/indexam.html"><LINK REL="PREVIOUS" TITLE="索引访问方法函数" HREF="index-functions.html"><LINK REL="NEXT" TITLE="索引锁的考量" HREF="index-locking.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/indexam.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="索引访问方法函数" HREF="index-functions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/indexam.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 54. 索引访问方法接口定义</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="索引锁的考量" HREF="index-locking.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="INDEX-SCANNING">54.3. 索引扫描</A></H1><P>在一个索引扫描里，索引访问方法负责把它拿到的那些据说匹配<I CLASS="FIRSTTERM">扫描键字</I>的所有行之 TID 的回流。
访问方法<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不会</I></SPAN>卷入从索引的父表中实际抓取这些行的动作中，也不会判断他们是否通过了扫描的时间条件测试或者是其它条件。
</P><P>一个扫描键字是形如<TT CLASS="REPLACEABLE"><I>index_key</I></TT> <TT CLASS="REPLACEABLE"><I>operator</I></TT><TT CLASS="REPLACEABLE"><I>constant</I></TT>
的<TT CLASS="LITERAL">WHERE</TT>子句的内部表现形式，
这里的索引键字是索引中的一个字段，而操作符是和该索引字段相关联的操作符族的一个成员。
一个索引扫描拥有零个或者多个扫描键字，他们是隐含着 AND 的关系 —返回的行被认为是满所所有列出的条件的行。
</P><P>访问方法可以声称自己是<I CLASS="FIRSTTERM">有损的</I>或对特定的查询需要再检查。
这意味着，索引扫描会返回所有通过扫描键字的条目并可能加上一些不能通过的条目。
核心系统的索引扫描装置之后会对堆元组应用索引条件以确认是否真的这个元组应该被选中。
如果再检查选项没有被指定，索引扫描必须精确返回匹配的条目。
</P><P>请注意，确保找到所有条目以及确保所有条目都通过给出的扫描键字的条件完全是访问方法的责任。
还有，核心系统将只是简单的把所有匹配扫描键字和操作符族的<TT CLASS="LITERAL">WHERE</TT>子句传递过来，而不会做任何语义分析，以判断他们是否冗余或者是否相互矛盾。
举例来说，给出<TT CLASS="LITERAL">WHERE x &gt; 4 AND x &gt; 14</TT> where <TT CLASS="LITERAL">x</TT> ，这里的
<TT CLASS="LITERAL">x</TT>是一个 b-tree 索引字段，
那么把第一个扫描键字识别成冗余的和可抛弃的工作是 b-tree <CODE CLASS="FUNCTION">amrescan</CODE>函数的事。
<CODE CLASS="FUNCTION">amrescan</CODE>过程中所需要的预处理的范围将由索引访问方法把扫描键字缩减为一个<SPAN CLASS="QUOTE">"规范化"</SPAN>形式的具体需要而定。
</P><P>一些访问方法以明确的顺序返回索引项，另外一些则不是。
实际上访问方法可以支持两种不同的排序输出方法：
<P></P></P><UL><LI><P>以自然的数据顺序返回条目的访问方法（比如btree）应该设置<TT CLASS="STRUCTNAME">pg_am</TT>.<TT CLASS="STRUCTFIELD">amcanorder</TT>为真。
当前，这样的访问方法必须为它们的相等和排序操作符使用btree兼容的策略数。
</P></LI><LI><P>支持排序操作的访问方法必须设置<TT CLASS="STRUCTNAME">pg_am</TT>.<TT CLASS="STRUCTFIELD">amcanorderbyop</TT>为真。
这表明这个索引能够以满足<TT CLASS="LITERAL">ORDER BY</TT> <TT CLASS="REPLACEABLE"><I>index_key</I></TT><TT CLASS="REPLACEABLE"><I>operator</I></TT> <TT CLASS="REPLACEABLE"><I>constant</I></TT>
的顺序返回条目。
这种形式的扫描修饰子能够像前面描述的那样被传入<CODE CLASS="FUNCTION">amrescan</CODE>。
</P></LI></UL><P>
</P><P><CODE CLASS="FUNCTION">amgettuple</CODE>函数有一个<TT CLASS="LITERAL">direction</TT>参数，它可以是<TT CLASS="LITERAL">ForwardScanDirection</TT>
(正常情况)或者 <TT CLASS="LITERAL">BackwardScanDirection</TT> 。
如果<CODE CLASS="FUNCTION">amrescan</CODE>之后的第一次调用声明<TT CLASS="LITERAL">BackwardScanDirection</TT>，那么匹配条件的索引记录集是从后向前扫描的，而不是通常的从前向后扫描，
因此<CODE CLASS="FUNCTION">amgettuple</CODE>必须返回索引中最后的匹配行，而不是通常情况下的第一条。
（这些事情只会在那些设置了<TT CLASS="STRUCTFIELD">amcanorder</TT>为真的访问方法上会发生。）
在第一次调用之后，<CODE CLASS="FUNCTION">amgettuple</CODE>必须准备从最近返回的条目的位置开始，在两个方向上进行扫描步进。
（但是，如果<TT CLASS="STRUCTNAME">pg_am</TT>.<TT CLASS="STRUCTFIELD">amcanbackward</TT>为假，所有随后的调用将会和第一次调用使用相同的顺序。）
</P><P>支持排序扫描的访问方法必须支持在扫描上<SPAN CLASS="QUOTE">"标记"</SPAN>位置，并在之后可以返回这个被标记的位置。
相同的位置可能被恢复多次。
然而，每次扫描只有一个位置需要被记住；一次新的<CODE CLASS="FUNCTION">ammarkpos</CODE>调用会覆盖先前被标记的位置。
不支持排序扫描的访问方法仍然可以在<TT CLASS="STRUCTNAME">pg_am</TT>中提供标记和恢复函数，但是如果被调用可以让这些函数抛出错误。
</P><P>扫描位置和标记位置(如果存在)都必须在面对索引中存在并发插入和删除的时候保持一致性。
如果一条并发新插入的记录并未被一次扫描返回(而如果扫描开始的时候该记录就存在的话，则会被返回)，
或者说扫描通过重新扫描或者回头扫描返回这样的记录（即使它第一次跑的时候没有返回这样的行），对于系统来说，这种情况是可以接受的。
类似的还有，一个并发的删除可以反映，也可以不反应一个扫描的结果。
重要的是，插入或者删除不会导致扫描会略过或者重复返回本身不是被插入或者删除的条目。
</P><P>如果索引存储原始的被索引数据值（而不是某种有损的表现形式），对支持index-only扫描是有用的，
这时，索引返回实际的数据而不仅是堆元组的TID。
只有在可见性映射显示这个TID在一个全可见页上是这才有效；否则还是必须检查堆元组的MVCC可见性。
但是访问方法不需要关心这件事。
</P><P>作为<CODE CLASS="FUNCTION">amgettuple</CODE>的替代，索引扫描可以可以通过一次<CODE CLASS="FUNCTION">amgetbitmap</CODE>调用抓取所有元组来完成。
这明显可能比<CODE CLASS="FUNCTION">amgettuple</CODE>更高效，因为可以避免在访问方法内部的加锁解锁。
一般而言，<CODE CLASS="FUNCTION">amgetbitmap</CODE>和重复调用 <CODE CLASS="FUNCTION">amgettuple</CODE>有相同的效果，
但是为了简化我们加入了一些限制。
首先，<CODE CLASS="FUNCTION">amgetbitmap</CODE>一次返回所有元组，并且不支持标记和恢复位置。
第二，在bitmap中返回的元组没有任何指定的顺序，这也是<CODE CLASS="FUNCTION">amgetbitmap</CODE>没有<TT CLASS="LITERAL">direction</TT>参数的原因。
（排序操作也就永远不会被应用到这样的扫描上）
既然没有办法返回被索引元组的内容，也就不会有使用<CODE CLASS="FUNCTION">amgetbitmap</CODE>的index-only扫描。
最后，<CODE CLASS="FUNCTION">amgetbitmap</CODE>不能保证对被返回元组上实施任何在<A HREF="index-locking.html">第 54.4 &#33410;</A>中描述的锁。
</P><P>注意，如果一个访问方法的内部实现不适合实现其中一个API的话，
允许一个访问方法只实现<CODE CLASS="FUNCTION">amgetbitmap</CODE>和<CODE CLASS="FUNCTION">amgettuple</CODE>中的一个。
</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="index-functions.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="index-locking.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">索引访问方法函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/indexam.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">索引锁的考量</TD></TR></TABLE></DIV></BODY></HTML>
