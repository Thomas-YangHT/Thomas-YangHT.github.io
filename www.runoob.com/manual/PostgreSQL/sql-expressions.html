<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>值表达式</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL语法" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html"><LINK REL="PREVIOUS" TITLE="词法结构" HREF="sql-syntax-lexical.html"><LINK REL="NEXT" TITLE="调用函数" HREF="sql-syntax-calling-funcs.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/syntax.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="词法结构" HREF="sql-syntax-lexical.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 4. SQL语法</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="调用函数" HREF="sql-syntax-calling-funcs.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="SQL-EXPRESSIONS">4.2. 值表达式</A></H1><P>
值表达式用在各种语法环境中，比如在<TT CLASS="COMMAND">SELECT</TT>命令的目标列表中，
在<TT CLASS="COMMAND">INSERT</TT>或<TT CLASS="COMMAND">UPDATE</TT>中用作新的列值，
或者在许多命令的搜索条件中使用。我们有时候把值表达式的结果叫做<I CLASS="FIRSTTERM">标量</I>，
以便与一个表表达式的结果相区别(是一个表)。因此值表达式也叫做
<I CLASS="FIRSTTERM">标量表达式</I>(或简称<I CLASS="FIRSTTERM">表达式</I>)。
表达式语法允许对来自基本部分的数值进行算术、逻辑、集合、和其它运算。 </P><P>
值表达式是下列内容之一：
<P></P></P><UL><LI><P>
一个常量或者字面值
</P></LI><LI><P>
一个字段引用
</P></LI><LI><P> 一个位置参数引用(在函数声明体中或预编写的语句中)
</P></LI><LI><P> 一个下标表达式
</P></LI><LI><P>
一个字段选择表达式
</P></LI><LI><P> 一个操作符调用
</P></LI><LI><P> 一个函数调用
</P></LI><LI><P> 一个聚合表达式
</P></LI><LI><P> 一个窗口函数调用
</P></LI><LI><P> 一个类型转换
</P></LI><LI><P> 一个排序规则表达式
</P></LI><LI><P> 一个标量子查询
</P></LI><LI><P> 一个数组构造器
</P></LI><LI><P> 一个行构造器
</P></LI><LI><P>一个在圆括弧里面的值表达式(可用于子表达式分组和覆盖优先级)。</P></LI></UL><P>
</P><P>除了这个列表以外，还有许多构造可以归类为表达式，但是不遵循任何通用的语法规则。
它们通常有函数或操作符的语义，并且在<A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html">第 9 &#31456;</A>里合适的位置描述。
一个例子是<TT CLASS="LITERAL">IS NULL</TT>子句。</P><P>我们已经在<A HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS">第 4.1.2 &#33410;</A>里讨论过常量了。下面的节讨论剩下的选项。 </P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-EXPRESSIONS-COLUMN-REFS">4.2.1. 字段引用</A></H2><P>
一个字段可以用下面的形式引用：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>correlation</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>columnname</I
></TT
></PRE><P>
</P><P><TT CLASS="REPLACEABLE"><I>correlation</I></TT>是一个表的名字(可能有模式修饰)，
或者是用<TT CLASS="LITERAL">FROM</TT>子句这样的方法定义的表的别名。
如果在当前查询所使用的所有表中，该字段名字是唯一的，
那么这个相关名字(correlation)和分隔用的点就可以省略(参见<A HREF="http://school.yunwei.edu/manual/PostgreSQL/queries.html">第 7 &#31456;</A>)。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-EXPRESSIONS-PARAMETERS-POSITIONAL">4.2.2. 位置参数</A></H2><P>
位置参数引用用于标识从外部给 SQL 语句的参数。参数用于 SQL
函数定义语句和预编写的查询。有些客户端库还支持在 SQL 命令字符串外边声明数据值，
这种情况下参数用于引用 SQL 字符串行外的数据。一个参数的形式如下：
</P><PRE CLASS="SYNOPSIS">$<TT
CLASS="REPLACEABLE"
><I
>number</I
></TT
></PRE><P>
</P><P>
比如下面这个<CODE CLASS="FUNCTION">dept</CODE>函数的定义：
</P><PRE CLASS="PROGRAMLISTING">CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;</PRE><P>
在函数被调用的时候这里的<TT CLASS="LITERAL">$1</TT>将引用第一个参数。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-EXPRESSIONS-SUBSCRIPTS">4.2.3. 下标</A></H2><P>
如果一个表达式生成一个数组类型的数值，
那么我们可以通过下面这样的表达式来提取数组中的元素
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>[<TT
CLASS="REPLACEABLE"
><I
>subscript</I
></TT
>]</PRE><P>
或者如果是多个相邻的元素(<SPAN CLASS="QUOTE">"数组片断"</SPAN>)可以用下面的方法抽取
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>[<TT
CLASS="REPLACEABLE"
><I
>lower_subscript</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>upper_subscript</I
></TT
>]</PRE><P>
(这里的方括号<TT CLASS="LITERAL">[ ]</TT>按照字面文本的方式出现。)
每个<TT CLASS="REPLACEABLE"><I>subscript</I></TT>自己都是一个表达式，它必须生成一个整数值。
</P><P>
通常，数组<TT CLASS="REPLACEABLE"><I>expression</I></TT>必须用圆括弧包围，
但如果只是一个字段引用或者一个位置参数，那么圆括弧可以省略。同样，
如果源数组是多维的，那么多个下标可以连接在一起。比如：
</P><PRE CLASS="PROGRAMLISTING">mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]</PRE><P>
最后一个例子里的圆括弧是必须的。参阅<A HREF="arrays.html">第 8.15 &#33410;</A>获取有关数组的更多信息。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FIELD-SELECTION">4.2.4. 字段选择</A></H2><P>如果一个表达式生成一个复合类型(行类型)，那么用下面的方法可以抽取一个指定的字段
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>fieldname</I
></TT
></PRE><P>
</P><P>
通常，行<TT CLASS="REPLACEABLE"><I>expression</I></TT>必须用圆括弧包围，
但是如果要选取的表达式只是一个表引用或者位置参数，可以省略圆括弧。比如:
</P><PRE CLASS="PROGRAMLISTING">mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3</PRE><P>
因此，一个全称的字段引用实际上只是一个字段选择语法的特例。
一个重要的特殊情形是提取的表列是一个复合型的字段：
</P><PRE CLASS="PROGRAMLISTING">(compositecol).somefield
(mytable.compositecol).somefield</PRE><P>
在这里，括号是必须的，用来指出<TT CLASS="STRUCTFIELD">compositecol</TT>是列名而不是表名，
<TT CLASS="STRUCTNAME">mytable</TT>是表名而不是模式名。
</P><P>
在一个选择列表中（查看<A HREF="queries-select-lists.html">第 7.3 &#33410;</A>），
你可以通过使用<TT CLASS="LITERAL">.*</TT>来要求所有的组合值字段。
</P><PRE CLASS="PROGRAMLISTING">(compositecol).*</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-EXPRESSIONS-OPERATOR-CALLS">4.2.5. 操作符调用</A></H2><P>
操作符调用有三种语法：
<P></P><TABLE BORDER="0"><TBODY><TR><TD><TT CLASS="REPLACEABLE"><I>expression</I></TT> <TT CLASS="REPLACEABLE"><I>operator</I></TT> <TT CLASS="REPLACEABLE"><I>expression</I></TT> (双目中缀操作符)</TD></TR><TR><TD><TT CLASS="REPLACEABLE"><I>operator</I></TT> <TT CLASS="REPLACEABLE"><I>expression</I></TT> (单目前缀操作符)</TD></TR><TR><TD><TT CLASS="REPLACEABLE"><I>expression</I></TT> <TT CLASS="REPLACEABLE"><I>operator</I></TT> (单目后缀操作符)</TD></TR></TBODY></TABLE><P></P>
这里的<TT CLASS="REPLACEABLE"><I>operator</I></TT>记号遵循<A HREF="sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS">第 4.1.3 &#33410;</A>的语法规则，
或者是记号<TT CLASS="TOKEN">AND</TT>，<TT CLASS="TOKEN">OR</TT>，<TT CLASS="TOKEN">NOT</TT>之一。
或者是一个被修饰的操作符名：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="LITERAL"
>OPERATOR(</TT
><TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
><TT
CLASS="LITERAL"
>.</TT
><TT
CLASS="REPLACEABLE"
><I
>operatorname</I
></TT
><TT
CLASS="LITERAL"
>)</TT
></PRE><P>
具体存在哪个操作符以及它们是单目还是双目取决于系统或用户定义了什么操作符。
<A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html">第 9 &#31456;</A>描述了内置的操作符。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-EXPRESSIONS-FUNCTION-CALLS">4.2.6. 函数调用</A></H2><P>
函数调用的语法是合法函数名(可能有模式名修饰)，后面跟着包含参数列表的圆括弧：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ([<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ... </SPAN
>]</SPAN
>] )</PRE><P>
</P><P>
比如，下面的代码计算 2 的平方根：
</P><PRE CLASS="PROGRAMLISTING">sqrt(2)</PRE><P>
</P><P>内置函数的列表在<A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html">第 9 &#31456;</A>里。其它函数可由用户添加。</P><P>可选的可附加名字的参数，详细请参阅<A HREF="sql-syntax-calling-funcs.html">第 4.3 &#33410;</A>。 </P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>一个接受一个复合类型参数的函数，可以使用字段选择语法调用，相反的，
字段选择可以用函数的风格写出来。也就是说，符号<TT CLASS="LITERAL">col(table)</TT>
和 <TT CLASS="LITERAL">table.col</TT>是可以互换的。这个行为不是SQL标准，但是由
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>提供，因为它允许函数使用仿真<SPAN CLASS="QUOTE">"计算域"</SPAN>。
获取更多信息，请参阅<A HREF="xfunc-sql.html#XFUNC-SQL-COMPOSITE-FUNCTIONS">第 35.4.3 &#33410;</A>。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SYNTAX-AGGREGATES">4.2.7. 聚合表达式</A></H2><P>
一个<I CLASS="FIRSTTERM">聚合表达式</I>代表一个聚合函数对查询选出的行的处理。
一个聚合函数把多个输入缩减为一个输出值，比如给输入求和或求平均。
一个聚合表达式的语法是下列之一：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>aggregate_name</I
></TT
> (<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ , ... ] [ <TT
CLASS="REPLACEABLE"
><I
>order_by_clause</I
></TT
> ] )
<TT
CLASS="REPLACEABLE"
><I
>aggregate_name</I
></TT
> (ALL <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ , ... ] [ <TT
CLASS="REPLACEABLE"
><I
>order_by_clause</I
></TT
> ] )
<TT
CLASS="REPLACEABLE"
><I
>aggregate_name</I
></TT
> (DISTINCT <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ , ... ] [ <TT
CLASS="REPLACEABLE"
><I
>order_by_clause</I
></TT
> ] )
<TT
CLASS="REPLACEABLE"
><I
>aggregate_name</I
></TT
> ( * )</PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>aggregate_name</I></TT>是前面定义的聚合(可能是带有模式的全称)，
而<TT CLASS="REPLACEABLE"><I>expression</I></TT>是一个本身不包含聚合表达式或一个窗口函数调用的任意值表达式。
<TT CLASS="REPLACEABLE"><I>order_by_clause</I></TT>是<TT CLASS="LITERAL">ORDER BY</TT> 子句的一个选项，下面会有描述。
</P><P>第一种形式的聚合表达式为每个输入行调用聚合。
第二种形式与第一种等价(因为<TT CLASS="LITERAL">ALL</TT>是缺省值)。
第三种形式为每个表达式中不同的值调用聚合（或者为多个表达式不同的值的集合）。
最后一种形式为每个输入行调用一次聚合，因为没有声明特定的输入值，
通常它只用于<CODE CLASS="FUNCTION">count(*)</CODE>聚合函数。 </P><P>大多数的聚合函数忽略了NULL输入，因此在一个或多个表达式中产生NULL的行会被丢弃。
对所有的内置聚合函数而言，这样做是可以的，除非另行说明。 </P><P>比如，<TT CLASS="LITERAL">count(*)</TT>生成输入行的总数；<TT CLASS="LITERAL">count(f1)</TT>生成
<TT CLASS="LITERAL">f1</TT>不为 NULL 的输入行数，因为<CODE CLASS="FUNCTION">count</CODE>忽略NULL；
<TT CLASS="LITERAL">count(distinct f1)</TT>生成<TT CLASS="LITERAL">f1</TT>唯一且非 NULL 的行数。 </P><P>
一般情况下，输入行会以非特定顺序放入到聚合函数中。在许多情况下，这样做是没有影响的；
如，无论以什么顺序输入，<CODE CLASS="FUNCTION">min</CODE>输出相同的结果。然而，
一些聚合函数（如<CODE CLASS="FUNCTION">array_agg</CODE> 和 <CODE CLASS="FUNCTION">string_agg</CODE>）并非如此。
当使用这种聚合函数时，可以用<TT CLASS="REPLACEABLE"><I>order_by_clause</I></TT>选项指定输入的顺序。
除了它的表达式仅仅只是表达式，并且不能输出列名或列数之外，<TT CLASS="REPLACEABLE"><I>order_by_clause</I></TT>
与<TT CLASS="LITERAL">ORDER BY</TT>查询子句有相同的语法结构，在<A HREF="queries-order.html">第 7.5 &#33410;</A>中有描述，如：
</P><PRE CLASS="PROGRAMLISTING">SELECT array_agg(a ORDER BY b DESC) FROM table;</PRE><P>
</P><P>在处理多参数聚合函数时需要注意，<TT CLASS="LITERAL">ORDER BY</TT>子句要在所有的聚合函数参数之后，如这样写：
</P><PRE CLASS="PROGRAMLISTING">SELECT string_agg(a, ',' ORDER BY a) FROM table;</PRE><P>
而不是：
</P><PRE CLASS="PROGRAMLISTING">SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect</PRE><P>
后者在语法上是有效的，但它表示的是，
有两个<TT CLASS="LITERAL">ORDER BY</TT>关键字的单参数的聚合函数的调用（第二个是无用的，
因为它是一个常量）。
</P><P>如果<TT CLASS="REPLACEABLE"><I>order_by_clause</I></TT>中声明了<TT CLASS="LITERAL">DISTINCT</TT>，
那么所有的<TT CLASS="LITERAL">ORDER BY</TT>表达式必须匹配规则的聚合参数，也就是说，
不能对没有包含在<TT CLASS="LITERAL">DISTINCT</TT>列表中的表达式进行排序。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>同时在一个聚合函数中声明<TT CLASS="LITERAL">DISTINCT</TT>和<TT CLASS="LITERAL">ORDER BY</TT>是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的一个扩展。 </P></BLOCKQUOTE></DIV><P>预定义的聚合函数在<A HREF="functions-aggregate.html">第 9.20 &#33410;</A>里描述。其它聚合函数可以由用户增加。</P><P>一个聚合表达式只能在<TT CLASS="COMMAND">SELECT</TT>命令的结果列表或者<TT CLASS="LITERAL">HAVING</TT>子句里出现。
禁止在其它子句里出现(比如<TT CLASS="LITERAL">WHERE</TT>子句)，因为这些子句逻辑上在生成聚合结果之前计算。</P><P>
如果一个聚合表达式出现在一个子查询里(参阅<A HREF="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES">第 4.2.11 &#33410;</A>
和<A HREF="functions-subquery.html">第 9.22 &#33410;</A>)，聚合通常是在子查询中进行计算。
但是如果聚合的参数只包含外层查询的变量则例外：这个聚合会属于离他最近的外层查询，
并且在该查询上进行计算。该聚合表达式整体上属于它出现的子查询对外层查询的引用，
其作用相当于子查询每一次计算中的一个常量。前述限制(聚合表达式只能出现在结果列或者
<TT CLASS="LITERAL">HAVING</TT>子句中)只适用于聚合所属的查询层。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SYNTAX-WINDOW-FUNCTIONS">4.2.8. 窗口调用函数</A></H2><P>通过查询筛选出的行的某些部分，<I CLASS="FIRSTTERM">窗口调用函数</I>实现了类似于聚合函数的功能。
不同的是，窗口调用函数不需要将查询结果打包成一行输出&mdash;在查询输出中，每一行都是分开的。
然而，窗口调用函数可以扫描所有的行，根据窗口调用函数的分组规范(<TT CLASS="LITERAL">PARTITION BY</TT>列)，
这些行可能会是当前行所在组的一部分。一个窗口调用函数的语法是下列之一：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ([<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ... </SPAN
>]</SPAN
>]) OVER ( <TT
CLASS="REPLACEABLE"
><I
>window_definition</I
></TT
> )
<TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ([<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ... </SPAN
>]</SPAN
>]) OVER <TT
CLASS="REPLACEABLE"
><I
>window_name</I
></TT
>
<TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( * ) OVER ( <TT
CLASS="REPLACEABLE"
><I
>window_definition</I
></TT
> )
<TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( * ) OVER <TT
CLASS="REPLACEABLE"
><I
>window_name</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>window_definition</I></TT>具有如下语法：
</P><PRE CLASS="SYNOPSIS">[ <TT
CLASS="REPLACEABLE"
><I
>existing_window_name</I
></TT
> ]
[ PARTITION BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ]
[ ORDER BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <TT
CLASS="REPLACEABLE"
><I
>frame_clause</I
></TT
> ]</PRE><P>
选项<TT CLASS="REPLACEABLE"><I>frame_clause</I></TT>可以是：
</P><PRE CLASS="SYNOPSIS">[ RANGE | ROWS ] <TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
>
[ RANGE | ROWS ] BETWEEN <TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
> AND <TT
CLASS="REPLACEABLE"
><I
>frame_end</I
></TT
></PRE><P>
<TT CLASS="REPLACEABLE"><I>frame_start</I></TT> 和 <TT CLASS="REPLACEABLE"><I>frame_end</I></TT>可以是：
</P><PRE CLASS="SYNOPSIS">UNBOUNDED PRECEDING
<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> PRECEDING
CURRENT ROW
<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> FOLLOWING
UNBOUNDED FOLLOWING</PRE><P>
</P><P>在这里，<TT CLASS="REPLACEABLE"><I>expression</I></TT> 表示的是任何自己不含窗口调用函数的值表达式。</P><P><TT CLASS="REPLACEABLE"><I>window_name</I></TT>引用的是查询语句中<TT CLASS="LITERAL">WINDOW</TT>
子句定义的命名窗口规范。命名窗口规范通常只是用<TT CLASS="LITERAL">OVER</TT> <TT CLASS="REPLACEABLE"><I>window_name</I></TT>
来引用，但它也可以在括号里写一个窗口名，并且可以有选择的使用排序和/或框架(frame）子句
（如果应用这些子句的话，那么被引用的窗口必须不能有这些子句）。
后者语法遵循相同的规则（修改<TT CLASS="LITERAL">WINDOW</TT>子句中已有的窗口名）。
参阅<A HREF="sql-select.html">SELECT</A>查看更多资料。 </P><P><TT CLASS="LITERAL">PARTITION BY</TT>选项将查询的行分为一组进入<I CLASS="FIRSTTERM">partitions</I>，
这些行在窗口函数中单独处理。<TT CLASS="LITERAL">PARTITION BY</TT>和查询级别<TT CLASS="LITERAL">GROUP BY</TT>
子句做相似的工作，除了它的表达式只能作为表达式不能作为输出列的名字或数。
没有<TT CLASS="LITERAL">PARTITION BY</TT>，所有由查询产生的行被视为一个单独的分区。<TT CLASS="LITERAL">ORDER BY</TT>
选项决定分区中的行被窗口函数处理的顺序。它和查询级别<TT CLASS="LITERAL">ORDER BY</TT>子句做相似的工作，
但是同样的它不能作为输出列的名字或数。没有<TT CLASS="LITERAL">ORDER BY</TT>，行以一个不被预知的顺序处理。</P><P>对这些窗口函数（在这个框架而不是整个分区上的），
<TT CLASS="REPLACEABLE"><I>frame_clause</I></TT>指定构成<I CLASS="FIRSTTERM">window frame</I>的行，
他们是当前分区的一个子集。框架可以用<TT CLASS="LITERAL">RANGE</TT> 或 <TT CLASS="LITERAL">ROWS</TT>模式声明；不管哪种情况，
它的变化范围是从<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>到<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>。如果省略了<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>
默认为<TT CLASS="LITERAL">CURRENT ROW</TT>。</P><P>一个<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>的<TT CLASS="LITERAL">UNBOUNDED PRECEDING</TT>意味着框架从分区中的第一行开始，
相似的，一个<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>的<TT CLASS="LITERAL">UNBOUNDED FOLLOWING</TT>意味着框架从分区中的最后一行结束。</P><P>在<TT CLASS="LITERAL">RANGE</TT>模式中，<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>的<TT CLASS="LITERAL">CURRENT ROW</TT>
意味着框架从当前行的第一个<I CLASS="FIRSTTERM">peer</I>行开始（<TT CLASS="LITERAL">ORDER BY</TT>
认为等于当前行的行），而<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>的<TT CLASS="LITERAL">CURRENT ROW</TT>
意味着框架从最后一个同等的行结束。在<TT CLASS="LITERAL">ROWS</TT>模式中， <TT CLASS="LITERAL">CURRENT ROW</TT>
简单的意味着当前行。</P><P><TT CLASS="REPLACEABLE"><I>value</I></TT> <TT CLASS="LITERAL">PRECEDING</TT>和<TT CLASS="REPLACEABLE"><I>value</I></TT> <TT CLASS="LITERAL">FOLLOWING</TT>
当前只允许<TT CLASS="LITERAL">ROWS</TT>模式。这也就意味着，框架从当前行之前或之后指定的行数启动或结束。
<TT CLASS="REPLACEABLE"><I>value</I></TT>必须是整型表达式，而不能包含变量，聚合函数，或者窗口函数。
该值不能为空或负，但可以是零，表示只选择当前行本身。 </P><P>默认的框架选项是<TT CLASS="LITERAL">RANGE UNBOUNDED PRECEDING</TT>，该选项与
<TT CLASS="LITERAL">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</TT>相同。有<TT CLASS="LITERAL">ORDER BY</TT>，
它设置框架从分区的开始一直到与当前行相同的最后一行。没有<TT CLASS="LITERAL">ORDER BY</TT>，
那么就是当前分区的所有行都包含在框架中，因为所有行都会成为当前行的相同行。</P><P>限制条件是<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>不能为<TT CLASS="LITERAL">UNBOUNDED FOLLOWING</TT>，
<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>不能为<TT CLASS="LITERAL">UNBOUNDED PRECEDING</TT>，并且<TT CLASS="REPLACEABLE"><I>frame_end</I></TT>
选项不能在上面的列表中出现的比<TT CLASS="REPLACEABLE"><I>frame_start</I></TT>选项早&mdash;例如
<TT CLASS="LITERAL">RANGE BETWEEN CURRENT ROW AND <TT CLASS="REPLACEABLE"><I>value</I></TT> PRECEDING</TT>是不被允许的。</P><P>内置窗口函数在<A HREF="functions-window.html#FUNCTIONS-WINDOW-TABLE">&#34920; 9-48</A>中有描述。其他窗口函数，
用户可以自己添加。同样，任意内置或用户自定义聚合函数可以同窗口函数一样使用。</P><P>使用<TT CLASS="LITERAL">*</TT>的语法可以用来调用无参数的聚合函数为窗口函数，如
<TT CLASS="LITERAL">count(*) OVER (PARTITION BY x ORDER BY y)</TT>。星号(<TT CLASS="LITERAL">*</TT>)
通常不用于非聚合的窗口函数。与通常的聚合函数不同，聚合窗口函数不允许在函数参数列中使用
<TT CLASS="LITERAL">DISTINCT</TT>或<TT CLASS="LITERAL">ORDER BY</TT>。</P><P>窗口调用函数只能在<TT CLASS="LITERAL">SELECT</TT>列，或者查询的<TT CLASS="LITERAL">ORDER BY</TT>子句中使用。 </P><P>更多关于窗口函数的信息可以参考：
<A HREF="tutorial-window.html">第 3.5 &#33410;</A>,
<A HREF="functions-window.html">第 9.21 &#33410;</A>,
<A HREF="queries-table-expressions.html#QUERIES-WINDOW">第 7.2.4 &#33410;</A>.
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-TYPE-CASTS">4.2.9. 类型转换</A></H2><P>
一个类型转换声明一个从一种数据类型到另外一种数据类型的转换。
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>接受两种等效的类型转换语法：
</P><PRE CLASS="SYNOPSIS">CAST ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> AS <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> )
<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>::<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
></PRE><P>
<TT CLASS="LITERAL">CAST</TT>语法遵循 SQL 标准；<TT CLASS="LITERAL">::</TT>语法是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>历史用法。
</P><P>如果对一个已知类型的值表达式应用转换，它代表一个运行时类型转换。
只有在已经定义了合适的类型转换操作的情况下，该转换才能成功。
请注意这一点和用于常量的转换略有区别(如<A HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC">第 4.1.2.7 &#33410;</A>所示)。
一个应用于字符串文本的转换表示给该字符串文本的常数值赋予一个初始类型，
因此它对于任何类型都会成功(如果字符串文本的内容符合该数据类型的输入语法)。</P><P>如果一个值表达式的值对某类型而言不存在混淆的情况，那么我们可以省略明确的类型转换(比如，
在给一个表字段赋值的时候)，而由系统自动执行类型转换。不过，
自动转换只适用于那些系统表中标记着<SPAN CLASS="QUOTE">"OK to apply implicitly"</SPAN>的转换函数。
其它转换函数必须用明确的转换语法调用。这些限制是为了避免一些怪异的转换被自动的应用。</P><P>
我们也可以用函数风格的语法声明一个类型转换：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>typename</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> )</PRE><P>
不过，这个方法只能用于那些类型名同时也是有效函数名的类型。比如，
<TT CLASS="LITERAL">double precision</TT>就不能这么用，但是等效的<TT CLASS="LITERAL">float8</TT>
可以。同样，<TT CLASS="LITERAL">interval</TT>，<TT CLASS="LITERAL">time</TT>和<TT CLASS="LITERAL">timestamp</TT>
如果加了双引号也只能这么用，因为存在语法冲突。因此，函数风格的类型转换会导致不一致，
所以应该避免这么使用。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>函数风格语法实际上就是一个函数调用。如果使用两种标准转换语法做运行时转换，
那么它将在内部调用一个已注册的函数执行转换。通常，这种转换函数和它们的输出类型同名，
因此<SPAN CLASS="QUOTE">"函数风格语法"</SPAN>只不过是直接调用底层转换函数。
但是可以移植的程序不能依赖这一点。详情请参阅<A HREF="sql-createcast.html">CREATE CAST</A>。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-COLLATE-EXPRS">4.2.10. 排序规则表达式</A></H2><P><TT CLASS="LITERAL">COLLATE</TT>子句重写了表达式的排序规则。它附加到要应用的表达式上：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>expr</I
></TT
> COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>collation</I></TT>是一个可能的模式限定标识符。
<TT CLASS="LITERAL">COLLATE</TT>子句绑定得比操作符更紧密；需要时可以用括号。
</P><P>如果没有明确声明排序规则，数据库系统要么从表达式中的列获取一个排序规则，
要么如果表达式中没有包含列，使用数据库的默认排序规则。</P><P>
<TT CLASS="LITERAL">COLLATE</TT>子句的两个常见的使用是重写<TT CLASS="LITERAL">ORDER BY</TT>子句里的排序次序，
例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";</PRE><P>
和重写执行结果区域敏感的函数或运算符调用的排序规则，例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";</PRE><P>
请注意，在后面一种情况下，<TT CLASS="LITERAL">COLLATE</TT>子句附加到我们希望作用的运算符的输入参数。
<TT CLASS="LITERAL">COLLATE</TT>子句附加到运算符或者调用函数的哪个参数不重要，
因为运算符或者函数的排序规则是考虑所有参数得到的，并且一个明确的<TT CLASS="LITERAL">COLLATE</TT>
子句将重写所有其他参数的排序规则。（附加不匹配的<TT CLASS="LITERAL">COLLATE</TT>子句到多个参数，
是一个错误。更多详细信息请参阅<A HREF="collation.html">第 22.2 &#33410;</A>。）因此，
下面的例子给出前一个例子相同的结果：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';</PRE><P>
但是这样做是错误的：
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";</PRE><P>
因为它尝试应用一个排序规则到<TT CLASS="LITERAL">&gt;</TT>运算符的结果，而这个结果是非排序规则类型<TT CLASS="TYPE">boolean</TT>。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-SCALAR-SUBQUERIES">4.2.11. 标量子查询</A></H2><P>一个标量子查询是一个放在圆括弧里只返回一行一列的普通<TT CLASS="COMMAND">SELECT</TT>
查询(参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/queries.html">第 7 &#31456;</A>获取有关书写查询的信息)。该<TT CLASS="COMMAND">SELECT</TT>
将被执行，而其返回值将在周围的值表达式中使用。
把一个返回超过一行或者超过一列的查询用做标量查询是错误的。
（不过，在一个特定的表达式中，子查询不返回行则不算错误；标量结果被认为是 NULL)。
子查询可以引用外围查询的变量，这些变量在每次子查询中当做常量使用。
参见<A HREF="functions-subquery.html">第 9.22 &#33410;</A>以获取其它包含子查询的表达式。</P><P>
比如，下面的查询找出每个州中的最大人口数量的城市：
</P><PRE CLASS="PROGRAMLISTING">SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-ARRAY-CONSTRUCTORS">4.2.12. 数组构造器</A></H2><P>一个数组构造器是一个表达式，它从自身成员元素上构造一个数组值。
一个简单的数组构造器由关键字<TT CLASS="LITERAL">ARRAY</TT>、一个左方括弧
<TT CLASS="LITERAL">[</TT>、一个或多个表示数组元素值的表达式(用逗号分隔)、一个右方括弧<TT CLASS="LITERAL">]</TT>
组成。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</PRE><P>
默认的，数组元素类型是成员表达式的公共类型，使用和<TT CLASS="LITERAL">UNION</TT>或
<TT CLASS="LITERAL">CASE</TT>构造一样的规则决定(参阅<A HREF="typeconv-union-case.html">第 10.5 &#33410;</A>)。
你可以通过明确地转换数组构造器为想要的类型来重写这个规则，例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)</PRE><P>
这和单独构造每个表达式为数组元素类型有相同的效果。关于构造的更多信息，请参阅<A HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS">第 4.2.9 &#33410;</A>。
</P><P>多维数组值可以通过嵌套数组构造器的方法来制作。内层构造器中的<TT CLASS="LITERAL">ARRAY</TT>
关键字可以省略。比如，下面的两句生成同样的结果：
</P><PRE CLASS="PROGRAMLISTING">SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</PRE><P>
因为多维数组必须是方形，所以同层的内层构造器必须生成同维的子数组。
任何应用于外层<TT CLASS="LITERAL">ARRAY</TT>构造器的类型转换自动的应用到所有的内层构造器。
</P><P>多维数组构造器元素可以是任何生成合适数组的东西，而不仅仅是一个子<TT CLASS="LITERAL">ARRAY</TT>构造。比如：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)</PRE><P>
</P><P>因为数组必须得有类型，因此在构造一个空数组时，必须明确的将其构造成需要的类型，如：
</P><PRE CLASS="PROGRAMLISTING">SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)</PRE><P>
</P><P>我们也可以从一个子查询的结果中构造一个数组。此时，
数组构造器是关键字<TT CLASS="LITERAL">ARRAY</TT>后跟着一个用圆括弧(不是方括弧)包围的子查询。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)</PRE><P>
子查询必须只返回一个单独的字段。生成的一维数组将为子查询里每行结果生成一个元素，
元素类型匹配子查询的输出字段。
</P><P>用<TT CLASS="LITERAL">ARRAY</TT>建立的数组下标总是从1开始。
有关数组的更多信息，参阅<A HREF="arrays.html">第 8.15 &#33410;</A>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SQL-SYNTAX-ROW-CONSTRUCTORS">4.2.13. 行构造器</A></H2><P>行构造器是一个从提供给它的成员字段数值中构造行值(也叫复合类型值)的表达式。
一个行构造器由关键字<TT CLASS="LITERAL">ROW</TT>、一个左圆括弧、零个或多个作为行字段值的表达式(用逗号分隔)、
一个右圆括弧组成。比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT ROW(1,2.5,'this is a test');</PRE><P>
如果在列表里有多个表达式，那么关键字<TT CLASS="LITERAL">ROW</TT>是可选的。
</P><P>行构造器可以包含<TT CLASS="REPLACEABLE"><I>rowvalue</I></TT><TT CLASS="LITERAL">.*</TT>语法，
它将被扩展为行值元素的列表，就像将<TT CLASS="LITERAL">.*</TT>语法用于一个<TT CLASS="COMMAND">SELECT</TT>
列表顶层一样。例如，如果表<TT CLASS="LITERAL">t</TT>有<TT CLASS="LITERAL">f1</TT>和<TT CLASS="LITERAL">f2</TT>两个字段，
那么下面两句是等价的：
</P><PRE CLASS="PROGRAMLISTING">SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;</PRE><P>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.2之前，<TT CLASS="LITERAL">.*</TT>语法是不会被扩展的，
所以<TT CLASS="LITERAL">ROW(t.*, 42)</TT> 将创建一个两字段的行，其第一个字段是另一行的值。
新的行为通常更有用。如果你需要旧式的嵌套行值的做法，请将内部的行值写成不包含<TT CLASS="LITERAL">.*</TT>，
比如<TT CLASS="LITERAL">ROW(t, 42)</TT>。</P></BLOCKQUOTE></DIV><P>缺省时，<TT CLASS="LITERAL">ROW</TT>表达式创建的值是一个匿名的记录类型。如果必要，
你可以把它转换成一个命名的复合类型(既可以是一个表的行类型，
也可以是一个用<TT CLASS="COMMAND">CREATE TYPE AS</TT>创建的复合类型)。
可能会需要一个明确的转换以避免歧义。比如：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;


-- 因为只有一个getf1()存在，所以不需要类型转换
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- 现在我们需要类型转换以表明调用哪个函数：
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)</PRE><P>
</P><P>行构造器可以用于制作存储在复合类型字段中的复合类型值，
或者是传递给一个接受复合类型参数的函数。另外，
我们也可以用它比较两个行值或者用<TT CLASS="LITERAL">IS NULL</TT>
或<TT CLASS="LITERAL">IS NOT NULL</TT>测试一个行值，比如：
</P><PRE CLASS="PROGRAMLISTING">SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -- detect all-null rows</PRE><P>
更多的细节，请参阅<A HREF="functions-comparisons.html">第 9.23 &#33410;</A>。
行构造器还可以用于连接子查询，这些在<A HREF="functions-subquery.html">第 9.22 &#33410;</A>里面有详细讨论。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="SYNTAX-EXPRESS-EVAL">4.2.14. 表达式计算规则</A></H2><P>子表达式的计算顺序是未定义的。特别要指出的是，
一个操作符或者函数的输入并不一定是按照从左向右的顺序或者以某种特定的顺序进行计算的。</P><P>另外，如果一个表达式的结果可以通过只判断它的一部分就可以得到，
那么其它子表达式就可以完全不计算了。比如，如果我们这么写：
</P><PRE CLASS="PROGRAMLISTING">SELECT true OR somefunc();</PRE><P>
那么<TT CLASS="LITERAL">somefunc()</TT>就(可能)根本不会被调用。
即使像下面这样写也是一样：
</P><PRE CLASS="PROGRAMLISTING">SELECT somefunc() OR true;</PRE><P>
请注意这和某些编程语言里从左向右<SPAN CLASS="QUOTE">"短路"</SPAN>布尔操作符是不一样的。
</P><P>因此，拿有副作用的函数作为复杂表达式的一部分是不明智的。
在<TT CLASS="LITERAL">WHERE</TT>和<TT CLASS="LITERAL">HAVING</TT>子句里依赖副作用或者是计算顺序是特别危险的，
因为这些子句都是作为生成一个执行规划的一部分进行了大量的再处理。
在这些子句里的布尔表达式(<TT CLASS="LITERAL">AND</TT>/<TT CLASS="LITERAL">OR</TT>/<TT CLASS="LITERAL">NOT</TT>
的组合)可以用布尔代数运算律允许的任何方式进行识别。</P><P>如果需要强制计算顺序，那么可以使用<TT CLASS="LITERAL">CASE</TT>构造(参阅<A HREF="functions-conditional.html">第 9.17 &#33410;</A>)。
比如，下面是一种企图避免在<TT CLASS="LITERAL">WHERE</TT>子句里被零除的不可靠方法：
</P><PRE CLASS="PROGRAMLISTING">SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;</PRE><P>
但是下面这个是安全的：
</P><PRE CLASS="PROGRAMLISTING">SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</PRE><P>
这种风格的<TT CLASS="LITERAL">CASE</TT>构造会阻止优化，因此应该只在必要的时候才使用。
在这个特殊的例子里，毫无疑问写成 <TT CLASS="LITERAL">y &gt; 1.5*x</TT>更好。
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-syntax-lexical.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-syntax-calling-funcs.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">词法结构</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-syntax.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">调用函数</TD></TR></TABLE></DIV></BODY></HTML>
