<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>不同解决方案的比较</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="高可用性与负载均衡，复制" HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html"><LINK REL="PREVIOUS" TITLE="高可用性与负载均衡，复制" HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html"><LINK REL="NEXT" TITLE="日志传送备份服务器" HREF="warm-standby.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/high-availability.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="高可用性与负载均衡，复制" HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 25. 高可用性与负载均衡，复制</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="日志传送备份服务器" HREF="warm-standby.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="DIFFERENT-REPLICATION-SOLUTIONS">25.1. 不同解决方案的比较</A></H1><P></P><DIV CLASS="VARIABLELIST"><DL><DT>共享磁盘失效切换</DT><DD><P> 共享磁盘失效切换通过仅保存一份数据库副本来避免花在同步上的开销。
这个方案让多台服务器共享使用一个单独的磁盘阵列。
如果主服务器失效，备份服务器将立即挂载该数据库，
就像是从一次崩溃中恢复一样。这个方案允许快速的失效切换并且不会丢失数据。</P><P> 共享硬件的功能通常由网络存储设备提供，
也可以使用完全符合<ACRONYM CLASS="ACRONYM">POSIX</ACRONYM>行为的网络文件系统(参阅<A HREF="creating-cluster.html#CREATING-CLUSTER-NFS">第 17.2.1 &#33410;</A>)。
这种方案的局限性在于如果共享的磁盘阵列损坏了，
那么整个系统将会瘫痪。
另一个局限是备份服务器在主服务器正常运行的时候不能访问共享的存储器。</P></DD><DT>文件系统复制（块设备）</DT><DD><P> 一种改进的方案是文件系统复制：对文件系统的任何更改都将镜像到备份服务器上。
这个方案的唯一局限是必须确保备份服务器的镜像与主服务器完全一致&mdash;
特别是写入顺序必须完全相同。<SPAN CLASS="PRODUCTNAME">DRBD</SPAN>是Linux上的一种流行的文件系统复制方案。</P></DD><DT>事务日志传送</DT><DD><P> 热备份服务器可以通过读取<ACRONYM CLASS="ACRONYM">WAL</ACRONYM>记录流来保持数据库的当前状态。
如果主服务器失效，那么热备份服务器将包含几乎所有主服务器的数据，
并可以迅速的将自己切换为主服务器。这是一个异步方案，
并且只能在整个数据库服务器上实施。&#13;</P><P> 使用基于文件的日志传送或流复制，或两者相结合。
前者参阅<A HREF="warm-standby.html">第 25.2 &#33410;</A>, 后者参阅<A HREF="warm-standby.html#STREAMING-REPLICATION">第 25.2.5 &#33410;</A>。
请参阅<A HREF="hot-standby.html">第 25.5 &#33410;</A>获取关于热备的信息。</P></DD><DT>基于触发器的主备复制</DT><DD><P> 这个方案将所有修改数据的请求发送到主服务器。
主服务器异步向从服务器发送数据的更改信息。
从服务器在主服务器运行的情况下只应答读请求。对于数据仓库的请求来说，
从服务器非常理想的。</P><P> <SPAN CLASS="PRODUCTNAME">Slony-I</SPAN>是这个方案的一个例子，它支持针对每个表的粒度并支持多个从服务器。
因为它异步、批量的更新从服务器，
在失效切换的时候可能会有数据丢失。</P></DD><DT>基于语句的复制中间件</DT><DD><P> 可以使用一个基于语句的复制中间件程序截取每一个SQL查询，
并将其发送到某一个或者全部服务器。每一个服务器都独立运行。
读-写请求发送给所有服务器，所以每个服务器接收到任何变化。但是只
读请求则仅发送给某一个服务器，从而实现读取的负载均衡。</P><P> 如果只是简单的广播修改数据的SQL语句，
那么类似<CODE CLASS="FUNCTION">random()</CODE>, <CODE CLASS="FUNCTION">CURRENT_TIMESTAMP</CODE>
以及序列函数在不同的服务器上将生成不同的结果。
这是因为每个服务器都独立运行并且广播的是SQL语句而不是如何对行进行修改。
如果这种结果是不可接受的，那么中间件或者应用程序必须保证始终从同
一个服务器读取这些值并将其应用到写入请求中。
另外还必须保证每一个事务必须在所有服务器上全部提交成功或者全部回滚，
或者使用两阶段提交(<A HREF="sql-prepare-transaction.html">PREPARE TRANSACTION</A>
和<A HREF="sql-commit-prepared.html">COMMIT PREPARED</A>)。
<SPAN CLASS="PRODUCTNAME">Pgpool-II</SPAN>和<SPAN CLASS="PRODUCTNAME">Continuent Tungsten</SPAN>是这种方案的实例。</P></DD><DT>异步多主服务器复制</DT><DD><P> 对于那些不规则连接的服务器(比如笔记本电脑或远程服务器)，
要在它们之间保持数据一致是很麻烦的。
在这个方案中，每台服务器都独立工作并周期性的与其他服务器通信以识别相互冲突的事务。
可以通过用户或者冲突判决规则处理出现的冲突。</P></DD><DT>同步多主服务器复制</DT><DD><P> 在这种方案中，每个服务器都可以接受写入请求，
修改的数据将在事务被提交之前必须从原始服务器广播到所有其它服务器。
过多的写入动作将导致过多的锁定，从而导致性能低下。
事实上，在多台服务器上同时写的性能总是比在单独一台服务器上写的性能低。
读请求将被均衡的分散到每台单独的服务器。 某些实现使用共享磁盘来减少通信开销。
同步多主服务器复制方案最适合于读取远多于写入的场合。
它的优势是每台服务器都能接受写请求&mdash;因此不需要在主从服务器之间划分工作负荷。
因为在服务器之间发送的是数据的变化，
所以不会对非确定性函数(比如<CODE CLASS="FUNCTION">random()</CODE>)造成不良影响。</P><P> <SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>不提供这种类型的复制。
但是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的两阶段提交(<A HREF="sql-prepare-transaction.html">PREPARE TRANSACTION</A>和
<A HREF="sql-commit-prepared.html">COMMIT PREPARED</A>)
可以用于在应用层或中间件代码中实现这个功能。</P></DD><DT>商业解决方案</DT><DD><P> 因为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>是开放源代码并且很容易被扩展，
许多公司在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的基础上创建了商业的闭源解决方案，
提供独特的失效切换、复制、负载均衡功能。</P></DD></DL></DIV><P> <A HREF="different-replication-solutions.html#HIGH-AVAILABILITY-MATRIX">&#34920; 25-1</A>总结了以上所列的各种解决方案的能力。</P><DIV CLASS="TABLE"><A NAME="HIGH-AVAILABILITY-MATRIX"></A><P><B>&#34920; 25-1. High Availability, Load Balancing, and Replication Feature Matrix</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><COL><COL><COL><COL><THEAD><TR><TH>Feature</TH><TH>Shared Disk Failover</TH><TH>File System Replication</TH><TH>Transaction Log Shipping</TH><TH>Trigger-Based Master-Standby Replication</TH><TH>Statement-Based Replication Middleware</TH><TH>Asynchronous Multimaster Replication</TH><TH>Synchronous Multimaster Replication</TH></TR></THEAD><TBODY><TR><TD>Most Common Implementation</TD><TD ALIGN="CENTER">NAS</TD><TD ALIGN="CENTER">DRBD</TD><TD ALIGN="CENTER">Streaming Repl.</TD><TD ALIGN="CENTER">Slony</TD><TD ALIGN="CENTER">pgpool-II</TD><TD ALIGN="CENTER">Bucardo</TD><TD ALIGN="CENTER">&nbsp;</TD></TR><TR><TD>Communication Method</TD><TD ALIGN="CENTER">shared disk</TD><TD ALIGN="CENTER">disk blocks</TD><TD ALIGN="CENTER">WAL</TD><TD ALIGN="CENTER">table rows</TD><TD ALIGN="CENTER">SQL</TD><TD ALIGN="CENTER">table rows</TD><TD ALIGN="CENTER">table rows and row locks</TD></TR><TR><TD>No special hardware required</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD></TR><TR><TD>Allows multiple master servers</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD></TR><TR><TD>No master server overhead</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD></TR><TR><TD>No waiting for multiple servers</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">with sync off</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD></TR><TR><TD>Master failure will never lose data</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">with sync on</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD></TR><TR><TD>Standby accept read-only queries</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">with hot</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD></TR><TR><TD>Per-table granularity</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD></TR><TR><TD>No conflict resolution necessary</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&bull;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD><TD ALIGN="CENTER">&bull;</TD></TR></TBODY></TABLE></DIV><P> 有几个解决方案不适合上边这些分类：</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT>数据分区</DT><DD><P> 数据分区将表拆分为数据集。每个数据集只有一台服务器可以修改。
例如，数据可以按办事处进行分区，例如，
伦敦和巴黎，每个办公室用一个服务器。
如果查询需要伦敦和巴黎相结合的数据，应用程序可以查询两台服务器，
或主/备用复制可以用来保持每个服务器上有其他办公室的只读数据副本。</P></DD><DT>多服务器并行查询执行</DT><DD><P> 许多上述解决方案允许多个服务器来处理多个查询，
但不是允许单个查询使用多个服务器来更快完成。
此解决方案允许多个服务器上单个查询同时运行。
它通常被通过服务器之间的数据分开而执行其查询的一部分，
并将结果返回到中央服务器，由它来联合结果并返回给用户。
<SPAN CLASS="PRODUCTNAME">Pgpool-II</SPAN>有这种能力。
也可以使用<SPAN CLASS="PRODUCTNAME">PL/Proxy</SPAN>工具集实现。</P></DD></DL></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="warm-standby.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">高可用性与负载均衡，复制</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/high-availability.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">日志传送备份服务器</TD></TR></TABLE></DIV></BODY></HTML>
