<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>psql</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="PostgreSQL 客户端应用程序" HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html"><LINK REL="PREVIOUS" TITLE="pg_restore" HREF="app-pgrestore.html"><LINK REL="NEXT" TITLE="reindexdb" HREF="app-reindexdb.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/psql-ref.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pg_restore" HREF="app-pgrestore.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="reindexdb" HREF="app-reindexdb.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="APP-PSQL"></A><SPAN CLASS="APPLICATION">psql</SPAN></H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN86287"></A><H2>&#21517;&#31216;</H2><SPAN CLASS="APPLICATION">psql</SPAN>&nbsp;--&nbsp;
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 交互终端
</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN86294"></A><H2>&#22823;&#32434;</H2><P><TT CLASS="COMMAND">psql</TT> [<TT CLASS="REPLACEABLE"><I>option</I></TT>...] [<TT CLASS="REPLACEABLE"><I>dbname</I></TT>
[<TT CLASS="REPLACEABLE"><I>username</I></TT>]]</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN86303"></A><H2>描述</H2><P><SPAN CLASS="APPLICATION">psql</SPAN>是一个以终端为基础的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
前端。它允许你交互地键入查询，然后把它们发出给<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>，
再显示查询的结果。另外，输入可以来自一个文件。还有，它提供了一些元命令和多种类似
shell的特性来实现书写脚本以及对大量任务的自动化。</P></DIV><DIV CLASS="REFSECT1"><A NAME="R1-APP-PSQL-3"></A><H2>选项</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-a</TT><BR><TT CLASS="OPTION">--echo-all</TT></DT><DD><P>在读取行时向标准输出打印所有内容。这个选项在脚本处理时比交互模式时更有用。
这个选项等效于设置<TT CLASS="VARNAME">ECHO</TT>变量为<TT CLASS="LITERAL">all</TT>。</P></DD><DT><TT CLASS="OPTION">-A</TT><BR><TT CLASS="OPTION">--no-align</TT></DT><DD><P>切换为非对齐输出模式。缺省输出模式是对齐的。</P></DD><DT><TT CLASS="OPTION">-c <TT CLASS="REPLACEABLE"><I>command</I></TT></TT><BR><TT CLASS="OPTION">--command=<TT CLASS="REPLACEABLE"><I>command</I></TT></TT></DT><DD><P>声明<SPAN CLASS="APPLICATION">psql</SPAN>将执行一条命令字符串
<TT CLASS="REPLACEABLE"><I>command</I></TT>，然后退出。
这一点在 shell 脚本里很有用。这个选项忽略启动文件
(<TT CLASS="FILENAME">psqlrc</TT>和<TT CLASS="FILENAME">~/.psqlrc</TT>)。</P><P><TT CLASS="REPLACEABLE"><I>command</I></TT>必须是一条完全可以被服务器分析的字符串
(也就是不包含<SPAN CLASS="APPLICATION">psql</SPAN>特有的特性)，或者是一个反斜杠命令。
这样你就不会混合<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>和<SPAN CLASS="APPLICATION">psql</SPAN>元命令。
要想混合使用，你可以把字符串重定向到<SPAN CLASS="APPLICATION">psql</SPAN>里，
像这样：<TT CLASS="LITERAL">echo '\x \\ SELECT * FROM foo;' | psql</TT>
(<TT CLASS="LITERAL">\\</TT>用于隔开元命令)。</P><P>如果命令字符串包含多个 SQL 命令，那么他们将在一个事务里处理，
除非在字符串里包含了明确的<TT CLASS="COMMAND">BEGIN</TT>/<TT CLASS="COMMAND">COMMIT</TT>命令把他们分成多个事务。
这个和从<SPAN CLASS="APPLICATION">psql</SPAN>的标准输入里给它填充相同字符串不同。
另外，只返回最后一条SQL命令的结果。</P></DD><DT><TT CLASS="OPTION">-d <TT CLASS="REPLACEABLE"><I>dbname</I></TT></TT><BR><TT CLASS="OPTION">--dbname=<TT CLASS="REPLACEABLE"><I>dbname</I></TT></TT></DT><DD><P>声明想要连接的数据库名称。等效于在命令行行上把
<TT CLASS="REPLACEABLE"><I>dbname</I></TT>声明为第一个非选项参数。</P><P>如果这个参数包含一个<TT CLASS="SYMBOL">=</TT>号，或者以一个有效的<ACRONYM CLASS="ACRONYM">URI</ACRONYM>
前缀(<TT CLASS="LITERAL">postgresql://</TT>或<TT CLASS="LITERAL">postgres://</TT>)开头，
那么将它看做一个<TT CLASS="PARAMETER">conninfo</TT>字符串。
参阅<A HREF="libpq-connect.html#LIBPQ-CONNSTRING">第 31.1.1 &#33410;</A>获取更多信息。</P></DD><DT><TT CLASS="OPTION">-e</TT><BR><TT CLASS="OPTION">--echo-queries</TT></DT><DD><P>把所有发送给服务器的查询同时也回显到标准输出。等效于把变量
<TT CLASS="VARNAME">ECHO</TT>设置为<TT CLASS="LITERAL">queries</TT>。</P></DD><DT><TT CLASS="OPTION">-E</TT><BR><TT CLASS="OPTION">--echo-hidden</TT></DT><DD><P>回显由<TT CLASS="COMMAND">\d</TT>和其它反斜杠命令生成的实际查询。
你可以使用这个命令学习<SPAN CLASS="APPLICATION">psql</SPAN>的内部操作。
这等效于在<SPAN CLASS="APPLICATION">psql</SPAN>里设置变量<TT CLASS="VARNAME">ECHO_HIDDEN</TT>。</P></DD><DT><TT CLASS="OPTION">-f <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT><BR><TT CLASS="OPTION">--file=<TT CLASS="REPLACEABLE"><I>filename</I></TT></TT></DT><DD><P>使用<TT CLASS="REPLACEABLE"><I>filename</I></TT>
作为命令的语句源而不是交互式读入查询。<SPAN CLASS="APPLICATION">psql</SPAN>
将在处理完文件后结束。这个选项在很多方面等效于元命令<TT CLASS="COMMAND">\i</TT>。</P><P>如果<TT CLASS="REPLACEABLE"><I>filename</I></TT>是<TT CLASS="LITERAL">-</TT>(连字符)，则从标准输入读取。</P><P>使用这个选项与使用<TT CLASS="LITERAL">psql &lt; <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT>
有微小的区别。通常，两者都会按照你预期那样运行，但是使用<TT CLASS="LITERAL">-f</TT>
打开了一些很好的特性，比如带行号的错误信息。而且，使用这个选项还可能减小启动的开销。
另一方面，如果你把所有内容手工输入，使用shell输入定向的方式(理论上)
能保证生成和你已经得到的完全一样的输出。</P></DD><DT><TT CLASS="OPTION">-F <TT CLASS="REPLACEABLE"><I>separator</I></TT></TT><BR><TT CLASS="OPTION">--field-separator=<TT CLASS="REPLACEABLE"><I>separator</I></TT></TT></DT><DD><P>使用<TT CLASS="REPLACEABLE"><I>separator</I></TT>作为未对齐输出的域分隔符。
等效于<TT CLASS="COMMAND">\pset fieldsep</TT>或<TT CLASS="COMMAND">\f</TT>。</P></DD><DT><TT CLASS="OPTION">-h <TT CLASS="REPLACEABLE"><I>hostname</I></TT></TT><BR><TT CLASS="OPTION">--host=<TT CLASS="REPLACEABLE"><I>hostname</I></TT></TT></DT><DD><P>指定正在运行服务器的主机名。如果主机名以斜杠开头，则它被用作到Unix域套接字的路径。</P></DD><DT><TT CLASS="OPTION">-H</TT><BR><TT CLASS="OPTION">--html</TT></DT><DD><P>打开<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>格式输出。等效于<TT CLASS="LITERAL">\pset format html</TT>
或<TT CLASS="COMMAND">\H</TT>命令。</P></DD><DT><TT CLASS="OPTION">-l</TT><BR><TT CLASS="OPTION">--list</TT></DT><DD><P>列出所有可用的数据库，然后退出。其它非连接选项将被忽略。类似于元命令<TT CLASS="COMMAND">\list</TT>。</P></DD><DT><TT CLASS="OPTION">-L <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT><BR><TT CLASS="OPTION">--log-file=<TT CLASS="REPLACEABLE"><I>filename</I></TT></TT></DT><DD><P>除了正常的输出源之外，把所有查询输出记录到文件<TT CLASS="REPLACEABLE"><I>filename</I></TT>。</P></DD><DT><TT CLASS="OPTION">-n</TT><BR><TT CLASS="OPTION">--no-readline</TT></DT><DD><P>在行编辑中不使用<SPAN CLASS="APPLICATION">readline</SPAN>，并且不使用历史。
这可以在剪切和粘贴时用于关闭tab扩展。</P></DD><DT><TT CLASS="OPTION">-o <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT><BR><TT CLASS="OPTION">--output=<TT CLASS="REPLACEABLE"><I>filename</I></TT></TT></DT><DD><P>将所有查询输出重定向到文件<TT CLASS="REPLACEABLE"><I>filename</I></TT>。
这个选项等效于<TT CLASS="COMMAND">\o</TT>命令。</P></DD><DT><TT CLASS="OPTION">-p <TT CLASS="REPLACEABLE"><I>port</I></TT></TT><BR><TT CLASS="OPTION">--port=<TT CLASS="REPLACEABLE"><I>port</I></TT></TT></DT><DD><P>指定服务器侦听的TCP端口或本地Unix域套接字文件的扩展。
缺省使用环境变量<TT CLASS="ENVAR">PGPORT</TT>的值，
如果没有设置的话则使用编译时声明的端口(通常是 5432)。</P></DD><DT><TT CLASS="OPTION">-P <TT CLASS="REPLACEABLE"><I>assignment</I></TT></TT><BR><TT CLASS="OPTION">--pset=<TT CLASS="REPLACEABLE"><I>assignment</I></TT></TT></DT><DD><P>以<TT CLASS="COMMAND">\pset</TT>的风格设置打印选项。
要注意的是你在这里必须用等号而不是空格分割名称和值。
例如，要把输出格式设置为<SPAN CLASS="APPLICATION">LaTeX</SPAN>，
你可以敲入<TT CLASS="LITERAL">-P format=latex</TT>。</P></DD><DT><TT CLASS="OPTION">-q</TT><BR><TT CLASS="OPTION">--quiet</TT></DT><DD><P>声明<SPAN CLASS="APPLICATION">psql</SPAN>应该安静地执行处理任务。缺省时，
它将打印欢迎和许多其它输出信息。如果使用了此选项，这些都不会出现。
这在和<TT CLASS="OPTION">-c</TT>选项一起使用时很有效。在<SPAN CLASS="APPLICATION">psql</SPAN>
里可以通过设置<TT CLASS="VARNAME">QUIET</TT>变量实现同样效果。</P></DD><DT><TT CLASS="OPTION">-R <TT CLASS="REPLACEABLE"><I>separator</I></TT></TT><BR><TT CLASS="OPTION">--record-separator=<TT CLASS="REPLACEABLE"><I>separator</I></TT></TT></DT><DD><P>使用<TT CLASS="REPLACEABLE"><I>separator</I></TT>
做为非对齐输出的记录分隔符。等效于<TT CLASS="COMMAND">\pset recordsep</TT>命令。</P></DD><DT><TT CLASS="OPTION">-s</TT><BR><TT CLASS="OPTION">--single-step</TT></DT><DD><P>单步模式运行。意味着每个命令在发往服务器之前都要提示用户，
用这个选项也可以取消执行。此选项主要用于调试脚本。</P></DD><DT><TT CLASS="OPTION">-S</TT><BR><TT CLASS="OPTION">--single-line</TT></DT><DD><P>单行运行模式，这时每个命令都将由换行符结束，像分号那样。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这个模式是给那些坚持要使用这个特性的人保留的，不鼓励你这么用。实际上，
如果你在一行里混合使用<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>和元命令，
执行的顺序对不熟练的用户而言并不总是清晰的。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="OPTION">-t</TT><BR><TT CLASS="OPTION">--tuples-only</TT></DT><DD><P>关闭打印列名称和结果行计数脚注等信息。等效于<TT CLASS="COMMAND">\t</TT>命令。</P></DD><DT><TT CLASS="OPTION">-T <TT CLASS="REPLACEABLE"><I>table_options</I></TT></TT><BR><TT CLASS="OPTION">--table-attr=<TT CLASS="REPLACEABLE"><I>table_options</I></TT></TT></DT><DD><P>声明放在<ACRONYM CLASS="ACRONYM">HTML</ACRONYM> <CODE CLASS="SGMLTAG">table</CODE>标签里的选项。
参阅<TT CLASS="COMMAND">\pset</TT>获取细节。</P></DD><DT><TT CLASS="OPTION">-U <TT CLASS="REPLACEABLE"><I>username</I></TT></TT><BR><TT CLASS="OPTION">--username=<TT CLASS="REPLACEABLE"><I>username</I></TT></TT></DT><DD><P>以用户<TT CLASS="REPLACEABLE"><I>username</I></TT>
代替缺省用户与数据库连接。当然，你必须有这么做的权限。</P></DD><DT><TT CLASS="OPTION">-v <TT CLASS="REPLACEABLE"><I>assignment</I></TT></TT><BR><TT CLASS="OPTION">--set=<TT CLASS="REPLACEABLE"><I>assignment</I></TT></TT><BR><TT CLASS="OPTION">--variable=<TT CLASS="REPLACEABLE"><I>assignment</I></TT></TT></DT><DD><P>像元命令<TT CLASS="COMMAND">\set</TT>那样进行一次变量分配。注意，如果有变量名和值的话，
你必须在命令行上用等号分隔它们。去掉等号则重置变量。要设置一个带有空值的变量，
可以保留等号但是不指定值。这个分配是在启动之初进行的，
所以为内部使用而保留的变量可能被再次覆盖。</P></DD><DT><TT CLASS="OPTION">-V</TT><BR><TT CLASS="OPTION">--version</TT></DT><DD><P>打印<SPAN CLASS="APPLICATION">psql</SPAN>版本信息然后退出。</P></DD><DT><TT CLASS="OPTION">-w</TT><BR><TT CLASS="OPTION">--no-password</TT></DT><DD><P>从不提示密码。如果服务器需要密码验证而密码不可通过其他方式
（比如<TT CLASS="FILENAME">.pgpass</TT>文件）获得，则连接尝试将失败。
该选项在批量工作和不存在用户输入密码的脚本中很有帮助。</P><P>请注意，这个选项对整个会话有效，所以它影响元命令<TT CLASS="COMMAND">\connect</TT>的使用，
还有初始连接尝试。</P></DD><DT><TT CLASS="OPTION">-W</TT><BR><TT CLASS="OPTION">--password</TT></DT><DD><P>强制<SPAN CLASS="APPLICATION">psql</SPAN>在与一个数据库连接前提示输入口令。</P><P>这个选项从来不是至关重要的，因为如果服务器需求密码认证，
则<SPAN CLASS="APPLICATION">psql</SPAN>自动提示一个密码。不过，<SPAN CLASS="APPLICATION">psql</SPAN>
将在找出服务器想要一个密码上浪费一个连接尝试。在某些情况下，
值得输入<TT CLASS="OPTION">-W</TT>以避免额外的连接尝试。</P><P>请注意，这个选项对整个会话有效，所以它影响元命令<TT CLASS="COMMAND">\connect</TT>的使用，
还有初始连接尝试。</P></DD><DT><TT CLASS="OPTION">-x</TT><BR><TT CLASS="OPTION">--expanded</TT></DT><DD><P>打开扩展表格式模式。等效于<TT CLASS="COMMAND">\x</TT>命令。</P></DD><DT><TT CLASS="OPTION">-X,</TT><BR><TT CLASS="OPTION">--no-psqlrc</TT></DT><DD><P>不读取启动文件(系统范围的<TT CLASS="FILENAME">psqlrc</TT>或者你自己的
<TT CLASS="FILENAME">~/.psqlrc</TT>都不读取)。</P></DD><DT><TT CLASS="OPTION">-z</TT><BR><TT CLASS="OPTION">--field-separator-zero</TT></DT><DD><P>为未对齐的输出设置字段分隔符为零字节。</P></DD><DT><TT CLASS="OPTION">-0</TT><BR><TT CLASS="OPTION">--record-separator-zero</TT></DT><DD><P>为未对齐的输出设置记录分隔符为零字节。这个接口连接时是有用的，
例如，<TT CLASS="LITERAL">xargs -0</TT>。</P></DD><DT><TT CLASS="OPTION">-1</TT><BR><TT CLASS="OPTION">--single-transaction</TT></DT><DD><P>当<SPAN CLASS="APPLICATION">psql</SPAN>执行脚本时，
使用这个选项将导致在脚本的开头和结尾分别加上<TT CLASS="COMMAND">BEGIN</TT>/<TT CLASS="COMMAND">COMMIT</TT>
来把整个脚本当作一个事务执行。这将保证该脚本要么完全执行成功，要么不产生任何影响。</P><P>如果在脚本中已经使用了<TT CLASS="COMMAND">BEGIN</TT>、<TT CLASS="COMMAND">COMMIT</TT>、<TT CLASS="COMMAND">ROLLBACK</TT>，
那么该选项将不会得到期望的效果。同样，如果脚本中包含任何不能在事务块内部使用的命令，
使用这个选项将导致这样的命令执行失败，当然整个事务亦将失败。</P></DD><DT><TT CLASS="OPTION">-?</TT><BR><TT CLASS="OPTION">--help</TT></DT><DD><P>显示关于<SPAN CLASS="APPLICATION">psql</SPAN>命令行参数的帮助然后退出。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN86667"></A><H2>退出状态</H2><P>如果正常结束，那么<SPAN CLASS="APPLICATION">psql</SPAN>向 shell 返回 0 ，
如果自身发生致命错误，则返回 1(比如内存用尽，未找到文件等)，
如果和数据库的连接失效而且会话不再活跃则返回 2 ，
如果脚本中发生错误并且设置了<TT CLASS="VARNAME">ON_ERROR_STOP</TT>则返回 3 。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN86672"></A><H2>用法</H2><DIV CLASS="REFSECT2"><A NAME="R2-APP-PSQL-CONNECTING"></A><H3>连接一个数据库</H3><P><SPAN CLASS="APPLICATION">psql</SPAN>是一个普通的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
客户端应用。为了与一个数据库连接，你需要知道目标数据库、服务器的主机名和端口号、
以及你希望以哪个用户的身份进行连接等信息。可以通过命令行参数<TT CLASS="OPTION">-d</TT>,
<TT CLASS="OPTION">-h</TT>, <TT CLASS="OPTION">-p</TT>, <TT CLASS="OPTION">-U</TT>告诉
<SPAN CLASS="APPLICATION">psql</SPAN>这些信息。如果某个参数不属于任何选项，
那么它会被解释成数据库名或者是用户名(如果数据库名称已经给出了)。
不是所有这些选项都是必须的，有的缺省就存在。如果你省略主机名，<SPAN CLASS="APPLICATION">psql</SPAN>
将通过Unix域套接字与本地主机的服务器相联，或者在没有unix域套接字的机器上，
通过TCP/IP与<TT CLASS="LITERAL">localhost</TT>连接。缺省的端口号是编译时确定的。
因为数据库服务器使用同样的缺省值，所以在大多数设置下，你可能不需要声明端口号。
缺省的用户名是你的Unix用户名，与数据库同名。
要注意的是你不能用任意用户名与任何数据库相联。你的数据库管理员应该告诉你有哪些访问权限。</P><P>如果缺省不太正确，那么你可以通过设置几个环境变量<TT CLASS="ENVAR">PGDATABASE</TT>,
<TT CLASS="ENVAR">PGHOST</TT>,<TT CLASS="ENVAR">PGPORT</TT>和/或<TT CLASS="ENVAR">PGUSER</TT>
的方法节约几次敲击。其它环境变量的信息，参阅<A HREF="libpq-envars.html">第 31.14 &#33410;</A>。
另外，用一个<TT CLASS="FILENAME">~/.pgpass</TT>文件来避免输入密码也是很方便的。
参阅<A HREF="libpq-pgpass.html">第 31.15 &#33410;</A>获取更多信息。</P><P>声明连接参数的另一种方式是在<TT CLASS="PARAMETER">conninfo</TT>字符串或
<ACRONYM CLASS="ACRONYM">URI</ACRONYM>中，代替数据库名字。这种机制让你非常广泛的控制连接。
例如：
</P><PRE CLASS="PROGRAMLISTING">$ <KBD
CLASS="USERINPUT"
>psql "service=myservice sslmode=require"</KBD
>
$ <KBD
CLASS="USERINPUT"
>psql postgresql://dbmaster:5433/mydb?sslmode=require</KBD
></PRE><P>
这种方式你也可以使用<ACRONYM CLASS="ACRONYM">LDAP</ACRONYM>查找连接参数，就像
<A HREF="libpq-ldap.html">第 31.17 &#33410;</A>里描述的那样。参阅<A HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS">第 31.1.2 &#33410;</A>
获取所有可用的连接选项的信息。</P><P>如果因为任何原因而无法与数据库相联(权限不够、服务器没有运行等)，
<SPAN CLASS="APPLICATION">psql</SPAN>将返回一个错误并退出。</P><P>如果至少有一个标准输入或标准输出是一个终端，那么<SPAN CLASS="APPLICATION">psql</SPAN>
设置客户端编码为<SPAN CLASS="QUOTE">"自动"</SPAN>，这将从本地设置中检测合适的客户端编码
（在Unix系统上是<TT CLASS="ENVAR">LC_CTYPE</TT>环境变量）。如果不像预期的那样工作，
客户端编码可以使用环境变量<TT CLASS="ENVAR">PGCLIENTENCODING</TT>重写。</P></DIV><DIV CLASS="REFSECT2"><A NAME="R2-APP-PSQL-4"></A><H3>输入 SQL 命令</H3><P>通常状况下，<SPAN CLASS="APPLICATION">psql</SPAN>提供一个带有正在与之连接的接数据库名的，
后缀<TT CLASS="LITERAL">=&gt;</TT>的提示符。例如：
</P><PRE CLASS="PROGRAMLISTING">$ <KBD
CLASS="USERINPUT"
>psql testdb</KBD
>
psql (9.3.1)
Type "help" for help.

testdb=&gt;</PRE><P></P><P>用户可以在这个提示符下键入<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令。通常，
输入的行将在命令终止分号出现时送到服务器。一行的终止并不表示命令的结束。
因此命令可以为了清晰起见跨越好几行。如果命令发送出去而且执行没有错误，
命令结果会显示在屏幕上。</P><P>当命令正在进行时，<SPAN CLASS="APPLICATION">psql</SPAN>同样还轮询由
<A HREF="sql-listen.html">LISTEN</A>和<A HREF="sql-notify.html">NOTIFY</A>生成的异步通知信号。</P></DIV><DIV CLASS="REFSECT2"><A NAME="APP-PSQL-META-COMMANDS"></A><H3>元命令</H3><P>你在<SPAN CLASS="APPLICATION">psql</SPAN>里输入的任何以不带引号的反斜杠开头的东西都是
<SPAN CLASS="APPLICATION">psql</SPAN>元命令，这些命令是将由<SPAN CLASS="APPLICATION">psql</SPAN>
自己处理的。这些命令使得<SPAN CLASS="APPLICATION">psql</SPAN>
更便于管理或书写脚本。元命令通常被称为斜杠或反斜杠命令。</P><P>一个<SPAN CLASS="APPLICATION">psql</SPAN>命令的格式是反斜杠后面紧跟一个命令动词，
然后是任意参数。参数与命令动词和其它参数以任意个空白字符间隔。</P><P>要在参数里面包含空白，你必须用单引号把它包围起来。要在参数里包含单引号，
在单引号包围的文本里写两个单引号。任何包含在单引号里的东西都会被进一步进行类
C的替换：<TT CLASS="LITERAL">\n</TT>(新行)、<TT CLASS="LITERAL">\t</TT>(制表符)、
<TT CLASS="LITERAL">\b</TT>（退格）、<TT CLASS="LITERAL">\r</TT>（回车）、
<TT CLASS="LITERAL">\f</TT>（换页）、<TT CLASS="LITERAL">\</TT><TT CLASS="REPLACEABLE"><I>digits</I></TT>
(八进制表示的字符)、<TT CLASS="LITERAL">\x</TT><TT CLASS="REPLACEABLE"><I>digits</I></TT>
(十六进制表示的字符)。在单引号包围的文本中，反斜杠前导任何其他字符，
都表示是该单个字符，不管它是什么。</P><P>在一个参数中，加上反勾号(<TT CLASS="LITERAL">`</TT>)的文本被看做是一个命令行，
传递给shell。该命令的输出（删除结尾的新行）替换了加上反勾号的文本。</P><P>如果一个未加引号的冒号(<TT CLASS="LITERAL">:</TT>)后面跟着一个<SPAN CLASS="APPLICATION">psql</SPAN>
变量名，出现在一个参数中，那么它会被变量的值取代，就像
<A HREF="app-psql.html#APP-PSQL-INTERPOLATION"><I><I>SQL</I> 代换</I></A>
中描述的那样。</P><P>有些命令以一个<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标识的名称(比如一个表名)为参数。
这些参数遵循<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>语法关于双引号的规则：
不带双引号的标识强制成小写，而双引号(<TT CLASS="LITERAL">"</TT>)保护字母不进行大小写转换，
并且允许在标识符中使用空白。在双引号中，
成对的双引号在结果名字中分析成一个双引号。比如，
<TT CLASS="LITERAL">FOO"BAR"BAZ</TT>解析成<TT CLASS="LITERAL">fooBARbaz</TT>；
而<TT CLASS="LITERAL">"A weird"" name"</TT>解析成<TT CLASS="LITERAL">A weird" name</TT>。</P><P>对参数的分析在行的末尾停止，或者在找到另一个不带引号的反斜杠时停止。
一个不带引号的反斜杠会认为是一个新的元命令的开始。特殊的双反斜杠序列
<TT CLASS="LITERAL">\\</TT>标识参数的结尾并将继续分析后面的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>
命令(如果存在的话)。这样<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>和<SPAN CLASS="APPLICATION">psql</SPAN>
命令可以自由的在一行里面混合。但是在任何情况下，一条元命令的参数不能延续超过行尾。</P><P>
下面是已定义的元命令：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">\a</TT></DT><DD><P>如果目前的表输出格式是不对齐的，则切换成对齐的。如果是对齐的，则切换成不对齐。
这条命令是为了向后兼容。参阅<TT CLASS="COMMAND">\pset</TT>获取一个更通用的解决方法。</P></DD><DT><TT CLASS="LITERAL">\c</TT> 或 <TT CLASS="LITERAL">\connect</TT> <TT CLASS="LITERAL">[ <TT CLASS="REPLACEABLE"><I>dbname</I></TT> [ <TT CLASS="REPLACEABLE"><I>username</I></TT> ] [ <TT CLASS="REPLACEABLE"><I>host</I></TT> ] [ <TT CLASS="REPLACEABLE"><I>port</I></TT> ] ]</TT></DT><DD><P>与一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器建立一个新的连接。如果成功建立了新的连接，
则前面的连接将关闭。如果<TT CLASS="REPLACEABLE"><I>dbname</I></TT>,
<TT CLASS="REPLACEABLE"><I>username</I></TT>,
<TT CLASS="REPLACEABLE"><I>host</I></TT>,
<TT CLASS="REPLACEABLE"><I>port</I></TT>被省略或是指定为
<TT CLASS="LITERAL">-</TT>，那么就使用上次连接里面的值。
如果之前没有链接则使用<SPAN CLASS="APPLICATION">libpq</SPAN>的缺省值。</P><P>如果连接失败(用户名错、访问被拒绝等)，那么仅当<SPAN CLASS="APPLICATION">psql</SPAN>
处于交互模式时将保留前面的连接。如果运行的是非交互的脚本，
处理会马上停止并返回一个错误。设置这样的区别一方面是为用户使用方便考虑，
另一方面也为了保证脚本不会碰巧操作了错误的数据库的安全机制考虑。</P></DD><DT><TT CLASS="LITERAL">\C [ <TT CLASS="REPLACEABLE"><I>title</I></TT> ]</TT></DT><DD><P>把正在打印的表的标题设置为一个查询的结果或者取消这样的设置。
这条命令等效于<TT CLASS="LITERAL">\pset title <TT CLASS="REPLACEABLE"><I>title</I></TT></TT>。
这条命令的名称源于<SPAN CLASS="QUOTE">"caption"</SPAN>，因为以前只是用于在一个
<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>表格里面设置标题。</P></DD><DT><TT CLASS="LITERAL">\cd [ <TT CLASS="REPLACEABLE"><I>directory</I></TT> ]</TT></DT><DD><P>把当前工作目录改变到<TT CLASS="REPLACEABLE"><I>directory</I></TT>。
没有参数则是改变到当前用户的家目录。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>使用<TT CLASS="LITERAL">\! pwd</TT>打印出当前工作目录。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\conninfo</TT></DT><DD><P>输出关于当前数据库连接的信息。</P></DD><DT><A NAME="APP-PSQL-META-COMMANDS-COPY"></A><TT CLASS="LITERAL">\copy { <TT CLASS="REPLACEABLE"><I>table</I></TT> [ ( <TT CLASS="REPLACEABLE"><I>column_list</I></TT> ) ] | ( <TT CLASS="REPLACEABLE"><I>query</I></TT> ) }
{ <TT CLASS="LITERAL">from</TT> | <TT CLASS="LITERAL">to</TT> }
{ <TT CLASS="REPLACEABLE"><I>'filename'</I></TT> | program <TT CLASS="REPLACEABLE"><I>'command'</I></TT> | stdin | stdout | pstdin | pstdout }
[ [ with ] ( <TT CLASS="REPLACEABLE"><I>option</I></TT> [, ...] ) ]</TT></DT><DD><P>执行前端(客户端)拷贝。这是一个运行<ACRONYM CLASS="ACRONYM">SQL</ACRONYM> <A HREF="sql-copy.html">COPY</A>
命令的操作，不同的是服务器在读写指明的文件，而<SPAN CLASS="APPLICATION">psql</SPAN>
读写文件并作为本地的文件系统和服务器之间的跳板取出或写入数据。
这意味着文件访问性和权限都是本地用户的，而不是服务器的，
因此不需要 SQL 超级用户权限。</P><P>当指定了<TT CLASS="LITERAL">program</TT>时，<TT CLASS="REPLACEABLE"><I>command</I></TT>
是通过<SPAN CLASS="APPLICATION">psql</SPAN>执行的，并且来自或到达
<TT CLASS="REPLACEABLE"><I>command</I></TT>
的数据在服务器和客户端之间传送。这意味着文件访问性和权限都是本地用户的，
而不是服务器的，因此不需要 SQL 超级用户权限。</P><P><TT CLASS="LITERAL">\copy ... from stdin | to stdout</TT>分别基于命令输入和输出进行读/写。
所有行都从发出命令的同一个源读取，直到读到了<TT CLASS="LITERAL">\.</TT>
或者流达到<ACRONYM CLASS="ACRONYM">EOF</ACRONYM>。输出发送到和命令输出相同的位置。
要从<SPAN CLASS="APPLICATION">psql</SPAN>的标准输入或者输出读/写，
可以使用<TT CLASS="LITERAL">pstdin</TT>或<TT CLASS="LITERAL">pstdout</TT>。
这个选项用于填充SQL 脚本文件中嵌入的表很有用。</P><P>这条命令的语法是类似于<ACRONYM CLASS="ACRONYM">SQL</ACRONYM> <A HREF="sql-copy.html">COPY</A>命令，
并且<TT CLASS="REPLACEABLE"><I>option</I></TT>必须指出
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM> <A HREF="sql-copy.html">COPY</A>命令的一个选项。
要注意的是因此带来一些应用于<TT CLASS="COMMAND">\copy</TT>命令的特殊分析规则。
尤其是变量替换规则和反斜杠逃逸规则将不起作用。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>此操作不像<ACRONYM CLASS="ACRONYM">SQL</ACRONYM> <TT CLASS="COMMAND">COPY</TT>命令这样高效，
因为所有数据必须通过客户端/服务器连接。对于大数据量的操作，
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令的方法更可行。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\copyright</TT></DT><DD><P>显示<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的版权和版本信息。</P></DD><DT><TT CLASS="LITERAL">\d[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>对于每个匹配<TT CLASS="REPLACEABLE"><I>pattern</I></TT>的关系
(表、视图、索引、序列或外部表)或复合类型，显示所有列、它们的类型、
表空间(如果不是缺省的)和任何特殊属性(诸如<TT CLASS="LITERAL">NOT NULL</TT>或缺省等)。
相关的索引、约束、规则、触发器也同样显示出来。对于外部表，也显示相关的外部服务器。
<SPAN CLASS="QUOTE">"匹配模式"</SPAN>在下面的<A HREF="app-psql.html#APP-PSQL-PATTERNS"><I>匹配模式</I></A>
中定义。</P><P>对于一些关系类型，<TT CLASS="LITERAL">\d</TT>为每个字段显示了额外的信息：序列的字段值，
索引的索引表达式和外部表的外部数据封装器选项。</P><P>从<TT CLASS="LITERAL">\d+</TT>来的命令也是一样的，只不过显示更多信息：
任何与表的列关联的注释也都会显示，还有就是表中出现的 OID ，
如果关系是一个视图，那么也显示视图定义。</P><P>缺省的，只显示用户创建的对象；应用一个模式或<TT CLASS="LITERAL">S</TT>
修饰符包含系统对象。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>如果不带任何<TT CLASS="REPLACEABLE"><I>pattern</I></TT>参数调用
<TT CLASS="COMMAND">\d</TT>，那么等效于<TT CLASS="COMMAND">\dtvsE</TT>，
将显示一个所有可见表，视图，序列和外部表的列表。这完全是出于方便的考虑。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\da[S] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出聚集函数，以及它们的返回类型和操作的数据类型。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只显示匹配模式的聚集函数。缺省的，只显示用户创建的对象；
应用一个模式或<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。</P></DD><DT><TT CLASS="LITERAL">\db[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出表空间。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只显示那些匹配模式的表空间。如果在命令名上附加了<TT CLASS="LITERAL">+</TT>，
那么每个对象都和与之相关的权限一起列出。</P></DD><DT><TT CLASS="LITERAL">\dc[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出字符集编码之间的转换。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出那些匹配模式的转换。缺省的，只显示用户创建的对象；
应用一个模式或<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。如果在命令名上附加了
<TT CLASS="LITERAL">+</TT>，那么每个对象都和与之相关的描述一起列出。</P></DD><DT><TT CLASS="LITERAL">\dC[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出类型转换。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出源或目标类型匹配该模式的转换。如果在命令名上附加了
<TT CLASS="LITERAL">+</TT>，那么每个对象都和与之相关的描述一起列出。</P></DD><DT><TT CLASS="LITERAL">\dd[S] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>显示类型为<TT CLASS="LITERAL">constraint</TT>、<TT CLASS="LITERAL">operator class</TT>、<TT CLASS="LITERAL">operator family</TT>、
<TT CLASS="LITERAL">rule</TT>和<TT CLASS="LITERAL">trigger</TT>的对象的描述。
所有其他的注释可以通过各自对象类型的反斜杠命令看到。</P><P><TT CLASS="LITERAL">\dd</TT>显示匹配<TT CLASS="REPLACEABLE"><I>pattern</I></TT>
的对象的描述，或者如果没有给出参数，显示适当类型的可视对象。但是不管怎样，
只有那些有描述内容的对象才显示出来。缺省的，只显示用户创建的对象；
应用一个模式或<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。</P><P>可以用<A HREF="sql-comment.html">COMMENT</A> <ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令生成对象的描述。</P></DD><DT><TT CLASS="LITERAL">\ddp [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出缺省访问权限设置。为缺省权限设置已经从内建的缺省改变了的每个角色
（还有模式，如果适用）显示一个记录。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出角色名或模式名匹配该模式的记录。</P><P><A HREF="sql-alterdefaultprivileges.html">ALTER DEFAULT PRIVILEGES</A>命令用来设置缺省访问权限。
权限显示的含义在<A HREF="sql-grant.html">GRANT</A>中解释。</P></DD><DT><TT CLASS="LITERAL">\dD[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出域。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只显示匹配该模式的域。缺省的，只显示用户创建的对象；
应用一个模式或<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。如果在命令名上附加了
<TT CLASS="LITERAL">+</TT>，那么每个对象都和与之相关的权限和描述一起列出。</P></DD><DT><TT CLASS="LITERAL">\dE[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT><BR><TT CLASS="LITERAL">\di[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT><BR><TT CLASS="LITERAL">\dm[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT><BR><TT CLASS="LITERAL">\ds[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT><BR><TT CLASS="LITERAL">\dt[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT><BR><TT CLASS="LITERAL">\dv[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>在这组命令中，字母<TT CLASS="LITERAL">E</TT>、<TT CLASS="LITERAL">i</TT>、<TT CLASS="LITERAL">m</TT>、
<TT CLASS="LITERAL">s</TT>、<TT CLASS="LITERAL">t</TT>和<TT CLASS="LITERAL">v</TT>
分别代表外部表、索引、物化视图、序列、表和视图。
你可以以任意的顺序声明任意或所有这些字母，获取这些类型的对象的列表。
例如，<TT CLASS="LITERAL">\dit</TT>列出索引和表。如果在命令名上附加了<TT CLASS="LITERAL">+</TT>，
那么每个对象都和它在磁盘上的物理尺寸和与之相关的描述一起列出，如果有。
如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只列出匹配该模式的对象。缺省的，只显示用户创建的对象；
提供一个模式或<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。</P></DD><DT><TT CLASS="LITERAL">\des[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出外部服务器（助记：<SPAN CLASS="QUOTE">"扩展服务器"</SPAN>）。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只列出匹配该模式的服务器。如果使用了<TT CLASS="LITERAL">\des+</TT>格式，
则显示每个服务器的全部描述，包括服务器的ACL、类型、版本、选项和描述。</P></DD><DT><TT CLASS="LITERAL">\det[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出外部表（助记：<SPAN CLASS="QUOTE">"扩展表"</SPAN>）。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只列出表名或模式名匹配该模式的记录。如果使用了<TT CLASS="LITERAL">\det+</TT>
格式，那么也显示通用选项和外部表描述。</P></DD><DT><TT CLASS="LITERAL">\deu[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出用户映射（助记：<SPAN CLASS="QUOTE">"外部用户"</SPAN>）。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只列出用户名匹配该模式的那些映射。如果使用了<TT CLASS="LITERAL">\deu+</TT>格式，
那么也显示关于每个映射的额外的信息。</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="90%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P><TT CLASS="LITERAL">\deu+</TT>可能也显示远程用户的用户名和密码，
所以要小心不要透漏它们。</P></TD></TR></TABLE></DIV></DD><DT><TT CLASS="LITERAL">\dew[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出外部数据封装器（助记：<SPAN CLASS="QUOTE">"扩展的封装器"</SPAN>）。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只显示名字匹配该模式的外部数据封装器。如果使用了<TT CLASS="LITERAL">\dew+</TT>格式，
则外部数据封装器的ACL、选项和描述也显示。</P></DD><DT><TT CLASS="LITERAL">\df[antwS+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出分类为<SPAN CLASS="QUOTE">"agg"</SPAN> (aggregate)、<SPAN CLASS="QUOTE">"normal"</SPAN>、<SPAN CLASS="QUOTE">"trigger"</SPAN>或
<SPAN CLASS="QUOTE">"window"</SPAN>的函数和它们的参数、返回类型和函数类型。
要想只显示指定类型的函数，在命令中添加对应的字母<TT CLASS="LITERAL">a</TT>、
<TT CLASS="LITERAL">n</TT>、<TT CLASS="LITERAL">t</TT>或<TT CLASS="LITERAL">w</TT>。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只显示名字匹配该模式的函数。如果使用了<TT CLASS="LITERAL">\df+</TT>格式，
则也显示关于每个函数的额外信息，包括安全、波动性、语言、源代码和描述。
缺省的，只显示用户创建的对象；提供一个模式或<TT CLASS="LITERAL">S</TT>
修饰符包含系统对象。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>要查找接受或者返回特定类型的函数，使用你的分页器搜索功能来滚动<TT CLASS="LITERAL">\df</TT>的输出。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\dF[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出文本搜索配置。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只显示名字匹配该模式的配置。如果使用了<TT CLASS="LITERAL">\dF+</TT>格式，
则显示每个配置的全部描述，包括底层的文本搜索解析器和为每个解析器标记类型列出的字典。</P></DD><DT><TT CLASS="LITERAL">\dFd[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出文本搜索字典。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只显示名字匹配该模式的字典。如果使用了<TT CLASS="LITERAL">\dFd+</TT>格式，
则显示关于每个选中的字典的额外信息，包括底层的文本搜索模板和选项值。</P></DD><DT><TT CLASS="LITERAL">\dFp[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出文本搜索解析器。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
只显示名字匹配该模式的解析器。如果使用了<TT CLASS="LITERAL">\dFp+</TT>格式，
则显示每个解析器的全部描述，包括底层的函数和识别的标记类型的列表。</P></DD><DT><TT CLASS="LITERAL">\dFt[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出文本搜索模板。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只显示名字匹配该模式的模板。如果使用了<TT CLASS="LITERAL">\dFt+</TT>格式，
则显示关于每个模板的额外的信息，包括底层的函数名。</P></DD><DT><TT CLASS="LITERAL">\dg[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出数据库角色。（因为<SPAN CLASS="QUOTE">"用户"</SPAN>和<SPAN CLASS="QUOTE">"组"</SPAN>的概念已经统一成<SPAN CLASS="QUOTE">"角色"</SPAN>，
所以这个命令现在等于<TT CLASS="LITERAL">\du</TT>。）如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，则只列出名字匹配该模式的那些角色。
如果使用了<TT CLASS="LITERAL">\dg+</TT>格式，则显示关于每个角色的额外信息；
目前这增加了每个角色的注释。</P></DD><DT><TT CLASS="LITERAL">\dl</TT></DT><DD><P><TT CLASS="COMMAND">\lo_list</TT>的别名，显示一个大对象的列表。</P></DD><DT><TT CLASS="LITERAL">\dL[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出过程语言。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出名字匹配该模式的语言。缺省的，只显示用户创建的语言；
提供<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。如果在命令名上附加了<TT CLASS="LITERAL">+</TT>，
那么每个语言的调用处理器、验证器、访问权限和它是否是一个系统对象也和语言一起列出。</P></DD><DT><TT CLASS="LITERAL">\dn[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出模式(名字空间)。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
那么只列出匹配模式的模式名。缺省的，只显示用户创建的对象；提供一个模式或
<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。如果在命令名上附加了<TT CLASS="LITERAL">+</TT>，
那么每个对象都和与之相关的权限和注释一起列出(如果有的话)。</P></DD><DT><TT CLASS="LITERAL">\do[S] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出操作符，以及它们的操作数和返回的数据类型。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，那么只显示匹配模式的操作符。
缺省的，只显示用户创建的对象；提供一个模式或<TT CLASS="LITERAL">S</TT>
修饰符包含系统对象。</P></DD><DT><TT CLASS="LITERAL">\dO[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出排序规则。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出名字匹配该模式的排序规则。缺省的，只显示用户创建的对象；
提供一个模式或<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。如果在命令名上附加了
<TT CLASS="LITERAL">+</TT>，则每个排序规则与和它相关的描述一起列出，如果有的话。
请注意，只显示可用于当前数据库的编码的排序规则，所以相同安装的不同数据库的结果可能不同。</P></DD><DT><TT CLASS="LITERAL">\dp [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出表、视图和序列和它们相关的访问权限。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出名字匹配该模式的表、视图和序列。</P><P><A HREF="sql-grant.html">GRANT</A>和<A HREF="sql-revoke.html">REVOKE</A>
命令用于设置访问权限。权限显示的含义在<A HREF="sql-grant.html">GRANT</A>中解释。</P></DD><DT><TT CLASS="LITERAL">\drds [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>role-pattern</I></TT></A> [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>database-pattern</I></TT></A> ] ]</TT></DT><DD><P>列出定义的配置设置。这些设置可以是角色特定的、数据库特定的，或两者都有。
<TT CLASS="REPLACEABLE"><I>role-pattern</I></TT>和<TT CLASS="REPLACEABLE"><I>database-pattern</I></TT>
分别用于选择要列出的特定角色和数据库。如果省略了，或者声明了<TT CLASS="LITERAL">*</TT>，
那么列出所有设置，包括那些非角色特定的或非数据库特定的。</P><P><A HREF="sql-alterrole.html">ALTER ROLE</A>和<A HREF="sql-alterdatabase.html">ALTER DATABASE</A>
命令用于定义每用户和每数据库配置设置。</P></DD><DT><TT CLASS="LITERAL">\dT[S+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出数据类型。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出名字匹配该模式的类型。如果在命令名上附加了<TT CLASS="LITERAL">+</TT>，
那么每个类型和它的内部名字和尺寸、它允许的值（如果它是<TT CLASS="TYPE">enum</TT>类型）
和它相关的权限一起列出。缺省的，只显示用户创建的对象；提供一个模式或
<TT CLASS="LITERAL">S</TT>修饰符包含系统对象。</P></DD><DT><TT CLASS="LITERAL">\du[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出数据库角色。（因为<SPAN CLASS="QUOTE">"用户"</SPAN>和<SPAN CLASS="QUOTE">"组"</SPAN>的概念已经统一成<SPAN CLASS="QUOTE">"角色"</SPAN>，
所以这个命令现在等于<TT CLASS="LITERAL">\du</TT>。）如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，则只列出名字匹配该模式的那些角色。
如果使用了<TT CLASS="LITERAL">\du+</TT>格式，则显示关于每个角色的额外信息；
目前这增加了每个角色的注释。</P></DD><DT><TT CLASS="LITERAL">\dx[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出安装了的扩展。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出那些名字匹配该模式的扩展。如果使用了<TT CLASS="LITERAL">\dx+</TT>格式，
则列出所有属于每个匹配的扩展的对象。</P></DD><DT><TT CLASS="LITERAL">\dy[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出事件触发器。如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出那些名字匹配该模式的事件触发器。如果在命令名上附加了<TT CLASS="LITERAL">+</TT>，
则每个对象都和与其相关的描述一起列出。</P></DD><DT><TT CLASS="LITERAL">\e</TT> 或 <TT CLASS="LITERAL">\edit</TT> <TT CLASS="LITERAL"> [<SPAN CLASS="OPTIONAL"> <TT CLASS="REPLACEABLE"><I>filename</I></TT> </SPAN>] [<SPAN CLASS="OPTIONAL"> <TT CLASS="REPLACEABLE"><I>line_number</I></TT> </SPAN>] </TT></DT><DD><P>如果声明了<TT CLASS="REPLACEABLE"><I>filename</I></TT>，
则编辑此文件并且在编辑器退出后将其内容拷贝回查询缓冲区。如果没有给出
<TT CLASS="REPLACEABLE"><I>filename</I></TT>，
则把当前查询缓冲区内容拷贝到一个临时文件然后以相同方式编辑。</P><P>然后根据一般的<SPAN CLASS="APPLICATION">psql</SPAN>规则重新分析查询缓冲区，
这时整个缓冲区当作一个单行，因此你无法用这个方法制作脚本(用<TT CLASS="COMMAND">\i</TT>)。
这意味着如果该查询以分号结尾(或者包含分号)，它就会马上被执行。
否则它只是在查询缓冲区里等待；分号或<TT CLASS="LITERAL">\g</TT>发送，或<TT CLASS="LITERAL">\r</TT>取消。</P><P>如果声明了行号，<SPAN CLASS="APPLICATION">psql</SPAN>将在文件或查询缓冲区的指定行上定位游标。
请注意，如果给出了一个数字参数，<SPAN CLASS="APPLICATION">psql</SPAN>将假设它是一个行号，
而不是文件名。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>参阅下面的<A HREF="app-psql.html#APP-PSQL-ENVIRONMENT"><I>环境变量</I></A>
获取如何配置和自定义你的编辑器。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\echo <TT CLASS="REPLACEABLE"><I>text</I></TT> [ ... ]</TT></DT><DD><P>向标准输出打印参数，用一个空格分隔并且最后跟着一个新行。
这个特性在显示脚本的输出时会有用。例如：
</P><PRE CLASS="PROGRAMLISTING">=&gt; <KBD
CLASS="USERINPUT"
>\echo `date`</KBD
>
Tue Oct 26 21:40:57 CEST 1999</PRE><P>
如果第一个参数是一个无引号的<TT CLASS="LITERAL">-n</TT>，那么不会写出结尾的新行。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>如果使用<TT CLASS="COMMAND">\o</TT>命令重定向查询的输出，
你可能会用<TT CLASS="COMMAND">\qecho</TT>取代这条命令。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\ef [<SPAN CLASS="OPTIONAL"> <TT CLASS="REPLACEABLE"><I>function_description</I></TT> [<SPAN CLASS="OPTIONAL"> <TT CLASS="REPLACEABLE"><I>line_number</I></TT> </SPAN>] </SPAN>] </TT></DT><DD><P>这个命令抓取并编辑命名函数的定义，以<TT CLASS="COMMAND">CREATE OR REPLACE FUNCTION</TT>
命令的形式。编辑处理的方式和<TT CLASS="LITERAL">\edit</TT>相同。在编辑退出之后，
更新的命令等待在查询缓冲区中；分号或<TT CLASS="LITERAL">\g</TT>发送，或<TT CLASS="LITERAL">\r</TT>取消。</P><P>目标函数可以只通过名字指定，或者通过名字和参数指定，例如
<TT CLASS="LITERAL">foo(integer, text)</TT>。如果有多个相同名字的函数，
则必须给出参数类型。</P><P>如果没有指定函数，则提供一个空白的<TT CLASS="COMMAND">CREATE FUNCTION</TT>模板以供编辑。</P><P>如果声明了行号，<SPAN CLASS="APPLICATION">psql</SPAN>将在函数体的指定行定位游标。
（请注意，函数体通常不在文件的第一行开始。）</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>参阅下面的<A HREF="app-psql.html#APP-PSQL-ENVIRONMENT"><I>环境变量</I></A>
获取如何配置和自定义你的编辑器的信息。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\encoding [ <TT CLASS="REPLACEABLE"><I>encoding</I></TT> ]</TT></DT><DD><P>设置客户端字符编码方式。不带参数时，这条命令显示当前的编码方式。</P></DD><DT><TT CLASS="LITERAL">\f [ <TT CLASS="REPLACEABLE"><I>string</I></TT> ]</TT></DT><DD><P>为不对齐的查询输出设置域分隔符。缺省时是竖条(<TT CLASS="LITERAL">|</TT>)。
参阅<TT CLASS="COMMAND">\pset</TT>获取设置输出选项的通用方法。</P></DD><DT><TT CLASS="LITERAL">\g</TT> [ { <TT CLASS="REPLACEABLE"><I>filename</I></TT> | <TT CLASS="LITERAL">|</TT><TT CLASS="REPLACEABLE"><I>command</I></TT> } ]</DT><DD><P>把当前的查询输入缓冲区的内容发送给服务器并且把查询的输出存储到可选的
<TT CLASS="REPLACEABLE"><I>filename</I></TT>
或者把输出重定向到一个独立的执行<TT CLASS="REPLACEABLE"><I>command</I></TT>
的 Unix shell 。文件或命令只在查询成功返回零个或更多元组时写入，
查询失败或者是一个非数据返回的SQL命令时不写入。</P><P>单独一个<TT CLASS="LITERAL">\g</TT>实际上等效于一个分号。一个带有参数的
<TT CLASS="LITERAL">\g</TT>是<SPAN CLASS="QUOTE">"一次性"</SPAN>的<TT CLASS="COMMAND">\o</TT>命令的代用品。</P></DD><DT><TT CLASS="LITERAL">\gset</TT> [ <TT CLASS="REPLACEABLE"><I>prefix</I></TT> ]</DT><DD><P>把当前的查询输入缓冲区发送到服务器并将查询输出存储到<SPAN CLASS="APPLICATION">psql</SPAN>变量
（参阅<A HREF="app-psql.html#APP-PSQL-VARIABLES"><I>变量</I></A>）。
要执行的查询必须正好返回一行。该行的每个字段存储到单独的变量中，
和字段的命名相同。例如：
</P><PRE CLASS="PROGRAMLISTING">=&gt; <KBD
CLASS="USERINPUT"
>SELECT 'hello' AS var1, 10 AS var2</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>\gset</KBD
>
=&gt; <KBD
CLASS="USERINPUT"
>\echo :var1 :var2</KBD
>
hello 10</PRE><P></P><P>如果声明了<TT CLASS="REPLACEABLE"><I>prefix</I></TT>，
该字符串成为查询的字段名的前缀，创建变量名：
</P><PRE CLASS="PROGRAMLISTING">=&gt; <KBD
CLASS="USERINPUT"
>SELECT 'hello' AS var1, 10 AS var2</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>\gset result_</KBD
>
=&gt; <KBD
CLASS="USERINPUT"
>\echo :result_var1 :result_var2</KBD
>
hello 10</PRE><P></P><P>如果一个字段结果为NULL，那么对应的变量是未设置的。</P><P>如果查询失败或没有返回行，那么没有变量改变。</P></DD><DT><TT CLASS="LITERAL">\h</TT> 或 <TT CLASS="LITERAL">\help</TT> <TT CLASS="LITERAL">[ <TT CLASS="REPLACEABLE"><I>command</I></TT> ]</TT></DT><DD><P>给出指定<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令的语法帮助。如果没有给出
<TT CLASS="REPLACEABLE"><I>command</I></TT>，
那么<SPAN CLASS="APPLICATION">psql</SPAN>将列出可获得语法帮助的所有命令。
如果<TT CLASS="REPLACEABLE"><I>command</I></TT>是一个星号
(<TT CLASS="LITERAL">*</TT>) ，则显示所有<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令的语法帮助。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>为简化击键，包含多个单字的命令不需要引起。因此键入
<KBD CLASS="USERINPUT">\help alter table</KBD>是正确的。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\H</TT></DT><DD><P>打开<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>查询输出格式。如果<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>格式已经打开，
则切换回缺省的对齐的文本格式。这个命令是为了兼容和方便，
参阅<TT CLASS="COMMAND">\pset</TT>获取设置其它输出选项的内容。</P></DD><DT><TT CLASS="LITERAL">\i <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT></DT><DD><P>从文件<TT CLASS="REPLACEABLE"><I>filename</I></TT>
中读取并把其内容当作从键盘输入的那样执行查询。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>如果你想在屏幕上看到读入的行，就必须将变量<TT CLASS="VARNAME">ECHO</TT>
设置为<TT CLASS="LITERAL">all</TT>。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\ir <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT></DT><DD><P><TT CLASS="LITERAL">\ir</TT>命令类似于<TT CLASS="LITERAL">\i</TT>，但是对相关文件名的解析不同。
当在交互模式执行时，两个命令的表现相同。不过，当在脚本中调用时，
<TT CLASS="LITERAL">\ir</TT>解释文件名关系为脚本所在的目录，而不是当前工作目录。</P></DD><DT><TT CLASS="LITERAL">\l[+]</TT> 或 <TT CLASS="LITERAL">\list[+] [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出服务器上的数据库并显示它们的名字、所有者、字符集编码和访问权限。
如果声明了<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只列出名字匹配该模式的数据库。如果在命令名称后面加一个<TT CLASS="LITERAL">+</TT>，
则也显示数据库尺寸、缺省表空间和描述。（尺寸信息只在当前用户可以联接的数据库上可用。）</P></DD><DT><TT CLASS="LITERAL">\lo_export <TT CLASS="REPLACEABLE"><I>loid</I></TT> <TT CLASS="REPLACEABLE"><I>filename</I></TT></TT></DT><DD><P>从数据库里读取<ACRONYM CLASS="ACRONYM">OID</ACRONYM>为<TT CLASS="REPLACEABLE"><I>loid</I></TT>
的大对象并把它写到<TT CLASS="REPLACEABLE"><I>filename</I></TT>里。
注意这个功能与服务器函数<CODE CLASS="FUNCTION">lo_export</CODE>有些微小的区别，
后者运行时带着运行数据库服务器的用户权限，而且是在服务器的文件系统上。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>使用<TT CLASS="COMMAND">\lo_list</TT>查看大对象的<ACRONYM CLASS="ACRONYM">OID</ACRONYM>。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\lo_import <TT CLASS="REPLACEABLE"><I>filename</I></TT> [ <TT CLASS="REPLACEABLE"><I>comment</I></TT> ]</TT></DT><DD><P>把文件存储为一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>大对象。
可以带着一个该对象的注解选项。例如：
</P><PRE CLASS="PROGRAMLISTING">foo=&gt; <KBD
CLASS="USERINPUT"
>\lo_import '/home/peter/pictures/photo.xcf' 'a picture of me'</KBD
>
lo_import 152801</PRE><P>
响应表明此大对象得到一个对象标识 152801 ，可以用来在后面访问新创建的大对象。
出于可读性的目的，建议总是给每个对象关联一个人类可读的注解。
可以用<TT CLASS="COMMAND">\lo_list</TT>命令看到OID和注解。</P><P>注意这条命令与服务器端的<CODE CLASS="FUNCTION">lo_import</CODE>有一些区别，
因为这条命令是本地用户在本地文件系统上操作，
而不是以服务器用户在服务器文件系统上操作。</P></DD><DT><TT CLASS="LITERAL">\lo_list</TT></DT><DD><P>显示一个目前存储在该数据库里的所有<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
大对象和为它们提供的任意注解的列表。</P></DD><DT><TT CLASS="LITERAL">\lo_unlink <TT CLASS="REPLACEABLE"><I>loid</I></TT></TT></DT><DD><P>从数据库里删除<ACRONYM CLASS="ACRONYM">OID</ACRONYM>为
<TT CLASS="REPLACEABLE"><I>loid</I></TT>的大对象。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>使用<TT CLASS="COMMAND">\lo_list</TT>查找大对象的<ACRONYM CLASS="ACRONYM">OID</ACRONYM>。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\o</TT> [ {<TT CLASS="REPLACEABLE"><I>filename</I></TT> | <TT CLASS="LITERAL">|</TT><TT CLASS="REPLACEABLE"><I>command</I></TT>} ]</DT><DD><P>把后面的查询结果保存到文件<TT CLASS="REPLACEABLE"><I>filename</I></TT>
里或者把后面的查询结果重定向到一个独立的 Unix shell执行
<TT CLASS="REPLACEABLE"><I>command</I></TT>。
如果没有声明参数，查询输出将被重置为标准输出。</P><P><SPAN CLASS="QUOTE">"查询结果"</SPAN>包括所有表，命令响应和从数据库服务器来的提示，
同样还有各种各样查询数据库的反斜杠命令的输出(如<TT CLASS="COMMAND">\d</TT>)，
但是没有错误信息。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>要分散查询结果之间的文本输出，用<TT CLASS="COMMAND">\qecho</TT>。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\p</TT></DT><DD><P>打印当前查询缓冲区到标准输出。</P></DD><DT><TT CLASS="LITERAL">\password [ <TT CLASS="REPLACEABLE"><I>username</I></TT> ]</TT></DT><DD><P>更改指定用户的口令，缺省为当前用户。该命令将提示口令输入，
然后将加密过的口令使用<TT CLASS="COMMAND">ALTER ROLE</TT>之类的命令发送给服务器。
这可以保证新口令不会以明文形式出现在命令历史、服务器日志、或其他什么地方。</P></DD><DT><TT CLASS="LITERAL">\prompt [ <TT CLASS="REPLACEABLE"><I>text</I></TT> ] <TT CLASS="REPLACEABLE"><I>name</I></TT></TT></DT><DD><P>提示用户提供文本，分配给变量<TT CLASS="REPLACEABLE"><I>name</I></TT>。
可以声明可选的提示字符串<TT CLASS="REPLACEABLE"><I>text</I></TT>。
（对于多个字的提示，用单引号包围文本。）</P><P>缺省的，<TT CLASS="LITERAL">\prompt</TT>使用终端输入和输出。不过，如果使用了<TT CLASS="OPTION">-f</TT>
命令行开关，<TT CLASS="LITERAL">\prompt</TT>使用标准的输入和输出。</P></DD><DT><TT CLASS="LITERAL">\pset <TT CLASS="REPLACEABLE"><I>option</I></TT> [ <TT CLASS="REPLACEABLE"><I>value</I></TT> ]</TT></DT><DD><P>这条命令设置影响查询结果表输出的选项。<TT CLASS="REPLACEABLE"><I>option</I></TT>
描述要设置的选项是哪一个。<TT CLASS="REPLACEABLE"><I>value</I></TT>
的语意也取决于选取的选项。对于一些选项，省略<TT CLASS="REPLACEABLE"><I>value</I></TT>导致选项切换或复位，
就像特定的选项中描述的那样。如果没有提及这样的行为，那么省略
<TT CLASS="REPLACEABLE"><I>value</I></TT>只会导致显示当前的设置。</P><P>
可调节的打印选项有：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">border</TT></DT><DD><P><TT CLASS="REPLACEABLE"><I>value</I></TT>必须是一个数字。通常，
数字越大，表就有越宽的边界和越多的线，但是这个参数取决于实际的格式。
在<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>格式中，这个参数会直接翻译成<TT CLASS="LITERAL">border=...</TT>
属性，在其它的模式里，只有值 0(无边界)、1(内部分隔线)、2(表框架)有意义。
<TT CLASS="LITERAL">latex</TT>和<TT CLASS="LITERAL">latex-longtable</TT>
也支持<TT CLASS="LITERAL">border</TT>值为3，在每行之间添加一个分隔线。</P></DD><DT><TT CLASS="LITERAL">columns</TT></DT><DD><P>为<TT CLASS="LITERAL">wrapped</TT>格式设置目标宽度，并且宽度限制决定输出是否太宽需要分页，
或在自动扩展模式下切换到垂直显示。0（缺省）代表目标宽度受到环境变量
<TT CLASS="ENVAR">COLUMNS</TT>的控制，或者如果没有设置<TT CLASS="ENVAR">COLUMNS</TT>，
则是受到检测到的屏幕宽度的限制。另外，如果<TT CLASS="LITERAL">columns</TT>为0，
那么<TT CLASS="LITERAL">wrapped</TT>格式只影响屏幕输出。如果<TT CLASS="LITERAL">columns</TT>非0，
那么字段和管道输出也包装为那个宽度。</P></DD><DT><TT CLASS="LITERAL">expanded</TT> (或 <TT CLASS="LITERAL">x</TT>)</DT><DD><P>如果声明了<TT CLASS="REPLACEABLE"><I>value</I></TT>，则必须是
<TT CLASS="LITERAL">on</TT>或者<TT CLASS="LITERAL">off</TT>（这将启用或禁用扩展模式）
或者<TT CLASS="LITERAL">auto</TT>。如果省略了<TT CLASS="REPLACEABLE"><I>value</I></TT>，
那么命令在正常和扩展格式之间切换。当打开扩展格式时，查询结果用两列显示，
字段名称在左、数据在右。这个模式在数据无法放进通常的<SPAN CLASS="QUOTE">"水平"</SPAN>
模式的屏幕时很有用。在自动设置模式下，扩展模式在查询输出比屏幕宽时使用，
否则使用正常模式。自动设置只在对齐和封装格式下有效。在其他格式下，
它总是表现的好像扩展模式为关闭一样。</P></DD><DT><TT CLASS="LITERAL">fieldsep</TT></DT><DD><P>声明在非对齐格式时的域分隔符。这样就可以创建其它程序希望的输出，
例如制表符或逗号分隔的输出。要设置制表符作为域分隔符，
键入<TT CLASS="LITERAL">\pset fieldsep '\t'</TT>。缺省域分隔符是
<TT CLASS="LITERAL">'|'</TT>(竖条符)。</P></DD><DT><TT CLASS="LITERAL">fieldsep_zero</TT></DT><DD><P>设置非对齐输出格式中使用的域分隔符为0字节。</P></DD><DT><TT CLASS="LITERAL">footer</TT></DT><DD><P>如果声明了<TT CLASS="REPLACEABLE"><I>value</I></TT>，
它必须是<TT CLASS="LITERAL">on</TT>或者<TT CLASS="LITERAL">off</TT>，
这将启用或禁用表的脚注的显示（<TT CLASS="LITERAL">(<TT CLASS="REPLACEABLE"><I>n</I></TT> rows)</TT>计数）。
如果省略了<TT CLASS="REPLACEABLE"><I>value</I></TT>，
那么命令切换脚注显示为on或off。</P></DD><DT><TT CLASS="LITERAL">format</TT></DT><DD><P>设置输出格式为<TT CLASS="LITERAL">unaligned</TT>、<TT CLASS="LITERAL">aligned</TT>、
<TT CLASS="LITERAL">wrapped</TT>、<TT CLASS="LITERAL">html</TT>、<TT CLASS="LITERAL">latex</TT>
（使用<TT CLASS="LITERAL">tabular</TT>）、<TT CLASS="LITERAL">latex-longtable</TT>或
<TT CLASS="LITERAL">troff-ms</TT>之一。允许使用唯一缩写，这也意味着一个字母就够了。</P><P><TT CLASS="LITERAL">unaligned</TT>(不对齐)格式把一条记录的所有字段都输出到一行，
用当前有效的域分隔符分隔。这主要用于生成那些要被其它程序读取的输出
(比如，制表符分隔或逗号分隔格式)。</P><P><TT CLASS="LITERAL">aligned</TT>(对齐)模式是标准的，人类可读的，
格式化好了的文本输出，也是缺省。</P><P><TT CLASS="LITERAL">wrapped</TT>格式类似于<TT CLASS="LITERAL">aligned</TT>，但是包装跨行的宽数据值，
使其适应目标字段的宽度输出。目标宽度的确定如<TT CLASS="LITERAL">columns</TT>选项中的描述。
请注意，<SPAN CLASS="APPLICATION">psql</SPAN>将不会尝试包装字段标题：因此，
如果字段标题所需的总宽度超过目标宽度，则<TT CLASS="LITERAL">wrapped</TT>格式的行为和
<TT CLASS="LITERAL">aligned</TT>相同。</P><P><TT CLASS="LITERAL">html</TT>、<TT CLASS="LITERAL">latex</TT>、<TT CLASS="LITERAL">latex-longtable</TT>和
<TT CLASS="LITERAL">troff-ms</TT>模式把表输出为可用于文档里的对应标记语言。
它们还不是完整的文档！可能对于<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>变化还不是太大，
但是在<SPAN CLASS="APPLICATION">LaTeX</SPAN>里，你必须有一个完整的文档包装器。
<TT CLASS="LITERAL">latex-longtable</TT>也需要<SPAN CLASS="APPLICATION">LaTeX</SPAN>
<TT CLASS="LITERAL">longtable</TT>和<TT CLASS="LITERAL">booktabs</TT>包装器。</P></DD><DT><TT CLASS="LITERAL">linestyle</TT></DT><DD><P>设置边界线绘画风格为<TT CLASS="LITERAL">ascii</TT>、<TT CLASS="LITERAL">old-ascii</TT>
或<TT CLASS="LITERAL">unicode</TT>之一。允许独特的缩写。（这意味着一个字母就足够了。）
缺省设置是<TT CLASS="LITERAL">ascii</TT>。这个选项只影响<TT CLASS="LITERAL">aligned</TT>和
<TT CLASS="LITERAL">wrapped</TT>输出格式。</P><P><TT CLASS="LITERAL">ascii</TT>风格使用纯<ACRONYM CLASS="ACRONYM">ASCII</ACRONYM>字母。
数据中的换行使用一个<TT CLASS="LITERAL">+</TT>符号在右手边显示。
当<TT CLASS="LITERAL">wrapped</TT>格式从一行到下一行包装数据而不带有换行符时，
一个点(<TT CLASS="LITERAL">.</TT>)显示在第一行的右手边，在下一行的左手边。</P><P><TT CLASS="LITERAL">old-ascii</TT>风格使用纯<ACRONYM CLASS="ACRONYM">ASCII</ACRONYM>字符，
使用在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4及更早版本中使用的格式风格。
数据中的换行使用一个<TT CLASS="LITERAL">:</TT>符号显示，代替左侧的域分隔符。
当数据从一行包装到下一行而不带有换行符时，使用一个<TT CLASS="LITERAL">;</TT>符号，
代替左侧的域分隔符。</P><P><TT CLASS="LITERAL">unicode</TT>风格使用Unicode box-drawing字符。
数据中的换行在右侧使用一个回车符显示。当数据从一行包装到下一行而不带有换行符时，
一个省略号显示在第一行的右手边，在下一行的左手边。</P><P>当<TT CLASS="LITERAL">border</TT>设置大于0时，这个选项也决定画边界线的字符。
纯<ACRONYM CLASS="ACRONYM">ASCII</ACRONYM>字符无处不在，
但是Unicode字符看起来显示的更好，更容易辨认。</P></DD><DT><TT CLASS="LITERAL">null</TT></DT><DD><P>设置打印出来替换空值的字符串。缺省是什么都不输出，
这样很容易和一个空字符串混淆。例如，可能更喜欢
<TT CLASS="LITERAL">\pset null '(null)'</TT>。</P></DD><DT><TT CLASS="LITERAL">numericlocale</TT></DT><DD><P>如果声明了<TT CLASS="REPLACEABLE"><I>value</I></TT>，那么它必须是
<TT CLASS="LITERAL">on</TT>或<TT CLASS="LITERAL">off</TT>，这将启用或禁用区域特定的字符的显示，
分隔小数点左边的数值组。如果省略了<TT CLASS="REPLACEABLE"><I>value</I></TT>，
那么该命令在普通和区域特定的数值输出之间切换。</P></DD><DT><TT CLASS="LITERAL">pager</TT></DT><DD><P>控制查询和<SPAN CLASS="APPLICATION">psql</SPAN>帮助输出的分页器程序的使用。
如果设置了环境变量<TT CLASS="ENVAR">PAGER</TT>，那么输出被定向到指定程序，
否则使用系统缺省(比如<TT CLASS="FILENAME">more</TT>)。</P><P>如果<TT CLASS="LITERAL">pager</TT>选项为<TT CLASS="LITERAL">off</TT>，则不使用分页器程序。如果<TT CLASS="LITERAL">pager</TT>
选项是<TT CLASS="LITERAL">on</TT>，则在适当的时候使用分页器，也就是说，输出是到终端，
而且很可能无法与屏幕匹配。也可以把<TT CLASS="LITERAL">pager</TT>选项设置为<TT CLASS="LITERAL">always</TT>，
导致在所有终端输出中都使用分页器，而不管它是否适合屏幕。不带有
<TT CLASS="REPLACEABLE"><I>value</I></TT>的<TT CLASS="LITERAL">\pset pager</TT>
切换分页器的使用与否。</P></DD><DT><TT CLASS="LITERAL">recordsep</TT></DT><DD><P>声明在非对齐模式时的记录分隔符。缺省是换行符。</P></DD><DT><TT CLASS="LITERAL">recordsep_zero</TT></DT><DD><P>设置在非对齐输出格式中使用的记录分隔符为0字节。</P></DD><DT><TT CLASS="LITERAL">tableattr</TT> (或 <TT CLASS="LITERAL">T</TT>)</DT><DD><P>在<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>格式下，这指定了要放置在<CODE CLASS="SGMLTAG">table</CODE>
标签中的属性。例如<TT CLASS="LITERAL">cellpadding</TT>或<TT CLASS="LITERAL">bgcolor</TT>。
请注意，你可能不需要在这里声明<TT CLASS="LITERAL">border</TT>，
因为已经在<TT CLASS="LITERAL">\pset border</TT>里用过了。如果没有给出
<TT CLASS="REPLACEABLE"><I>value</I></TT>，那么表的属性是未设置的。</P><P>在<TT CLASS="LITERAL">latex-longtable</TT>格式中，这控制每个包含左对齐数据类型的字段的比例宽度。
它声明为空白分隔的值列表，比如<TT CLASS="LITERAL">'0.2 0.2 0.6'</TT>。
为指明的输出列使用最后指定的值。</P></DD><DT><TT CLASS="LITERAL">title</TT></DT><DD><P>为任何随后打印的表设置标题。这个参数可以用于给你的输出一个描述性标记。
如果不带<TT CLASS="REPLACEABLE"><I>value</I></TT>，重置标题。</P></DD><DT><TT CLASS="LITERAL">tuples_only</TT> (或 <TT CLASS="LITERAL">t</TT>)</DT><DD><P>如果声明了<TT CLASS="REPLACEABLE"><I>value</I></TT>，那么必须是
<TT CLASS="LITERAL">on</TT>或<TT CLASS="LITERAL">off</TT>，这将启用或禁用仅元组模式。
如果省略了<TT CLASS="REPLACEABLE"><I>value</I></TT>，
那么该命令在普通和仅元组输出间切换。普通输出包括额外的信息，
比如列头、标题、各种脚注等。在仅元组模式下，只显示实际的表数据。</P></DD></DL></DIV><P>
</P><P>可以在<A HREF="app-psql.html#APP-PSQL-EXAMPLES"><I>例子</I></A>
小节看到这些不同格式输出的示例。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>有很多用于<TT CLASS="COMMAND">\pset</TT>的快速命令。
参阅<TT CLASS="COMMAND">\a</TT>、<TT CLASS="COMMAND">\C</TT>、<TT CLASS="COMMAND">\H</TT>、
<TT CLASS="COMMAND">\t</TT>、<TT CLASS="COMMAND">\T</TT>和<TT CLASS="COMMAND">\x</TT>。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>无参数运行<TT CLASS="COMMAND">\pset</TT>是错误的。以后这种情况将显示当前打印选项状态。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\q</TT> 或 <TT CLASS="LITERAL">\quit</TT></DT><DD><P>退出<SPAN CLASS="APPLICATION">psql</SPAN>程序。在脚本文件中，只终止该脚本的执行。</P></DD><DT><TT CLASS="LITERAL">\qecho <TT CLASS="REPLACEABLE"><I>text</I></TT> [ ... ] </TT></DT><DD><P>这条命令等效于<TT CLASS="COMMAND">\echo</TT>，区别是所有输出将写入由
<TT CLASS="COMMAND">\o</TT>设置的输出通道。</P></DD><DT><TT CLASS="LITERAL">\r</TT></DT><DD><P>重置(清空)查询缓冲区</P></DD><DT><TT CLASS="LITERAL">\s [ <TT CLASS="REPLACEABLE"><I>filename</I></TT> ]</TT></DT><DD><P>将命令行历史打印出或是存放到<TT CLASS="REPLACEABLE"><I>filename</I></TT>。
如果省略则输出到标准输出。这个选项只有在<SPAN CLASS="APPLICATION">psql</SPAN>
配置成使用<ACRONYM CLASS="ACRONYM">GNU</ACRONYM> <SPAN CLASS="APPLICATION">Readline</SPAN>库后才生效。</P></DD><DT><TT CLASS="LITERAL">\set [ <TT CLASS="REPLACEABLE"><I>name</I></TT> [ <TT CLASS="REPLACEABLE"><I>value</I></TT> [ ... ] ] ]</TT></DT><DD><P>设置<SPAN CLASS="APPLICATION">psql</SPAN>变量<TT CLASS="REPLACEABLE"><I>name</I></TT>
为<TT CLASS="REPLACEABLE"><I>value</I></TT>，或者如果给出了多于一个值，
设置为所有这些值的连接结果。如果只给出了一个参数，那么只设带有空值的变量。
要重置一个变量，使用<TT CLASS="COMMAND">\unset</TT>命令。</P><P>不带有任何参数的<TT CLASS="COMMAND">\set</TT>显示所有当前设置的<SPAN CLASS="APPLICATION">psql</SPAN>
变量的名字和值。</P><P>有效的变量名可以包含字母，数字和下划线。参阅下面的<A HREF="app-psql.html#APP-PSQL-VARIABLES"><I>变量</I></A>获取细节。变量名是大小写敏感的。</P><P>尽管你可以设置任何变量为任意值，<SPAN CLASS="APPLICATION">psql</SPAN>
对一些变量特殊对待。它们在关于变量的小节里面有文档。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这条命令和<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令<A HREF="sql-set.html">SET</A>是没有关系的。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="LITERAL">\setenv [ <TT CLASS="REPLACEABLE"><I>name</I></TT> [ <TT CLASS="REPLACEABLE"><I>value</I></TT> ] ]</TT></DT><DD><P>设置环境变量<TT CLASS="REPLACEABLE"><I>name</I></TT>为
<TT CLASS="REPLACEABLE"><I>value</I></TT>，
或者如果没有提供<TT CLASS="REPLACEABLE"><I>value</I></TT>，
则重置环境变量。例如：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\setenv PAGER less</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>\setenv LESS -imx4F</KBD
></PRE><P></P></DD><DT><TT CLASS="LITERAL">\sf[+] <TT CLASS="REPLACEABLE"><I>function_description</I></TT> </TT></DT><DD><P>这个命令抓取并显示命名函数的定义，以<TT CLASS="COMMAND">CREATE OR REPLACE FUNCTION</TT>
命令的格式。定义打印到当前查询输出通道，正如<TT CLASS="COMMAND">\o</TT>所设定的。</P><P>目标函数可以只通过名字指定，或者通过名字和参数指定，例如<TT CLASS="LITERAL">foo(integer, text)</TT>。
如果有多个函数的名字相同，则必须给出参数的类型。</P><P>如果在命令名后面附加上了<TT CLASS="LITERAL">+</TT>，那么输出行是编号了的，
函数体的第一行为1。</P></DD><DT><TT CLASS="LITERAL">\t</TT></DT><DD><P>切换输出的字段名标题和行记数脚注的显示。这条命令等效于<TT CLASS="LITERAL">\pset
tuples_only</TT>，提供它主要为了方便。</P></DD><DT><TT CLASS="LITERAL">\T <TT CLASS="REPLACEABLE"><I>table_options</I></TT></TT></DT><DD><P>声明<ACRONYM CLASS="ACRONYM">HTML</ACRONYM>输出格式中放在<CODE CLASS="SGMLTAG">table</CODE>标记里的属性。
这条命令等效于<TT CLASS="LITERAL">\pset tableattr <TT CLASS="REPLACEABLE"><I>table_options</I></TT></TT>。</P></DD><DT><TT CLASS="LITERAL">\timing [ <TT CLASS="REPLACEABLE"><I>on</I></TT> | <TT CLASS="REPLACEABLE"><I>off</I></TT> ]</TT></DT><DD><P>没有参数，以毫秒为单位显示每条 SQL 语句的耗时。有参数，设置相同。</P></DD><DT><TT CLASS="LITERAL">\unset <TT CLASS="REPLACEABLE"><I>name</I></TT></TT></DT><DD><P>取消（删除）<SPAN CLASS="APPLICATION">psql</SPAN>变量<TT CLASS="REPLACEABLE"><I>name</I></TT>。</P></DD><DT><TT CLASS="LITERAL">\w</TT> <TT CLASS="REPLACEABLE"><I>filename</I></TT><BR><TT CLASS="LITERAL">\w</TT> <TT CLASS="LITERAL">|</TT><TT CLASS="REPLACEABLE"><I>command</I></TT></DT><DD><P>将当前查询缓冲区输出到文件<TT CLASS="REPLACEABLE"><I>filename</I></TT>
或者重定向到 Unix 命令<TT CLASS="REPLACEABLE"><I>command</I></TT>。</P></DD><DT><TT CLASS="LITERAL">\watch [ <TT CLASS="REPLACEABLE"><I>seconds</I></TT> ]</TT></DT><DD><P>重复执行当前查询缓冲区（像<TT CLASS="LITERAL">\g</TT>），直到中断或查询失败。
在执行之间等待指定的秒数（缺省是2）。</P></DD><DT><TT CLASS="LITERAL">\x [ <TT CLASS="REPLACEABLE"><I>on</I></TT> | <TT CLASS="REPLACEABLE"><I>off</I></TT> | <TT CLASS="REPLACEABLE"><I>auto</I></TT> ]</TT></DT><DD><P>设置或切换扩展表格式化模式。等效于<TT CLASS="LITERAL">\pset expanded</TT>。</P></DD><DT><TT CLASS="LITERAL">\z [ <A HREF="app-psql.html#APP-PSQL-PATTERNS"><TT CLASS="REPLACEABLE"><I>pattern</I></TT></A> ]</TT></DT><DD><P>列出带有相关访问权限的表、视图和序列。如果声明了
<TT CLASS="REPLACEABLE"><I>pattern</I></TT>，
则只显示名字匹配该模式的表、视图和序列。</P><P>这是<TT CLASS="COMMAND">\dp</TT>(<SPAN CLASS="QUOTE">"显示权限"</SPAN>)的别名。</P></DD><DT><TT CLASS="LITERAL">\! [ <TT CLASS="REPLACEABLE"><I>command</I></TT> ]</TT></DT><DD><P>返回到一个单独的 Unix shell 或者执行 Unix 命令
<TT CLASS="REPLACEABLE"><I>command</I></TT>。参数不会被进一步解释，
shell 将看到全部参数。特别的，变量替换规则和反斜杠逃逸并不适用。</P></DD><DT><TT CLASS="LITERAL">\?</TT></DT><DD><P>显示关于反斜杠命令的帮助信息。</P></DD></DL></DIV><P>
</P><DIV CLASS="REFSECT3"><A NAME="APP-PSQL-PATTERNS"></A><H4>匹配模式</H4><P>各种<TT CLASS="LITERAL">\d</TT>命令都接受一个<TT CLASS="REPLACEABLE"><I>pattern</I></TT>
参数，声明要显示的对象名字。最简单的情况下 pattern 正好等于对象的名字。
pattern 中的字符通常会被自动转换成小写，就像 SQL 名字一样。
例如<TT CLASS="LITERAL">\dt FOO</TT>将显示名为<TT CLASS="LITERAL">foo</TT>的表。
与在 SQL 名字中相同的是双引号界定的 pattern 将保持原样(不做大小写转换)。
如果需要在双引号界定的 pattern 中使用双引号字符，你可以写两个并列的双引号，
这与 SQL 的引号规则相同。例如，<TT CLASS="LITERAL">\dt "FOO""BAR"</TT>
将会显示名为<TT CLASS="LITERAL">FOO"BAR</TT>的表，但是不会显示<TT CLASS="LITERAL">foo"bar</TT>。
与一般的 SQL 名字规则不同的是，你可以仅用双引号界定名字的一部分，
例如<TT CLASS="LITERAL">\dt FOO"FOO"BAR</TT>将显示名为<TT CLASS="LITERAL">fooFOObar</TT>的表。</P><P>如果完全省略<TT CLASS="REPLACEABLE"><I>pattern</I></TT>参数，
那么<TT CLASS="LITERAL">\d</TT>命令显示所有在当前模式搜索路径中可见的对象，
等价于使用<TT CLASS="LITERAL">*</TT>作为匹配模式。（如果一个对象的包含模式在搜索路径中，
并且没有相同类型、名字的对象出现在搜索路径中的更早位置，那么就说该对象是
<I CLASS="FIRSTTERM">可见的</I>。这就等于可以通过名字引用而不明确模式限定的语句。）
要查阅在数据库中的所有对象，使用<TT CLASS="LITERAL">*.*</TT>模式。</P><P>pattern 中的<TT CLASS="LITERAL">*</TT>匹配任何字符序列，包括没有字符，而<TT CLASS="LITERAL">?</TT>
匹配任何单个字符。这个表示法和 Unix 的 shell 文件名模式兼容。
比如<TT CLASS="LITERAL">\dt int*</TT>显示所有名字以<TT CLASS="LITERAL">int</TT>开头的表。
但是在双引号内部的<TT CLASS="LITERAL">*</TT>和<TT CLASS="LITERAL">?</TT>不具有匹配的功能，它们只代表自身。</P><P>包含点(<TT CLASS="LITERAL">.</TT>)的pattern将被解释成模式名pattern后面跟一个对象名pattern。
例如<TT CLASS="LITERAL">\dt foo*.*bar*</TT>显示所有名字以<TT CLASS="LITERAL">foo</TT>
开头的模式中的所有名字包含<TT CLASS="LITERAL">bar</TT>的表。如果没有出现句点，
那么这个模式只匹配在当前模式搜索路径中可见的对象。同样，
在双引号内的点没有这个含义，它只代表其自身。</P><P>还可以使用正则表达式语法，比如字符类等等。例如用<TT CLASS="LITERAL">[0-9]</TT>匹配所有数字。
所有正则表达式中的特殊字符都按照<A HREF="functions-matching.html#FUNCTIONS-POSIX-REGEXP">第 9.7.3 &#33410;</A>
里面描述的规则进行解析，除了<TT CLASS="LITERAL">.</TT>如上所述被当做分隔符，<TT CLASS="LITERAL">*</TT>
将被理解成<TT CLASS="LITERAL">.*</TT>，<TT CLASS="LITERAL">?</TT>将被理解成<TT CLASS="LITERAL">.</TT>，<TT CLASS="LITERAL">$</TT>
逐字匹配之外。这样一来，你就可以用<TT CLASS="LITERAL">?</TT>代替<TT CLASS="LITERAL">.</TT>、
用<TT CLASS="LITERAL">(<TT CLASS="REPLACEABLE"><I>R</I></TT>+|)</TT>代替
<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>R</I></TT>*</TT>、
用<TT CLASS="LITERAL">(<TT CLASS="REPLACEABLE"><I>R</I></TT>|)</TT>代替
<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>R</I></TT>?</TT>。
不需要<TT CLASS="LITERAL">$</TT>作为正则表达式字符，因为模式必须匹配整个名称，
而不是一般理解的匹配一部分即可（换句话说，<TT CLASS="LITERAL">$</TT>自动附加到你的模式）。
如果你只想匹配一部分，可以在 pattern 的开头和结尾使用<TT CLASS="LITERAL">*</TT>。
还需要注意的是在双引号内部的所有正则表达式特殊字符都将失去其特殊含义。
同样，在对操作符(也就是作为<TT CLASS="LITERAL">\do</TT>参数的时候)
进行匹配时正则表达式特殊字符也将失去其特殊含义。</P></DIV></DIV><DIV CLASS="REFSECT2"><A NAME="AEN87909"></A><H3>高级特性</H3><DIV CLASS="REFSECT3"><A NAME="APP-PSQL-VARIABLES"></A><H4>变量</H4><P><SPAN CLASS="APPLICATION">psql</SPAN>提供类似通常Unix命令shell那样的变量替换特性。
变量只是简单的名称/值对，这里的值可以是任何长度的任何值。
名字必须由字母（包括非拉丁字母）、数字和下划线组成。</P><P>要设置一个变量，使用<SPAN CLASS="APPLICATION">psql</SPAN>元命令<TT CLASS="COMMAND">\set</TT>，例如：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\set foo bar</KBD
></PRE><P>
把变量<TT CLASS="LITERAL">foo</TT>的值设置为<TT CLASS="LITERAL">bar</TT>。
要检索变量的内容，在变量名前面放上冒号，例如：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\echo :foo</KBD
>
bar</PRE><P>
这在SQL命令和元命令中都能运行；更详细信息在下面的
<A HREF="app-psql.html#APP-PSQL-INTERPOLATION"><I><I>SQL</I> 代换</I></A>
中给出。
</P><P>如果你不带第二个参数调用<TT CLASS="COMMAND">\set</TT>，那么设置这个变量，
带有一个空字符串作为值。要重置(也就是删除)一个变量，使用<TT CLASS="COMMAND">\unset</TT>命令。
要显示所有变量的值，不带有任何参数的调用<TT CLASS="COMMAND">\set</TT>。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><TT CLASS="COMMAND">\set</TT>的参数服从和其它命令一样的替换规则。
因此你可以构造有趣的引用，像<TT CLASS="LITERAL">\set :foo 'something'</TT>这样，
获得分别像<SPAN CLASS="PRODUCTNAME">Perl</SPAN>或<SPAN CLASS="PRODUCTNAME"><ACRONYM CLASS="ACRONYM">PHP</ACRONYM></SPAN>
那样有名的<SPAN CLASS="QUOTE">"软连接"</SPAN>或<SPAN CLASS="QUOTE">"变量变量"</SPAN>。不幸(或者万幸?)的是，
用这些构造不能做任何有用的事情。另一方面，<TT CLASS="LITERAL">\set bar :foo</TT>
是一个非常有效的拷贝变量的方法。</P></BLOCKQUOTE></DIV><P>有一些常用变量被<SPAN CLASS="APPLICATION">psql</SPAN>特殊相待。它们代表特定的选项设置，
这些选项在运行时可以通过改变变量的值而改变，或者在某些情况下代表
<SPAN CLASS="APPLICATION">psql</SPAN>的可变状态。尽管你可以把这些变量用于其它用途，
但是不鼓励这么做，因为程序的行为可能会变得非常奇怪。通常，
所有特殊对待的变量名都是由大写ASCII字母组成(可能还有数字和下划线)。
为了保证和未来的最大限度的兼容性，请避免使用这样的变量。
下面是一个所有特殊对待的变量列表。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="VARNAME">AUTOCOMMIT</TT></DT><DD><P>如果是<TT CLASS="LITERAL">on</TT>(缺省)，那么每个 SQL 命令都在成功完成后自动提交。
要推迟这种模式下的提交，你必须输入一个<TT CLASS="COMMAND">BEGIN</TT>或<TT CLASS="COMMAND">START TRANSACTION</TT>
命令。如果是<TT CLASS="LITERAL">off</TT>或者未设置，SQL 命令不会提交，直到你明确地发出
<TT CLASS="COMMAND">COMMIT</TT>或<TT CLASS="COMMAND">END</TT>。关闭自动提交的模式是通过为你明确发出一个
<TT CLASS="COMMAND">BEGIN</TT>实现的，它是放在任何尚未在一个事务块中并且自己不是
<TT CLASS="COMMAND">BEGIN</TT>或其它事务控制命令也不是那些不能在事务块里执行的命令
(比如<TT CLASS="COMMAND">VACUUM</TT>)的前面。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>在关闭自动提交的模式下，你必须明确放弃任何失败的事务，方法是执行<TT CLASS="COMMAND">ABORT</TT>
或<TT CLASS="COMMAND">ROLLBACK</TT>。还要注意，如果你不提交就退出会话，所做的工作会丢失。</P></BLOCKQUOTE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>打开自动提交是<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的传统行为，但是关闭自动提交更接近SQL规范。
如果你更喜欢关闭自动提交，你可以在系统范围的<TT CLASS="FILENAME">psqlrc</TT>
或<TT CLASS="FILENAME">~/.psqlrc</TT>文件中设置它。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="VARNAME">COMP_KEYWORD_CASE</TT></DT><DD><P>在完成SQL关键字时决定哪个字母使用大小写。如果设置为<TT CLASS="LITERAL">lower</TT>
或<TT CLASS="LITERAL">upper</TT>，则完成的单词将分别为小写或大写。如果设置为
<TT CLASS="LITERAL">preserve-lower</TT>或<TT CLASS="LITERAL">preserve-upper</TT>（缺省），
那么完成的单词将是输入时的情况，但是单词在没有任何输入的情况下完成，
将分别是小写或大写的情况。</P></DD><DT><TT CLASS="VARNAME">DBNAME</TT></DT><DD><P>正在连接着的数据库名称。每次与一个数据库联结都会设置这个值(包括程序启动)，
但是可以删除。</P></DD><DT><TT CLASS="VARNAME">ECHO</TT></DT><DD><P>如果设为<TT CLASS="LITERAL">all</TT>，那么来自键盘或脚本的所有输入行在分析或执行前都回显到标准输出。
使用<TT CLASS="OPTION">-a</TT>选项声明在程序启动时就默认这样做。如果设置为<TT CLASS="LITERAL">queries</TT>，
那么<SPAN CLASS="APPLICATION">psql</SPAN>只是在查询发送给服务器之前打印出来。
实现这个功能的命令行选项是<TT CLASS="OPTION">-e</TT>。</P></DD><DT><TT CLASS="VARNAME">ECHO_HIDDEN</TT></DT><DD><P>当设置了这个变量并且一个反斜杠命令查询数据库时，首先显示查询。
这样你可以学习<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>内部的东西，
并且在你自己的程序里提供类似功能。要在程序一起动的时候就启用这个行为，
可以使用<TT CLASS="OPTION">-E</TT>选项。如果你设置该变量的值为<TT CLASS="LITERAL">noexec</TT>，
那么查询只是显示出来但是实际上不发送到服务器去执行。</P></DD><DT><TT CLASS="VARNAME">ENCODING</TT></DT><DD><P>当前的客户端字符集编码。</P></DD><DT><TT CLASS="VARNAME">FETCH_COUNT</TT></DT><DD><P>如果该变量的值大于零，<TT CLASS="COMMAND">SELECT</TT>查询的结果将按此值分批返回和显示，
而不是缺省的一次取出和显示所有结果。这样就可以无论结果集有多大都只使用很少量的内存。
一般来说，设为 100 到 1000 之间的值比较合理。需要注意的是，使用此特性后，
一个查询可能在显示了一部分结果之后遭遇失败。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>虽然该特性可以用于所有输出格式。但是并不适合在缺省的<TT CLASS="LITERAL">aligned</TT>
格式上使用这个特性，因为每一批<TT CLASS="VARNAME">FETCH_COUNT</TT>行会被单独的分开格式化，
这样一来每一批输出结果的列宽就可能各不相等。不过对于其他格式这个特性工作的很好。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="VARNAME">HISTCONTROL</TT></DT><DD><P>如果将这个变量设为<TT CLASS="LITERAL">ignorespace</TT>，
那么以空格开始的行将不会进入历史列表。如果设置为<TT CLASS="LITERAL">ignoredups</TT>，
那么与以前历史记录里匹配的行也不会进入历史记录。值<TT CLASS="LITERAL">ignoreboth</TT>
是上面两个的结合。如果删除此变量或者其值为任何与上面的值不同的东西，
所有交互模式读入的行都被保存入历史列表。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这个特性是从<SPAN CLASS="APPLICATION">Bash</SPAN>偷学来的。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="VARNAME">HISTFILE</TT></DT><DD><P>此文件将用于存储历史列表。缺省值是<TT CLASS="FILENAME">~/.psql_history</TT>。
比如，在<TT CLASS="FILENAME">~/.psqlrc</TT>里使用：
</P><PRE CLASS="PROGRAMLISTING">\set HISTFILE ~/.psql_history- :DBNAME</PRE><P>
将使得<SPAN CLASS="APPLICATION">psql</SPAN>为每个数据库维护一个独立的历史。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这个特性是从<SPAN CLASS="APPLICATION">Bash</SPAN>偷学来的。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="VARNAME">HISTSIZE</TT></DT><DD><P>保存在命令历史里的命令的个数。缺省值是 500 。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这个特性是从<SPAN CLASS="APPLICATION">Bash</SPAN>偷学来的。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="VARNAME">HOST</TT></DT><DD><P>当前你正连接的数据库服务器主机。这是在每次你与数据库连接时(包括程序启动)设置的，
但是可以删除。</P></DD><DT><TT CLASS="VARNAME">IGNOREEOF</TT></DT><DD><P>如果删除此变量，向一个交互的<SPAN CLASS="APPLICATION">psql</SPAN>会话发送一个
<ACRONYM CLASS="ACRONYM">EOF</ACRONYM>(通常是<B CLASS="KEYCAP">Control</B>+<B CLASS="KEYCAP">D</B>)
将终止应用。如果设置为一个数字值，那么在应用终止前该数值的<ACRONYM CLASS="ACRONYM">EOF</ACRONYM>
字符将被忽略。如果设置了此变量但是没有数字值，缺省是 10 。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这个特性是从<SPAN CLASS="APPLICATION">Bash</SPAN>偷学来的。</P></BLOCKQUOTE></DIV></DD><DT><TT CLASS="VARNAME">LASTOID</TT></DT><DD><P>最后影响的OID值，即为从一条<TT CLASS="COMMAND">INSERT</TT>或<TT CLASS="COMMAND">\lo_import</TT>
命令返回的值。此变量只保证在下一条<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>命令的结果显示之前有效。</P></DD><DT><TT CLASS="VARNAME">ON_ERROR_ROLLBACK</TT></DT><DD><P>如果是<TT CLASS="LITERAL">on</TT>，那么当一个事务块里的语句产生错误的时候，
这个错误将被忽略而事务将继续。如果是<TT CLASS="LITERAL">interactive</TT>，
那么这样的错误只是在交互的会话里忽略，而不是在从读取脚本文件的时候。
如果是<TT CLASS="LITERAL">off</TT>(缺省)，事务块里一个语句生成的错误将会回滚整个事务。
on_error_rollback-on 的模式是通过在一个事务块的每个命令前为你隐含地发出一个
<TT CLASS="COMMAND">SAVEPOINT</TT>的方式工作的，在发生错误的时候回滚到该保存点。</P></DD><DT><TT CLASS="VARNAME">ON_ERROR_STOP</TT></DT><DD><P>缺省时，遇到错误后命令处理继续进行。如果设置了这个变量，遇到错误后会立即停止。
在交互模式下，<SPAN CLASS="APPLICATION">psql</SPAN>将返回到命令提示符；
否则，<SPAN CLASS="APPLICATION">psql</SPAN>将退出，并返回错误代码 3 ，
以示这个情况与致命错误条件的区别，致命错误条件的错误代码为 1。
不管在哪种情况下，任何当前运行的脚本（顶级脚本，如果有，和任何它调用的其他脚本）
都将立即终止。如果顶级命令字符串包含多个SQL命令，处理将在当前命令停止。</P></DD><DT><TT CLASS="VARNAME">PORT</TT></DT><DD><P>当前你正在连接的数据库服务器的端口。这是在每次你与数据库连接时
(包括程序启动)设置的，但是可以删除。</P></DD><DT><TT CLASS="VARNAME">PROMPT1</TT><BR><TT CLASS="VARNAME">PROMPT2</TT><BR><TT CLASS="VARNAME">PROMPT3</TT></DT><DD><P>这些指明<SPAN CLASS="APPLICATION">psql</SPAN>显示的提示符看上去像什么。
参阅下面的<A HREF="app-psql.html#APP-PSQL-PROMPTING"><I>提示符</I></A>。</P></DD><DT><TT CLASS="VARNAME">QUIET</TT></DT><DD><P>这个变量等效于命令行选项<TT CLASS="OPTION">-q</TT>。可能在交互模式下没有什么用。</P></DD><DT><TT CLASS="VARNAME">SINGLELINE</TT></DT><DD><P>这个变量等效于命令行选项<TT CLASS="OPTION">-S</TT>。</P></DD><DT><TT CLASS="VARNAME">SINGLESTEP</TT></DT><DD><P>这个变量等效于命令行选项<TT CLASS="OPTION">-s</TT>。</P></DD><DT><TT CLASS="VARNAME">USER</TT></DT><DD><P>当前你正用于连接的数据库用户。这是在每次你与数据库连接时(包括程序启动)设置的，
但是可以被删除。</P></DD><DT><TT CLASS="VARNAME">VERBOSITY</TT></DT><DD><P>这个选项可以设置为值<TT CLASS="LITERAL">default</TT>、<TT CLASS="LITERAL">verbose</TT>或<TT CLASS="LITERAL">terse</TT>
之一以控制错误报告的冗余。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT3"><A NAME="APP-PSQL-INTERPOLATION"></A><H4><ACRONYM CLASS="ACRONYM">SQL</ACRONYM> 代换</H4><P><SPAN CLASS="APPLICATION">psql</SPAN>变量的关键特性是你可以把它们替换成正规的
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>语句，也可以是元命令的参数。另外，<SPAN CLASS="APPLICATION">psql</SPAN>
提供工具确保变量值用作SQL文本并且正确的引用标识符。
不用引用替换一个值的语法是在变量名前面加一个冒号(<TT CLASS="LITERAL">:</TT>)。例如：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\set foo 'my_table'</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM :foo;</KBD
></PRE><P>
将会查询<TT CLASS="LITERAL">my_table</TT>表。请注意，这可能是不安全的：
变量的值是逐字拷贝的，所以它甚至可以包含不对称的引号或反斜杠命令。
你必须保证你输入的东西是有意义的。</P><P>当一个值被用作SQL文本或标识符时，将其引用是最安全的。
要引用一个变量的值作为SQL文本，在单引号中的变量名后面写一个冒号。
要引用值作为SQL标识符，在双引号中的变量名后面写一个冒号。
这些构造正确的处理引号和嵌入在变量值中的其他特殊字符。
上面的例子这样写更安全：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\set foo 'my_table'</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM :"foo";</KBD
></PRE><P></P><P>变量替换将不在引用的<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>文本和标识符中执行。因此，
一个构造比如<TT CLASS="LITERAL">':foo'</TT>并不从变量的值中产生一个引用的文本
（如果它确实发生了，那么它是不安全的，因为它不会正确的处理嵌入在值中的引号。）</P><P>使用这个机制的一个例子是拷贝一个文件的内容到一个表字段中。
首先加载文件到一个变量，然后替换变量的值为引用的字符串：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\set content `cat my_file.txt`</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>INSERT INTO my_table VALUES (:'content');</KBD
></PRE><P>
（注意，如果<TT CLASS="FILENAME">my_file.txt</TT>包含NUL字节，则这将不会运行。
<SPAN CLASS="APPLICATION">psql</SPAN>在变量值中不支持嵌入的NUL字节。）</P><P>因为冒号可以合法的出现在SQL命令中，一个代换的明显试图（也就是，<TT CLASS="LITERAL">:name</TT>、
<TT CLASS="LITERAL">:'name'</TT>或<TT CLASS="LITERAL">:"name"</TT>）是不会替换的，
除非命名的变量是当前设置。在任何情况下，都可以用反斜杠逃逸一个冒号以保护它不被替换。</P><P>变量的冒号语法符合诸如<SPAN CLASS="APPLICATION">ECPG</SPAN>之类的嵌入式查询语言的
<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准。用于数组片段和类型转换的冒号语法是
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>扩展，有时与标准的用法会有冲突。
逃逸变量值为SQL文本或标识符的冒号引号语法是<SPAN CLASS="APPLICATION">psql</SPAN>扩展。</P></DIV><DIV CLASS="REFSECT3"><A NAME="APP-PSQL-PROMPTING"></A><H4>提示符</H4><P><SPAN CLASS="APPLICATION">psql</SPAN>使用的提示符可以根据你的喜好自定义。
三个变量<TT CLASS="VARNAME">PROMPT1</TT>、<TT CLASS="VARNAME">PROMPT2</TT>、<TT CLASS="VARNAME">PROMPT3</TT>
包含描述提示符的外观的字符串和特殊逃逸序列。PROMPT1 是<SPAN CLASS="APPLICATION">psql</SPAN>
请求一个新命令时使用的正常提示符。PROMPT2 是在一个命令输入期待更多输入时
(因为查询没有用一个分号结束或者引号没有关闭)显示的提示符。
PROMPT3 在你运行一个<ACRONYM CLASS="ACRONYM">SQL</ACRONYM> <TT CLASS="COMMAND">COPY</TT>
命令和等待你在终端上键入记录时使用。</P><P>相应的提示符变量的值是按字面打印的，除非碰到一个百分号(<TT CLASS="LITERAL">%</TT>)。
这时某些其它的文本被替换，替换为何物取决于下一个字符。已定义的替换是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">%M</TT></DT><DD><P>数据库服务器全程主机名(带着域名)，如果连接是通过 Unix 域套接字进行的就是
<TT CLASS="LITERAL">[local]</TT>，或者如果 Unix 域套接字不是编译的缺省位置，
就是<TT CLASS="LITERAL">[local:<TT CLASS="REPLACEABLE"><I>/dir/name</I></TT>]</TT>。</P></DD><DT><TT CLASS="LITERAL">%m</TT></DT><DD><P>数据库服务器的主机名删去第一个点后面的部分剩下的东西。
或者如果是通过 Unix 域套接字连接，就是<TT CLASS="LITERAL">[local]</TT>。</P></DD><DT><TT CLASS="LITERAL">%&gt;</TT></DT><DD><P>数据库服务器正在侦听的端口号。</P></DD><DT><TT CLASS="LITERAL">%n</TT></DT><DD><P>数据库会话的用户名。这个值的扩展可能在一个数据库会话过程中因为
<TT CLASS="COMMAND">SET SESSION AUTHORIZATION</TT>命令而改变。</P></DD><DT><TT CLASS="LITERAL">%/</TT></DT><DD><P>当前数据库名称。</P></DD><DT><TT CLASS="LITERAL">%~</TT></DT><DD><P>类似<TT CLASS="LITERAL">%/</TT>，但如果数据库是你的缺省数据库输出是波浪线<TT CLASS="LITERAL">~</TT>。</P></DD><DT><TT CLASS="LITERAL">%#</TT></DT><DD><P>如果会话用户是数据库超级用户，使用<TT CLASS="LITERAL">#</TT>，否则用
<TT CLASS="LITERAL">&gt;</TT>。这个值的扩展可能在一个数据库会话过程中因为
<TT CLASS="COMMAND">SET SESSION AUTHORIZATION</TT>命令而改变。</P></DD><DT><TT CLASS="LITERAL">%R</TT></DT><DD><P>对于 PROMPT1 通常是<TT CLASS="LITERAL">=</TT>，但是如果是单行模式则是<TT CLASS="LITERAL">^</TT>，
而如果会话与数据库断开(如果<TT CLASS="COMMAND">\connect</TT>失败可能发生)
则是<TT CLASS="LITERAL">!</TT>。对于 PROMPT2 该序列被<TT CLASS="LITERAL">-</TT>、
<TT CLASS="LITERAL">*</TT>、一个单引号/双引号/美元符(取决于<SPAN CLASS="APPLICATION">psql</SPAN>
是否等待更多的输入：查询没有终止、正在一个<TT CLASS="LITERAL">/* ... */</TT>
注释里、正在引号或者美元符逃逸字符串里)代替。对于 PROMPT3 该序列不解释成任何东西。</P></DD><DT><TT CLASS="LITERAL">%x</TT></DT><DD><P>事务状态：如果不在事务块里则是一个空字符串，如果在事务块里则是<TT CLASS="LITERAL">*</TT>，
如果在一个失败的事务块里则是<TT CLASS="LITERAL">!</TT>，或者无法判断事务状态时为<TT CLASS="LITERAL">?</TT>
(比如没有连接)。</P></DD><DT><TT CLASS="LITERAL">%</TT><TT CLASS="REPLACEABLE"><I>digits</I></TT></DT><DD><P>指定字节值的字符将被替换到该位置。</P></DD><DT><TT CLASS="LITERAL">%:</TT><TT CLASS="REPLACEABLE"><I>name</I></TT><TT CLASS="LITERAL">:</TT></DT><DD><P><SPAN CLASS="APPLICATION">psql</SPAN>变量<TT CLASS="REPLACEABLE"><I>name</I></TT>
的值。参阅<A HREF="app-psql.html#APP-PSQL-VARIABLES"><I>变量</I></A>
小节获取细节。</P></DD><DT><TT CLASS="LITERAL">%`</TT><TT CLASS="REPLACEABLE"><I>command</I></TT><TT CLASS="LITERAL">`</TT></DT><DD><P><TT CLASS="REPLACEABLE"><I>command</I></TT>的输出，
类似于通常的<SPAN CLASS="QUOTE">"反勾号"</SPAN>替换。</P></DD><DT><TT CLASS="LITERAL">%[</TT> ... <TT CLASS="LITERAL">%]</TT></DT><DD><P>提示可以包含终端控制字符，这些字符可以改变颜色、背景、提示文本的风格、
终端窗口的标题。为了让<SPAN CLASS="APPLICATION">Readline</SPAN>的行编辑特性正确运行，
这些不可打印的控制字符必须设计成不可见的，方法是用<TT CLASS="LITERAL">%[</TT>
和<TT CLASS="LITERAL">%]</TT>包围它们。在提示符里可能出现这些东西的多个配对。例如：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; \set PROMPT1 '%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%# '</PRE><P>
的结果是在 VT100 兼容的可显示彩色的终端上的一个宽体(<TT CLASS="LITERAL">1;</TT>)
黑底黄字(<TT CLASS="LITERAL">33;40</TT>)。</P></DD></DL></DIV><P>
键入<TT CLASS="LITERAL">%%</TT>可以在提示符里插入百分号。
缺省提示符为<TT CLASS="LITERAL">'%/%R%# '</TT>用于第一二个提示符，
<TT CLASS="LITERAL">'&gt;&gt; '</TT>用于第三个提示符。
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这个特性是从<SPAN CLASS="APPLICATION">tcsh</SPAN>偷学来的。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="REFSECT3"><A NAME="AEN88296"></A><H4>命令行编辑</H4><P><SPAN CLASS="APPLICATION">psql</SPAN>为了编辑和检索命令行的方便支持
<SPAN CLASS="APPLICATION">Readline</SPAN>库。命令历史在<SPAN CLASS="APPLICATION">psql</SPAN>
退出的时候自动保存，在<SPAN CLASS="APPLICATION">psql</SPAN>启动的时候加载。
还支持 Tab 补齐，尽管该补齐逻辑并不是一个<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>分析器必备的。
tab补齐产生的查询也可以与其他SQL命令交互，比如<TT CLASS="LITERAL">SET TRANSACTION ISOLATION LEVEL</TT>。
如果因某些原因你不喜欢 tab 补齐，可以把下面几行放在你的家目录下的
<TT CLASS="FILENAME">.inputrc</TT>文件里关闭这个特性：
</P><PRE CLASS="PROGRAMLISTING">$if psql
set disable-completion on
$endif</PRE><P>
这不是<SPAN CLASS="APPLICATION">psql</SPAN>而是<SPAN CLASS="APPLICATION">Readline</SPAN>
的特性，参考它的文档获取更多细节。</P></DIV></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PSQL-ENVIRONMENT"></A><H2>环境变量</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="ENVAR">COLUMNS</TT></DT><DD><P>如果<TT CLASS="LITERAL">\pset columns</TT>为0，控制<TT CLASS="LITERAL">wrapped</TT>
格式的宽度和宽度确定（如果宽的输出需要分页或在自动扩展模式应该切换为垂直模式）。</P></DD><DT><TT CLASS="ENVAR">PAGER</TT></DT><DD><P>如果查询结果在一页里放不下，那么它们被重定向到这个命令。
典型的值是<TT CLASS="LITERAL">more</TT>或<TT CLASS="LITERAL">less</TT>。
缺省值是平台相关的。可以用<TT CLASS="COMMAND">\pset</TT>命令关闭分页器。</P></DD><DT><TT CLASS="ENVAR">PGDATABASE</TT><BR><TT CLASS="ENVAR">PGHOST</TT><BR><TT CLASS="ENVAR">PGPORT</TT><BR><TT CLASS="ENVAR">PGUSER</TT></DT><DD><P>缺省连接的参数（参阅<A HREF="libpq-envars.html">第 31.14 &#33410;</A>）。</P></DD><DT><TT CLASS="ENVAR">PSQL_EDITOR</TT><BR><TT CLASS="ENVAR">EDITOR</TT><BR><TT CLASS="ENVAR">VISUAL</TT></DT><DD><P><TT CLASS="COMMAND">\e</TT>和<TT CLASS="COMMAND">\ef</TT>命令使用的编辑器。
这些变量是按照上面的顺序检查的；设置最早的最先使用。</P><P>在Unix系统上内建的缺省编辑器是<TT CLASS="FILENAME">vi</TT>，
在Windows系统上是<TT CLASS="FILENAME">notepad.exe</TT>。</P></DD><DT><TT CLASS="ENVAR">PSQL_EDITOR_LINENUMBER_ARG</TT></DT><DD><P>当<TT CLASS="COMMAND">\e</TT>或<TT CLASS="COMMAND">\ef</TT>带有行号参数使用时，
这个变量声明传递给用户编辑器的启动行号的命令行参数。
对于<SPAN CLASS="PRODUCTNAME">Emacs</SPAN>或<SPAN CLASS="PRODUCTNAME">vi</SPAN>这样的编辑器，这是一个加号。
如果在选项名和行号之间需要空格，则包括变量值中尾随的空白。例子：
</P><PRE CLASS="PROGRAMLISTING">PSQL_EDITOR_LINENUMBER_ARG='+'
PSQL_EDITOR_LINENUMBER_ARG='--line '</PRE><P></P><P>在Unix系统上的缺省是<TT CLASS="LITERAL">+</TT>（对应于默认的编辑器
<TT CLASS="FILENAME">vi</TT>，并且可用于许多其他常见的编辑器）；
在Windows系统上没有缺省。</P></DD><DT><TT CLASS="ENVAR">PSQL_HISTORY</TT></DT><DD><P>命令历史文件的替代位置。执行波浪符(<TT CLASS="LITERAL">~</TT>)扩展。</P></DD><DT><TT CLASS="ENVAR">PSQLRC</TT></DT><DD><P>用户的<TT CLASS="FILENAME">.psqlrc</TT>文件的替代位置。
执行波浪符(<TT CLASS="LITERAL">~</TT>)扩展。</P></DD><DT><TT CLASS="ENVAR">SHELL</TT></DT><DD><P><TT CLASS="COMMAND">\!</TT>命令执行的命令。</P></DD><DT><TT CLASS="ENVAR">TMPDIR</TT></DT><DD><P>存储临时文件的目录。缺省是<TT CLASS="FILENAME">/tmp</TT>。</P></DD></DL></DIV><P>这个工具，像大多数其他<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>工具一样，
也使用<SPAN CLASS="APPLICATION">libpq</SPAN>提供的环境变量（参阅<A HREF="libpq-envars.html">第 31.14 &#33410;</A>）。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN88395"></A><H2>文件</H2><P></P><UL><LI><P>除非传递了<TT CLASS="OPTION">-X</TT>或<TT CLASS="OPTION">-c</TT>选项，否则在启动之前，
<SPAN CLASS="APPLICATION">psql</SPAN>将会读取和执行来自系统范围的<TT CLASS="FILENAME">psqlrc</TT>
文件和用户<TT CLASS="FILENAME">~/.psqlrc</TT>文件里面的命令。
在 Windows 里，用户的启动文件名是<TT CLASS="FILENAME">%APPDATA%\postgresql\psqlrc.conf</TT>。
参阅<TT CLASS="FILENAME"><TT CLASS="REPLACEABLE"><I>PREFIX</I></TT>/share/psqlrc.sample</TT>
获取如何设置全系统的文件的信息。可将它用于设置客户端或者服务器的风格
(使用<TT CLASS="COMMAND">\set</TT>和<TT CLASS="COMMAND">SET</TT>命令)。</P><P>用户的<TT CLASS="FILENAME">~/.psqlrc</TT>文件的位置也可以通过
<TT CLASS="ENVAR">PSQLRC</TT>环境设置明确的设置。</P></LI><LI><P>系统范围的<TT CLASS="FILENAME">psqlrc</TT>和用户自己的<TT CLASS="FILENAME">~/.psqlrc</TT>
都可以通过在后面附着一个破折号和<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
主要或次要<SPAN CLASS="APPLICATION">psql</SPAN>版本号的方法变得与版本相关，
比如<TT CLASS="FILENAME">~/.psqlrc-9.2</TT>或<TT CLASS="FILENAME">~/.psqlrc-9.2.5</TT>。
更确切的版本匹配文件比无版本的文件优先读取。</P></LI><LI><P>命令行历史存储在<TT CLASS="FILENAME">~/.psql_history</TT>文件中，
或者在 Windows 里是<TT CLASS="FILENAME">%APPDATA%\postgresql\psql_history</TT>文件。</P><P>历史文件的位置也可以通过<TT CLASS="ENVAR">PSQL_HISTORY</TT>环境设置来明确设置。</P></LI></UL></DIV><DIV CLASS="REFSECT1"><A NAME="AEN88427"></A><H2>注意</H2><P></P><UL><LI><P>一些<SPAN CLASS="APPLICATION">psql</SPAN>的早期版本允许一个单字母的反斜杠命令
(元命令)的第一个参数直接跟在命令后面，而不用空白间隔。
到了<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.4就不再允许这样使用了。</P></LI><LI><P><SPAN CLASS="APPLICATION">psql</SPAN>能与同版本或更老主要版本的服务器工作。
如果服务器的版本比<SPAN CLASS="APPLICATION">psql</SPAN>本身要新，则反斜杠命令是特别容易失效的。
不过，<TT CLASS="LITERAL">\d</TT>家族的反斜杠命令应该在7.4的服务器版本上工作，
尽管不必要用比<SPAN CLASS="APPLICATION">psql</SPAN>本身更新的服务器。
运行SQL命令和显示查询结果的通用功能也应该在更新主版本的服务器上工作，
但是并不保证所有情况都没问题。</P><P>如果你想要使用<SPAN CLASS="APPLICATION">psql</SPAN>连接几个不同主版本的服务器，
建议你使用<SPAN CLASS="APPLICATION">psql</SPAN>的最新版本。或者，
你可以保存每个主版本的<SPAN CLASS="APPLICATION">psql</SPAN>的拷贝，
确保使用匹配各自服务器的版本。但是在实际中，不必要弄的这么复杂。</P></LI></UL></DIV><DIV CLASS="REFSECT1"><A NAME="AEN88444"></A><H2>Windows 用户需要注意的地方</H2><P><SPAN CLASS="APPLICATION">psql</SPAN>是以一种<SPAN CLASS="QUOTE">"控制台应用"</SPAN>的方式制作的。
因为 Windows 控制台窗口和系统其它部分使用不同的编码，所以在
<SPAN CLASS="APPLICATION">psql</SPAN>里使用 8 位字符的时候必须采取特殊的注意措施。
如果<SPAN CLASS="APPLICATION">psql</SPAN>检测到一个有问题的控制台代码页，
那么它在启动的时候会警告你。要修改控制台代码页，有两件事是必须做的：
<P></P></P><UL><LI><P>通过输入<KBD CLASS="USERINPUT">cmd.exe /c chcp 1252</KBD>设置代码页。
（1252 是适用于德语的代码页；请换成合适你的数值。）
如果你使用 Cygwin ，你可以在<TT CLASS="FILENAME">/etc/profile</TT>里面输入这条命令。</P></LI><LI><P>控制台字体设置为<TT CLASS="LITERAL">Lucida Console</TT>，因为光栅字体(点阵字体)
不能在 ANSI 代码页下工作。</P></LI></UL><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="APP-PSQL-EXAMPLES"></A><H2>例子</H2><P>第一个例子演示了如何把一个查询分成多个行进行输入。注意提示符的变化：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>CREATE TABLE my_table (</KBD
>
testdb(&gt; <KBD
CLASS="USERINPUT"
> first integer not null default 0,</KBD
>
testdb(&gt; <KBD
CLASS="USERINPUT"
> second text)</KBD
>
testdb-&gt; <KBD
CLASS="USERINPUT"
>;</KBD
>
CREATE TABLE</PRE><P>
现在再看看表定义：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\d my_table</KBD
>
             Table "my_table"
 Attribute |  Type   |      Modifier
-----------+---------+--------------------
 first     | integer | not null default 0
 second    | text    |&#13;</PRE><P>
把提示符变成更有趣的东西：
</P><PRE CLASS="PROGRAMLISTING">testdb=&gt; <KBD
CLASS="USERINPUT"
>\set PROMPT1 '%n@%m %~%R%# '</KBD
>
peter@localhost testdb=&gt;</PRE><P>
假设你用数据填充了表并且想看一眼：
</P><PRE CLASS="PROGRAMLISTING">peter@localhost testdb=&gt; SELECT * FROM my_table;
 first | second
-------+--------
     1 | one
     2 | two
     3 | three
     4 | four
(4 rows)&#13;</PRE><P>
你可以用<TT CLASS="COMMAND">\pset</TT>命令以不同的方法显示表：
</P><PRE CLASS="PROGRAMLISTING">peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset border 2</KBD
>
Border style is 2.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM my_table;</KBD
>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)

peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset border 0</KBD
>
Border style is 0.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM my_table;</KBD
>
first second
----- ------
    1 one
    2 two
    3 three
    4 four
(4 rows)

peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset border 1</KBD
>
Border style is 1.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset format unaligned</KBD
>
Output format is unaligned.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset fieldsep ","</KBD
>
Field separator is ",".
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset tuples_only</KBD
>
Showing only tuples.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT second, first FROM my_table;</KBD
>
one,1
two,2
three,3
four,4</PRE><P>
还可以用短(缩写)命令：
</P><PRE CLASS="PROGRAMLISTING">peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\a \t \x</KBD
>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM my_table;</KBD
>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four</PRE><P></P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="app-pgrestore.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="app-reindexdb.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">pg_restore</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/reference-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><SPAN CLASS="APPLICATION">reindexdb</SPAN></TD></TR></TABLE></DIV></BODY></HTML>
