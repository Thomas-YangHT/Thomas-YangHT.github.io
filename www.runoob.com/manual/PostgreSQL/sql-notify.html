<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>NOTIFY</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="MOVE" HREF="sql-move.html"><LINK REL="NEXT" TITLE="PREPARE" HREF="sql-prepare.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/notify.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="MOVE" HREF="sql-move.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="PREPARE" HREF="sql-prepare.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-NOTIFY"></A>NOTIFY</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN78507"></A><H2>&#21517;&#31216;</H2>NOTIFY&nbsp;--&nbsp;生成一个通知</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN78512"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">NOTIFY <TT
CLASS="REPLACEABLE"
><I
>channel</I
></TT
> [ , <TT
CLASS="REPLACEABLE"
><I
>payload</I
></TT
> ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78516"></A><H2>描述</H2><P><TT CLASS="COMMAND">NOTIFY</TT>命令向当前数据库中所有执行过
<TT CLASS="COMMAND">LISTEN <TT CLASS="REPLACEABLE"><I>channel</I></TT></TT>，
正在监听特定通道名字的前端应用发送一个通知事件和一个可选的<SPAN CLASS="QUOTE">"payload"</SPAN>字符串。
通知对所有用户可见。</P><P><TT CLASS="COMMAND">NOTIFY</TT>为访问同一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
数据库的一组进程提供了一种简单的进程间通讯机制。负载字符串可以和通知一起发送，
并且传送结构化数据的更高级的机制可以通过使用数据库中的表从通知者传递数据到接收者。</P><P>传递给前端的通知事件包括通知通道名、发出通知的后端进程<ACRONYM CLASS="ACRONYM">PID</ACRONYM>
和负载字符串，如果已经指定了字符串则该负载字符串为空。</P><P>定义将要用于给定数据库的通道名和每个意味着什么取决于数据库设计者。
通常，通知通道名与数据库里的表的名字相同，通知事件实际上意味着<SPAN CLASS="QUOTE">"我修改了此数据库，
请看一眼有什么新东西"</SPAN>。<TT CLASS="COMMAND">NOTIFY</TT>和<TT CLASS="COMMAND">LISTEN</TT>
命令并不强制这种联系。例如，数据库设计者可以使用几个不同的通道名来标志一个表的几种不同改变。
另外，负载字符串可以用来区分各种情况。</P><P>当<TT CLASS="COMMAND">NOTIFY</TT>用于通知某一特定表修改的动作的发生，
一个实用的编程技巧是将<TT CLASS="COMMAND">NOTIFY</TT>放在一个由表更新触发的规则里。用这种方法，
通知将在表更新的时候自动触发，而且应用程序员不会碰巧忘记处理它。</P><P><TT CLASS="COMMAND">NOTIFY</TT>和 SQL 事务用某种重要的方法进行交换。首先，如果<TT CLASS="COMMAND">NOTIFY</TT>
在事务内部执行，通知事件直到事务提交才会送出。这么做是有道理的，因为如果事务退出了，
那么在它里面的所有命令都没有效果(包括<TT CLASS="COMMAND">NOTIFY</TT>)。但如果有人希望通知事件立即发送，
这就不太好了。其次，当一个正在监听的会话在一次事务内收到一个通知信号，
直到本次事务完成(提交或退出)之前，该通知事件将不被送到与之相连的客户端。同样，
如果一个通知在事务内部发送出去了，而该事务稍后又退出了，就希望通知可以在某种程度上被撤消，
因为通知一旦发送出去，服务器便不能从客户端<SPAN CLASS="QUOTE">"收回"</SPAN>通知，所以通知事件只是在事务之间传递。
这一点就要求使用<TT CLASS="COMMAND">NOTIFY</TT>作为实时信号的应用应该确保他们的事务尽可能短。</P><P>如果相同的通道名已经从相同的事务中发出了同样的负载字符串多次，
数据库服务器可以决定只送出一个字符串通知。另一方面，不同负载字符串的通知将总是作为不同通知传送。
相似的，来自不同事件的通知将永远不会被并入一个通知。除了删除稍后复制通知的实例，
<TT CLASS="COMMAND">NOTIFY</TT>保证来自相同事务的通知以它们被传送的顺序到达。
也保证来自不同事务的信息以事务提交的顺序到达。</P><P>客户端经常会自己发送与正在监听的通知通道一样的<TT CLASS="COMMAND">NOTIFY</TT>。
这时它(客户端)也和其它正在监听的会话一样收到一个通知事件。
这样可能导致一些无用的工作(与应用逻辑有关)。例如，
对客户端刚写过的表又进行一次读操作以发现是否有更新。
可以通过检查服务器进程的<ACRONYM CLASS="ACRONYM">PID</ACRONYM>(在通知事件中提供)是否与自己的会话的<ACRONYM CLASS="ACRONYM">PID</ACRONYM>
一致(从<SPAN CLASS="APPLICATION">libpq</SPAN>中取得)避免这样的额外工作。当他们一样时，
说明这是其自身回弹的信息，可以忽略。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78548"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="REPLACEABLE"><I>channel</I></TT></DT><DD><P>生成信号(通知)的通知通道(任何标识符)。</P></DD><DT><TT CLASS="REPLACEABLE"><I>payload</I></TT></DT><DD><P><SPAN CLASS="QUOTE">"payload"</SPAN>字符串与通知交流。必须指定为简单的字符串文本。缺省配置中必须少于8000字节。
（如果二进制数据或大量的信息需要交流，最好放在数据库表中并发送该记录的键字。）</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78562"></A><H2>注意</H2><P>有一个已经发送的持有通知但目前还未被所有监听会话处理的序列。如果这个序列满了，
会话调用<TT CLASS="COMMAND">NOTIFY</TT>将会在提交时失败。序列是相当大的（标准安装中是8GB）
并且应该足够为几乎每个使用情况大。但是，如果会话执行<TT CLASS="COMMAND">LISTEN</TT>
并且然后进入一个事务很长时间那么将不会有清除发生。一旦序列是半满的，
您将在日志中看到警告指向您的会话阻止清除。在这种情况下，应该确保这个会话结束他的当前事务，
这样清理能够进行。</P><P>一个已经执行了<TT CLASS="COMMAND">NOTIFY</TT>的事务不能准备两阶段提交。</P><DIV CLASS="REFSECT2"><A NAME="AEN78569"></A><H3>pg_notify</H3><P>也可以使用函数<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_notify</CODE>(<TT CLASS="TYPE">text</TT>, <TT CLASS="TYPE">text</TT>)</TT>
发送一个通知。函数接受通道名作为第一个参数，负载作为第二个参数。
如果你需要使用不稳定的通道名和负载，那么使用函数比使用<TT CLASS="COMMAND">NOTIFY</TT>命令更简单。</P></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78579"></A><H2>例子</H2><P>在<SPAN CLASS="APPLICATION">psql</SPAN>里配置和执行一个监听/通知序列：
</P><PRE CLASS="PROGRAMLISTING">LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
NOTIFY virtual, 'This is the payload';
Asynchronous notification "virtual" with payload "This is the payload" received from server process with PID 8448.

LISTEN foo;
SELECT pg_notify('fo' || 'o', 'pay' || 'load');
Asynchronous notification "foo" with payload "payload" received from server process with PID 14728.</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78584"></A><H2>兼容性</H2><P>SQL 标准里没有<TT CLASS="COMMAND">NOTIFY</TT>语句。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN78588"></A><H2>又见</H2><A HREF="sql-listen.html">LISTEN</A>, <A HREF="sql-unlisten.html">UNLISTEN</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-move.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-prepare.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">MOVE</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">PREPARE</TD></TR></TABLE></DIV></BODY></HTML>
