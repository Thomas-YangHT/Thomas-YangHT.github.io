<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>xml2</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="uuid-ossp" HREF="uuid-ossp.html"><LINK REL="NEXT" TITLE="额外提供的程序" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib-prog.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/xml2.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="uuid-ossp" HREF="uuid-ossp.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="额外提供的程序" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib-prog.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="XML2">F.42. xml2</A></H1><P><TT CLASS="FILENAME">xml2</TT>模块提供XPath查询和XSLT功能。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN150942">F.42.1. 弃用通知</A></H2><P>从<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.3开始，在内核服务器中有一个基于SQL/XML标准的XML相关的功能。
这个功能包含了XML语法检查和XPath查询，这也是这个模块的包含的，甚至更多，不过API一点也不兼容。
计划在未来的PostgreSQL版本中删除这个模块，支持新的标准的API，所以鼓励你尝试转换你的应用。
如果你发现这个模块的某些功能在一个适当形式的更新的API中不可用，
请解释你的问题到<CODE CLASS="EMAIL">&#60;<A HREF="mailto:pgsql-hackers@postgresql.org">pgsql-hackers@postgresql.org</A>&#62;</CODE>，以便解决这个缺陷。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN150947">F.42.2. 功能说明</A></H2><P><A HREF="xml2.html#XML2-FUNCTIONS-TABLE">&#34920; F-32</A>显示了这个模块提供的函数。
这些函数提供了简单的XMP解析和XPath查询。所有参数都是<TT CLASS="TYPE">text</TT>类型的，
所以为了简化没有显示。</P><DIV CLASS="TABLE"><A NAME="XML2-FUNCTIONS-TABLE"></A><P><B>&#34920; F-32. 函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <CODE CLASS="FUNCTION"> xml_is_well_formed(document)
</CODE>
</TD><TD> <TT CLASS="TYPE">bool</TT>
</TD><TD>
<P>解析它的参数中的文件正文，并且如果文件是格式良好的XML则返回真。
（注意：在PostgreSQL 8.2之前，这个函数称为<CODE CLASS="FUNCTION">xml_valid()</CODE>。
这是错误的名字，因为在XML中有效性和良构性有不同的含义。
老的名字仍然可用，但是已经废弃了。）</P>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_string(document, query)
</CODE>
</TD><TD> <TT CLASS="TYPE">text</TT>
</TD><TD ROWSPAN="3">
<P>这个函数在提供的文件上评估XPath查询，并转换结果到指定的类型。</P>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_number(document, query)
</CODE>
</TD><TD> <TT CLASS="TYPE">float4</TT>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_bool(document, query)
</CODE>
</TD><TD> <TT CLASS="TYPE">bool</TT>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_nodeset(document, query, toptag, itemtag)
</CODE>
</TD><TD> <TT CLASS="TYPE">text</TT>
</TD><TD>
<P>在文件上评估查询并将结果包装在XML标签中。如果结果是多值的，那么输出将看起来像：
</P><PRE CLASS="SYNOPSIS">&lt;toptag&gt;
&lt;itemtag&gt;Value 1 which could be an XML fragment&lt;/itemtag&gt;
&lt;itemtag&gt;Value 2....&lt;/itemtag&gt;
&lt;/toptag&gt;</PRE><P>
如果<TT CLASS="LITERAL">toptag</TT>或<TT CLASS="LITERAL">itemtag</TT>中的任意一个是空字符串，那么省略相关的标签。</P>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_nodeset(document, query)
</CODE>
</TD><TD> <TT CLASS="TYPE">text</TT>
</TD><TD>
<P>类似于<CODE CLASS="FUNCTION">xpath_nodeset(document, query, toptag, itemtag)</CODE>，但是结果省略两个标签。</P>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_nodeset(document, query, itemtag)
</CODE>
</TD><TD> <TT CLASS="TYPE">text</TT>
</TD><TD>
<P>类似于<CODE CLASS="FUNCTION">xpath_nodeset(document, query, toptag, itemtag)</CODE>，但是结果省略toptag。</P>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_list(document, query, separator)
</CODE>
</TD><TD> <TT CLASS="TYPE">text</TT>
</TD><TD>
<P>这个函数返回由指定的分隔符分开的多个值，例如如果分隔符是<TT CLASS="LITERAL">,</TT>，
返回值是<TT CLASS="LITERAL">Value 1,Value 2,Value 3</TT>。</P>
</TD></TR><TR><TD> <CODE CLASS="FUNCTION"> xpath_list(document, query)
</CODE>
</TD><TD> <TT CLASS="TYPE">text</TT>
</TD><TD>
这是一个对于使用<TT CLASS="LITERAL">,</TT>作为分隔符的以上函数的包装器。
</TD></TR></TBODY></TABLE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN151028">F.42.3. <TT CLASS="LITERAL">xpath_table</TT></A></H2><PRE CLASS="SYNOPSIS">xpath_table(text key, text document, text relation, text xpaths, text criteria) returns setof record</PRE><P><CODE CLASS="FUNCTION">xpath_table</CODE>是一个表函数，在每一组文档上计算一组XPath查询，
并作为一个表返回结果。原始文档表的主键字段作为结果的第一个字段返回，
因此结果集可以容易的用于连接。参数在<A HREF="xml2.html#XML2-XPATH-TABLE-PARAMETERS">&#34920; F-33</A>中描述。</P><DIV CLASS="TABLE"><A NAME="XML2-XPATH-TABLE-PARAMETERS"></A><P><B>&#34920; F-33. <CODE CLASS="FUNCTION">xpath_table</CODE> 参数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>参数</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="PARAMETER">key</TT></TD><TD>
<P><SPAN CLASS="QUOTE">"key"</SPAN>字段的名字&mdash;这只是用作输出表的第一个字段，也就是，
它识别每个传来的输出行的记录（请参见下面关于多行值的注释）</P>
</TD></TR><TR><TD><TT CLASS="PARAMETER">document</TT></TD><TD>
<P>包含XML文档的字段名</P>
</TD></TR><TR><TD><TT CLASS="PARAMETER">relation</TT></TD><TD>
<P>包含文档的表或视图的名字</P>
</TD></TR><TR><TD><TT CLASS="PARAMETER">xpaths</TT></TD><TD>
<P>一个或多个XPath表达式，由<TT CLASS="LITERAL">|</TT>分隔</P>
</TD></TR><TR><TD><TT CLASS="PARAMETER">criteria</TT></TD><TD>
<P>WHERE子句的内容。这个不能省略，所以如果你想要在关系中处理所有的行，
那么使用<TT CLASS="LITERAL">true</TT>或<TT CLASS="LITERAL">1=1</TT></P>
</TD></TR></TBODY></TABLE></DIV><P>这些参数（除了XPath字符串）只是代替一个纯SQL SELECT语句，
所以你有一些灵活性&mdash;该语句是</P><P> <TT CLASS="LITERAL"> SELECT &lt;key&gt;, &lt;document&gt; FROM &lt;relation&gt; WHERE &lt;criteria&gt;
</TT>
</P><P>所以这些参数可以是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">任何</I></SPAN>在这些特定位置的有效值。
这个SELECT的结果需要返回正好两个字段（除非你尝试为key或document列出多个字段）。
注意这个简单的方法需要验证任何用户提供的值，以避免SQL注入攻击。</P><P>
该函数必须用于<TT CLASS="LITERAL">FROM</TT>表达式中，用一个<TT CLASS="LITERAL">AS</TT>子句指定输出字段；例如
</P><PRE CLASS="PROGRAMLISTING">SELECT * FROM
xpath_table('article_id',
            'article_xml',
            'articles',
            '/article/author|/article/pages|/article/title',
            'date_entered &#62; ''2003-01-01'' ')
AS t(article_id integer, author text, page_count integer, title text);</PRE><P>
<TT CLASS="LITERAL">AS</TT>子句定义输出表中字段的名字和类型。第一个是<SPAN CLASS="QUOTE">"key"</SPAN>字段，
剩余的对应于XPath查询。如果XPath查询多于结果字段，那么额外的查询将被忽略。
如果结果字段多于XPath查询，那么额外的字段将为空。
</P><P>请注意，这个示例定义<TT CLASS="STRUCTNAME">page_count</TT>的结果字段为一个整数。
该函数内部处理字符串的表示，所以当你说你在输出中想要一个整数时，
它将接收XPath结果的字符串表示，并使用PostgreSQL输入函数将它转换为一个整数
（或者任何<TT CLASS="TYPE">AS</TT>子句要求的类型）。如果它不能这么做则导致一个错误&mdash;
例如，如果结果为空&mdash;所以如果你认为你的数据有任何问题，
你可能想要坚持<TT CLASS="TYPE">text</TT>作为该字段的类型。</P><P>调用的<TT CLASS="COMMAND">SELECT</TT>语句不需要只是<TT CLASS="LITERAL">SELECT *</TT>&mdash;
它可以通过名字或链接输出字段到其他的表引用输出字段。
该函数产生一个虚拟表，用该虚拟表你可以执行任何你想要的操作
（例如，聚集、链接、排序等等）。所以我们也可以将：
</P><PRE CLASS="PROGRAMLISTING">SELECT t.title, p.fullname, p.email
FROM xpath_table('article_id', 'article_xml', 'articles',
                 '/article/title|/article/author/@id',
                 'xpath_string(article_xml,''/article/@date'') &#62; ''2003-03-20'' ')
       AS t(article_id integer, title text, author_id integer),
     tblPeopleInfo AS p
WHERE t.author_id = p.person_id;</PRE><P>
作为一个更复杂的示例。当然，为了方便，你可以将所有这些包装到一个视图中。
</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN151094">F.42.3.1. 多值的结果</A></H3><P><CODE CLASS="FUNCTION">xpath_table</CODE>函数假设每个XPath查询的结果可能是多值的，
所以该函数返回的行数可能和输入文档的行数不同。
返回的第一行包含每个查询的第一个结果，第二行包含每个查询的第二个结果。
如果其中的一个查询比其他查询的值少，那么将返回空值。</P><P>在某些情况下，用户知道一个给定的XPath查询将只返回一个结果（可能是一个唯一文档标识符）&mdash;
如果和返回多个结果的XPath查询一起使用，那么唯一值结果将只在结果的第一行出现。
这个问题的解决方法是使用该关键字段作为一个更简单的XPath查询连接的一部分。
示例：
</P><PRE CLASS="PROGRAMLISTING">CREATE TABLE test (
    id int PRIMARY KEY,
    xml text
);

INSERT INTO test VALUES (1, '&lt;doc num="C1"&gt;
&lt;line num="L1"&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;c&gt;3&lt;/c&gt;&lt;/line&gt;
&lt;line num="L2"&gt;&lt;a&gt;11&lt;/a&gt;&lt;b&gt;22&lt;/b&gt;&lt;c&gt;33&lt;/c&gt;&lt;/line&gt;
&lt;/doc&gt;');

INSERT INTO test VALUES (2, '&lt;doc num="C2"&gt;
&lt;line num="L1"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;
&lt;line num="L2"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;
&lt;/doc&gt;');

SELECT * FROM
  xpath_table('id','xml','test',
              '/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
              'true')
  AS t(id int, doc_num varchar(10), line_num varchar(10), val1 int, val2 int, val3 int)
WHERE id = 1 ORDER BY doc_num, line_num

 id | doc_num | line_num | val1 | val2 | val3
----+---------+----------+------+------+------
  1 | C1      | L1       |    1 |    2 |    3
  1 |         | L2       |   11 |   22 |   33</PRE><P>
</P><P>要在每个行上获得<TT CLASS="LITERAL">doc_num</TT>，解决方法是使用两个<CODE CLASS="FUNCTION">xpath_table</CODE>
的调用并连接结果：
</P><PRE CLASS="PROGRAMLISTING">SELECT t.*,i.doc_num FROM
  xpath_table('id', 'xml', 'test',
              '/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',
              'true')
    AS t(id int, line_num varchar(10), val1 int, val2 int, val3 int),
  xpath_table('id', 'xml', 'test', '/doc/@num', 'true')
    AS i(id int, doc_num varchar(10))
WHERE i.id=t.id AND i.id=1
ORDER BY doc_num, line_num;

 id | line_num | val1 | val2 | val3 | doc_num
----+----------+------+------+------+---------
  1 | L1       |    1 |    2 |    3 | C1
  1 | L2       |   11 |   22 |   33 | C1
(2 rows)</PRE><P>
</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN151104">F.42.4. XSLT 函数</A></H2><P>如果安装了libxslt，那么下列的函数是可用的：</P><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN151107">F.42.4.1. <TT CLASS="LITERAL">xslt_process</TT></A></H3><PRE CLASS="SYNOPSIS">xslt_process(text document, text stylesheet, text paramlist) returns text</PRE><P>这个函数应用XSL样式表到文档并返回转换了的结果。<TT CLASS="LITERAL">paramlist</TT>
是一个在转换中使用的参数分配列表，以格式<TT CLASS="LITERAL">a=1,b=2</TT>指定。
请注意，参数分析是非常简单的：参数值不能包含逗号！</P><P>也有一个两参数的<CODE CLASS="FUNCTION">xslt_process</CODE>版本，不传递任何参数到转换。</P></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN151118">F.42.5. 作者</A></H2><P> John Gray <CODE CLASS="EMAIL">&#60;<A HREF="mailto:jgray@azuli.co.uk">jgray@azuli.co.uk</A>&#62;</CODE>
</P><P>这个模块的发展是由Torchbox Ltd. (www.torchbox.com)赞助的。
它和PostgreSQL有一样的BSD许可证。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="uuid-ossp.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib-prog.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">uuid-ossp</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">额外提供的程序</TD></TR></TABLE></DIV></BODY></HTML>
