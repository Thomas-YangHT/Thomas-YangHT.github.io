<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>seg</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="postgres_fdw" HREF="postgres-fdw.html"><LINK REL="NEXT" TITLE="sepgsql" HREF="sepgsql.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/seg.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="postgres_fdw" HREF="postgres-fdw.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="sepgsql" HREF="sepgsql.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="SEG">F.32. seg</A></H1><P>
这个模块为定义线段和浮点类型的时间间隔提供了一种数据类型 <TT CLASS="TYPE">seg</TT>，
这种数据类型由于可以代表不确定终点的区间，所以在做实验测量的时候特别有用。
</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149738">F.32.1. 原理</A></H2><P>
几何学测量要比测量连续的点复杂的多，测量出的结果通常是一些模糊限制的连续值
组成的区间值。这种区间的产生可能是由于测量出结果的不确定性，随机性，也可能
要测量的值本身就是以区间的形式作为条件的，如测量蛋白质稳定性的温度范围。
</P><P>
一般来说，用这个数据类型存储区间值比用双引号更方便。实际上，在大部分的应用
中这么使用也更有效率。
</P><P>
进一步说，传统数值类型存储数据可能对一些模糊限制的值产生偏差，你获取的会
值是6.50并且存入数据库，当你读出的时候会是什么，看下面例子：
</P><PRE CLASS="SCREEN">test=&#62; select 6.50 :: float8 as "pH";
 pH
---
6.5
(1 row)</PRE><P>
在精确测量中，6.50和6.5代表的意思是不一样的，而且有时差异会很大。测量者
记下或者公布6.50代表了一个更大甚至更模糊的区间值，6.5只是代表了6.50的一
个中心点。像这种不同数据的同化表达是我们绝对不想看到的。
</P><P>
本章的特殊数据类型可以用来记录任意可变精度的间隔值，而且记录的每个数据都可以
使用自己的精度。
</P><P>
查看结果：
</P><PRE CLASS="SCREEN">test=&#62; select '6.25 .. 6.50'::seg as "pH";
          pH
------------
6.25 .. 6.50
(1 row)</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149747">F.32.2. 语法</A></H2><P>
使用一个或者二个精度数代表一个区间,连接格式（<TT CLASS="LITERAL">..</TT>或
<TT CLASS="LITERAL">...</TT>）。另外也可以用值和偏移符号表示（<TT CLASS="LITERAL">&lt;</TT>，
<TT CLASS="LITERAL">&gt;</TT> 或 <TT CLASS="LITERAL">~</TT>）。（正确的符号会被所有内建
的操作忽略。）表<A HREF="seg.html#SEG-REPR-TABLE">&#34920; F-24</A>和<A HREF="seg.html#SEG-INPUT-EXAMPLES">&#34920; F-25</A>
给出了区间表示的方法和一些例子。
</P><P>
在表<A HREF="seg.html#SEG-REPR-TABLE">&#34920; F-24</A>中 <TT CLASS="REPLACEABLE"><I>x</I></TT>, <TT CLASS="REPLACEABLE"><I>y</I></TT>和
<TT CLASS="REPLACEABLE"><I>delta</I></TT>代表双精度数。可以在<TT CLASS="REPLACEABLE"><I>x</I></TT>, <TT CLASS="REPLACEABLE"><I>y</I></TT>之前
添加正确的操作符。
</P><DIV CLASS="TABLE"><A NAME="SEG-REPR-TABLE"></A><P><B>&#34920; F-24. <TT CLASS="TYPE">seg</TT> External Representations</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><TBODY><TR><TD><TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>x</I></TT></TT></TD><TD>单个值（间隔为0）
</TD></TR><TR><TD><TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>x</I></TT> .. <TT CLASS="REPLACEABLE"><I>y</I></TT></TT></TD><TD>区间<TT CLASS="REPLACEABLE"><I>x</I></TT> 到 <TT CLASS="REPLACEABLE"><I>y</I></TT>
</TD></TR><TR><TD><TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>x</I></TT> (+-) <TT CLASS="REPLACEABLE"><I>delta</I></TT></TT></TD><TD>区间 <TT CLASS="REPLACEABLE"><I>x</I></TT> - <TT CLASS="REPLACEABLE"><I>delta</I></TT> to
<TT CLASS="REPLACEABLE"><I>x</I></TT> + <TT CLASS="REPLACEABLE"><I>delta</I></TT>
</TD></TR><TR><TD><TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>x</I></TT> ..</TT></TD><TD> <TT CLASS="REPLACEABLE"><I>x</I></TT>开区间无下限
</TD></TR><TR><TD><TT CLASS="LITERAL">.. <TT CLASS="REPLACEABLE"><I>x</I></TT></TT></TD><TD> <TT CLASS="REPLACEABLE"><I>x</I></TT>开区间无上限
</TD></TR></TBODY></TABLE></DIV><DIV CLASS="TABLE"><A NAME="SEG-INPUT-EXAMPLES"></A><P><B>&#34920; F-25. Examples of Valid <TT CLASS="TYPE">seg</TT> Input</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><TBODY><TR><TD><TT CLASS="LITERAL">5.0</TT></TD><TD>
零长度的区间（一个点）
</TD></TR><TR><TD><TT CLASS="LITERAL">~5.0</TT></TD><TD>
<TT CLASS="LITERAL">~</TT>作为一个标记存在，5.0的点和记录
</TD></TR><TR><TD><TT CLASS="LITERAL">&lt;5.0</TT></TD><TD>
<TT CLASS="LITERAL">&lt;</TT>作为一保留个标记存在，比点5.0小的
</TD></TR><TR><TD><TT CLASS="LITERAL">&gt;5.0</TT></TD><TD>
<TT CLASS="LITERAL">&gt;</TT>作为一个保留标记存在，比点5.0大的
</TD></TR><TR><TD><TT CLASS="LITERAL">5(+-)0.3</TT></TD><TD>
同区间 <TT CLASS="LITERAL">4.7 .. 5.3</TT>， <TT CLASS="LITERAL">(+-)</TT>不是保留标记
</TD></TR><TR><TD><TT CLASS="LITERAL">50 .. </TT></TD><TD> 区间大于50
</TD></TR><TR><TD><TT CLASS="LITERAL">.. 0</TT></TD><TD> 区间小于0
</TD></TR><TR><TD><TT CLASS="LITERAL">1.5e-2 .. 2E-2 </TT></TD><TD> 表示区间<TT CLASS="LITERAL">0.015 .. 0.02</TT>
</TD></TR><TR><TD><TT CLASS="LITERAL">1 ... 2</TT></TD><TD>
<TT CLASS="LITERAL">1...2</TT>,<TT CLASS="LITERAL">1 .. 2</TT>,<TT CLASS="LITERAL">1..2</TT>
表达区间相同（空格会被忽略）
</TD></TR></TBODY></TABLE></DIV><P>
在数据源中<TT CLASS="LITERAL">...</TT>被广泛使用，他的作用和另外一种拼写 <TT CLASS="LITERAL">..</TT>
相同。但这可能产生歧义如<TT CLASS="LITERAL">0...23</TT>是表示<TT CLASS="LITERAL">23</TT>还是<TT CLASS="LITERAL">0.23</TT>.
所以在 <TT CLASS="TYPE">seg</TT>数据类型中所有十进制小数的小数点前都需要有一个数字。
</P><P>
<TT CLASS="TYPE">seg</TT>不允许表示的区间由大到小表示，如 <TT CLASS="LITERAL">5 .. 2</TT>。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149864">F.32.3. 精度</A></H2><P>
<TT CLASS="TYPE">seg</TT>存储的值使用32-位的浮点数。精度不超过7位。
</P><P>
精度小于7位，保留本身的精度。换句话说如果你的返回值是0.00，那么这是数值本身带的精度
而不是格式化处理的。数值前的0不作为精度:值0.0067的精度被视为2。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149869">F.32.4. 使用</A></H2><P>
<TT CLASS="FILENAME"> seg</TT>模块包含可以在 GiST索引中操作 <TT CLASS="TYPE">seg</TT>数据类型值的类，该类支持表
<A HREF="seg.html#SEG-GIST-OPERATORS">&#34920; F-26</A>中的操作。
</P><DIV CLASS="TABLE"><A NAME="SEG-GIST-OPERATORS"></A><P><B>&#34920; F-26. Seg GiST Operators</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>操作</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">[a, b] &lt;&lt; [c, d]</TT></TD><TD> [a,b]的范围完全在[c,d]的左侧。换句话说，b &lt; c那么 [a,b] &lt;&lt; [c, d]
为真，否则为假。
</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] &gt;&gt; [c, d]</TT></TD><TD> [a,b]的范围全部在[c,d]的右侧。换句话说，a &gt; d那么 [a,b] &gt;&gt; [c, d]
为真，否则为假。
</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] &amp;&lt; [c, d]</TT></TD><TD> 左包含，或者解读为取值范围不超过右边，b &lt;= d时为真。
</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] &amp;&gt; [c, d]</TT></TD><TD> 右包含，或者解读为取值范围不超过左边，a &gt;= c时为真。
</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] = [c, d]</TT></TD><TD> [a, b]和[c, d]相同，当a=c并且b=d时为真。
</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] &amp;&amp; [c, d]</TT></TD><TD> [a, b]和[c, d]重叠部分
</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] @&gt; [c, d]</TT></TD><TD> [a, b]包含[c, d]，意味着 a &lt;= c并且 b &gt;= d。
</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] &lt;@ [c, d]</TT></TD><TD> [a, b]被[c, d]包含，意味着 a &gt;= c and b &lt;= d。
</TD></TR></TBODY></TABLE></DIV><P>
PostgresSQL 8.2之前的版本中，<TT CLASS="LITERAL">@&gt;</TT> 和<TT CLASS="LITERAL">&lt;@</TT>分别用<TT CLASS="LITERAL">@</TT>和<TT CLASS="LITERAL">~</TT>表示。
但那种表示方式会在将来完全被替代，所以不赞成使用。注意旧的名称会随着代表几何的数据类型转换为惯例的格式。
</P><P>
提供标准的B-tree操作，例如
<DIV CLASS="INFORMALTABLE"><P></P><A NAME="AEN149921"></A><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>操作</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">[a, b] &lt; [c, d]</TT></TD><TD>小于</TD></TR><TR><TD><TT CLASS="LITERAL">[a, b] &gt; [c, d]</TT></TD><TD>大于</TD></TR></TBODY></TABLE><P></P></DIV>
这些操作除了做排序以外没有别的用处，首先是(a)和(c)比较大小，如果
相等在比较(b)和(d)。如果使用这种类型排序，得到的的结果在大多数情
况下是合理的。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149936">F.32.5. 注意</A></H2><P>
使用例子，参看回归测试 <TT CLASS="FILENAME">sql/seg.sql</TT>。
</P><P>
使用 <TT CLASS="LITERAL">(+-)</TT>机制转换数字的时候可能得到不确定的精度。举个例子他可能
为较低的边界值增加额外的精度：
</P><PRE CLASS="SCREEN">postgres=&#62; select '10(+-)1'::seg as seg;
      seg
---------
9.0 .. 11             -- 应该为: 9 .. 11</PRE><P>
</P><P>
R-tree索引的性能很大程度上依赖初始输入值的排序。在输入表的<TT CLASS="TYPE">seg</TT>类型列
上排序可能是非常有效果的；参考脚本 <TT CLASS="FILENAME">sort-segments.pl</TT>。
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN149946">F.32.6. 感谢</A></H2><P>
原作者：Gene Selkov, Jr. <CODE CLASS="EMAIL">&#60;<A HREF="mailto:selkovjr@mcs.anl.gov">selkovjr@mcs.anl.gov</A>&#62;</CODE>，数学与计算机科学部，阿贡国家实验室。
</P><P>
感谢Joe Hellerstein教授 (<A HREF="http://db.cs.berkeley.edu/jmh/" TARGET="_top">http://db.cs.berkeley.edu/jmh/</A>)阐明的思想
(<A HREF="http://gist.cs.berkeley.edu/" TARGET="_top">http://gist.cs.berkeley.edu/</A>)。感谢所有 Postgres开发者，使我可以站在巨人的肩膀上。
感谢阿贡实验室和美国能源部多年的忠实支持我的数据库的研究。
</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="postgres-fdw.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sepgsql.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">postgres_fdw</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">sepgsql</TD></TR></TABLE></DIV></BODY></HTML>
