<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>各种函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="控制函数" HREF="libpq-control.html"><LINK REL="NEXT" TITLE="注意信息处理" HREF="libpq-notice-processing.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="控制函数" HREF="libpq-control.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="注意信息处理" HREF="libpq-notice-processing.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-MISC">31.11. 各种函数</A></H1><P>一如往常，也有一些函数，只是不是在任何地方都适合。</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQFREEMEM"></A><CODE CLASS="FUNCTION">PQfreemem</CODE>
</DT><DD><P>释放<SPAN CLASS="APPLICATION">libpq</SPAN>分配的内存。
</P><PRE CLASS="SYNOPSIS">void PQfreemem(void *ptr);</PRE><P>
</P><P>释放<SPAN CLASS="APPLICATION">libpq</SPAN>分配的内存，尤其是<CODE CLASS="FUNCTION">PQescapeByteaConn</CODE>，
<CODE CLASS="FUNCTION">PQescapeBytea</CODE>，<CODE CLASS="FUNCTION">PQunescapeBytea</CODE>和<CODE CLASS="FUNCTION">PQnotifies</CODE>。
尤其重要的是，在Windows系统上使用这个函数，而不是<CODE CLASS="FUNCTION">free()</CODE>。
这是因为只有DLL和应用程序的多线程/单线程，发布/调试，静态/动态标志是相同的时，
才在一个DLL中分配内存，并在应用程序工作时释放内存。在非Windows平台上，
这个函数与标准库函数<CODE CLASS="FUNCTION">free()</CODE>相同。</P></DD><DT><A NAME="LIBPQ-PQCONNINFOFREE"></A><CODE CLASS="FUNCTION">PQconninfoFree</CODE>
</DT><DD><P>释放<CODE CLASS="FUNCTION">PQconndefaults</CODE>或<CODE CLASS="FUNCTION">PQconninfoParse</CODE>分配的数据结构。
</P><PRE CLASS="SYNOPSIS">void PQconninfoFree(PQconninfoOption *connOptions);</PRE><P>
</P><P>一个简单的<CODE CLASS="FUNCTION">PQfreemem</CODE>不会这样做，因为数组包含对子字符串的引用。</P></DD><DT><A NAME="LIBPQ-PQENCRYPTPASSWORD"></A><CODE CLASS="FUNCTION">PQencryptPassword</CODE>
</DT><DD><P>准备一个<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>密码的加密形式：
</P><PRE CLASS="SYNOPSIS">char * PQencryptPassword(const char *passwd, const char *user);</PRE><P>
这个函数旨在用于那些发送类似于<TT CLASS="LITERAL">ALTER USER joe PASSWORD 'pwd'</TT>命令的客户端应用程序。
这是一个很好的方法，这种命令不发送原始的明文密码，因为它可能被暴露在命令日志，活动显示中等等。
相反，在发送前，使用这个函数可以将密码转换为加密的形式。参数是明文密码和用户的SQL名字。
返回值是<CODE CLASS="FUNCTION">malloc</CODE>分配的一个字符串，或超出内存时为<TT CLASS="SYMBOL">NULL</TT>。
调用可以认为字符串中不包含需要转义的特殊字符。当使用结束之后，用<CODE CLASS="FUNCTION">PQfreemem</CODE>进行释放。
</P></DD><DT><A NAME="LIBPQ-PQMAKEEMPTYPGRESULT"></A><CODE CLASS="FUNCTION">PQmakeEmptyPGresult</CODE>
</DT><DD><P>用给定的状态构造一个空<TT CLASS="STRUCTNAME">PGresult</TT>对象。
</P><PRE CLASS="SYNOPSIS">PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);</PRE><P>
</P><P>这是<SPAN CLASS="APPLICATION">libpq</SPAN>的内部函数，用于分配和初始化一个空<TT CLASS="STRUCTNAME">PGresult</TT>对象。
如果不能分配内存，那么这个函数返回<TT CLASS="SYMBOL">NULL</TT>。这是输出，
因为一些应用程序发现它可以有效的生成结果对象本身（特别是带有错误状态的对象）。
如果<TT CLASS="PARAMETER">conn</TT>非空，并且<TT CLASS="PARAMETER">status</TT>用于表示一个错误，
那么指定连接的当前错误信息被复制到<TT CLASS="STRUCTNAME">PGresult</TT>中。同时，
如果<TT CLASS="PARAMETER">conn</TT>非空，那么连接中的任何事件过程会被复制到
<TT CLASS="STRUCTNAME">PGresult</TT>中。（它们不会获得<TT CLASS="LITERAL">PGEVT_RESULTCREATE</TT>请求，
但会看到<CODE CLASS="FUNCTION">PQfireResultCreateEvents</CODE>）。需要注意的是随着<SPAN CLASS="APPLICATION">libpq</SPAN>
本身返回<TT CLASS="STRUCTNAME">PGresult</TT>时，对象最后应该请求<CODE CLASS="FUNCTION">PQclear</CODE>。</P></DD><DT><A NAME="LIBPQ-PQFIRERESULTCREATEEVENTS"></A><CODE CLASS="FUNCTION">PQfireResultCreateEvents</CODE>
</DT><DD><P>为<TT CLASS="STRUCTNAME">PGresult</TT>对象中的每个事件过程触发一个<TT CLASS="LITERAL">PGEVT_RESULTCREATE</TT>事件
（参阅<A HREF="libpq-events.html">第 31.13 &#33410;</A>）。成功时返回非0，如果任何事件过程失败返回0。
</P><PRE CLASS="SYNOPSIS">int PQfireResultCreateEvents(PGconn *conn, PGresult *res);</PRE><P>
</P><P><TT CLASS="LITERAL">conn</TT>被传送给事件过程，但不会被直接使用。如果事件过程不使用它，则会返回<TT CLASS="SYMBOL">NULL</TT>。</P><P>已经接收到这个对象的<TT CLASS="LITERAL">PGEVT_RESULTCREATE</TT>或<TT CLASS="LITERAL">PGEVT_RESULTCOPY</TT>
事件的事件过程不会被再次触发。</P><P>这个函数与<CODE CLASS="FUNCTION">PQmakeEmptyPGResult</CODE>分开的主要原因是它经常创建一个
<TT CLASS="STRUCTNAME">PGresult</TT>，并且在调用事件过程之前就用数据对其进行填充。</P></DD><DT><A NAME="LIBPQ-PQCOPYRESULT"></A><CODE CLASS="FUNCTION">PQcopyResult</CODE>
</DT><DD><P>完成一个<TT CLASS="STRUCTNAME">PGresult</TT>对象的拷贝。这个拷贝不会以任何方式来连接到资源结果，
并且当该拷贝不再需要时，需要调用<CODE CLASS="FUNCTION">PQclear</CODE>进行清理。如果函数失败，返回<TT CLASS="SYMBOL">NULL</TT>。
</P><PRE CLASS="SYNOPSIS">PGresult *PQcopyResult(const PGresult *src, int flags);</PRE><P>
</P><P>不会制作一个明确的拷贝。返回的结果通常会是<TT CLASS="LITERAL">PGRES_TUPLES_OK</TT>状态，
并且不会拷贝资源中的错误信息，然而会拷贝命令状态字符串。<TT CLASS="PARAMETER">flags</TT>
决定其他需要拷贝的。通常是几个<TT CLASS="LITERAL">PG_COPYRES_ATTRS</TT>的按位或。
<TT CLASS="LITERAL">PG_COPYRES_ATTRS</TT>声明复制源结果的属性（列定义）。
<TT CLASS="LITERAL">PG_COPYRES_TUPLES</TT>声明复制源结果的元组（这意味着也复制属性）。
<TT CLASS="LITERAL">PG_COPYRES_NOTICEHOOKS</TT>声明复制源结果的通知陷阱。
<TT CLASS="LITERAL">PG_COPYRES_EVENTS</TT>声明负值源结果的事件。（但任何与源关联的实例数据不会被复制。）</P></DD><DT><A NAME="LIBPQ-PQSETRESULTATTRS"></A><CODE CLASS="FUNCTION">PQsetResultAttrs</CODE>
</DT><DD><P>设置<TT CLASS="STRUCTNAME">PGresult</TT>对象的属性。
</P><PRE CLASS="SYNOPSIS">int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);</PRE><P>
</P><P>提供的<TT CLASS="PARAMETER">attDescs</TT>被复制到结果中。如果<TT CLASS="PARAMETER">attDescs</TT>
指针为<TT CLASS="SYMBOL">NULL</TT>，或<TT CLASS="PARAMETER">numAttributes</TT>小于1，那么请求将被忽略，
并且函数成功。如果<TT CLASS="PARAMETER">res</TT>已经有了属性，那么函数会失败。如果函数失败，
会返回0。如果函数成功，会返回非0。</P></DD><DT><A NAME="LIBPQ-PQSETVALUE"></A><CODE CLASS="FUNCTION">PQsetvalue</CODE>
</DT><DD><P>设置<TT CLASS="STRUCTNAME">PGresult</TT>对象的元组字段值。
</P><PRE CLASS="SYNOPSIS">int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);</PRE><P>
</P><P>这个函数会自动按需增加结果的内置元组。然而，<TT CLASS="PARAMETER">tup_num</TT>
参数必须小于等于<CODE CLASS="FUNCTION">PQntuples</CODE>，意味着这个函数一次只能增加一个元组。
但已存在的任意的元组中的任意字段可以以任意顺序进行调整。如果<TT CLASS="PARAMETER">field_num</TT>
中的一个值已经存在，会被覆盖重写。如果<TT CLASS="PARAMETER">len</TT>是-1，或<TT CLASS="PARAMETER">value</TT>
是<TT CLASS="SYMBOL">NULL</TT>，字段值会被设置为一个SQL空值。<TT CLASS="PARAMETER">value</TT>
被复制到结果的私有存储中，因此函数返回结果后就不再需要了。如果函数失败，会返回0。
如果函数成功，会返回非0。</P></DD><DT><A NAME="LIBPQ-PQRESULTALLOC"></A><CODE CLASS="FUNCTION">PQresultAlloc</CODE>
</DT><DD><P>为<TT CLASS="STRUCTNAME">PGresult</TT>对象分配子存储。
</P><PRE CLASS="SYNOPSIS">void *PQresultAlloc(PGresult *res, size_t nBytes);</PRE><P>
</P><P>当<TT CLASS="PARAMETER">res</TT>被清理时，该函数分配的内存也会被释放掉。如果函数失败，
返回<TT CLASS="SYMBOL">NULL</TT>。结果是保证任何类型的数据能够充分对齐，如同对<CODE CLASS="FUNCTION">malloc</CODE>一样。</P></DD><DT><A NAME="LIBPQ-PQLIBVERSION"></A><CODE CLASS="FUNCTION">PQlibVersion</CODE>
</DT><DD><P>返回正在使用的<SPAN CLASS="PRODUCTNAME">libpq</SPAN>的版本。
</P><PRE CLASS="SYNOPSIS">int PQlibVersion(void);</PRE><P>
</P><P>如果特定的功能在libpq当前加载的版本中可用，那么用于决定运行时此函数的结果。
该函数可以使用，比如，用来确定可用于<CODE CLASS="FUNCTION">PQconnectdb</CODE>的连接选项，
或者是否支持PostgreSQL 9.0中添加的<TT CLASS="LITERAL">hex</TT> <TT CLASS="TYPE">bytea</TT>输出。</P><P>数字是通过把主、次及版本号转换成两位十进制数并且把它们连接在一起组成的。例如，
版本9.1将被返回901000，版本9.1.2将被返回90102（前导零没有显示）。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>这个函数是在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>版本9.1中出现的，所以它不能用来在较早的版本中检测所需功能，
因此连接它将在版本9.1上创建一个连接依赖。</P></BLOCKQUOTE></DIV></DD></DL></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-control.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-notice-processing.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">控制函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">注意信息处理</TD></TR></TABLE></DIV></BODY></HTML>
