<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>pgbench</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="客户端应用程序" HREF="contrib-prog-client.html"><LINK REL="PREVIOUS" TITLE="oid2name" HREF="oid2name.html"><LINK REL="NEXT" TITLE="vacuumlo" HREF="vacuumlo.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/pgbench.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="oid2name" HREF="oid2name.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="contrib-prog-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="vacuumlo" HREF="vacuumlo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="PGBENCH"></A><SPAN CLASS="APPLICATION">pgbench</SPAN></H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN151309"></A><H2>&#21517;&#31216;</H2>pgbench&nbsp;--&nbsp;在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>上运行一个基准测试</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN151315"></A><H2>&#22823;&#32434;</H2><P><TT CLASS="COMMAND">pgbench</TT> <TT CLASS="OPTION">-i</TT> [<TT CLASS="REPLACEABLE"><I>option</I></TT>...] [<TT CLASS="REPLACEABLE"><I>dbname</I></TT>]</P><P><TT CLASS="COMMAND">pgbench</TT> [<TT CLASS="REPLACEABLE"><I>option</I></TT>...] [<TT CLASS="REPLACEABLE"><I>dbname</I></TT>]</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN151330"></A><H2>描述</H2><P><SPAN CLASS="APPLICATION">pgbench</SPAN>是在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>上运行基准测试的简单程序。
它一遍一遍的运行SQL命令的相同序列，可能是在多个并行的数据库会话上，
然后计算平均事务率（每秒钟事务数）。默认的，<SPAN CLASS="APPLICATION">pgbench</SPAN>
测试基于TPC-B的宽松的情节，每个事务包括5个<TT CLASS="COMMAND">SELECT</TT>、<TT CLASS="COMMAND">UPDATE</TT>
和<TT CLASS="COMMAND">INSERT</TT>命令。不过，通过写你自己的事务脚本文件，可以很容易的测试其他情况。</P><P>
通常来自pgbench的输出看起来像：
</P><PRE CLASS="SCREEN">transaction type: TPC-B (sort of)
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)</PRE><P>
前六行报告了一些比较重要的参数设置。下一行报告了事务完成/打算的数量
（后者正好是客户端数量和每客户端的事务数量的乘积）；
它们将是相等的，除非运行在完成之前失败。（在<TT CLASS="OPTION">-T</TT>模式，
只打印事务的实际数量。）最后两行报告了每秒的事务数量，
计算和不计算启动数据库会话的时间。
</P><P>缺省TPC-B风格的事务测试需要事先设置好特定的表。<SPAN CLASS="APPLICATION">pgbench</SPAN>
应该使用<TT CLASS="OPTION">-i</TT>（初始化）选项调用，以创建和填充这些表。
（当你在测试一个自定义的脚本时，不需要这个步骤，但是需要做你的测试需要的步骤。）
初始化看起来像这样：
</P><PRE CLASS="PROGRAMLISTING">pgbench -i [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>other-options</I
></TT
> </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>dbname</I></TT>是早已创建的要测试的数据库的名字。
（可能也需要<TT CLASS="OPTION">-h</TT>、<TT CLASS="OPTION">-p</TT>和/或<TT CLASS="OPTION">-U</TT>
选项来指定如何连接到数据库服务器。）
</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P><TT CLASS="LITERAL">pgbench -i</TT>创建四个表<TT CLASS="STRUCTNAME">pgbench_accounts</TT>、
<TT CLASS="STRUCTNAME">pgbench_branches</TT>、<TT CLASS="STRUCTNAME">pgbench_history</TT>
和<TT CLASS="STRUCTNAME">pgbench_tellers</TT>，销毁任何已存在的同名的表。
如果你有这些名字的表，要非常小心的使用另外一个数据库。</P></TD></TR></TABLE></DIV><P>缺省<SPAN CLASS="QUOTE">"比例因子"</SPAN>为1，表最初包含这些行：
</P><PRE CLASS="SCREEN">table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0</PRE><P>
你可以（对于大多数目的，可能应该）使用<TT CLASS="OPTION">-s</TT>（比例因子）选项增加行数。
<TT CLASS="OPTION">-F</TT>（填充因子）选项也可以用于这点。
</P><P>一旦你完成了必要的步骤，你可以用一个不包含<TT CLASS="OPTION">-i</TT>
的命令运行你的benchmark，也就是
</P><PRE CLASS="PROGRAMLISTING">pgbench [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
> </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE><P>
在几乎所有情况下，你都将需要一些选项来做一个有用的测试。
最重要的选项是<TT CLASS="OPTION">-c</TT>（客户端的数量）、<TT CLASS="OPTION">-t</TT>（事务的数量）、
<TT CLASS="OPTION">-T</TT>（时间限制）和<TT CLASS="OPTION">-f</TT>（声明一个自定义的脚本文件）。
见下文的完整列表。
</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN151375"></A><H2>选项</H2><P>下面分成了三个章节：不同的选项在数据库初始化和运行benchmark时使用，
有些选项在两种情况下都使用。</P><DIV CLASS="REFSECT2"><A NAME="PGBENCH-INIT-OPTIONS"></A><H3>初始化选项</H3><P><SPAN CLASS="APPLICATION">pgbench</SPAN>接受下列的命令行初始化参数：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-i</TT></DT><DD><P>要求调用初始化模式。</P></DD><DT><TT CLASS="OPTION">-F</TT> <TT CLASS="REPLACEABLE"><I>fillfactor</I></TT></DT><DD><P>用给定的填充因子创建<TT CLASS="STRUCTNAME">pgbench_accounts</TT>、<TT CLASS="STRUCTNAME">pgbench_tellers</TT>
和<TT CLASS="STRUCTNAME">pgbench_branches</TT>表。缺省是100。</P></DD><DT><TT CLASS="OPTION">-n</TT></DT><DD><P>在初始化之后不执行清理。</P></DD><DT><TT CLASS="OPTION">-q</TT></DT><DD><P>日志切换到安静模式，每5秒钟只产生一条进度信息。缺省的日志输出是每100000行一条信息，
通常每秒输出多行（特别是在好的硬件上）。</P></DD><DT><TT CLASS="OPTION">-s</TT> <TT CLASS="REPLACEABLE"><I>scale_factor</I></TT></DT><DD><P>乘以比例因子生成的行数。例如，<TT CLASS="LITERAL">-s 100</TT>将在
<TT CLASS="STRUCTNAME">pgbench_accounts</TT>表中创建10,000,000行。缺省是1。
当比例是20,000或更大时，用于保存计数标识符的字段（<TT CLASS="STRUCTFIELD">aid</TT>字段）
将切换到使用更大的整数(<TT CLASS="TYPE">bigint</TT>)，以足够保存计数标识符的范围。</P></DD><DT><TT CLASS="OPTION">--foreign-keys</TT></DT><DD><P>在标准表之间创建外键约束。</P></DD><DT><TT CLASS="OPTION">--index-tablespace=<TT CLASS="REPLACEABLE"><I>index_tablespace</I></TT></TT></DT><DD><P>在指定的表空间中创建索引，而不是在缺省的表空间中。</P></DD><DT><TT CLASS="OPTION">--tablespace=<TT CLASS="REPLACEABLE"><I>tablespace</I></TT></TT></DT><DD><P>在指定的表空间中创建表，而不是在缺省的表空间中。</P></DD><DT><TT CLASS="OPTION">--unlogged-tables</TT></DT><DD><P>创建所有的表为unlogged表，而不是永久表。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT2"><A NAME="PGBENCH-RUN-OPTIONS"></A><H3>基准选项</H3><P><SPAN CLASS="APPLICATION">pgbench</SPAN>接受下列的命令行基准参数：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-c</TT> <TT CLASS="REPLACEABLE"><I>clients</I></TT></DT><DD><P>模拟客户端的数量，也就是并发数据库会话的数量。缺省是1。</P></DD><DT><TT CLASS="OPTION">-C</TT></DT><DD><P>为每个事务建立一个新的连接，而不是每客户端会话只执行一次。
这对于测量连接开销是有用的。</P></DD><DT><TT CLASS="OPTION">-d</TT></DT><DD><P>打印调试输出。</P></DD><DT><TT CLASS="OPTION">-D</TT> <TT CLASS="REPLACEABLE"><I>varname</I></TT><TT CLASS="LITERAL">=</TT><TT CLASS="REPLACEABLE"><I>value</I></TT></DT><DD><P>定义一个自定义脚本使用的变量（见下文）。允许使用多个<TT CLASS="OPTION">-D</TT>选项。</P></DD><DT><TT CLASS="OPTION">-f</TT> <TT CLASS="REPLACEABLE"><I>filename</I></TT></DT><DD><P>从<TT CLASS="REPLACEABLE"><I>filename</I></TT>中读取事务脚本。见下文获取细节。
<TT CLASS="OPTION">-N</TT>、<TT CLASS="OPTION">-S</TT>、和<TT CLASS="OPTION">-f</TT>是互相排斥的。</P></DD><DT><TT CLASS="OPTION">-j</TT> <TT CLASS="REPLACEABLE"><I>threads</I></TT></DT><DD><P><SPAN CLASS="APPLICATION">pgbench</SPAN>中工作线程的数量。在多CPU的机器上使用多个线程会很有帮助。
客户端的数量必须是线程数量的倍数，因为每个线程都有相同数量的客户端会话管理。
缺省是1。</P></DD><DT><TT CLASS="OPTION">-l</TT></DT><DD><P>记录每个事务写入日志文件的时间。见下文获取细节。</P></DD><DT><TT CLASS="OPTION">-M</TT> <TT CLASS="REPLACEABLE"><I>querymode</I></TT></DT><DD><P>
提交查询到服务器使用的协议：
<P></P></P><UL><LI><P><TT CLASS="LITERAL">simple</TT>：使用简单的查询协议。</P></LI><LI><P><TT CLASS="LITERAL">extended</TT>：使用扩展的查询协议。</P></LI><LI><P><TT CLASS="LITERAL">prepared</TT>：使用带有预备语句的扩展查询协议。</P></LI></UL><P>
缺省是简单的查询协议。（参阅<A HREF="http://school.yunwei.edu/manual/PostgreSQL/protocol.html">第 48 &#31456;</A>获取更多信息。）
</P></DD><DT><TT CLASS="OPTION">-n</TT></DT><DD><P>运行测试时不执行清理。如果你正在运行一个不包含标准表<TT CLASS="STRUCTNAME">pgbench_accounts</TT>、
<TT CLASS="STRUCTNAME">pgbench_branches</TT>、<TT CLASS="STRUCTNAME">pgbench_history</TT>、和
<TT CLASS="STRUCTNAME">pgbench_tellers</TT>的自定义测试，那么该选项是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必需的</I></SPAN>。</P></DD><DT><TT CLASS="OPTION">-N</TT></DT><DD><P>不要更新<TT CLASS="STRUCTNAME">pgbench_tellers</TT>和<TT CLASS="STRUCTNAME">pgbench_branches</TT>。
这将避免争用这些表，但是它使得测试用例更不像TPC-B。</P></DD><DT><TT CLASS="OPTION">-r</TT></DT><DD><P>在benchmark完成后报告每个命令的平均每语句延迟（从客户的角度看的执行时间）。
见下文获取细节。</P></DD><DT><TT CLASS="OPTION">-s</TT> <TT CLASS="REPLACEABLE"><I>scale_factor</I></TT></DT><DD><P>在<SPAN CLASS="APPLICATION">pgbench</SPAN>的输出中报告指定的比例因子。在内建的测试中，这不是必需的；
正确的比例因子将通过计数<TT CLASS="STRUCTNAME">pgbench_branches</TT>表中的行数检测到。
不过，在测试自定义benchmark(<TT CLASS="OPTION">-f</TT>选项)时，比例因子将报告为1，除非使用了该选项。</P></DD><DT><TT CLASS="OPTION">-S</TT></DT><DD><P>执行只有select的事务，替代类似TPC-B的测试。</P></DD><DT><TT CLASS="OPTION">-t</TT> <TT CLASS="REPLACEABLE"><I>transactions</I></TT></DT><DD><P>每个客户端运行的事务数量。缺省是10。</P></DD><DT><TT CLASS="OPTION">-T</TT> <TT CLASS="REPLACEABLE"><I>seconds</I></TT></DT><DD><P>运行测试这么多秒，而不是每客户端固定数量的事务。<TT CLASS="OPTION">-t</TT>
和<TT CLASS="OPTION">-T</TT>是互相排斥的。</P></DD><DT><TT CLASS="OPTION">-v</TT></DT><DD><P>在运行测试之前清理四个标准表。既不用<TT CLASS="OPTION">-n</TT>也不用<TT CLASS="OPTION">-v</TT>，
pgbench将清理<TT CLASS="STRUCTNAME">pgbench_tellers</TT>和<TT CLASS="STRUCTNAME">pgbench_branches</TT>表，
截断<TT CLASS="STRUCTNAME">pgbench_history</TT>表。</P></DD><DT><TT CLASS="OPTION">--aggregate-interval=<TT CLASS="REPLACEABLE"><I>seconds</I></TT></TT></DT><DD><P>汇总时间间隔的长度（以秒计）。可能只与<SPAN CLASS="APPLICATION">-l</SPAN>选项一起使用，
日志包含每间隔的总结（事务的数量、最小/最大延迟和可用于方差估计的两个额外字段）。</P><P>目前在Windows上不支持这个选项。</P></DD><DT><TT CLASS="OPTION">--sampling-rate=<TT CLASS="REPLACEABLE"><I>rate</I></TT></TT></DT><DD><P>采样率，在写入数据到日志时使用，以减少生成日志的数量。如果给出了这个选项，
则只记录指定比例的事务。1.0意味着记录所有事务，0.05意味着只记录了5%的事务。</P><P>在处理日志文件时记得计算上采样率。例如，计算tps值时，需要乘以相应的数字
（比如，0.01的采样率，将只得到1/100的实际tps）。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="REFSECT2"><A NAME="PGBENCH-COMMON-OPTIONS"></A><H3>公共选项</H3><P><SPAN CLASS="APPLICATION">pgbench</SPAN>接受下列的命令行公共参数：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="OPTION">-h</TT> <TT CLASS="REPLACEABLE"><I>hostname</I></TT></DT><DD><P>数据库服务器的主机名</P></DD><DT><TT CLASS="OPTION">-p</TT> <TT CLASS="REPLACEABLE"><I>port</I></TT></DT><DD><P>数据库服务器的端口号</P></DD><DT><TT CLASS="OPTION">-U</TT> <TT CLASS="REPLACEABLE"><I>login</I></TT></DT><DD><P>要连接的用户名</P></DD><DT><TT CLASS="OPTION">-V</TT><BR><TT CLASS="OPTION">--version</TT></DT><DD><P>打印<SPAN CLASS="APPLICATION">pgbench</SPAN>的版本并退出。</P></DD><DT><TT CLASS="OPTION">-?</TT><BR><TT CLASS="OPTION">--help</TT></DT><DD><P>显示关于<SPAN CLASS="APPLICATION">pgbench</SPAN>命令行参数的帮助并退出。</P></DD></DL></DIV><P>
</P></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN151622"></A><H2>注意</H2><DIV CLASS="REFSECT2"><A NAME="AEN151624"></A><H3>什么是在pgbench上实际执行的<SPAN CLASS="QUOTE">"事务"</SPAN>？</H3><P>缺省的事务脚本每事务发出7个命令：</P><P></P><OL TYPE="1"><LI><P><TT CLASS="LITERAL">BEGIN;</TT></P></LI><LI><P><TT CLASS="LITERAL">UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</TT></P></LI><LI><P><TT CLASS="LITERAL">SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</TT></P></LI><LI><P><TT CLASS="LITERAL">UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</TT></P></LI><LI><P><TT CLASS="LITERAL">UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</TT></P></LI><LI><P><TT CLASS="LITERAL">INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</TT></P></LI><LI><P><TT CLASS="LITERAL">END;</TT></P></LI></OL><P>如果你声明了<TT CLASS="OPTION">-N</TT>，那么不包含步骤4和5。如果你声明了<TT CLASS="OPTION">-S</TT>，
那么只发出<TT CLASS="COMMAND">SELECT</TT>。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN151654"></A><H3>自定义脚本</H3><P><SPAN CLASS="APPLICATION">pgbench</SPAN>支持运行自定义的benchmark脚本，
通过使用从文件中读取的事务脚本(<TT CLASS="OPTION">-f</TT>选项)
替换缺省的事务脚本（上面描述了）。在这种情况下，一个<SPAN CLASS="QUOTE">"事务"</SPAN>
被认为是一个脚本文件的一次执行。你可以声明多个脚本（多个<TT CLASS="OPTION">-f</TT>选项），
在这种情况下，每次客户端会话启动一个新的事务时随机选择一个脚本。</P><P>脚本文件的格式是每行一个SQL命令；不支持一行多个SQL命令。
忽略空行和以<TT CLASS="LITERAL">--</TT>开始的行。脚本文件行也可以是<SPAN CLASS="QUOTE">"元命令"</SPAN>，
被<SPAN CLASS="APPLICATION">pgbench</SPAN>本身解读，就像下面描述的那样。</P><P>脚本文件有一个简单的变量替换设施。变量可以通过命令行<TT CLASS="OPTION">-D</TT>选项设置，
在上文中解释了，或者通过上文解释的元命令设置。除了预先通过<TT CLASS="OPTION">-D</TT>
命令行选项设置的任何变量外，变量<TT CLASS="LITERAL">scale</TT>是为当前比例因子预设的。
一旦设置，变量的值可以通过书写<TT CLASS="LITERAL">:</TT><TT CLASS="REPLACEABLE"><I>variablename</I></TT>
插入到SQL命令中。当运行多于一个客户端会话时，每个会话都有它自己的变量设置。</P><P>脚本文件元命令以反斜杠(<TT CLASS="LITERAL">\</TT>)开始。元命令的参数通过空格分隔开。
支持这些元命令：</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">\set <TT CLASS="REPLACEABLE"><I>varname</I></TT> <TT CLASS="REPLACEABLE"><I>operand1</I></TT> [ <TT CLASS="REPLACEABLE"><I>operator</I></TT> <TT CLASS="REPLACEABLE"><I>operand2</I></TT> ]</TT></DT><DD><P>设置变量<TT CLASS="REPLACEABLE"><I>varname</I></TT>为一个经过计算的整数值。
每个<TT CLASS="REPLACEABLE"><I>operand</I></TT>是一个整数常量或者一个<TT CLASS="LITERAL">:</TT><TT CLASS="REPLACEABLE"><I>variablename</I></TT>
到一个有整数值的变量的引用。<TT CLASS="REPLACEABLE"><I>operator</I></TT>可以是
<TT CLASS="LITERAL">+</TT>, <TT CLASS="LITERAL">-</TT>, <TT CLASS="LITERAL">*</TT>, 或 <TT CLASS="LITERAL">/</TT>。</P><P>例子：
</P><PRE CLASS="PROGRAMLISTING">\set ntellers 10 * :scale</PRE><P></P></DD><DT><TT CLASS="LITERAL">\setrandom <TT CLASS="REPLACEABLE"><I>varname</I></TT> <TT CLASS="REPLACEABLE"><I>min</I></TT> <TT CLASS="REPLACEABLE"><I>max</I></TT></TT></DT><DD><P>设置变量<TT CLASS="REPLACEABLE"><I>varname</I></TT>为范围<TT CLASS="REPLACEABLE"><I>min</I></TT>到<TT CLASS="REPLACEABLE"><I>max</I></TT>
（包含）之间的随机整数值。每个限制可以是一个整数常量或者一个
<TT CLASS="LITERAL">:</TT><TT CLASS="REPLACEABLE"><I>variablename</I></TT>到一个有整数值的变量的引用。</P><P>例子：
</P><PRE CLASS="PROGRAMLISTING">\setrandom aid 1 :naccounts</PRE><P></P></DD><DT><TT CLASS="LITERAL">\sleep <TT CLASS="REPLACEABLE"><I>number</I></TT> [ us | ms | s ]</TT></DT><DD><P>导致脚本执行睡眠指定的持续时间，单位是微妙(<TT CLASS="LITERAL">us</TT>)、毫秒(<TT CLASS="LITERAL">ms</TT>)
或秒(<TT CLASS="LITERAL">s</TT>)。如果省略了单位，则缺省是秒。<TT CLASS="REPLACEABLE"><I>number</I></TT>
可以是一个整数常量或者一个<TT CLASS="LITERAL">:</TT><TT CLASS="REPLACEABLE"><I>variablename</I></TT>
到一个有整数值的变量的引用。</P><P>例子：
</P><PRE CLASS="PROGRAMLISTING">\sleep 10 ms</PRE><P></P></DD><DT><TT CLASS="LITERAL">\setshell <TT CLASS="REPLACEABLE"><I>varname</I></TT> <TT CLASS="REPLACEABLE"><I>command</I></TT> [ <TT CLASS="REPLACEABLE"><I>argument</I></TT> ... ]</TT></DT><DD><P>设置变量<TT CLASS="REPLACEABLE"><I>varname</I></TT>为shell命令<TT CLASS="REPLACEABLE"><I>command</I></TT>的结果。
该命令必须通过它的标准输出返回一个整数值。</P><P><TT CLASS="REPLACEABLE"><I>argument</I></TT>可以是一个文本常量或者一个<TT CLASS="LITERAL">:</TT><TT CLASS="REPLACEABLE"><I>variablename</I></TT>
到一个任何类型的变量的引用。如果你想要使用以冒号开始的<TT CLASS="REPLACEABLE"><I>argument</I></TT>，
你需要在<TT CLASS="REPLACEABLE"><I>argument</I></TT>的开始添加一个额外的冒号。</P><P>例子：
</P><PRE CLASS="PROGRAMLISTING">\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon</PRE><P></P></DD><DT><TT CLASS="LITERAL">\shell <TT CLASS="REPLACEABLE"><I>command</I></TT> [ <TT CLASS="REPLACEABLE"><I>argument</I></TT> ... ]</TT></DT><DD><P>和<TT CLASS="LITERAL">\setshell</TT>相同，但是忽略结果。</P><P>例子：
</P><PRE CLASS="PROGRAMLISTING">\shell command literal_argument :variable ::literal_starting_with_colon</PRE><P></P></DD></DL></DIV><P>作为一个示例，内建的类TPC-B的事务的全部定义是：
</P><PRE CLASS="PROGRAMLISTING">\set nbranches :scale
\set ntellers 10 * :scale
\set naccounts 100000 * :scale
\setrandom aid 1 :naccounts
\setrandom bid 1 :nbranches
\setrandom tid 1 :ntellers
\setrandom delta -5000 5000
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;</PRE><P>
这个脚本允许事务的每次迭代的引用不同，随机选取行。
这个示例也显示了为什么每个客户端会话有它自己的变量是重要的 &mdash;
否则它们不能独立的访问不同的行。
</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN151753"></A><H3>每事务的日志</H3><P>带有<TT CLASS="OPTION">-l</TT>选项，但是不带有<TT CLASS="OPTION">--aggregate-interval</TT>，
<SPAN CLASS="APPLICATION">pgbench</SPAN>将每个事务花费的时间写入到日志文件中。
日志文件将命名为<TT CLASS="FILENAME">pgbench_log.<TT CLASS="REPLACEABLE"><I>nnn</I></TT></TT>，
这里的<TT CLASS="REPLACEABLE"><I>nnn</I></TT>是pgbench进程的PID。如果<TT CLASS="OPTION">-j</TT>
选项是2或更高，则创建多个工作线程，每个都将拥有它自己的日志文件。
第一个工作线程的日志文件名字和标准的单个工作线程情况相同。
其他工作线程的日志文件将命名为<TT CLASS="FILENAME">pgbench_log.<TT CLASS="REPLACEABLE"><I>nnn</I></TT>.<TT CLASS="REPLACEABLE"><I>mmm</I></TT></TT>，
这里的<TT CLASS="REPLACEABLE"><I>mmm</I></TT>是每个工作线程的序列号，起始值为1。</P><P>日志格式是：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>client_id</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>transaction_no</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>file_no</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time_epoch</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time_us</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>time</I></TT>是事务运行的总时间，以毫秒计，
<TT CLASS="REPLACEABLE"><I>file_no</I></TT>标识出使用哪个脚本文件（在使用<TT CLASS="OPTION">-f</TT>
声明了多个脚本时有用），<TT CLASS="REPLACEABLE"><I>time_epoch</I></TT>/<TT CLASS="REPLACEABLE"><I>time_us</I></TT>
是一个UNIX纪元格式的时间戳和以毫秒计的时间偏移（适用于创建一个以分数计的ISO 8601的时间戳），
显示事务是何时完成的。</P><P>这里是示例输出：
</P><PRE CLASS="SCREEN"> 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663</PRE><P></P><P>在可以处理大量事务的硬件上运行一个长文本时，日志文件会变得非常大。
<TT CLASS="OPTION">--sampling-rate</TT>选项可以用来只记录一个随机的事务样本。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN151784"></A><H3>聚合的日志</H3><P>带有<TT CLASS="OPTION">--aggregate-interval</TT>选项，日志会使用一个稍微不同的格式：
</P><PRE CLASS="SYNOPSIS"><TT
CLASS="REPLACEABLE"
><I
>interval_start</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>num_of_transactions</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>latency_sum</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>latency_2_sum</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>min_latency</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>max_latency</I
></TT
></PRE><P>
这里的<TT CLASS="REPLACEABLE"><I>interval_start</I></TT>是间隔的开始（UNIX纪元格式的时间戳），
<TT CLASS="REPLACEABLE"><I>num_of_transactions</I></TT>是间隔内事务的数量，<TT CLASS="REPLACEABLE"><I>latency_sum</I></TT>
是延迟的总和（这样你可以非常容易的计算平均延迟）。下列的两个字段对于方差估计是有帮助的-
<TT CLASS="REPLACEABLE"><I>latency_sum</I></TT>是延迟的总和，<TT CLASS="REPLACEABLE"><I>latency_2_sum</I></TT>是延迟的二次方的总和。
最后两个字段是<TT CLASS="REPLACEABLE"><I>min_latency</I></TT>-间隔的最小延迟，<TT CLASS="REPLACEABLE"><I>max_latency</I></TT>-
间隔的最大延迟。当事务已经提交了时，计入间隔。</P><P>
这里是一个示例输出：
</P><PRE CLASS="SCREEN">1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411</PRE><P></P><P>请注意，当纯（未聚合）日志文件包含自定义脚本文件的索引时，聚合日志不包含。
因此，如果你需要每脚本的数据，你需要自己聚合数据。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN151805"></A><H3>每个语句的延迟</H3><P>对于<TT CLASS="OPTION">-r</TT>选项，<SPAN CLASS="APPLICATION">pgbench</SPAN>收集每个客户端执行的每个语句的事务时间。
然后报告一个平均值，在benchmark完成之后，当做每个语句延迟的参考。</P><P>
对于缺省的脚本，输出看起来像这样：
</P><PRE CLASS="SCREEN">starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
        0.004386        \set nbranches 1 * :scale
        0.001343        \set ntellers 10 * :scale
        0.001212        \set naccounts 100000 * :scale
        0.001310        \setrandom aid 1 :naccounts
        0.001073        \setrandom bid 1 :nbranches
        0.001005        \setrandom tid 1 :ntellers
        0.001078        \setrandom delta -5000 5000
        0.326152        BEGIN;
        0.603376        UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454643        SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528491        UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335435        UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371851        INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212976        END;</PRE><P>
</P><P>如果声明了多个脚本文件，那么为每个脚本文件单独报告平均值。</P><P>请注意，收集额外的时间信息需要每语句延迟计算加上一些开销。
这将减缓平均执行速度并降低计算的TPS。降低的值根据平台和硬件会有很大的变化。
启用和不启用延迟报告来计算TPS的平均值，是测量时间开销是否重要的一个很好的方法。</P></DIV><DIV CLASS="REFSECT2"><A NAME="AEN151814"></A><H3>好的实践</H3><P>使用<SPAN CLASS="APPLICATION">pgbench</SPAN>可以非常简单的生成完全毫无意义的数字。
这里有一些指导，帮助你获取有用的结果。</P><P>首先，<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">决不</I></SPAN>相信任何只运行几秒钟的测试。使用<TT CLASS="OPTION">-t</TT>
或<TT CLASS="OPTION">-T</TT>选项使测试最少运行几分钟，以平均噪音。
在某些情况下，你可能需要几小时才能获得可再生的数字。
尝试让测试多运行几次是一个好的想法，以找出你的数字是否再生了。</P><P>对于缺省的类TPC-B测试情况，初始化比例因子(<TT CLASS="OPTION">-s</TT>)
应该至少和你要测试的最大客户端数量(<TT CLASS="OPTION">-c</TT>)一样大；
否则你大多会测量到更新争用。在<TT CLASS="STRUCTNAME">pgbench_branches</TT>表中只有<TT CLASS="OPTION">-s</TT>行，
并且每个事务都想更新它们中的一条，所以<TT CLASS="OPTION">-c</TT>值大于<TT CLASS="OPTION">-s</TT>时，
将会毫无疑问的导致大量事务锁住，等待其他事务。</P><P>缺省的测试情节也对表被初始化了多久很敏感：表中死行的积累和死区会改变结果。
要理解结果，你必须跟踪更新的总数量和何时发生了清理。如果启用了自动清理，
那么它会导致在测量的性能中有不可预知的改变。</P><P><SPAN CLASS="APPLICATION">pgbench</SPAN>的一个限制是在尝试测试大量的客户端会话时，它本身会成为瓶颈。
这个可以通过在不同的机器上从数据库服务器运行<SPAN CLASS="APPLICATION">pgbench</SPAN>来减轻，
尽管少量的网络延迟是必然的。在几个客户端机器上，对同一个数据库服务器，
同时运行几个<SPAN CLASS="APPLICATION">pgbench</SPAN>实例可能也有帮助，</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="oid2name.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="vacuumlo.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">oid2name</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="contrib-prog-client.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><SPAN CLASS="APPLICATION">vacuumlo</SPAN></TD></TR></TABLE></DIV></BODY></HTML>
