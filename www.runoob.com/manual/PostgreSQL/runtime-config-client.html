<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>客户端连接缺省</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="服务器配置" HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html"><LINK REL="PREVIOUS" TITLE="自动清理" HREF="runtime-config-autovacuum.html"><LINK REL="NEXT" TITLE="锁管理" HREF="runtime-config-locks.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/config.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="自动清理" HREF="runtime-config-autovacuum.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 18. 服务器配置</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="锁管理" HREF="runtime-config-locks.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="RUNTIME-CONFIG-CLIENT">18.11. 客户端连接缺省</A></H1><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="RUNTIME-CONFIG-CLIENT-STATEMENT">18.11.1. 语句行为</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="GUC-SEARCH-PATH"></A><TT CLASS="VARNAME">search_path</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 这个变量声明模式的搜索顺序，在一个被引用对象(表、数据类型、函数等)只是一个简单名字，
没有声明模式时需要这样的搜索。如果在另外一个模式里有一个相同的对象名，
那么使用在这个搜索路径中找到的第一个。
一个不在搜索路径中任何一个模式里出现的对象只能通过其所在模式的全称(打点的)名字来声明。</P><P> <TT CLASS="VARNAME">search_path</TT>的值必需是一个逗号分隔的模式名列表。
它不是一个现有的模式名，或者用户不具有<TT CLASS="LITERAL">USAGE</TT>权限的模式，都将被自动忽略。</P><P> 如果列表项之一是特殊名称<TT CLASS="LITERAL">$user</TT>，
那么通过<CODE CLASS="FUNCTION">SESSION_USER</CODE>返回的名称模式被取代，
如果有这样一个模式并且用户已经有<TT CLASS="LITERAL">USAGE</TT>权限。
（如果不是，那么忽略<TT CLASS="LITERAL">$user</TT>。）</P><P> 系统表模式<TT CLASS="LITERAL">pg_catalog</TT>总是被搜索，不管是否在搜索路径。如果在路径中，
那么按照路径指定的顺序搜索，
如果<TT CLASS="LITERAL">pg_catalog</TT>不在路径中，那么将在任何路径<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">之前</I></SPAN>搜索。</P><P> 同样，如果它存在，那么当前会话的临时表模式，
<TT CLASS="LITERAL">pg_temp_<TT CLASS="REPLACEABLE"><I>nnn</I></TT></TT>总是被搜索。
它可以通过使用别名<TT CLASS="LITERAL">pg_temp</TT>
被明确地列在该路径中。如果没有列在路径中，那么它首先被搜索（甚至<TT CLASS="LITERAL">pg_catalog</TT>之前）。
但是，临时模式只搜索关系（表，视图，序列等）以及数据类型名称。
它从来没有搜索函数或运算符名称。</P><P> 如果创建对象时没有声明特定的目标模式，那么它将被放进<TT CLASS="VARNAME">search_path</TT>中的第一个模式。
如果搜索路径是空的，那么会报告一个错误。</P><P> 这个参数的缺省值是<TT CLASS="LITERAL">"$user", public</TT>。
这样就支持共享使用一个数据库(没有用户拥有私有模式，所有人都共享使用<TT CLASS="LITERAL">public</TT>)、
私有的针对每个用户的模式、以及两者的组合。
其它效果可以通过全局或者针对每个用户修改搜索路径设置获取。</P><P> 搜索路径当前值可以用<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>函数<CODE CLASS="FUNCTION">current_schemas</CODE>（参阅<A HREF="functions-info.html">第 9.25 &#33410;</A>）
检查。它和检查<TT CLASS="VARNAME">search_path</TT>的值不太一样，因为<CODE CLASS="FUNCTION">current_schemas</CODE>
显示的是在<TT CLASS="VARNAME">search_path</TT>里出现的项如何被处理。</P><P> 有关模式处理的更多信息，参阅<A HREF="ddl-schemas.html">第 5.7 &#33410;</A>。</P></DD><DT><A NAME="GUC-DEFAULT-TABLESPACE"></A><TT CLASS="VARNAME">default_tablespace</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 这个变量声明当<TT CLASS="COMMAND">CREATE</TT>命令没有明确声明表空间时，
所创建对象(表和索引等)的缺省表空间。</P><P> 值要么是一个表空间的名字，要么是一个表明使用当前数据库缺省表空间的空字符串。
如果这个数值和任意现存表空间的名字都不匹配，
那么<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>将自动使用当前数据库的缺省表空间。
如果声明非缺省表空间，用户必须有<TT CLASS="LITERAL">CREATE</TT>权限，或者创建尝试将失败。</P><P> 这个变量不用于临时表;对他们来说，
<A HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</A>提供谘询。</P><P> 这个变量在创建数据库时也没有使用。默认情况下，新的数据库继承了从
模板数据库复制的表空间设置。</P><P> 关于表空间的更多信息，请参阅<A HREF="manage-ag-tablespaces.html">第 21.6 &#33410;</A>。</P></DD><DT><A NAME="GUC-TEMP-TABLESPACES"></A><TT CLASS="VARNAME">temp_tablespaces</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 当<TT CLASS="COMMAND">CREATE</TT>命令不明确指定一个表空间时，
这个变量指定要在其中创建临时对象的表空间（临时表和临时表的索引）。
出于此目的的临时文件，比如排序大型数据集，也在这些表空间中创建。</P><P> 该值是表空间名称的列表。当列表中有一个以上名称时，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>每次临时对象被创建时选择一个列表中的随机数；
除了在一个事务中之外，先后创建临时
对象放置在列表连续的表空间中。
如果列表中选定的元素是一个空字符串，
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>会自动使用当前数据库的缺省表空间。</P><P> 当<TT CLASS="VARNAME">temp_tablespaces</TT>交互设置时，指定
不存在的表空间是一个错误，为
不具有<TT CLASS="LITERAL">CREATE</TT>权限的用户声明一个表空间。但是，
当使用事先设定的值时，则忽略不存在的表空间，
因为对于缺少<TT CLASS="LITERAL">CREATE</TT>权限的用户是一个表空间。
特别是，该规则适用于使用<TT CLASS="FILENAME">postgresql.conf</TT>设置的值时。</P><P> 默认值是一个空字符串，这会导致所有临时对象在当前数据库缺省表空间被创建。</P><P> 参阅<A HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</A>。</P></DD><DT><A NAME="GUC-CHECK-FUNCTION-BODIES"></A><TT CLASS="VARNAME">check_function_bodies</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 这个参数通常是on。设置为<TT CLASS="LITERAL">off</TT>表示在<A HREF="sql-createfunction.html">CREATE FUNCTION</A>之间关闭函数体字符串的合法性检查。
关闭合法性检查有时候会有用，比如避免从转储中恢复函数定义时向前引用的问题。</P></DD><DT><A NAME="GUC-DEFAULT-TRANSACTION-ISOLATION"></A><TT CLASS="VARNAME">default_transaction_isolation</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 每个SQL事务都有一个隔离级别，可以是<SPAN CLASS="QUOTE">"读未提交"</SPAN>，<SPAN CLASS="QUOTE">"读已提交"</SPAN>，
<SPAN CLASS="QUOTE">"可重复读"</SPAN>或者是<SPAN CLASS="QUOTE">"可串性化"</SPAN>。
这个参数控制每个新事务的缺省隔离级别。缺省是<SPAN CLASS="QUOTE">"读已提交"</SPAN>。</P><P> 参考<A HREF="http://school.yunwei.edu/manual/PostgreSQL/mvcc.html">第 13 &#31456;</A>和<A HREF="sql-set-transaction.html">SET TRANSACTION</A>获取更多信息。</P></DD><DT><A NAME="GUC-DEFAULT-TRANSACTION-READ-ONLY"></A><TT CLASS="VARNAME">default_transaction_read_only</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 只读的SQL事务不能修改非临时表。这个参数控制每个新事务的只读状态。缺省是<TT CLASS="LITERAL">off</TT>(读/写)。</P><P> 参考<A HREF="sql-set-transaction.html">SET TRANSACTION</A>获取更多信息。</P></DD><DT><A NAME="GUC-DEFAULT-TRANSACTION-DEFERRABLE"></A><TT CLASS="VARNAME">default_transaction_deferrable</TT> (<TT CLASS="TYPE">boolean</TT>)</DT><DD><P> 当在<TT CLASS="LITERAL">可串行化</TT>隔离级别下运行时，
延迟的只读SQL事务允许继续进行之前可能会延迟。
然而，一旦开始执行不会产生任何开销要求，以确保串行化;
所以串行化代码没有理由迫使它终止，因为并发更新，
这使这些选项适合长时间运行只读事务。</P><P> 此参数控制每个新事务缺省延迟状态。
它目前对读写事务或那些比<TT CLASS="LITERAL">可串行化</TT>低的隔离级别下的操作没有影响。
缺省是<TT CLASS="LITERAL">off</TT>。</P><P> 参阅<A HREF="sql-set-transaction.html">SET TRANSACTION</A>获取更多详细信息。</P></DD><DT><A NAME="GUC-SESSION-REPLICATION-ROLE"></A><TT CLASS="VARNAME">session_replication_role</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 控制当前会话复制相关的触发器和规则。设置此变量需要
超级用户权限，并导致丢弃任何以前缓存查询规划。
可能的值是<TT CLASS="LITERAL">origin</TT> (缺省)，<TT CLASS="LITERAL">replica</TT>和<TT CLASS="LITERAL">local</TT>。
参阅<A HREF="sql-altertable.html">ALTER TABLE</A>获取更多信息。</P></DD><DT><A NAME="GUC-STATEMENT-TIMEOUT"></A><TT CLASS="VARNAME">statement_timeout</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 退出任何使用了超过此参数指定时间(毫秒)的语句，从服务器收到命令时开始计时。
如果<TT CLASS="VARNAME">log_min_error_statement</TT>设置为<TT CLASS="LITERAL">ERROR</TT>或者更低，
那么也会在日志中记录超时。
零值(缺省)关闭这个计时器。</P><P> 不推荐设置<TT CLASS="FILENAME">postgresql.conf</TT>中的<TT CLASS="VARNAME">statement_timeout</TT>，
因为它影响所有的会话。</P></DD><DT><A NAME="GUC-LOCK-TIMEOUT"></A><TT CLASS="VARNAME">lock_timeout</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P>
当试图获取表、索引、行或其他数据库对象的锁时，终止等待时间超过指定毫秒数的任何语句。
时间限制分别适用于每个锁获取尝试。该限制适用于明确
锁定请求（如<TT CLASS="COMMAND">LOCK TABLE</TT>或者没有<TT CLASS="LITERAL">NOWAIT</TT>的<TT CLASS="COMMAND">SELECT FOR UPDATE</TT>）
以及隐式获取的锁。
如果<TT CLASS="VARNAME">log_min_error_statement</TT>设置为<TT CLASS="LITERAL">ERROR</TT>或更低，
则记录超时的语句。零值（缺省值）关闭它。</P><P> 不像<TT CLASS="VARNAME">statement_timeout</TT>，此超时只能发生在等待锁的时候。
请注意，如果<TT CLASS="VARNAME">statement_timeout</TT>是非零，
设置<TT CLASS="VARNAME">lock_timeout</TT>相同或更大的值是相当没有意义的，
因为该语句超时总是会首先触发。</P><P> 不推荐设置<TT CLASS="FILENAME">postgresql.conf</TT>中的<TT CLASS="VARNAME">lock_timeout</TT>，
因为它影响所有的会话。</P></DD><DT><A NAME="GUC-VACUUM-FREEZE-TABLE-AGE"></A><TT CLASS="VARNAME">vacuum_freeze_table_age</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 如果该表<TT CLASS="STRUCTNAME">pg_class</TT>.<TT CLASS="STRUCTFIELD">relfrozenxid</TT>
字段已达到此设置中指定的时间，<TT CLASS="COMMAND">VACUUM</TT>执行全表扫描。
默认值是1.5亿个事务。虽然用户可以从零到十亿设置此值。
<TT CLASS="COMMAND">VACUUM</TT>会默默的限制<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</A>的95%的有效值，
从而使定期手动的<TT CLASS="COMMAND">VACUUM</TT>在自动清理该表之前有运行机会。
详细信息请见<A HREF="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND">第 23.1.5 &#33410;</A>。</P></DD><DT><A NAME="GUC-VACUUM-FREEZE-MIN-AGE"></A><TT CLASS="VARNAME">vacuum_freeze_min_age</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 指定<TT CLASS="COMMAND">VACUUM</TT>在扫描一个表时用于判断是否用<TT CLASS="LITERAL">FrozenXID</TT>
替换事务ID的中断寿命(在同一个事务中)。
缺省值为50百万。虽然用户可以指定一个 0-1000000000之间的值，
但是<TT CLASS="COMMAND">VACUUM</TT>将会悄无声息的将有效值限制在<A HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</A>的一半之内。
更多信息参见<A HREF="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND">第 23.1.5 &#33410;</A>。</P></DD><DT><A NAME="GUC-BYTEA-OUTPUT"></A><TT CLASS="VARNAME">bytea_output</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 设置<TT CLASS="TYPE">bytea</TT>类型值的输出格式。
有效值为<TT CLASS="LITERAL">hex</TT> (缺省)
和<TT CLASS="LITERAL">escape</TT> (传统PostgreSQL
格式)。参见<A HREF="datatype-binary.html">第 8.4 &#33410;</A>获取更多信息。
不管这些设置，其中<TT CLASS="TYPE">bytea</TT>类型总是接受这两种格式的输入。</P></DD><DT><A NAME="GUC-XMLBINARY"></A><TT CLASS="VARNAME">xmlbinary</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 设置二进制值是如何在XML中进行编码的。
这适用于当<TT CLASS="TYPE">bytea</TT>值通过<CODE CLASS="FUNCTION">xmlelement</CODE>
或者<CODE CLASS="FUNCTION">xmlforest</CODE>函数被转换为XML。
可能的值是<TT CLASS="LITERAL">base64</TT>和<TT CLASS="LITERAL">hex</TT>，
这在XML模式标准中定义。默认值是<TT CLASS="LITERAL">base64</TT>。
关于XML相关的函数的进一步信息，请参阅<A HREF="functions-xml.html">第 9.14 &#33410;</A>。</P><P> 这里的实际选择主要是口味问题，
只有在客户端应用程序中可能存在某些限制约束。
这两种方法都支持所有可能的值，
虽然十六进制编码将会比base64编码大一些。</P></DD><DT><A NAME="GUC-XMLOPTION"></A><TT CLASS="VARNAME">xmloption</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 当XML和字符串值之间进行转换时，设置<TT CLASS="LITERAL">DOCUMENT</TT>或
<TT CLASS="LITERAL">CONTENT</TT>是否是隐含的。
参见<A HREF="datatype-xml.html">第 8.13 &#33410;</A>获取更多详细信息。有效
值<TT CLASS="LITERAL">DOCUMENT</TT>和<TT CLASS="LITERAL">CONTENT</TT>。缺省是
<TT CLASS="LITERAL">CONTENT</TT>。</P><P>
按照SQL标准，设置这个选项的命令是：
</P><PRE CLASS="SYNOPSIS">SET XML OPTION { DOCUMENT | CONTENT };</PRE><P>
这种语法在PostgreSQL中是可用的。
</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="RUNTIME-CONFIG-CLIENT-FORMAT">18.11.2. 区域和格式化</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="GUC-DATESTYLE"></A><TT CLASS="VARNAME">DateStyle</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置日期和时间值的显示格式，以及有歧义的输入值的解析规则。
由于历史原因，这个变量包含两个独立的部分：输出格式声明(<TT CLASS="LITERAL">ISO</TT>,
<TT CLASS="LITERAL">Postgres</TT>, <TT CLASS="LITERAL">SQL</TT>或者<TT CLASS="LITERAL">German</TT>)、
输入输出的年/月/日顺序(<TT CLASS="LITERAL">DMY</TT>, <TT CLASS="LITERAL">MDY</TT>或者<TT CLASS="LITERAL">YMD</TT>)。
这两个可以独立设置或者一起设置。
关键字<TT CLASS="LITERAL">Euro</TT>和<TT CLASS="LITERAL">European</TT> 等价于<TT CLASS="LITERAL">DMY</TT>；
关键字<TT CLASS="LITERAL">US</TT>, <TT CLASS="LITERAL">NonEuro</TT>和
<TT CLASS="LITERAL">NonEuropean</TT>等价于<TT CLASS="LITERAL">MDY</TT>。
参阅<A HREF="datatype-datetime.html">第 8.5 &#33410;</A>获取更多信息。内置缺省是<TT CLASS="LITERAL">ISO, MDY</TT>，
但是<SPAN CLASS="APPLICATION">initdb</SPAN>将在初始化配置文件时根据<TT CLASS="VARNAME">lc_time</TT>选择一个合适的默认设置。</P></DD><DT><A NAME="GUC-INTERVALSTYLE"></A><TT CLASS="VARNAME">IntervalStyle</TT> (<TT CLASS="TYPE">enum</TT>)</DT><DD><P> 设置区间值的显示格式。
<TT CLASS="LITERAL">sql_standard</TT>将产生输出匹配<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准时间间隔。
<TT CLASS="LITERAL">postgres</TT>的值（默认值）会产生输出匹配<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>8.4之前的版本。
当<A HREF="runtime-config-client.html#GUC-DATESTYLE">DateStyle</A>参数设置为<TT CLASS="LITERAL">ISO</TT>时。
<TT CLASS="LITERAL">postgres_verbose</TT>将产生输出匹配<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>8.4之前的版本。
当<TT CLASS="VARNAME">DateStyle</TT>参数被设置成非-<TT CLASS="LITERAL">ISO</TT>输出时。
<TT CLASS="LITERAL">iso_8601</TT>将产生输出匹配4.4.3.2节中ISO 8601定义的时间间隔格式。</P><P> <TT CLASS="VARNAME">IntervalStyle</TT>参数也会影响不明确的间隔输入的说明。
参阅<A HREF="datatype-datetime.html#DATATYPE-INTERVAL-INPUT">第 8.5.4 &#33410;</A>获取更多详细信息。</P></DD><DT><A NAME="GUC-TIMEZONE"></A><TT CLASS="VARNAME">TimeZone</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置用于显示和解析时间戳的时区。内置缺省值<TT CLASS="LITERAL">GMT</TT>，
但是，这通常被<TT CLASS="FILENAME">postgresql.conf</TT>改写；<SPAN CLASS="APPLICATION">initdb</SPAN>
将安装设置对应它的系统环境。
意味着使用系统环境声明的时区。
参阅<A HREF="datatype-datetime.html#DATATYPE-TIMEZONES">第 8.5.3 &#33410;</A>获取更多信息。</P></DD><DT><A NAME="GUC-TIMEZONE-ABBREVIATIONS"></A><TT CLASS="VARNAME">timezone_abbreviations</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置服务器接受日期时间输入中使用的时区缩写集合。缺省值<TT CLASS="LITERAL">'Default'</TT>，
在全世界大多数地方都能工作的很好。
另外的可用值还有<TT CLASS="LITERAL">'Australia'</TT>和<TT CLASS="LITERAL">'India'</TT>等其它值。
参见<A HREF="http://school.yunwei.edu/manual/PostgreSQL/datetime-appendix.html">&#38468;&#24405; B</A>以获取更多信息。</P></DD><DT><A NAME="GUC-EXTRA-FLOAT-DIGITS"></A><TT CLASS="VARNAME">extra_float_digits</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> 这个参数为浮点数值调整显示的数据位数，浮点类型包括<TT CLASS="TYPE">float4</TT>, <TT CLASS="TYPE">float8</TT>以及几何数据类型。
参数值加在标准的数据位数上(<TT CLASS="LITERAL">FLT_DIG</TT>或者<TT CLASS="LITERAL">DBL_DIG</TT>中合适的)。
数值可以设置为最高3，
以包括部分关键的数据位；这个功能对转储那些需要精确恢复的浮点数据特别有用。
或者你也可以把它设置位负数以消除不需要的数据位。
参阅<A HREF="datatype-numeric.html#DATATYPE-FLOAT">第 8.1.3 &#33410;</A>。</P></DD><DT><A NAME="GUC-CLIENT-ENCODING"></A><TT CLASS="VARNAME">client_encoding</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置客户端编码(字符集)。缺省使用数据库编码。
字符集通过<A HREF="multibyte.html#MULTIBYTE-CHARSET-SUPPORTED">第 22.3.1 &#33410;</A>里描述的
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器支持。</P></DD><DT><A NAME="GUC-LC-MESSAGES"></A><TT CLASS="VARNAME">lc_messages</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置信息显示的语言。可接受的值是系统相关的；
参阅<A HREF="locale.html">第 22.1 &#33410;</A>获取更多信息。如果这个变量设置为空字符串(缺省值)，
那么其值将以一种系统相关的方式从服务器的执行环境中继承。</P><P> 在一些系统上，这个区域范畴并不存在，不过仍然允许设置这个变量，
只是不会有任何效果。同样，也有可能是所期望的语言的翻译信息不存在。
在这种情况下，你仍然能看到英文信息。&#13;</P><P> 只有超级用户可以改变这个设置。因为它同时影响发送到服务器日志和客户端的信息。
并且不正确的值可能会掩盖服务器日志的可读性。</P></DD><DT><A NAME="GUC-LC-MONETARY"></A><TT CLASS="VARNAME">lc_monetary</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 为格式化金额数量设置区域。比如用于<CODE CLASS="FUNCTION">to_char</CODE>函数族。可接受的值是系统相关的；
参阅<A HREF="locale.html">第 22.1 &#33410;</A>获取更多信息。如果这个变量设置为空字符串(缺省值)，
那么其值将以一种系统相关的方式从服务器的执行环境中继承。 </P></DD><DT><A NAME="GUC-LC-NUMERIC"></A><TT CLASS="VARNAME">lc_numeric</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置用于格式化数字的区域，比如用于<CODE CLASS="FUNCTION">to_char</CODE>函数族。可接受的值是系统相关的；
参阅<A HREF="locale.html">第 22.1 &#33410;</A>获取更多信息。如果这个变量设置为空字符串(缺省值)，
那么其值将以一种系统相关的方式从服务器的执行环境中继承。</P></DD><DT><A NAME="GUC-LC-TIME"></A><TT CLASS="VARNAME">lc_time</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 设置用于格式化日期和时间值的区域。比如<CODE CLASS="FUNCTION">to_char</CODE>函数族，
可接受的值是系统相关的；参阅<A HREF="locale.html">第 22.1 &#33410;</A>获取更多信息。
如果这个变量设置为空字符串(缺省值)，
那么其值将以一种系统相关的方式从服务器的执行环境中继承。</P></DD><DT><A NAME="GUC-DEFAULT-TEXT-SEARCH-CONFIG"></A><TT CLASS="VARNAME">default_text_search_config</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 选择文本搜索函数使用的那些变量的文本搜索配置没有声明配置的明确参数。
参见<A HREF="http://school.yunwei.edu/manual/PostgreSQL/textsearch.html">第 12 &#31456;</A>获取进一步信息。
内置缺省值是<TT CLASS="LITERAL">pg_catalog.simple</TT>，
如果配置匹配可以被识别的区域，则<SPAN CLASS="APPLICATION">initdb</SPAN>将初始化该设置的配置文件，
它对应于已选择的<TT CLASS="VARNAME">lc_ctype</TT>区域。 </P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="RUNTIME-CONFIG-CLIENT-OTHER">18.11.3. 其他缺省</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="GUC-DYNAMIC-LIBRARY-PATH"></A><TT CLASS="VARNAME">dynamic_library_path</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 如果需要打开一个可以动态装载的模块并且在<TT CLASS="COMMAND">CREATE FUNCTION</TT>或者
<TT CLASS="COMMAND">LOAD</TT>命令里面声明的名字没有目录部分(也就是说名字里不包含斜杠)，
那么系统将搜索这个目录以查找声明的文件。</P><P>
用于<TT CLASS="VARNAME">dynamic_library_path</TT>的数值必须是一个冒号分隔
(或者是在Windows上分号分隔)的绝对路径列表。
如果一个路径名字以特殊变量<TT CLASS="LITERAL">$libdir</TT>
(<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>编译好的库目录)开头，
那么就替换为<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>发布提供的模块安装路径。
(使用<TT CLASS="LITERAL">pg_config --pkglibdir</TT>打印这个目录名)。比如：
</P><PRE CLASS="PROGRAMLISTING">dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir'</PRE><P>
或者是在Windows环境里：
</P><PRE CLASS="PROGRAMLISTING">dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'</PRE><P>
</P><P> 这个参数的缺省值是<TT CLASS="LITERAL">'$libdir'</TT>。
如果把这个值设置为一个空字符串，则关闭自动路径搜索。</P><P> 这个参数可以在运行时由超级用户修改，但是这么修改的设置只能保持到这个客户端连接的结束，
因此这个方法应该保留给开发用途使用。我们建议在<TT CLASS="FILENAME">postgresql.conf</TT>配置文件里设置。</P></DD><DT><A NAME="GUC-GIN-FUZZY-SEARCH-LIMIT"></A><TT CLASS="VARNAME">gin_fuzzy_search_limit</TT> (<TT CLASS="TYPE">integer</TT>)</DT><DD><P> GIN索引扫描返回的集合尺寸软上限。更多信息参见<A HREF="gin-tips.html">第 57.4 &#33410;</A>。</P></DD><DT><A NAME="GUC-LOCAL-PRELOAD-LIBRARIES"></A><TT CLASS="VARNAME">local_preload_libraries</TT> (<TT CLASS="TYPE">string</TT>)</DT><DD><P> 指定在开始连接前预先加载一个或多个共享库，多个库之间用逗号分隔。
所有的库名被转换为小写字母，除非双引号引用。
该参数不能在会话开始之后更改。</P><P> 因为并非只有超级用户才能更改此选项，
因此只能加载安装的标准库目录下<TT CLASS="FILENAME">plugins</TT>子目录中的库文件，
数据库管理员有责任确保该目录中的库都是<SPAN CLASS="QUOTE">"安全的"</SPAN>。
<TT CLASS="VARNAME">local_preload_libraries</TT>中指定的项可以明确含有该目录，
例如<TT CLASS="LITERAL">$libdir/plugins/mylib</TT>；也可以仅指定库的名字&mdash;
例如<TT CLASS="LITERAL">mylib</TT>(等价于<TT CLASS="LITERAL">$libdir/plugins/mylib</TT>)。</P><P> 与<A HREF="runtime-config-resource.html#GUC-SHARED-PRELOAD-LIBRARIES">shared_preload_libraries</A>不同的是，
在会话开始时加载库比第一次使用时相比并不具有性能优势。
相反，这个特性的目的是为了调试或者测量在特定会话中不明确使用<TT CLASS="COMMAND">LOAD</TT>加载库时的性能。
例如针对某个用户将该参数设为<TT CLASS="COMMAND">ALTER ROLE SET</TT>来进行调试。</P><P> 如果指定的库未找到，那么连接将失败。</P><P> 每一个支持PostgreSQL的库都有一个<SPAN CLASS="QUOTE">"magic block"</SPAN>用于确保兼容性。
因此不支持PostgreSQL的库不能通过这个方法加载。</P></DD></DL></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="runtime-config-autovacuum.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="runtime-config-locks.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">自动清理</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/runtime-config.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">锁管理</TD></TR></TABLE></DIV></BODY></HTML>
