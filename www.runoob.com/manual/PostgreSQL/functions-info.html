<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>系统信息函数</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="函数和操作符" HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html"><LINK REL="PREVIOUS" TITLE="返回集合的函数" HREF="functions-srf.html"><LINK REL="NEXT" TITLE="系统管理函数" HREF="functions-admin.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/func.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="返回集合的函数" HREF="functions-srf.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 9. 函数和操作符</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="系统管理函数" HREF="functions-admin.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FUNCTIONS-INFO">9.25. 系统信息函数</A></H1><P><A HREF="functions-info.html#FUNCTIONS-INFO-SESSION-TABLE">&#34920; 9-51</A>显示了几个抽取会话及系统信息的函数。</P><P>另外在本节所列出的函数，有一些函数有关统计系统，也提供系统信息。
参阅<A HREF="monitoring-stats.html#MONITORING-STATS-VIEWS">第 27.2.2 &#33410;</A>获取更多信息。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-INFO-SESSION-TABLE"></A><P><B>&#34920; 9-51. 会话信息函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>Name</TH><TH>Return Type</TH><TH>Description</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_catalog</CODE></TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>当前数据库名（在SQL标准里叫<SPAN CLASS="QUOTE">"catalog"</SPAN>）</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_database()</CODE></TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>当前数据库名</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_query()</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>当前执行的查询文本，由客户端提交（可能包含多于1句）</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_schema</CODE>[()]</TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>当前模式名</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_schemas(<TT CLASS="TYPE">boolean</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">name[]</TT></TD><TD>搜索路径中的模式名字，包括可选的隐式模式</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_user</CODE></TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>当前执行环境下的用户名</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">inet_client_addr()</CODE></TT></TD><TD><TT CLASS="TYPE">inet</TT></TD><TD>连接的远端地址</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">inet_client_port()</CODE></TT></TD><TD><TT CLASS="TYPE">int</TT></TD><TD>连接的远端端口</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">inet_server_addr()</CODE></TT></TD><TD><TT CLASS="TYPE">inet</TT></TD><TD>连接的本地地址</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">inet_server_port()</CODE></TT></TD><TD><TT CLASS="TYPE">int</TT></TD><TD>连接的本地端口</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_backend_pid()</CODE></TT></TD><TD><TT CLASS="TYPE">int</TT></TD><TD> 连接到当前会话的服务器进程 ID
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_conf_load_time()</CODE></TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>配置加载时间</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_is_other_temp_schema(<TT CLASS="TYPE">oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>是否为另一个会话的临时模式?</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_listening_channels()</CODE></TT></TD><TD><TT CLASS="TYPE">setof text</TT></TD><TD>正在侦听的当前会话的信道名称</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_my_temp_schema()</CODE></TT></TD><TD><TT CLASS="TYPE">oid</TT></TD><TD>会话的临时模式的OID，不存在则为 0</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_postmaster_start_time()</CODE></TT></TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>服务器启动时间</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_trigger_depth()</CODE></TT></TD><TD><TT CLASS="TYPE">int</TT></TD><TD><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 触发器的当前嵌套级别
（如果没有直接或间接的从一个触发器内部调用，那么是0）
</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">session_user</CODE></TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>会话用户名</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">user</CODE></TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>等价于 <CODE CLASS="FUNCTION">current_user</CODE></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">version()</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 版本信息</TD></TR></TBODY></TABLE></DIV><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B><CODE CLASS="FUNCTION">current_catalog</CODE>, <CODE CLASS="FUNCTION">current_schema</CODE>,
<CODE CLASS="FUNCTION">current_user</CODE>, <CODE CLASS="FUNCTION">session_user</CODE>,
和<CODE CLASS="FUNCTION">user</CODE>在<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>里有特殊的语法：
调用他们时结尾不能跟圆括号。（在 PostgreSQL，<CODE CLASS="FUNCTION">current_schema</CODE>
可选的可以有括号，但是其它的不能。）</P></BLOCKQUOTE></DIV><P><CODE CLASS="FUNCTION">session_user</CODE>通常是连接当前数据库的初始用户，
不过超级用户可以用<A HREF="sql-set-session-authorization.html">SET SESSION AUTHORIZATION</A>修改这个设置。
<CODE CLASS="FUNCTION">current_user</CODE>是用于权限检查的用户标识。通常，它总是等于会话用户，
但是可以通过<A HREF="sql-set-role.html">SET ROLE</A>改变它。
在函数执行的过程中随着属性<TT CLASS="LITERAL">SECURITY DEFINER</TT>的改变，其值也会改变。
用 Unix 术语来说，会话用户是<SPAN CLASS="QUOTE">"真实用户"</SPAN>，而当前用户是<SPAN CLASS="QUOTE">"有效用户"</SPAN>。</P><P><CODE CLASS="FUNCTION">current_schema</CODE>返回在搜索路径前端的模式名字(如果搜索路径为空则返回 NULL)。
如果创建表或者其它命名对象时没有声明目标模式，那么它将是用于这些对象的模式。
<CODE CLASS="FUNCTION">current_schemas(boolean)</CODE>返回一个搜索路径中所有模式名字的数组。
布尔选项决定像<TT CLASS="LITERAL">pg_catalog</TT>这样隐含包含的系统模式是否包含在返回的搜索路径中。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>搜索路径可以通过运行时设置更改。命令是：
</P><PRE CLASS="PROGRAMLISTING">SET search_path TO <TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
>, ...</SPAN
>]</PRE><P>
</P></BLOCKQUOTE></DIV><P><CODE CLASS="FUNCTION">pg_listening_channels</CODE>返回当前会话正在监听的一组信道名称。
见<A HREF="sql-listen.html">LISTEN</A>获取更多信息。</P><P><CODE CLASS="FUNCTION">inet_client_addr</CODE>返回当前客户端的IP地址，
而<CODE CLASS="FUNCTION">inet_client_port</CODE>则返回当前客户端的端口号。
<CODE CLASS="FUNCTION">inet_server_addr</CODE>返回服务器接收当前连接用的 IP 地址，
而<CODE CLASS="FUNCTION">inet_server_port</CODE>返回接收当前连接的端口号。
如果是通过 Unix-domain socket 连接的，那么所有这些函数都返回 NULL 。</P><P><CODE CLASS="FUNCTION">pg_my_temp_schema</CODE>返回当前会话的临时模式 OID ，
如果不存在的话则返回 0(因为没有创建任何临时表)。<CODE CLASS="FUNCTION">pg_is_other_temp_schema</CODE>
返回给定的 OID 是否为其它会话的临时模式 OID ，这个函数是有实用价值的，
比如，在显示一个目录的时候排除掉其它会话的临时表。</P><P><CODE CLASS="FUNCTION">pg_postmaster_start_time</CODE>返回服务器启动时的<TT CLASS="TYPE">timestamp with time zone</TT>。</P><P><CODE CLASS="FUNCTION">pg_conf_load_time</CODE>返回最后加载服务器配置文件的时间戳。
（如果当前会话在那时还活动，将是当前会话本身重新读取配置文件的时间，
所以读取的时间会在不同的会话中稍微有所不同。否则，
它是postmaster进程重新读取配置文件的时间。）</P><P><CODE CLASS="FUNCTION">version</CODE>返回一个描述<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>服务器版本信息的字符串。</P><P><A HREF="functions-info.html#FUNCTIONS-INFO-ACCESS-TABLE">&#34920; 9-52</A>列出那些允许用户在程序里查询对象访问权限的函数。
参阅<A HREF="ddl-priv.html">第 5.6 &#33410;</A>获取更多有关权限的信息。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-INFO-ACCESS-TABLE"></A><P><B>&#34920; 9-52. 访问权限查询函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_any_column_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">table</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问表任何列的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_any_column_privilege</CODE>(<TT CLASS="PARAMETER">table</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问表任何列的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_column_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">table</TT>,
<TT CLASS="PARAMETER">column</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问列的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_column_privilege</CODE>(<TT CLASS="PARAMETER">table</TT>,
<TT CLASS="PARAMETER">column</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问列的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_database_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">database</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问数据库的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_database_privilege</CODE>(<TT CLASS="PARAMETER">database</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问数据库的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_foreign_data_wrapper_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">fdw</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问外部数据封装器的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_foreign_data_wrapper_privilege</CODE>(<TT CLASS="PARAMETER">fdw</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问外部数据封装器的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_function_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">function</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问函数的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_function_privilege</CODE>(<TT CLASS="PARAMETER">function</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问函数的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_language_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">language</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问语言的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_language_privilege</CODE>(<TT CLASS="PARAMETER">language</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问语言的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_schema_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">schema</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问模式的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_schema_privilege</CODE>(<TT CLASS="PARAMETER">schema</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问模式的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_sequence_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">sequence</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问序列的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_sequence_privilege</CODE>(<TT CLASS="PARAMETER">sequence</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问序列的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_server_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">server</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问外部服务的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_server_privilege</CODE>(<TT CLASS="PARAMETER">server</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问外部服务的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_table_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">table</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问表的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_table_privilege</CODE>(<TT CLASS="PARAMETER">table</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问表的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_tablespace_privilege</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">tablespace</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有访问表空间的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">has_tablespace_privilege</CODE>(<TT CLASS="PARAMETER">tablespace</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有访问表空间的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_has_role</CODE>(<TT CLASS="PARAMETER">user</TT>,
<TT CLASS="PARAMETER">role</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>指定用户是否有角色的权限</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_has_role</CODE>(<TT CLASS="PARAMETER">role</TT>,
<TT CLASS="PARAMETER">privilege</TT>)</TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>当前用户是否有角色的权限</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">has_table_privilege</CODE>检查用户是否可以用特定的方式访问表。
用户可以通过名字或OID（pg_authid.oid）来指定，<TT CLASS="LITERAL">public</TT>表明PUBLIC伪角色，
或如果缺省该参数，则使用<CODE CLASS="FUNCTION">current_user</CODE>。该表可以通过名字或者 OID 声明。
因此，实际上有六种<CODE CLASS="FUNCTION">has_table_privilege</CODE>变体，
我们可以通过它们的参数数目和类型来区分它们。如果用名字声明，那么在必要时可以用模式进行修饰。
所希望的权限类型是用一个文本字符串来声明的，必须是<TT CLASS="LITERAL">SELECT</TT>, <TT CLASS="LITERAL">INSERT</TT>,
<TT CLASS="LITERAL">UPDATE</TT>, <TT CLASS="LITERAL">DELETE</TT>, <TT CLASS="LITERAL">TRUNCATE</TT>, <TT CLASS="LITERAL">REFERENCES</TT>
或<TT CLASS="LITERAL">TRIGGER</TT>之一。可选，可以添加<TT CLASS="LITERAL">WITH GRANT OPTION</TT>到权限类型，
以测试权限是否拥有授权选项。也可以用逗号分隔多个列出的权限类型，如果拥有任何所列出的权限，
则结果便为<TT CLASS="LITERAL">true</TT>。（权限字符串不区分大小写，
权限名之间允许有额外空白但不属于权限名的部分。）一些例子：
</P><PRE CLASS="PROGRAMLISTING">SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');</PRE><P></P><P><CODE CLASS="FUNCTION">has_sequence_privilege</CODE>检查用户是否可以用特定的方式访问序列。
参数可能与<CODE CLASS="FUNCTION">has_table_privilege</CODE>类似。
想要的访问权限必须为<TT CLASS="LITERAL">USAGE</TT>，<TT CLASS="LITERAL">SELECT</TT>或<TT CLASS="LITERAL">UPDATE</TT>之一。</P><P><CODE CLASS="FUNCTION">has_any_column_privilege</CODE>检查用户是否可以用特定的方式访问表的任何列。
其参数可能与<CODE CLASS="FUNCTION">has_table_privilege</CODE>类似，除了想要的权限类型必须是<TT CLASS="LITERAL">SELECT</TT>，
<TT CLASS="LITERAL">INSERT</TT>，<TT CLASS="LITERAL">UPDATE</TT>，或<TT CLASS="LITERAL">REFERENCES</TT>的一些组合。
请注意，在表级别拥有任何这些权限隐含授予它为每个表列，因此如果与 <CODE CLASS="FUNCTION">has_table_privilege</CODE>
参数相同，<CODE CLASS="FUNCTION">has_any_column_privilege</CODE>总是返回<TT CLASS="LITERAL">true</TT>。
但是如果有至少一列的列级权限授予也成功。</P><P><CODE CLASS="FUNCTION">has_column_privilege</CODE>检查用户是否可以用特定的方式访问一列。
其可能的参数类似于<CODE CLASS="FUNCTION">has_table_privilege</CODE>，
可以通过列名或属性数添加列。想要的访问权限类型必须是<TT CLASS="LITERAL">SELECT</TT>，
<TT CLASS="LITERAL">INSERT</TT>，<TT CLASS="LITERAL">UPDATE</TT>，或<TT CLASS="LITERAL">REFERENCES</TT>的一些组合。
请注意，在表级别拥有任何这些权限隐含授予它为每个表列。</P><P><CODE CLASS="FUNCTION">has_database_privilege</CODE>检查一个用户是否能以特定方式访问一个数据库。
它可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>。权限类型必须是<TT CLASS="LITERAL">CREATE</TT>，
<TT CLASS="LITERAL">CONNECT</TT>，<TT CLASS="LITERAL">TEMPORARY</TT>，<TT CLASS="LITERAL">TEMP</TT>
(等价于<TT CLASS="LITERAL">TEMPORARY</TT>)的一些组合。</P><P><CODE CLASS="FUNCTION">has_function_privilege</CODE>检查一个用户是否能以特定方式访问一个函数。
它可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>。
我们声明一个函数用的是文本字符串而不是 OID ，允许的输入和<TT CLASS="TYPE">regprocedure</TT>
数据类型一样(参阅<A HREF="datatype-oid.html">第 8.18 &#33410;</A>)。权限类型必须是<TT CLASS="LITERAL">EXECUTE</TT>。
一个例子如下：
</P><PRE CLASS="PROGRAMLISTING">SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');</PRE><P></P><P><CODE CLASS="FUNCTION">has_foreign_data_wrapper_privilege</CODE>
检查一个用户是否能以特定的方式访问外部数据封装器。
它的可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>。权限类型必须是<TT CLASS="LITERAL">USAGE</TT>。</P><P><CODE CLASS="FUNCTION">has_language_privilege</CODE>检查一个用户是否能以特定方式访问一个过程语言。
它可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>。权限类型必须是<TT CLASS="LITERAL">USAGE</TT>。</P><P><CODE CLASS="FUNCTION">has_schema_privilege</CODE>检查一个用户是否能以特定方式访问一个模式。
它可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>。权限类型必须是<TT CLASS="LITERAL">CREATE</TT>
或<TT CLASS="LITERAL">USAGE</TT>的一些组合。</P><P><CODE CLASS="FUNCTION">has_server_privilege</CODE>检查一个用户是否能以特定方式访问一个外部服务器。
它可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>。权限类型必须是<TT CLASS="LITERAL">USAGE</TT>。</P><P><CODE CLASS="FUNCTION">has_tablespace_privilege</CODE>检查一个用户是否能以特定方式访问一个表空间。
它可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>。权限类型必须是<TT CLASS="LITERAL">CREATE</TT>。</P><P><CODE CLASS="FUNCTION">pg_has_role</CODE>检查一个用户是否能以特定方式访问一个角色。
它可能的参数类似<CODE CLASS="FUNCTION">has_table_privilege</CODE>，除了<TT CLASS="LITERAL">public</TT>
不能用做用户名。权限类型必须是<TT CLASS="LITERAL">MEMBER</TT>或<TT CLASS="LITERAL">USAGE</TT>的一些组合。
<TT CLASS="LITERAL">MEMBER</TT>表示的是角色中的直接或间接成员关系(也就是<TT CLASS="COMMAND">SET ROLE</TT>
的权限)，而<TT CLASS="LITERAL">USAGE</TT>表示角色的权限是否无需<TT CLASS="COMMAND">SET ROLE</TT>即可立即生效。</P><P><A HREF="functions-info.html#FUNCTIONS-INFO-SCHEMA-TABLE">&#34920; 9-53</A>
显示了那些判断一个对象是否在当前模式搜索路径中<I CLASS="FIRSTTERM">可见</I>的函数。
比如，如果一个表所在的模式在搜索路径中，并且没有同名的表出现在搜索路径的更靠前的地方，
那么就说这个表是可见的。它等效于表可以不带明确模式修饰进行引用。比如，要列出所有可见表的名字：
</P><PRE CLASS="PROGRAMLISTING">SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);</PRE><P> </P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-INFO-SCHEMA-TABLE"></A><P><B>&#34920; 9-53. 模式可见性查询函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_collation_is_visible(<TT CLASS="PARAMETER">collation_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该排序是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_conversion_is_visible(<TT CLASS="PARAMETER">conversion_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该转换是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_function_is_visible(<TT CLASS="PARAMETER">function_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该函数是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_opclass_is_visible(<TT CLASS="PARAMETER">opclass_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该操作符类是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_operator_is_visible(<TT CLASS="PARAMETER">operator_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该操作符是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_opfamily_is_visible(<TT CLASS="PARAMETER">opclass_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该操作符族是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_table_is_visible(<TT CLASS="PARAMETER">table_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该表是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_ts_config_is_visible(<TT CLASS="PARAMETER">config_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该文本检索配置是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_ts_dict_is_visible(<TT CLASS="PARAMETER">dict_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该文本检索词典是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_ts_parser_is_visible(<TT CLASS="PARAMETER">parser_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该文本搜索解析是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_ts_template_is_visible(<TT CLASS="PARAMETER">template_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该文本检索模板是否在搜索路径中可见</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_type_is_visible(<TT CLASS="PARAMETER">type_oid</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>该类型（或域）是否在搜索路径中可见</TD></TR></TBODY></TABLE></DIV><P>每个函数执行一种数据库对象类型的可见性检查。请注意<CODE CLASS="FUNCTION">pg_table_is_visible</CODE>
还可用于视图、索引、序列。<CODE CLASS="FUNCTION">pg_type_is_visible</CODE>还可用于域。
对于函数和操作符，如果在搜索路径中没有名字相同并且<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">参数的数据类型</I></SPAN>
也相同的对象出现在路径中更靠前的位置，那么该对象就是可见的。对于操作符类，
则要同时考虑名字和相关的索引访问方法。</P><P>所有这些函数都需要使用 OID 来标识要被检查的对象。如果你想通过名字测试对象，
那么使用 OID 别名类型(<TT CLASS="TYPE">regclass</TT>, <TT CLASS="TYPE">regtype</TT>, <TT CLASS="TYPE">regprocedure</TT>,
<TT CLASS="TYPE">regoperator</TT>, <TT CLASS="TYPE">regconfig</TT>或<TT CLASS="TYPE">regdictionary</TT>)将会很方便。例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT pg_type_is_visible('myschema.widget'::regtype);</PRE><P>
请注意用这种方法测试一个未经修饰的名字没什么意义，因为如果一个名字可以被识别，
那它首先必须是可见的。</P><P><A HREF="functions-info.html#FUNCTIONS-INFO-CATALOG-TABLE">&#34920; 9-54</A>列出了从系统表中抽取信息的函数。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-INFO-CATALOG-TABLE"></A><P><B>&#34920; 9-54. 系统表信息函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">format_type(<TT CLASS="PARAMETER">type_oid</TT>, <TT CLASS="PARAMETER">typemod</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个数据类型的 SQL 名称</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_describe_object(<TT CLASS="PARAMETER">catalog_id</TT>, <TT CLASS="PARAMETER">object_id</TT>, <TT CLASS="PARAMETER">object_sub_id</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个数据库对象的描述</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_identify_object(<TT CLASS="PARAMETER">catalog_id</TT> <TT CLASS="TYPE">oid</TT>, <TT CLASS="PARAMETER">object_id</TT> <TT CLASS="TYPE">oid</TT>, <TT CLASS="PARAMETER">object_sub_id</TT> <TT CLASS="TYPE">integer</TT>)</CODE></TT></TD><TD><TT CLASS="PARAMETER">type</TT> <TT CLASS="TYPE">text</TT>, <TT CLASS="PARAMETER">schema</TT> <TT CLASS="TYPE">text</TT>, <TT CLASS="PARAMETER">name</TT> <TT CLASS="TYPE">text</TT>, <TT CLASS="PARAMETER">identity</TT> <TT CLASS="TYPE">text</TT></TD><TD>获取一个数据库对象的身份</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_constraintdef(<TT CLASS="PARAMETER">constraint_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个约束的定义</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_constraintdef(<TT CLASS="PARAMETER">constraint_oid</TT>, <TT CLASS="PARAMETER">pretty_bool</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个约束的定义</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_expr(<TT CLASS="PARAMETER">pg_node_tree</TT>, <TT CLASS="PARAMETER">relation_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>反编译一个表达式的内部形式，假设其中的任何 Var 都引用第二个参数指出的关系</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_expr(<TT CLASS="PARAMETER">pg_node_tree</TT>, <TT CLASS="PARAMETER">relation_oid</TT>, <TT CLASS="PARAMETER">pretty_bool</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>反编译一个表达式的内部形式，假设其中的任何 Var 都引用第二个参数指出的关系</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_functiondef(<TT CLASS="PARAMETER">func_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个函数的定义</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_function_arguments(<TT CLASS="PARAMETER">func_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取函数定义的参数列表（带默认值）</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_function_identity_arguments(<TT CLASS="PARAMETER">func_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取参数列表来确定一个函数 (不带默认值)</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_function_result(<TT CLASS="PARAMETER">func_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取函数的<TT CLASS="LITERAL">RETURNS</TT>子句</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_indexdef(<TT CLASS="PARAMETER">index_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取索引的<TT CLASS="COMMAND">CREATE INDEX</TT>命令</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_indexdef(<TT CLASS="PARAMETER">index_oid</TT>, <TT CLASS="PARAMETER">column_no</TT>, <TT CLASS="PARAMETER">pretty_bool</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取索引的<TT CLASS="COMMAND">CREATE INDEX</TT>命令，如果<TT CLASS="PARAMETER">column_no</TT>不为零，
则只获取一个索引字段的定义。</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_keywords()</CODE></TT></TD><TD><TT CLASS="TYPE">setof record</TT></TD><TD>获取SQL关键字和类别列表</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_ruledef(<TT CLASS="PARAMETER">rule_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为规则获取<TT CLASS="COMMAND">CREATE RULE</TT>命令</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_ruledef(<TT CLASS="PARAMETER">rule_oid</TT>, <TT CLASS="PARAMETER">pretty_bool</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为规则获取<TT CLASS="COMMAND">CREATE RULE</TT>命令</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_serial_sequence(<TT CLASS="PARAMETER">table_name</TT>, <TT CLASS="PARAMETER">column_name</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个<TT CLASS="TYPE">serial</TT>，<TT CLASS="TYPE">smallserial</TT>或<TT CLASS="TYPE">bigserial</TT>字段使用的序列名</TD></TR><TR><TD><CODE CLASS="FUNCTION">pg_get_triggerdef</CODE>(<TT CLASS="PARAMETER">trigger_oid</TT>)</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为触发器获取<TT CLASS="COMMAND">CREATE [ CONSTRAINT ] TRIGGER</TT>命令 </TD></TR><TR><TD><CODE CLASS="FUNCTION">pg_get_triggerdef</CODE>(<TT CLASS="PARAMETER">trigger_oid</TT>, <TT CLASS="PARAMETER">pretty_bool</TT>)</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为触发器获取<TT CLASS="COMMAND">CREATE [ CONSTRAINT ] TRIGGER</TT>命令 </TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_userbyid(<TT CLASS="PARAMETER">role_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">name</TT></TD><TD>获取给定 OID 的角色名</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_viewdef(<TT CLASS="PARAMETER">view_name</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为视图或物化视图获取底层的<TT CLASS="COMMAND">SELECT</TT>命令(<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">已废弃</I></SPAN>)</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_viewdef(<TT CLASS="PARAMETER">view_name</TT>, <TT CLASS="PARAMETER">pretty_bool</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为视图或物化视图获取底层的<TT CLASS="COMMAND">SELECT</TT>命令(<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">已废弃</I></SPAN>)</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_viewdef(<TT CLASS="PARAMETER">view_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为视图或物化视图获取底层的<TT CLASS="COMMAND">SELECT</TT>命令</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_viewdef(<TT CLASS="PARAMETER">view_oid</TT>, <TT CLASS="PARAMETER">pretty_bool</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为视图或物化视图获取底层的<TT CLASS="COMMAND">SELECT</TT>命令</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_get_viewdef(<TT CLASS="PARAMETER">view_oid</TT>, <TT CLASS="PARAMETER">wrap_column_int</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>为视图或物化视图获取底层的<TT CLASS="COMMAND">SELECT</TT>命令；行字段被换到指定的列数，打印是隐含的</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_options_to_table(<TT CLASS="PARAMETER">reloptions</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">setof record</TT></TD><TD>获取存储选项名称/值对的集合</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_tablespace_databases(<TT CLASS="PARAMETER">tablespace_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">setof oid</TT></TD><TD>获取在指定的表空间有元素的数据库 OID 集合</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_tablespace_location(<TT CLASS="PARAMETER">tablespace_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取表空间所在的文件系统的路径</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">pg_typeof(<TT CLASS="PARAMETER">any</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">regtype</TT></TD><TD>获取任何值的数据类型</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">collation for (<TT CLASS="PARAMETER">any</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取参数的排序</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">format_type</CODE>通过某个数据类型的类型 OID 以及可能的类型修饰词返回其 SQL 名称。
如果不知道具体的修饰词，那么在类型修饰词的位置传入 NULL 。</P><P><CODE CLASS="FUNCTION">pg_get_keywords</CODE>返回一组记录描述服务器识别的 SQL 关键字。
<TT CLASS="STRUCTFIELD">word</TT>列包含关键字。<TT CLASS="STRUCTFIELD">catcode</TT>列包含一个分类代码：
<TT CLASS="LITERAL">U</TT>通用的，<TT CLASS="LITERAL">C</TT>列名，<TT CLASS="LITERAL">T</TT>类型或函数名，或<TT CLASS="LITERAL">R</TT>保留。
<TT CLASS="STRUCTFIELD">catdesc</TT>列包含了一个可能本地化描述分类的字符串。</P><P><CODE CLASS="FUNCTION">pg_get_constraintdef</CODE>，<CODE CLASS="FUNCTION">pg_get_indexdef</CODE>，
<CODE CLASS="FUNCTION">pg_get_ruledef</CODE>，和<CODE CLASS="FUNCTION">pg_get_triggerdef</CODE>
分别从一个约束、索引、规则或触发器上重新构造创建它们的命令(反编译的重新构造，
而不是该命令的原文)。<CODE CLASS="FUNCTION">pg_get_expr</CODE>反编译一个独立表达式的内部形式，
比如一个字段的缺省值。在检查系统表的内容的时候很有用。如果表达式可能包含Var，
那么指定他们参考的关联的OID为第二个参数；如果没有Var，0就足够了。
<CODE CLASS="FUNCTION">pg_get_viewdef</CODE>重新构造出定义视图的<TT CLASS="COMMAND">SELECT</TT>查询。
这些函数大多数都有两个变种，其中一个是<SPAN CLASS="QUOTE">"适合打印"</SPAN>的结果。这种格式更容易读，
但是缺省的格式更有可能被将来的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>版本用同样的方法解释；
如果是用于转储，那么尽可能避免使用适合打印的格式。给 pretty-print参数传递<TT CLASS="LITERAL">false</TT>
生成的结果和没有这个参数的变种生成的结果是完全一样。</P><P><CODE CLASS="FUNCTION">pg_get_functiondef</CODE>为函数返回一个完整的<TT CLASS="COMMAND">CREATE OR REPLACE FUNCTION</TT>语句。
<CODE CLASS="FUNCTION">pg_get_function_arguments</CODE>返回一个函数的参数列表，
这种格式需要在<TT CLASS="COMMAND">CREATE FUNCTION</TT>中使用。<CODE CLASS="FUNCTION">pg_get_function_result</CODE>
为函数简单的返回适当的<TT CLASS="LITERAL">RETURNS</TT>子句。<CODE CLASS="FUNCTION">pg_get_function_identity_arguments</CODE>
返回需要的参数列表以标识函数，这种格式需要在<TT CLASS="COMMAND">ALTER FUNCTION</TT>中使用。这种形式省略了默认值。</P><P><CODE CLASS="FUNCTION">pg_get_serial_sequence</CODE>返回与一个字段相关的序列名字；
如果没有任何序列与给定的字段相关则返回 NULL 。第一个输入参数是可选模式的表名，
第二个参数是列名。因为第一个参数可能是一个模式和表，它不是视为一个双引号的标识符，
意味着默认情况下小写，而第二个参数只是列名称，被视为双引号括起来的，并保留其大小写。
这个名字经过了合适的格式化，可以传递给序列函数(参阅<A HREF="functions-sequence.html">第 9.16 &#33410;</A>)。
这种相关性可以通过<TT CLASS="COMMAND">ALTER SEQUENCE OWNED BY</TT>修改或删除。
（其实将这个函数命名为<CODE CLASS="FUNCTION">pg_get_owned_sequence</CODE>或许更为妥当，
因为它的当前名字反映了它通常用于<TT CLASS="TYPE">serial</TT>或<TT CLASS="TYPE">bigserial</TT>字段的事实。）</P><P><CODE CLASS="FUNCTION">pg_get_userbyid</CODE>通过角色的 OID 抽取对应的用户名。</P><P><CODE CLASS="FUNCTION">pg_options_to_table</CODE>当通过<TT CLASS="STRUCTNAME">pg_class</TT>.<TT CLASS="STRUCTFIELD">reloptions</TT>
或<TT CLASS="STRUCTNAME">pg_attribute</TT>.<TT CLASS="STRUCTFIELD">attoptions</TT>时返回存储选项名字/值对
（<TT CLASS="LITERAL">option_name</TT>/<TT CLASS="LITERAL">option_value</TT>）的集合。</P><P><CODE CLASS="FUNCTION">pg_tablespace_databases</CODE>允许检查一个表空间的状况，
它返回在该表空间中保存了对象的数据库 OID 集合。如果这个函数返回数据行，
那么该表空间就是非空的，因此不能删除。要显示该表空间中的特定对象，
你需要把<CODE CLASS="FUNCTION">pg_tablespace_databases</CODE>
返回的数据库标识与 <TT CLASS="STRUCTNAME">pg_class</TT>表连接进行查询。</P><P><CODE CLASS="FUNCTION">pg_describe_object</CODE>返回由目录OID，对象OID和一个（或许0个）
子对象ID指定的数据库对象的描述。这个描述趋向于人类易读，并且可能是经过翻译的，取决于服务器的配置。
这有助于确定一个对象的标识存储在<TT CLASS="STRUCTNAME">pg_depend</TT>目录中。</P><P><CODE CLASS="FUNCTION">pg_identify_object</CODE>返回一个包含足够信息来唯一的标识由系统OID，
对象OID和一个（或许0个）子对象ID指定的数据库对象的行。这个信息趋向于机器易读，并且从不翻译。
<TT CLASS="PARAMETER">type</TT>标识数据库对象的类型；<TT CLASS="PARAMETER">schema</TT>是对象属于的模式名，或 <TT CLASS="LITERAL">NULL</TT>
表明对象类型不属于模式；<TT CLASS="PARAMETER">name</TT> 是对象的名字，如果需要就加上双引号，
只有在它可以用作对象的唯一标识符时使用（如果相关，跟随模式名），否则为<TT CLASS="LITERAL">NULL</TT>；
<TT CLASS="PARAMETER">identity</TT>是完整的对象身份，根据对象类型有精确的格式，并且格式内的每个部分都是模式限定的，
必要时加双引号。</P><P><CODE CLASS="FUNCTION">pg_typeof</CODE>返回传递给它的值的数据类型OID。
这可能有利于故障排除或动态构造SQL查询。函数声明返回OID别名类型的<TT CLASS="TYPE">regtype</TT>
（参阅<A HREF="datatype-oid.html">第 8.18 &#33410;</A>）；这意味着它和比较目的的OID相同但显示类型名称。例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)</PRE><P>
</P><P>表达式<TT CLASS="LITERAL">collation for</TT>返回传递给它的值的排序。例如
</P><PRE CLASS="PROGRAMLISTING">SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)</PRE><P>
值可能是引号括起来的并且模式限制的。如果没有为参数表达式排序，那么返回一个null值。
如果参数不是排序的类型，那么抛出一个错误。
</P><P><A HREF="functions-info.html#FUNCTIONS-INFO-COMMENT-TABLE">&#34920; 9-55</A>显示的函数将原来用<A HREF="sql-comment.html">COMMENT</A>
命令存储的评注抽取出来。如果没有找到，则返回 NULL 。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-INFO-COMMENT-TABLE"></A><P><B>&#34920; 9-55. 注释信息函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">col_description(<TT CLASS="PARAMETER">table_oid</TT>, <TT CLASS="PARAMETER">column_number</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个表字段的评注</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">obj_description(<TT CLASS="PARAMETER">object_oid</TT>, <TT CLASS="PARAMETER">catalog_name</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个数据库对象的评注</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">obj_description(<TT CLASS="PARAMETER">object_oid</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个数据库对象的评注(<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">已废弃</I></SPAN>)</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">shobj_description(<TT CLASS="PARAMETER">object_oid</TT>, <TT CLASS="PARAMETER">catalog_name</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">text</TT></TD><TD>获取一个共享数据库对象的评注</TD></TR></TBODY></TABLE></DIV><P><CODE CLASS="FUNCTION">col_description</CODE>返回一个表中字段的评注，它是通过表 OID 和字段号来声明的。
<CODE CLASS="FUNCTION">obj_description</CODE>不能用于表字段，因为字段没有自己的 OID 。&#13;</P><P>带有两个参数的<CODE CLASS="FUNCTION">obj_description</CODE>返回一个数据库对象的评注，
该对象是通过其 OID 和其所属的系统表名字声明的。比如，<TT CLASS="LITERAL">obj_description(123456,'pg_class')</TT>
将返回 OID 为 12345 的表的评注。只带一个参数的<CODE CLASS="FUNCTION">obj_description</CODE>
只要求对象 OID ，现在已经废弃了，因为我们不再保证 OID 在不同的系统表之间是唯一的，
因此可能会返回错误的评注。</P><P><CODE CLASS="FUNCTION">shobj_description</CODE>和<CODE CLASS="FUNCTION">obj_description</CODE>差不多，
不同之处仅在于前者用于共享对象。一些系统表是通用于集群中所有数据库的全局表，
因此这些表的评注也是全局存储的。</P><P><A HREF="functions-info.html#FUNCTIONS-TXID-SNAPSHOT">&#34920; 9-56</A>显示的函数在一个输出形式中提供服务器事务信息。
这些函数的主要用途是为了确定在两个快照之间有哪个事务提交。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-TXID-SNAPSHOT"></A><P><B>&#34920; 9-56. 事务ID和快照</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>名字</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">txid_current()</CODE></TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>获取当前事务 ID</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">txid_current_snapshot()</CODE></TT></TD><TD><TT CLASS="TYPE">txid_snapshot</TT></TD><TD>获取当前快照</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">txid_snapshot_xip(<TT CLASS="PARAMETER">txid_snapshot</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">setof bigint</TT></TD><TD>获取在快照中进行中的事务ID</TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">txid_snapshot_xmax(<TT CLASS="PARAMETER">txid_snapshot</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>获取快照的 <TT CLASS="LITERAL">xmax</TT></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">txid_snapshot_xmin(<TT CLASS="PARAMETER">txid_snapshot</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">bigint</TT></TD><TD>获取快照的<TT CLASS="LITERAL">xmin</TT></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">txid_visible_in_snapshot(<TT CLASS="PARAMETER">bigint</TT>, <TT CLASS="PARAMETER">txid_snapshot</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>在快照中事务ID是否可见？(不使用子事务ID)</TD></TR></TBODY></TABLE></DIV><P>内部事务 ID 类型(<TT CLASS="TYPE">xid</TT>)是32位，每40亿事务循环。然而这些函数导出一个64位格式，
是使用一个<SPAN CLASS="QUOTE">"epoch"</SPAN>计数器扩展，所以在安装过程中不会循环。
这些函数使用的数据类型<TT CLASS="TYPE">txid_snapshot</TT>，存储在某时刻事物ID可见性的信息。
其组件描述在<A HREF="functions-info.html#FUNCTIONS-TXID-SNAPSHOT-PARTS">&#34920; 9-57</A>。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-TXID-SNAPSHOT-PARTS"></A><P><B>&#34920; 9-57. 快照组件</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><THEAD><TR><TH>名字</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="TYPE">xmin</TT></TD><TD> 最早的事务ID（txid）仍然活动。所有较早事务将是可见提交了，或者要么死掉回滚了。
</TD></TR><TR><TD><TT CLASS="TYPE">xmax</TT></TD><TD> 首先作为尚未分配的txid。所有大于或等于此的txids作为这时的快照都是尚未开始的，因此不可见。
</TD></TR><TR><TD><TT CLASS="TYPE">xip_list</TT></TD><TD> 在当前快照活动的txids。这个列表只包含在<TT CLASS="LITERAL">xmin</TT>和<TT CLASS="LITERAL">xmax</TT>
之间的活动txids；有可能活动的txids高于<TT CLASS="LITERAL">xmax</TT>。
一个<TT CLASS="LITERAL">xmin &lt;= txid &lt; xmax</TT>，并且不在这个列表中的txid，
是在快照的这个时间已经完成的，因此要么可见或死掉对应它的提交状态。
这个列表不包含子事务的txids。
</TD></TR></TBODY></TABLE></DIV><P><TT CLASS="TYPE">txid_snapshot</TT>的文本表示为：<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>xmin</I></TT>:<TT CLASS="REPLACEABLE"><I>xmax</I></TT>:<TT CLASS="REPLACEABLE"><I>xip_list</I></TT></TT>。
例如<TT CLASS="LITERAL">10:20:10,14,15</TT>意思为：<TT CLASS="LITERAL">xmin=10, xmax=20, xip_list=10, 14, 15</TT>。</P></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="functions-srf.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="functions-admin.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">返回集合的函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">系统管理函数</TD></TR></TABLE></DIV></BODY></HTML>
