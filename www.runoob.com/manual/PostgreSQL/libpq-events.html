<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>事件系统</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="libpq - C 库" HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html"><LINK REL="PREVIOUS" TITLE="注意信息处理" HREF="libpq-notice-processing.html"><LINK REL="NEXT" TITLE="环境变量" HREF="libpq-envars.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/libpq.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="注意信息处理" HREF="libpq-notice-processing.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 31. <SPAN CLASS="APPLICATION">libpq</SPAN> - C 库</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="环境变量" HREF="libpq-envars.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="LIBPQ-EVENTS">31.13. 事件系统</A></H1><P><SPAN CLASS="APPLICATION">libpq</SPAN>事件系统用于通知对<SPAN CLASS="APPLICATION">libpq</SPAN>
事件感兴趣的注册事件处理过程，如创建或删除<TT CLASS="STRUCTNAME">PGconn</TT>和
<TT CLASS="STRUCTNAME">PGresult</TT>对象。一个主要的使用原因是，它允许应用程序通过一个
<TT CLASS="STRUCTNAME">PGconn</TT>或<TT CLASS="STRUCTNAME">PGresult</TT>关联它们自己的数据，
并且确保数据在适当的时候释放。</P><P>每个注册的事件处理程序与两片数据相关联，已知的<SPAN CLASS="APPLICATION">libpq</SPAN>
只作为不透明的<TT CLASS="LITERAL">void *</TT>指针。当事件处理程序注册带有<TT CLASS="STRUCTNAME">PGconn</TT>时，
应用程序会提供一个<I CLASS="FIRSTTERM">passthrough</I>指针。传递指针在由它产生的<TT CLASS="STRUCTNAME">PGconn</TT>
和所有的<TT CLASS="STRUCTNAME">PGresult</TT>的生命周期中永远不会改变，它指向生命周期长的数据。
除此之外，还有一个<I CLASS="FIRSTTERM">instance data</I>指针，它从每个<TT CLASS="STRUCTNAME">PGconn</TT>和
<TT CLASS="STRUCTNAME">PGresult</TT>中的<TT CLASS="SYMBOL">NULL</TT>开始。这个指针可以与<CODE CLASS="FUNCTION">PQinstanceData</CODE>，
<CODE CLASS="FUNCTION">PQsetInstanceData</CODE>，<CODE CLASS="FUNCTION">PQresultInstanceData</CODE>和
<CODE CLASS="FUNCTION">PQsetResultInstanceData</CODE>函数一起使用。需要注意的是不同于传递指针，
一个<TT CLASS="STRUCTNAME">PGconn</TT>的实例数据不会被由它产生的<TT CLASS="STRUCTNAME">PGresult</TT>自动继承。
<SPAN CLASS="APPLICATION">libpq</SPAN>不知道传递和实例数据指针指向的是什么，并且不会尝试去释放它们；
这对事件处理程序是一种保证。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EVENTS-TYPES">31.13.1. 事件类型</A></H2><P>枚举<TT CLASS="LITERAL">PGEventId</TT>命名事件系统处理的事件的类型。所有的命名值都是从
<TT CLASS="LITERAL">PGEVT</TT>开始。对每个事件类型来说，有一个相应的事件信息结构，
用于传送传递给事件处理程序的参数。事件类型如下：</P><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PGEVT-REGISTER"></A><TT CLASS="LITERAL">PGEVT_REGISTER</TT></DT><DD><P>当调用<CODE CLASS="FUNCTION">PQregisterEventProc</CODE>时，会发生注册的事件。这是一个理想化的时间，
用于初始化任意<TT CLASS="LITERAL">instanceData</TT>，可能需要一个事件过程。
每次连接中的每个事件处理程序只会触发一个注册了的事件。如果事件过程失败，会终止注册。
</P><PRE CLASS="SYNOPSIS">typedef struct
{
    PGconn *conn;
} PGEventRegister;</PRE><P>
当接收到<TT CLASS="LITERAL">PGEVT_REGISTER</TT>时，<TT CLASS="PARAMETER">evtInfo</TT>
指针应该被转换为一个<TT CLASS="STRUCTNAME">PGEventRegister *</TT>。
这个结构包含了一个<TT CLASS="LITERAL">CONNECTION_OK</TT>状态的<TT CLASS="STRUCTNAME">PGconn</TT>；
用以保证在获得一个好的<TT CLASS="STRUCTNAME">PGconn</TT>之后立即请求调用
<CODE CLASS="FUNCTION">PQregisterEventProc</CODE>。当返回一个错误代码时，必须执行所有的清理，
因为没有<TT CLASS="LITERAL">PGEVT_CONNDESTROY</TT>会被发送。
</P></DD><DT><A NAME="LIBPQ-PGEVT-CONNRESET"></A><TT CLASS="LITERAL">PGEVT_CONNRESET</TT></DT><DD><P><CODE CLASS="FUNCTION">PQreset</CODE>或<CODE CLASS="FUNCTION">PQresetPoll</CODE>函数完成时，触发连接复位事件。
在这两种情况下，只有重置成功时才会触发事件。如果事件过程失败，整个连接复位都会失败；
<TT CLASS="STRUCTNAME">PGconn</TT>被置为<TT CLASS="LITERAL">CONNECTION_BAD</TT>状态并且
<CODE CLASS="FUNCTION">PQresetPoll</CODE>将返回<TT CLASS="LITERAL">PGRES_POLLING_FAILED</TT>。
</P><PRE CLASS="SYNOPSIS">typedef struct
{
    PGconn *conn;
} PGEventConnReset;</PRE><P>
当接收到一个<TT CLASS="LITERAL">PGEVT_CONNRESET</TT>事件时，<TT CLASS="PARAMETER">evtInfo</TT>
指针应该被转换为一个<TT CLASS="STRUCTNAME">PGEventConnReset *</TT>。尽管包含的
<TT CLASS="STRUCTNAME">PGconn</TT>被重置了，但所有事件数据不会改变。
这个事件应该用于reset/reload/requery任何关联的<TT CLASS="LITERAL">instanceData</TT>。
需要注意的是即使事件过程在处理<TT CLASS="LITERAL">PGEVT_CONNRESET</TT>时失败了，当连接关闭时，
仍会接收一个<TT CLASS="LITERAL">PGEVT_CONNDESTROY</TT>事件。
</P></DD><DT><A NAME="LIBPQ-PGEVT-CONNDESTROY"></A><TT CLASS="LITERAL">PGEVT_CONNDESTROY</TT></DT><DD><P>在响应<CODE CLASS="FUNCTION">PQfinish</CODE>时会触发连接破坏事件。这是事件过程的职责：
合适的清理它的事件数据，因为libpq没有能力管理这部分内存。失败的清理会导致内存溢出。
</P><PRE CLASS="SYNOPSIS">typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;</PRE><P>
当接收到一个<TT CLASS="LITERAL">PGEVT_CONNDESTROY</TT>事件时，<TT CLASS="PARAMETER">evtInfo</TT>
指针应该被转换为一个<TT CLASS="STRUCTNAME">PGEventConnDestroy *</TT>。
在<CODE CLASS="FUNCTION">PQfinish</CODE>执行清理之前会触发该事件。事件过程的返回值会被忽略，
因为没有很好的方式从<CODE CLASS="FUNCTION">PQfinish</CODE>指出失败。同样，
一个事件过程失败不应该中止清理不需要的内存的过程。
</P></DD><DT><A NAME="LIBPQ-PGEVT-RESULTCREATE"></A><TT CLASS="LITERAL">PGEVT_RESULTCREATE</TT></DT><DD><P>回应任意产生一个结果（包括<CODE CLASS="FUNCTION">PQgetResult</CODE>）的查询执行函数时，
会触发结果创建事件。这个事件只有在成功创建结果时才会被触发。
</P><PRE CLASS="SYNOPSIS">typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;</PRE><P>
当接收到一个<TT CLASS="LITERAL">PGEVT_RESULTCREATE</TT>事件时，<TT CLASS="PARAMETER">evtInfo</TT>
指针应该被转换为一个<TT CLASS="STRUCTNAME">PGEventResultCreate *</TT>。<TT CLASS="PARAMETER">conn</TT>
是用于产生结果的连接。这是理想的位置，用于初始化任意需要与结果相关联的<TT CLASS="LITERAL">instanceData</TT>。
如果事件过程失败，结果会被清理并且传播该失败。事件过程不应该尝试自己<CODE CLASS="FUNCTION">PQclear</CODE>结果对象。
当返回一个错误代码时，必须执行所有的清理，因为没有<TT CLASS="LITERAL">PGEVT_RESULTDESTROY</TT>会被发送。
</P></DD><DT><A NAME="LIBPQ-PGEVT-RESULTCOPY"></A><TT CLASS="LITERAL">PGEVT_RESULTCOPY</TT></DT><DD><P>在响应<CODE CLASS="FUNCTION">PQcopyResult</CODE>时会触发结果拷贝事件。只有在拷贝完成时，
才会触发该事件。只有那些为源结果成功处理<TT CLASS="LITERAL">PGEVT_RESULTCREATE</TT>或
<TT CLASS="LITERAL">PGEVT_RESULTCOPY</TT>事件的事件过程才会收到<TT CLASS="LITERAL">PGEVT_RESULTCOPY</TT>事件。
</P><PRE CLASS="SYNOPSIS">typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;</PRE><P>
当接收到一个<TT CLASS="LITERAL">PGEVT_RESULTCOPY</TT>事件时，<TT CLASS="PARAMETER">evtInfo</TT>
指针应该被转换为一个<TT CLASS="STRUCTNAME">PGEventResultCopy *</TT>。<TT CLASS="PARAMETER">src</TT>
结果是当<TT CLASS="PARAMETER">dest</TT> 为拷贝目标时要进行拷贝的。这个事件用于提供一个
<TT CLASS="LITERAL">instanceData</TT>的深度拷贝，因为<TT CLASS="LITERAL">PQcopyResult</TT>做不到。
如果事件过程失败，整个拷贝过程都将失败，并且<TT CLASS="PARAMETER">dest</TT>结果也会被清理。
当返回一个错误代码时，必须执行所有的清理，因为没有<TT CLASS="LITERAL">PGEVT_RESULTDESTROY</TT>事件会被发送。
</P></DD><DT><A NAME="LIBPQ-PGEVT-RESULTDESTROY"></A><TT CLASS="LITERAL">PGEVT_RESULTDESTROY</TT></DT><DD><P>在回应<CODE CLASS="FUNCTION">PQclear</CODE>时会触发结果破坏事件。这是事件过程的责任；
合理清理它的事件数据，因为libpq没有能力管理这块内存。清理失败会导致内存溢出。
</P><PRE CLASS="SYNOPSIS">typedef struct
{
    PGresult *result;
} PGEventResultDestroy;</PRE><P>
当接收到一个<TT CLASS="LITERAL">PGEVT_RESULTDESTROY</TT>事件时，<TT CLASS="PARAMETER">evtInfo</TT>
指针应该被转换为一个<TT CLASS="STRUCTNAME">PGEventResultDestroy *</TT>。
这个事件会在<CODE CLASS="FUNCTION">PQclear</CODE>执行清理之前被触发。事件过程的返回结果会被忽略，
因为没有一个方式能够从<CODE CLASS="FUNCTION">PQclear</CODE>指出失败。同样，
一个事件过程失败不应该中止对不需要内存的清理。
</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EVENTS-PROC">31.13.2. 事件回调过程</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PGEVENTPROC"></A><TT CLASS="LITERAL">PGEventProc</TT>
</DT><DD><P><TT CLASS="LITERAL">PGEventProc</TT>是一个事件过程中指针的typedef，也就是，
从libpq接收事件的用户回调函数。事件过程的用法必须如下：
</P><PRE CLASS="SYNOPSIS">int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)</PRE><P>
<TT CLASS="PARAMETER">evtId</TT>参数指出要发生哪个<TT CLASS="LITERAL">PGEVT</TT>事件。
<TT CLASS="PARAMETER">evtInfo</TT>指针必须被转换为合适的结构类型以获取有关该事件的进一步信息。
<TT CLASS="PARAMETER">passThrough</TT>是当事件过程被注册时，提供给
<CODE CLASS="FUNCTION">PQregisterEventProc</CODE>的指针。这个函数应该返回一个非0的值，如果成功的话，反之，返回0。
</P><P>在任意<TT CLASS="STRUCTNAME">PGconn</TT>中，一个特殊的事件过程只能注册一次。
这是因为过程地址被用于作为查询关键字，以识别相关的实例数据。</P><DIV CLASS="CAUTION"><P></P><TABLE CLASS="CAUTION" BORDER="1" WIDTH="90%"><TR><TD ALIGN="CENTER"><B>&#23567;&#24515;</B></TD></TR><TR><TD ALIGN="LEFT"><P>在Windows上，函数可以有两个不同的地址：一个是内部DLL可见的，另一个是外部DLL可见的。
需要注意的是，<SPAN CLASS="APPLICATION">libpq</SPAN>事件过程函数只会使用其中一个地址，否则会造成混乱。
有效的编写代码的简单规则是为了保证事件过程声明为<TT CLASS="LITERAL">static</TT>。
如果过程地址在它的源文件之外是可用的，公开一个单独的函数以返回地址。</P></TD></TR></TABLE></DIV></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EVENTS-FUNCS">31.13.3. 事件支持函数</A></H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><A NAME="LIBPQ-PQREGISTEREVENTPROC"></A><CODE CLASS="FUNCTION">PQregisterEventProc</CODE>
</DT><DD><P>用libpq注册一个事件回调过程。
</P><PRE CLASS="SYNOPSIS">int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);</PRE><P>
</P><P>在每个<TT CLASS="STRUCTNAME">PGconn</TT>中必须注册一次事件过程，用于希望接受到的事件。除了内存之外，
对于一次连接注册的事件过程个数没有限制。如果成功，则返回一个非0的值，否则返回0。</P><P>当一个libpq事件被触发时，会调用一个<TT CLASS="PARAMETER">proc</TT>参数。
内存地址同样会被用于查找<TT CLASS="LITERAL">instanceData</TT>。<TT CLASS="PARAMETER">name</TT>
用于指出在错误信息中的事件过程。这个值不能为<TT CLASS="SYMBOL">NULL</TT>或一个长度为0的字符串。
名字字符串被拷贝到<TT CLASS="STRUCTNAME">PGconn</TT>中，因此被传递的不需要拥有很长的生命周期。
<TT CLASS="PARAMETER">passThrough</TT>指针被传递到<TT CLASS="PARAMETER">proc</TT>，
不管何时触发事件。这个参数可以是<TT CLASS="SYMBOL">NULL</TT>。</P></DD><DT><A NAME="LIBPQ-PQSETINSTANCEDATA"></A><CODE CLASS="FUNCTION">PQsetInstanceData</CODE>
</DT><DD><P>为<TT CLASS="PARAMETER">proc</TT>到<TT CLASS="PARAMETER">data</TT>的过程设置连接<TT CLASS="PARAMETER">conn</TT>
的<TT CLASS="LITERAL">instanceData</TT>。成功则返回一个非0值，否则返回0。
只有<TT CLASS="PARAMETER">proc</TT>没有成功在<TT CLASS="PARAMETER">conn</TT>注册时才会发生失败。
</P><PRE CLASS="SYNOPSIS">int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQINSTANCEDATA"></A><CODE CLASS="FUNCTION">PQinstanceData</CODE>
</DT><DD><P>返回与<TT CLASS="PARAMETER">proc</TT>过程，或<TT CLASS="SYMBOL">NULL</TT>（如果存在空）
相关的<TT CLASS="PARAMETER">conn</TT>的<TT CLASS="LITERAL">instanceData</TT>。
</P><PRE CLASS="SYNOPSIS">void *PQinstanceData(const PGconn *conn, PGEventProc proc);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQRESULTSETINSTANCEDATA"></A><CODE CLASS="FUNCTION">PQresultSetInstanceData</CODE>
</DT><DD><P>为<TT CLASS="PARAMETER">proc</TT>到<TT CLASS="PARAMETER">data</TT>的过程设置结果的<TT CLASS="LITERAL">instanceData</TT>。
成功则返回一个非0值，否则返回0。只有<TT CLASS="PARAMETER">proc</TT>没有成功在结果注册时才会发生失败。
</P><PRE CLASS="SYNOPSIS">int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);</PRE><P>
</P></DD><DT><A NAME="LIBPQ-PQRESULTINSTANCEDATA"></A><CODE CLASS="FUNCTION">PQresultInstanceData</CODE>
</DT><DD><P>返回与<TT CLASS="PARAMETER">proc</TT>过程，或<TT CLASS="SYMBOL">NULL</TT>（如果存在空）相关的结果的<TT CLASS="LITERAL">instanceData</TT>。
</P><PRE CLASS="SYNOPSIS">void *PQresultInstanceData(const PGresult *res, PGEventProc proc);</PRE><P>
</P></DD></DL></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="LIBPQ-EVENTS-EXAMPLE">31.13.4. 事件例子</A></H2><P>一个管理与libpq连接和结果相关的私有数据的例子：</P><PRE CLASS="PROGRAMLISTING">/* &#60;!-- required header for libpq events (note: includes libpq-fe.h) --&#62;需要libpq事件的头文件 (注意：包括 libpq-fe.h) */
#include &#60;libpq-events.h&#62;

/* The instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    &#60;!--
/* called once on any connection that should receive events.
     * Sends a PGEVT_REGISTER to myEventProc.
     */
 --&#62;
 /* 在任何应该接收事件的连接上调用一次。
     * 发送一个 PGEVT_REGISTER 到 myEventProc。
     */

    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    &#60;!-- /* conn instanceData is available */ --&#62; 
/* conn instanceData 是可用的 */
    data = PQinstanceData(conn, myEventProc);

    &#60;!-- /* Sends a PGEVT_RESULTCREATE to myEventProc */ --&#62;
/* 发送一个 PGEVT_RESULTCREATE 到 myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    &#60;!-- /* result instanceData is available */ --&#62;
/* 结果 instanceData 是可用的 */
    data = PQresultInstanceData(res, myEventProc);

    &#60;!-- /* If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc */ --&#62;
 /* 如果使用了 PG_COPYRES_EVENTS，发送一个 PGEVT_RESULTCOPY到 myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    &#60;!--
/* result instanceData is available if PG_COPYRES_EVENTS was
     * used during the PQcopyResult call.
     */
 --&#62;
 /* 结果 instanceData 是可用的，如果 PG_COPYRES_EVENTS 
     * 在PQcopyResult调用期间使用了的话。
     */
    data = PQresultInstanceData(res_copy, myEventProc);

    &#60;!-- /* Both clears send a PGEVT_RESULTDESTROY to myEventProc */ --&#62;
/* 两个clears都发送 PGEVT_RESULTDESTROY 到 myEventProc */
    PQclear(res);
    PQclear(res_copy);

    &#60;!-- /* Sends a PGEVT_CONNDESTROY to myEventProc */ --&#62;
/* 发送一个 PGEVT_CONNDESTROY 到 myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e-&#62;conn);

            &#60;!-- /* associate app specific data with connection */ --&#62;
/* 将应用程序特定的数据与连接相关联 */
            PQsetInstanceData(e-&#62;conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e-&#62;conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e-&#62;conn, myEventProc);

            &#60;!-- /* free instance data because the conn is being destroyed */ --&#62;
/* 释放实例数据，因为conn被破坏了 */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e-&#62;conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            &#60;!-- /* associate app specific data with result (copy it from conn) */ --&#62;
/* 将应用程序特定的数据与结果相关联 (从conn中拷贝) */
            PQsetResultInstanceData(e-&#62;result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e-&#62;src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            &#60;!-- /* associate app specific data with result (copy it from a result) */ --&#62;
/*将应用程序特定的数据与结果相关联 (从结果中拷贝)*/
            PQsetResultInstanceData(e-&#62;dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e-&#62;result, myEventProc);

            &#60;!-- /* free instance data because the result is being destroyed */ --&#62;
/* 释放实例数据，因为结果被破坏了 */
            if (data)
              free_mydata(data);
            break;
        }

        &#60;!-- /* unknown event ID, just return TRUE. */ --&#62;
/* 未知事件ID，只是返回TRUE。*/
        default:
            break;
    }

    return TRUE; /* &#60;!-- event processing succeeded --&#62;事件处理成功 */
}</PRE></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="libpq-notice-processing.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="libpq-envars.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">注意信息处理</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/libpq.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">环境变量</TD></TR></TABLE></DIV></BODY></HTML>
