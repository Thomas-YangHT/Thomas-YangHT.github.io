<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>时间/日期函数和操作符</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="函数和操作符" HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html"><LINK REL="PREVIOUS" TITLE="数据类型格式化函数" HREF="functions-formatting.html"><LINK REL="NEXT" TITLE="支持枚举函数" HREF="functions-enum.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/func.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="数据类型格式化函数" HREF="functions-formatting.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 9. 函数和操作符</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="支持枚举函数" HREF="functions-enum.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="FUNCTIONS-DATETIME">9.9. 时间/日期函数和操作符</A></H1><P><A HREF="functions-datetime.html#FUNCTIONS-DATETIME-TABLE">&#34920; 9-27</A>显示了可以用于处理日期/时间数值的函数，
随后一节里描述了细节。<A HREF="functions-datetime.html#OPERATORS-DATETIME-TABLE">&#34920; 9-26</A>
演示了基本算术操作符的行为(<TT CLASS="LITERAL">+</TT>,<TT CLASS="LITERAL">*</TT>, 等)。
而与格式化相关的函数，可以参考<A HREF="functions-formatting.html">第 9.8 &#33410;</A>。
你应该很熟悉<A HREF="datatype-datetime.html">第 8.5 &#33410;</A>的日期/时间数据类型的背景知识。</P><P>所有下述函数和操作符接收的<TT CLASS="TYPE">time</TT>或<TT CLASS="TYPE">timestamp</TT>输入实际上都来自两种可能：
一种是接收<TT CLASS="TYPE">time with time zone</TT>或<TT CLASS="TYPE">timestamp with time zone</TT>，
另外一种是接收<TT CLASS="TYPE">time without time zone</TT>或<TT CLASS="TYPE">timestamp without time zone</TT>。
出于简化考虑，这些变种没有独立显示出来。还有，<TT CLASS="LITERAL">+</TT>和<TT CLASS="LITERAL">*</TT>
操作符都是以可交换的操作符对(比如，date + integer 和 integer + date)；
我们只显示了这样的交换操作符对中的一个。</P><DIV CLASS="TABLE"><A NAME="OPERATORS-DATETIME-TABLE"></A><P><B>&#34920; 9-26. 日期/时间操做符</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>操作符</TH><TH>例子</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL">+</TT> </TD><TD><TT CLASS="LITERAL">date '2001-09-28' + integer '7'</TT></TD><TD><TT CLASS="LITERAL">date '2001-10-05'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">+</TT> </TD><TD><TT CLASS="LITERAL">date '2001-09-28' + interval '1 hour'</TT></TD><TD><TT CLASS="LITERAL">timestamp '2001-09-28 01:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">+</TT> </TD><TD><TT CLASS="LITERAL">date '2001-09-28' + time '03:00'</TT></TD><TD><TT CLASS="LITERAL">timestamp '2001-09-28 03:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">+</TT> </TD><TD><TT CLASS="LITERAL">interval '1 day' + interval '1 hour'</TT></TD><TD><TT CLASS="LITERAL">interval '1 day 01:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">+</TT> </TD><TD><TT CLASS="LITERAL">timestamp '2001-09-28 01:00' + interval '23 hours'</TT></TD><TD><TT CLASS="LITERAL">timestamp '2001-09-29 00:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">+</TT> </TD><TD><TT CLASS="LITERAL">time '01:00' + interval '3 hours'</TT></TD><TD><TT CLASS="LITERAL">time '04:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">- interval '23 hours'</TT></TD><TD><TT CLASS="LITERAL">interval '-23:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">date '2001-10-01' - date '2001-09-28'</TT></TD><TD><TT CLASS="LITERAL">integer '3'</TT> (days)</TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">date '2001-10-01' - integer '7'</TT></TD><TD><TT CLASS="LITERAL">date '2001-09-24'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">date '2001-09-28' - interval '1 hour'</TT></TD><TD><TT CLASS="LITERAL">timestamp '2001-09-27 23:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">time '05:00' - time '03:00'</TT></TD><TD><TT CLASS="LITERAL">interval '02:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">time '05:00' - interval '2 hours'</TT></TD><TD><TT CLASS="LITERAL">time '03:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">timestamp '2001-09-28 23:00' - interval '23 hours'</TT></TD><TD><TT CLASS="LITERAL">timestamp '2001-09-28 00:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">interval '1 day' - interval '1 hour'</TT></TD><TD><TT CLASS="LITERAL">interval '1 day -01:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">-</TT> </TD><TD><TT CLASS="LITERAL">timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</TT></TD><TD><TT CLASS="LITERAL">interval '1 day 15:00:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">*</TT> </TD><TD><TT CLASS="LITERAL">900 * interval '1 second'</TT></TD><TD><TT CLASS="LITERAL">interval '00:15:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">*</TT> </TD><TD><TT CLASS="LITERAL">21 * interval '1 day'</TT></TD><TD><TT CLASS="LITERAL">interval '21 days'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">*</TT> </TD><TD><TT CLASS="LITERAL">double precision '3.5' * interval '1 hour'</TT></TD><TD><TT CLASS="LITERAL">interval '03:30:00'</TT></TD></TR><TR><TD> <TT CLASS="LITERAL">/</TT> </TD><TD><TT CLASS="LITERAL">interval '1 hour' / double precision '1.5'</TT></TD><TD><TT CLASS="LITERAL">interval '00:40:00'</TT></TD></TR></TBODY></TABLE></DIV><DIV CLASS="TABLE"><A NAME="FUNCTIONS-DATETIME-TABLE"></A><P><B>&#34920; 9-27. 日期/时间函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回类型</TH><TH>描述</TH><TH>例子</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">age(<TT CLASS="TYPE">timestamp</TT>, <TT CLASS="TYPE">timestamp</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">interval</TT></TD><TD>减去参数后的<SPAN CLASS="QUOTE">"符号化"</SPAN>结果</TD><TD><TT CLASS="LITERAL">age(timestamp '2001-04-10', timestamp '1957-06-13')</TT></TD><TD><TT CLASS="LITERAL">43 years 9 mons 27 days</TT></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">age(<TT CLASS="TYPE">timestamp</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">interval</TT></TD><TD>从<CODE CLASS="FUNCTION">current_date</CODE>减去参数后的结果（在午夜）</TD><TD><TT CLASS="LITERAL">age(timestamp '1957-06-13')</TT></TD><TD><TT CLASS="LITERAL">43 years 8 mons 3 days</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">clock_timestamp()</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>实时时钟的当前时间戳（在语句执行时变化）；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_date</CODE></TT>
</TD><TD><TT CLASS="TYPE">date</TT></TD><TD>当前的日期；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_time</CODE></TT>
</TD><TD><TT CLASS="TYPE">time with time zone</TT></TD><TD>当日时间；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">current_timestamp</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>当前事务开始时的时间戳；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">date_part(<TT CLASS="TYPE">text</TT>, <TT CLASS="TYPE">timestamp</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>获取子域(等效于<CODE CLASS="FUNCTION">extract</CODE>)；又见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT">第 9.9.1 &#33410;</A>
</TD><TD><TT CLASS="LITERAL">date_part('hour', timestamp '2001-02-16 20:38:40')</TT></TD><TD><TT CLASS="LITERAL">20</TT></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">date_part(<TT CLASS="TYPE">text</TT>, <TT CLASS="TYPE">interval</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>获取子域(等效于<CODE CLASS="FUNCTION">extract</CODE>)；又见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT">第 9.9.1 &#33410;</A>
</TD><TD><TT CLASS="LITERAL">date_part('month', interval '2 years 3 months')</TT></TD><TD><TT CLASS="LITERAL">3</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">date_trunc(<TT CLASS="TYPE">text</TT>, <TT CLASS="TYPE">timestamp</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp</TT></TD><TD>截断成指定的精度；又见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-TRUNC">第 9.9.2 &#33410;</A>
</TD><TD><TT CLASS="LITERAL">date_trunc('hour', timestamp '2001-02-16 20:38:40')</TT></TD><TD><TT CLASS="LITERAL">2001-02-16 20:00:00</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">extract</CODE>(<TT CLASS="PARAMETER">field</TT> from
<TT CLASS="TYPE">timestamp</TT>)</TT>
</TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>获取子域；又见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT">第 9.9.1 &#33410;</A>
</TD><TD><TT CLASS="LITERAL">extract(hour from timestamp '2001-02-16 20:38:40')</TT></TD><TD><TT CLASS="LITERAL">20</TT></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">extract</CODE>(<TT CLASS="PARAMETER">field</TT> from
<TT CLASS="TYPE">interval</TT>)</TT></TD><TD><TT CLASS="TYPE">double precision</TT></TD><TD>获取子域；又见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT">第 9.9.1 &#33410;</A>
</TD><TD><TT CLASS="LITERAL">extract(month from interval '2 years 3 months')</TT></TD><TD><TT CLASS="LITERAL">3</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">isfinite(<TT CLASS="TYPE">date</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>测试是否为有穷日期(不是 +/-无穷)</TD><TD><TT CLASS="LITERAL">isfinite(date '2001-02-16')</TT></TD><TD><TT CLASS="LITERAL">true</TT></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">isfinite(<TT CLASS="TYPE">timestamp</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>测试是否为有穷时间戳(不是 +/-无穷)</TD><TD><TT CLASS="LITERAL">isfinite(timestamp '2001-02-16 21:28:30')</TT></TD><TD><TT CLASS="LITERAL">true</TT></TD></TR><TR><TD><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">isfinite(<TT CLASS="TYPE">interval</TT>)</CODE></TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>测试是否为有穷时间间隔</TD><TD><TT CLASS="LITERAL">isfinite(interval '4 hours')</TT></TD><TD><TT CLASS="LITERAL">true</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">justify_days(<TT CLASS="TYPE">interval</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">interval</TT></TD><TD>按照每月 30 天调整时间间隔</TD><TD><TT CLASS="LITERAL">justify_days(interval '35 days')</TT></TD><TD><TT CLASS="LITERAL">1 mon 5 days</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">justify_hours(<TT CLASS="TYPE">interval</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">interval</TT></TD><TD>按照每天 24 小时调整时间间隔</TD><TD><TT CLASS="LITERAL">justify_hours(interval '27 hours')</TT></TD><TD><TT CLASS="LITERAL">1 day 03:00:00</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">justify_interval(<TT CLASS="TYPE">interval</TT>)</CODE></TT>
</TD><TD><TT CLASS="TYPE">interval</TT></TD><TD>使用<CODE CLASS="FUNCTION">justify_days</CODE>和<CODE CLASS="FUNCTION">justify_hours</CODE>调整时间间隔的同时进行正负号调整</TD><TD><TT CLASS="LITERAL">justify_interval(interval '1 mon -1 hour')</TT></TD><TD><TT CLASS="LITERAL">29 days 23:00:00</TT></TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">localtime</CODE></TT>
</TD><TD><TT CLASS="TYPE">time</TT></TD><TD>当日时间；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">localtimestamp</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp</TT></TD><TD>当前事务开始时的时间戳；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">now()</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>当前事务开始时的时间戳；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">statement_timestamp()</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>实时时钟的当前时间戳；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">timeofday()</CODE></TT>
</TD><TD><TT CLASS="TYPE">text</TT></TD><TD>与<CODE CLASS="FUNCTION">clock_timestamp</CODE>相同，但结果是一个<TT CLASS="TYPE">text</TT>
字符串；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR><TR><TD>
<TT CLASS="LITERAL"><CODE CLASS="FUNCTION">transaction_timestamp()</CODE></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>当前事务开始时的时间戳；见<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT">第 9.9.4 &#33410;</A>
</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR></TBODY></TABLE></DIV><P>除了这些函数以外，还支持 SQL 的<TT CLASS="LITERAL">OVERLAPS</TT>操作符：
</P><PRE CLASS="SYNOPSIS">(<TT
CLASS="REPLACEABLE"
><I
>start1</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>end1</I
></TT
>) OVERLAPS (<TT
CLASS="REPLACEABLE"
><I
>start2</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>end2</I
></TT
>)
(<TT
CLASS="REPLACEABLE"
><I
>start1</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>length1</I
></TT
>) OVERLAPS (<TT
CLASS="REPLACEABLE"
><I
>start2</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>length2</I
></TT
>)</PRE><P>
这个表达式在两个时间域(用它们的终点定义)重叠的时候生成真值，在不重叠是生成假值。
终点可以用一对日期、时间、时间戳来声明；或者是一个后面跟着一个时间间隔的日期、
时间、时间戳。当提供一对值，不管先写开始还是结束；<TT CLASS="LITERAL">OVERLAPS</TT>
自动将这对值较早的作为开始。每段时间取值为半开区间<TT CLASS="REPLACEABLE"><I>开始</I></TT> <TT CLASS="LITERAL">&lt;=</TT>
<TT CLASS="REPLACEABLE"><I>时间</I></TT> <TT CLASS="LITERAL">&lt;</TT> <TT CLASS="REPLACEABLE"><I>结束</I></TT>，除非<TT CLASS="REPLACEABLE"><I>开始</I></TT>
和<TT CLASS="REPLACEABLE"><I>结束</I></TT>相等，此时表示单一的时刻。
这意味着两个时间段只有一个共同的端点没有重叠。
</P><PRE CLASS="SCREEN">SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>true</SAMP
>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>false</SAMP
>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>false</SAMP
>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>true</SAMP
></PRE><P>当把<TT CLASS="TYPE">interval</TT>值添加到<TT CLASS="TYPE">timestamp with time zone</TT>上(或从中减去)的时候，
days 部分会按照指定的天数增加(或减少)<TT CLASS="TYPE">timestamp with time zone</TT>的日期。
对于横跨夏令时的变化(会话的时区设置被识别为夏时制)，<TT CLASS="LITERAL">interval '1 day'</TT>
并不一定等于<TT CLASS="LITERAL">interval '24 hours'</TT>。例如，当会话的时区设置为<TT CLASS="LITERAL">CST7CDT</TT>
的时候<TT CLASS="LITERAL">timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </TT>
的结果是<TT CLASS="LITERAL">timestamp with time zone '2005-04-03 12:00-06'</TT>，
而将<TT CLASS="LITERAL">interval '24 hours'</TT>增加到相同的<TT CLASS="TYPE">timestamp with time zone</TT>
之上的结果则是<TT CLASS="LITERAL">timestamp with time zone '2005-04-03 13:00-06'</TT>，
因为<TT CLASS="LITERAL">CST7CDT</TT>时区在<TT CLASS="LITERAL">2005-04-03 02:00</TT>的时候有一个夏令时变更。</P><P>注意<CODE CLASS="FUNCTION">age</CODE>返回的<TT CLASS="LITERAL">月数</TT>可能有歧义，
因为不同的月份有不同的天数。<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>的方法是当计算部分月数时，
采用两个日期较早的月。例如：<TT CLASS="LITERAL">age('2004-06-01', '2004-04-30')</TT>
使用4月份产生<TT CLASS="LITERAL">1 mon 1 day</TT>，当用5月分时产生<TT CLASS="LITERAL">1 mon 2 days</TT>，
因为5月有31天，而4月只有30天。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-DATETIME-EXTRACT">9.9.1. <CODE CLASS="FUNCTION">EXTRACT</CODE>, <CODE CLASS="FUNCTION">date_part</CODE></A></H2><PRE CLASS="SYNOPSIS">EXTRACT(<TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
> FROM <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
>)</PRE><P><CODE CLASS="FUNCTION">extract</CODE>函数从日期/时间数值里抽取子域，比如年、小时等。
<TT CLASS="REPLACEABLE"><I>source</I></TT>必须是一个<TT CLASS="TYPE">timestamp</TT>, <TT CLASS="TYPE">time</TT>,
<TT CLASS="TYPE">interval</TT>类型的值表达式(类型为<TT CLASS="TYPE">date</TT>的表达式转换为
<TT CLASS="TYPE">timestamp</TT>，因此也可以用)。<TT CLASS="REPLACEABLE"><I>field</I></TT>
是一个标识符或者字符串，它指定从源数据中抽取的域。<CODE CLASS="FUNCTION">extract</CODE>
函数返回类型为<TT CLASS="TYPE">double precision</TT>的数值。下列数值是有效数据域的名字：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">century</TT></DT><DD><P>世纪</P><PRE CLASS="SCREEN">SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>20</SAMP
>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>21</SAMP
></PRE><P>第一个世纪从 0001-01-01 00:00:00 AD 开始，尽管那时候人们还不知道这是第一个世纪。
这个定义适用于所有使用阳历的国家。没有 0 世纪，我们直接从公元前 1 世纪到公元 1 世纪。
如果你认为这个不合理，那么请把抱怨发给：梵蒂冈，罗马圣彼得教堂，教皇收。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.0 以前版本里并不遵循世纪的习惯编号，
只是把年份除以 100 。</P></DD><DT><TT CLASS="LITERAL">day</TT></DT><DD><P>对于<TT CLASS="TYPE">timestamp</TT>值，(月份)里的日期(1-31)；对于<TT CLASS="TYPE">interval</TT>，天数</P><PRE CLASS="SCREEN">SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>16</SAMP
>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>40</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">decade</TT></DT><DD><P>年份除以 10</P><PRE CLASS="SCREEN">SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>200</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">dow</TT></DT><DD><P>每周的星期号，星期天(<TT CLASS="LITERAL">0</TT>)到星期六(<TT CLASS="LITERAL">6</TT>)</P><PRE CLASS="SCREEN">SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>5</SAMP
></PRE><P>请注意，<CODE CLASS="FUNCTION">extract</CODE>的星期几编号和<CODE CLASS="FUNCTION">to_char(..., 'D')</CODE>函数不同。</P></DD><DT><TT CLASS="LITERAL">doy</TT></DT><DD><P>一年的第几天(1-365/366)</P><PRE CLASS="SCREEN">SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>47</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">epoch</TT></DT><DD><P>对于<TT CLASS="TYPE">timestamp with time zone</TT>值而言，
是自 1970-01-01 00:00:00-00 UTC以来的秒数(结果可能是负数)；
对于<TT CLASS="TYPE">date</TT>和<TT CLASS="TYPE">timestamp</TT>值而言，
是自 1970-01-01 00:00:00 当地时间以来的秒数；
对于<TT CLASS="TYPE">interval</TT>值而言，它是时间间隔的总秒数。</P><PRE CLASS="SCREEN">SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>982384720.12</SAMP
>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>442800</SAMP
></PRE><P>下面是把 epoch 值转换回时间戳的方法：</P><PRE CLASS="SCREEN">SELECT TIMESTAMP WITH TIME ZONE 'epoch' + 982384720.12 * INTERVAL '1 second';</PRE><P>（<CODE CLASS="FUNCTION">to_timestamp</CODE>函数封装上面的转换。）</P></DD><DT><TT CLASS="LITERAL">hour</TT></DT><DD><P>小时域(0-23)</P><PRE CLASS="SCREEN">SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>20</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">isodow</TT></DT><DD><P>周中的第几天 [1-7] 星期一：(<TT CLASS="LITERAL">1</TT>)星期天：(<TT CLASS="LITERAL">7</TT>)。</P><PRE CLASS="SCREEN">SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>7</SAMP
></PRE><P>除了星期天外，都与<TT CLASS="LITERAL">dow</TT>相同。这与<ACRONYM CLASS="ACRONYM">ISO</ACRONYM> 8601标准周中的第几天编码相匹配。</P></DD><DT><TT CLASS="LITERAL">isoyear</TT></DT><DD><P>日期中的<ACRONYM CLASS="ACRONYM">ISO</ACRONYM> 8601标准年（不适用于间隔）。</P><PRE CLASS="SCREEN">SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2005</SAMP
>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2006</SAMP
></PRE><P>每个带有星期一开始的周中包含1月4日的<ACRONYM CLASS="ACRONYM">ISO</ACRONYM>年，
所以在年初的1月或12月下旬的<ACRONYM CLASS="ACRONYM">ISO</ACRONYM>年可能会不同于阳历的年。
见<TT CLASS="LITERAL">week</TT>获取更多信息。</P><P>这个域不能用于 PostgreSQL 8.3之前的版本。</P></DD><DT><TT CLASS="LITERAL">microseconds</TT></DT><DD><P>秒域(包括小数部分)乘以 1,000,000 。请注意它包括全部的秒。</P><PRE CLASS="SCREEN">SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>28500000</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">millennium</TT></DT><DD><P>千年</P><PRE CLASS="SCREEN">SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>3</SAMP
></PRE><P>20 世纪(19xx 年)里面的年份在第二个千年里。第三个千年从 2001 年 1 月 1 日零时开始。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 8.0 之前的版本并不遵循千年编号的习惯，
只是返回年份除以 1000 。</P></DD><DT><TT CLASS="LITERAL">milliseconds</TT></DT><DD><P>秒域(包括小数部分)乘以 1000 。请注意它包括完整的秒。</P><PRE CLASS="SCREEN">SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>28500</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">minute</TT></DT><DD><P>分钟域(0-59)</P><PRE CLASS="SCREEN">SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>38</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">month</TT></DT><DD><P>对于<TT CLASS="TYPE">timestamp</TT>值，它是一年里的月份数(1-12)；对于<TT CLASS="TYPE">interval</TT>值，
它是月的数目，然后对 12 取模(0-11)</P><PRE CLASS="SCREEN">SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2</SAMP
>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>3</SAMP
>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>1</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">quarter</TT></DT><DD><P>该天所在的该年的季度(1-4)</P><PRE CLASS="SCREEN">SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>1</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">second</TT></DT><DD><P>秒域，包括小数部分(0-59)<A NAME="AEN14063" HREF="functions-datetime.html#FTN.AEN14063"><SPAN CLASS="footnote">[1]</SPAN></A>)</P><PRE CLASS="SCREEN">SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>40</SAMP
>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>28.5</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">timezone</TT></DT><DD><P>与 UTC 的时区偏移量，以秒记。正数对应 UTC 东边的时区，负数对应 UTC 西边的时区。
（技术角度讲，<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>使用<ACRONYM CLASS="ACRONYM">UT1</ACRONYM>，因为不处理闰秒。）</P></DD><DT><TT CLASS="LITERAL">timezone_hour</TT></DT><DD><P>时区偏移量的小时部分。</P></DD><DT><TT CLASS="LITERAL">timezone_minute</TT></DT><DD><P>时区偏移量的分钟部分。</P></DD><DT><TT CLASS="LITERAL">week</TT></DT><DD><P>该天在所在的年份里是第几周。<ACRONYM CLASS="ACRONYM">ISO</ACRONYM> 8601
定义一年的第一周包含该年的一月四日(ISO-8601 的周从星期一开始)。换句话说，
一年的第一个星期四在第一周。</P><P>在ISO定义里，一月的头几天可能是前一年的第 52 或者第 53 周，
十二月的后几天可能是下一年第一周。比如，<TT CLASS="LITERAL">2005-01-01</TT>是 2004 年的第 53 周，
而<TT CLASS="LITERAL">2006-01-01</TT>是 2005 年的第 52 周，<TT CLASS="LITERAL">2012-12-31</TT>是2013年的第一周。
建议<TT CLASS="LITERAL">isoyear</TT>字段和<TT CLASS="LITERAL">week</TT>一起使用以得到一致的结果。</P><PRE CLASS="SCREEN">SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>7</SAMP
></PRE></DD><DT><TT CLASS="LITERAL">year</TT></DT><DD><P>年份域。要记住这里没有<TT CLASS="LITERAL">0 AD</TT>，所以从<TT CLASS="LITERAL">AD</TT>年里抽取<TT CLASS="LITERAL">BC</TT>年应该小心些。</P><PRE CLASS="SCREEN">SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001</SAMP
></PRE></DD></DL></DIV><P>
</P><P><CODE CLASS="FUNCTION">extract</CODE>函数主要的用途是运算。
对于用于显示的日期/时间数值格式化，参阅<A HREF="functions-formatting.html">第 9.8 &#33410;</A>。</P><P><CODE CLASS="FUNCTION">date_part</CODE>函数是在传统的<SPAN CLASS="PRODUCTNAME">Ingres</SPAN>
函数的基础上制作的(该函数等效于<ACRONYM CLASS="ACRONYM">SQL</ACRONYM>标准函数<CODE CLASS="FUNCTION">extract</CODE>)：
</P><PRE CLASS="SYNOPSIS">date_part('<TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
>', <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
>)</PRE><P>
请注意这里的 <TT CLASS="REPLACEABLE"><I>field</I></TT>参数必须是一个字符串值，而不是一个名字。
有效的<CODE CLASS="FUNCTION">date_part</CODE>数域名和<CODE CLASS="FUNCTION">extract</CODE>是一样的。
</P><PRE CLASS="SCREEN">SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>16</SAMP
>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>4</SAMP
></PRE></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-DATETIME-TRUNC">9.9.2. <CODE CLASS="FUNCTION">date_trunc</CODE></A></H2><P><CODE CLASS="FUNCTION">date_trunc</CODE>函数在概念上和用于数字的<CODE CLASS="FUNCTION">trunc</CODE>函数类似。</P><P></P><PRE CLASS="SYNOPSIS">date_trunc('<TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
>', <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
>)</PRE><P>
<TT CLASS="REPLACEABLE"><I>source</I></TT>是<TT CLASS="TYPE">timestamp</TT>或<TT CLASS="TYPE">interval</TT>
类型的值表达式(<TT CLASS="TYPE">date</TT>和<TT CLASS="TYPE">time</TT>类型的值都分别自动转换成
<TT CLASS="TYPE">timestamp</TT>或<TT CLASS="TYPE">interval</TT>)。用<TT CLASS="REPLACEABLE"><I>field</I></TT>
选择对该时间戳值用什么样的精度进行截断。返回的数值是<TT CLASS="TYPE">timestamp</TT>
或<TT CLASS="TYPE">interval</TT>类型，所有小于选定的精度的域都设置为零(日期和月份域则为 1)。
</P><P>
<TT CLASS="REPLACEABLE"><I>field</I></TT>的有效数值是：
<P></P><TABLE BORDER="0"><TBODY><TR><TD><TT CLASS="LITERAL">microseconds</TT></TD></TR><TR><TD><TT CLASS="LITERAL">milliseconds</TT></TD></TR><TR><TD><TT CLASS="LITERAL">second</TT></TD></TR><TR><TD><TT CLASS="LITERAL">minute</TT></TD></TR><TR><TD><TT CLASS="LITERAL">hour</TT></TD></TR><TR><TD><TT CLASS="LITERAL">day</TT></TD></TR><TR><TD><TT CLASS="LITERAL">week</TT></TD></TR><TR><TD><TT CLASS="LITERAL">month</TT></TD></TR><TR><TD><TT CLASS="LITERAL">quarter</TT></TD></TR><TR><TD><TT CLASS="LITERAL">year</TT></TD></TR><TR><TD><TT CLASS="LITERAL">decade</TT></TD></TR><TR><TD><TT CLASS="LITERAL">century</TT></TD></TR><TR><TD><TT CLASS="LITERAL">millennium</TT></TD></TR></TBODY></TABLE><P></P>
</P><P>
例子：
</P><PRE CLASS="SCREEN">SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-02-16 20:00:00</SAMP
>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-01-01 00:00:00</SAMP
></PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-DATETIME-ZONECONVERT">9.9.3. <TT CLASS="LITERAL">AT TIME ZONE</TT></A></H2><P><TT CLASS="LITERAL">AT TIME ZONE</TT>构造允许把时间戳转换成不同的时区。
<A HREF="functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT-TABLE">&#34920; 9-28</A>显示了其变体。</P><DIV CLASS="TABLE"><A NAME="FUNCTIONS-DATETIME-ZONECONVERT-TABLE"></A><P><B>&#34920; 9-28. <TT CLASS="LITERAL">AT TIME ZONE</TT> 变体</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>表达式</TH><TH>返回类型</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD> <TT CLASS="LITERAL"><TT CLASS="TYPE">timestamp without time zone</TT> AT TIME ZONE <TT CLASS="REPLACEABLE"><I>zone</I></TT></TT>
</TD><TD><TT CLASS="TYPE">timestamp with time zone</TT></TD><TD>把给出的<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">不带时区</I></SPAN>的时间戳转换成给定时区的时间戳</TD></TR><TR><TD> <TT CLASS="LITERAL"><TT CLASS="TYPE">timestamp with time zone</TT> AT TIME ZONE <TT CLASS="REPLACEABLE"><I>zone</I></TT></TT>
</TD><TD><TT CLASS="TYPE">timestamp without time zone</TT></TD><TD>把给出的<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">带时区</I></SPAN>的时间戳转换成未指定时区的时间戳</TD></TR><TR><TD> <TT CLASS="LITERAL"><TT CLASS="TYPE">time with time zone</TT> AT TIME ZONE <TT CLASS="REPLACEABLE"><I>zone</I></TT></TT>
</TD><TD><TT CLASS="TYPE">time with time zone</TT></TD><TD>把给出的<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">带时区</I></SPAN>的时间转换成给定时区的时间</TD></TR></TBODY></TABLE></DIV><P>在这些表达式里，<TT CLASS="REPLACEABLE"><I>zone</I></TT>可以声明为文本串(比如<TT CLASS="LITERAL">'PST'</TT>)
或者一个时间间隔(比如<TT CLASS="LITERAL">INTERVAL '-08:00'</TT>)。在文本的情况下，
可用的时区名字在<A HREF="datatype-datetime.html#DATATYPE-TIMEZONES">第 8.5.3 &#33410;</A>有详细描述。</P><P>
例子(假设本地时区是<TT CLASS="LITERAL">PST8PDT</TT>)：
</P><PRE CLASS="SCREEN">SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-02-16 19:38:40-08</SAMP
>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-02-16 18:38:40</SAMP
></PRE><P>
第一个例子接受一个无时区的时间戳然后把它解释成 MST(UTC-7) 时间生成 UTC 时间戳，
然后把这个时间转换为 PST(UTC-8) 显示。第二个例子接受一个声明为 EST(UTC-5) 的时间戳，
然后把它转换成 MST(UTC-7) 的当地时间。
</P><P><TT CLASS="LITERAL"><CODE CLASS="FUNCTION">timezone</CODE>(<TT CLASS="REPLACEABLE"><I>zone</I></TT>, <TT CLASS="REPLACEABLE"><I>timestamp</I></TT>)</TT>
函数等效于 SQL 兼容的构造<TT CLASS="LITERAL"><TT CLASS="REPLACEABLE"><I>timestamp</I></TT> AT TIME ZONE <TT CLASS="REPLACEABLE"><I>zone</I></TT></TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-DATETIME-CURRENT">9.9.4. 当前日期/时间</A></H2><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>提供许多返回当前日期和时间的函数。
这些符合 SQL 标准的函数全部都按照当前事务的开始时刻返回结果：
</P><PRE CLASS="SYNOPSIS">CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)
CURRENT_TIMESTAMP(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)
LOCALTIMESTAMP(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)</PRE><P>
</P><P><CODE CLASS="FUNCTION">CURRENT_TIME</CODE>和<CODE CLASS="FUNCTION">CURRENT_TIMESTAMP</CODE>
返回带有时区的值；<CODE CLASS="FUNCTION">LOCALTIME</CODE>和<CODE CLASS="FUNCTION">LOCALTIMESTAMP</CODE>
返回不带时区的值。</P><P><CODE CLASS="FUNCTION">CURRENT_TIME</CODE>,<CODE CLASS="FUNCTION">CURRENT_TIMESTAMP</CODE>,
<CODE CLASS="FUNCTION">LOCALTIME</CODE>,<CODE CLASS="FUNCTION">LOCALTIMESTAMP</CODE>
可以有选择地获取一个精度参数，该精度导致结果的秒数域园整到指定小数位。
如果没有精度参数，将给予所能得到的全部精度。</P><P>一些例子：
</P><PRE CLASS="SCREEN">SELECT CURRENT_TIME;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>14:39:53.662522-05</SAMP
>

SELECT CURRENT_DATE;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23</SAMP
>

SELECT CURRENT_TIMESTAMP;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23 14:39:53.662522-05</SAMP
>

SELECT CURRENT_TIMESTAMP(2);
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23 14:39:53.66-05</SAMP
>

SELECT LOCALTIMESTAMP;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23 14:39:53.662522</SAMP
></PRE><P>
</P><P>因为这些函数全部都按照当前事务的开始时刻返回结果，
所以它们的值在事务运行的整个期间内都不改变。我们认为这是一个特性：
目的是为了允许一个事务在<SPAN CLASS="QUOTE">"当前时间"</SPAN>上有连贯的概念，
这样在同一个事务里的多个修改可以保持同样的时间戳。</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>许多其它数据库系统更频繁地更新这些数值。</P></BLOCKQUOTE></DIV><P>
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>同样也提供了返回实时时间值的函数，
它们的返回值会在事务中随时间的前进而变化。这些不附合 SQL 标准的函数列表如下：
</P><PRE CLASS="SYNOPSIS">transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()</PRE><P>
</P><P><CODE CLASS="FUNCTION">transaction_timestamp()</CODE>等效于<CODE CLASS="FUNCTION">CURRENT_TIMESTAMP</CODE>，
不过其命名准确的表明了其含义。<CODE CLASS="FUNCTION">statement_timestamp()</CODE>
返回当前事务开始时刻的时间戳(更准确的说是收到客户端最后一条命令的时间)。
<CODE CLASS="FUNCTION">statement_timestamp()</CODE>和<CODE CLASS="FUNCTION">transaction_timestamp()</CODE>
在一个事务的第一条命令里返回值相同，但是在随后的命令中却不一定相同。
c<CODE CLASS="FUNCTION">clock_timestamp()</CODE>返回实时时钟的当前时间戳，
因此它的值甚至在同一条 SQL 命令中都会变化。<CODE CLASS="FUNCTION">timeofday()</CODE>是一个历史的
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>函数，类似于<CODE CLASS="FUNCTION">clock_timestamp()</CODE>，
它也返回实时时钟的当前时间戳，不过它返回一个格式化了的<TT CLASS="TYPE">text</TT>字符串，
而不是<TT CLASS="TYPE">timestamp with time zone</TT>值。<CODE CLASS="FUNCTION">now()</CODE>
是传统的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>和<CODE CLASS="FUNCTION">transaction_timestamp()</CODE>等效的函数。</P><P>所有日期/时间类型还接受特殊的文本值<TT CLASS="LITERAL">now</TT>，
用于声明当前的日期和时间(重申：当前事务的开始时刻)。
因此，下面三个都返回相同的结果：
</P><PRE CLASS="PROGRAMLISTING">SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- incorrect for use with DEFAULT</PRE><P>
</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B>在创建表的时候你不应该用第三种形式声明一个<TT CLASS="LITERAL">DEFAULT</TT>值。
系统将在分析这个常量的时候把<TT CLASS="LITERAL">now</TT>转换为一个<TT CLASS="TYPE">timestamp</TT>，
因此这个缺省值就会变成创建表的时间！而前两种形式要到实际使用缺省值的时候才计算，
因为它们是函数调用。因此它们可以给出每次插入行的时刻。</P></BLOCKQUOTE></DIV></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="FUNCTIONS-DATETIME-DELAY">9.9.5. 延时执行</A></H2><P>下面的这个函数可以用于让服务器进程延时执行：
</P><PRE CLASS="SYNOPSIS">pg_sleep(<TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
>)</PRE><P>
<CODE CLASS="FUNCTION">pg_sleep</CODE>让当前的会话进程休眠<TT CLASS="REPLACEABLE"><I>seconds</I></TT>
秒以后再执行。<TT CLASS="REPLACEABLE"><I>seconds</I></TT>是一个<TT CLASS="TYPE">double precision</TT>
类型的值，所以可以指定带小数的秒数。例如：
</P><PRE CLASS="PROGRAMLISTING">SELECT pg_sleep(1.5);</PRE><P>
</P><DIV CLASS="NOTE"><BLOCKQUOTE CLASS="NOTE"><P><B>&#27880;&#24847;: </B>有效的休眠时间间隔精度是平台相关的，通常 0.01 秒是通用的。
休眠的时间将至少等于指定的时间，也有可能由于服务器荷载较重等原因而比指定的时间长。</P></BLOCKQUOTE></DIV><DIV CLASS="WARNING"><P></P><TABLE CLASS="WARNING" BORDER="1" WIDTH="100%"><TR><TD ALIGN="CENTER"><B>&#35686;&#21578;</B></TD></TR><TR><TD ALIGN="LEFT"><P>请确保调用<CODE CLASS="FUNCTION">pg_sleep</CODE>的会话没有持有不必要的锁。
否则其它会话可能必须等待这个休眠的会话释放所持有的锁，从而减慢系统速度。</P></TD></TR></TABLE></DIV></DIV></DIV><H3 CLASS="FOOTNOTES">&#22791;&#27880;</H3><TABLE BORDER="0" CLASS="FOOTNOTES" WIDTH="100%"><TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="5%"><A NAME="FTN.AEN14063" HREF="functions-datetime.html#AEN14063"><SPAN CLASS="footnote">[1]</SPAN></A></TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95%"><P>如果操作系统实现了润秒，那么上限是 60 。</P></TD></TR></TABLE><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="functions-formatting.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="functions-enum.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">数据类型格式化函数</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/functions.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">支持枚举函数</TD></TR></TABLE></DIV></BODY></HTML>
