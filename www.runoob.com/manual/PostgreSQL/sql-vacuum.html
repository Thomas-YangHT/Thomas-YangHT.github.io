<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>VACUUM</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="SQL 命令" HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html"><LINK REL="PREVIOUS" TITLE="UPDATE" HREF="sql-update.html"><LINK REL="NEXT" TITLE="VALUES" HREF="sql-values.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="REFENTRY">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ref/vacuum.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="UPDATE" HREF="sql-update.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom"></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="VALUES" HREF="sql-values.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><H1><A NAME="SQL-VACUUM"></A>VACUUM</H1><DIV CLASS="REFNAMEDIV"><A NAME="AEN81841"></A><H2>&#21517;&#31216;</H2>VACUUM&nbsp;--&nbsp;垃圾收集以及可选地分析一个数据库</DIV><DIV CLASS="REFSYNOPSISDIV"><A NAME="AEN81846"></A><H2>&#22823;&#32434;</H2><PRE CLASS="SYNOPSIS">VACUUM [ ( { FULL | FREEZE | VERBOSE | ANALYZE } [, ...] ) ] [ <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ (<TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) ] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ (<TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) ] ]</PRE></DIV><DIV CLASS="REFSECT1"><A NAME="AEN81853"></A><H2>描述</H2><P><TT CLASS="COMMAND">VACUUM</TT>回收死行占据的存储空间。在一般的<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
操作里，那些已经 DELETE 的行或者被 UPDATE 过后过时的行并没有从它们所属的表中物理删除；
在完成<TT CLASS="COMMAND">VACUUM</TT>之前它们仍然存在。因此有必要周期地运行<TT CLASS="COMMAND">VACUUM</TT>，
特别是在经常更新的表上。</P><P>如果没有参数，<TT CLASS="COMMAND">VACUUM</TT>处理当前用户有权限vacuum的当前数据库里的每个表，
如果有参数，<TT CLASS="COMMAND">VACUUM</TT>只处理那个表。</P><P><TT CLASS="COMMAND">VACUUM ANALYZE</TT>先执行一个<TT CLASS="COMMAND">VACUUM</TT>
然后是给每个选定的表执行一个<TT CLASS="COMMAND">ANALYZE</TT>。对于日常维护脚本而言，
这是一个很方便的组合。参阅<A HREF="sql-analyze.html">ANALYZE</A>获取更多有关其处理的细节。</P><P>简单的<TT CLASS="COMMAND">VACUUM</TT>(没有<TT CLASS="LITERAL">FULL</TT>)只是简单地回收空间并且令其可以再次使用。
这种形式的命令可以和对表的普通读写并发操作，因为没有请求排他锁。然而，
额外的空间并不返回到操作系统（在大多数情况下）；仅保持在相同的表中可重用。
<TT CLASS="COMMAND">VACUUM FULL</TT>将表的全部内容重写到一个没有任何多余空间的新磁盘文件中，
允许未使用的空间返回到操作系统中。这种形式要慢许多并且在处理的时候需要在表上施加一个排它锁。</P><P>当选项列表被括号括起来时，该选项可以任意顺序来写。没有圆括号，选项必须按以上显示的顺序指定。
加圆括号的语法在<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN> 9.0中添加；不加括号的语法已经废弃了。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN81874"></A><H2>参数</H2><P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">FULL</TT></DT><DD><P>选择<SPAN CLASS="QUOTE">"完全"</SPAN>清理，这样可以恢复更多的空间，但是花的时间更多并且在表上施加了排它锁。
该方法也需要额外的磁盘空间，因为它写了一个表的新拷贝并且不释放旧的拷贝，直到操作完成。
通常这应该只用于当一个大量的空间需要在这个表中回收时。</P></DD><DT><TT CLASS="LITERAL">FREEZE</TT></DT><DD><P>选择激进的行<SPAN CLASS="QUOTE">"冻结"</SPAN>。指定<TT CLASS="LITERAL">FREEZE</TT>相当于执行
<TT CLASS="COMMAND">VACUUM</TT>时将<A HREF="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</A>参数设为零。</P></DD><DT><TT CLASS="LITERAL">VERBOSE</TT></DT><DD><P>为每个表打印一份详细的清理工作报告。</P></DD><DT><TT CLASS="LITERAL">ANALYZE</TT></DT><DD><P>更新用于优化器的统计信息，以决定执行查询的最有效方法。</P></DD><DT><TT CLASS="REPLACEABLE"><I>table_name</I></TT></DT><DD><P>要清理的表的名称(可以有模式修饰)。缺省时是当前数据库中的所有表。</P></DD><DT><TT CLASS="REPLACEABLE"><I>column_name</I></TT></DT><DD><P>要分析的具体的字段名称。缺省是所有字段。若指定一个字段列表，就暗含<TT CLASS="LITERAL">ANALYZE</TT>。</P></DD></DL></DIV></DIV><DIV CLASS="REFSECT1"><A NAME="AEN81913"></A><H2>输出</H2><P>如果指定了<TT CLASS="LITERAL">VERBOSE</TT>，那么<TT CLASS="COMMAND">VACUUM</TT>将发出处理过程中的信息，
以表明当前正在处理哪个表。各种有关这些表的统计也会打印出来。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN81918"></A><H2>注意</H2><P>要清空一个表，一个人必须通常是表的所有者或是一个超级用户。然而，
数据库所有者允许清空他们的数据库中的所有表，除了共享目录。
（对共享目录的限制意味着一个真正的数据库范围的<TT CLASS="COMMAND">VACUUM</TT>仅能由超级用户执行。）
<TT CLASS="COMMAND">VACUUM</TT>将跳过调用用户没有权限清空的任何表。</P><P><TT CLASS="COMMAND">VACUUM</TT>不能在事务块内执行。</P><P>对于有<ACRONYM CLASS="ACRONYM">GIN</ACRONYM>索引的表，<TT CLASS="COMMAND">VACUUM</TT>（以任何形式）
也完成任何挂起索引插入内容，通过移动挂起索引条目到主<ACRONYM CLASS="ACRONYM">GIN</ACRONYM>索引结构中的相应位置。
参阅<A HREF="gin-implementation.html#GIN-FAST-UPDATE">第 57.3.1 &#33410;</A>获取详细信息。</P><P>建议生产数据库经常清理(至少每晚一次)，以保证不断地删除死行。尤其是在增删了大量记录之后，
对受影响的表执行<TT CLASS="COMMAND">VACUUM ANALYZE</TT>命令是一个很好的习惯。
这样做将更新系统目录为最近的更改，并且允许<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>
查询优化器在规划用户查询时有更好的选择。</P><P>不建议日常使用<TT CLASS="OPTION">FULL</TT>选项，但是可以在特殊情况下使用。
一个例子就是在你删除或更新了一个表的大部分行之后，
希望从物理上缩小该表以减少磁盘空间占用并且允许更快的表扫描。<TT CLASS="COMMAND">VACUUM FULL</TT>
通常要比单纯的<TT CLASS="COMMAND">VACUUM</TT>收缩更多的表尺寸。</P><P><TT CLASS="COMMAND">VACUUM</TT>导致 I/O 流量增加，可能会导致其它活动会话的性能恶劣。因此，
有时候会建议使用基于开销的 vacuum 延迟特性。
参阅<A HREF="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST">第 18.4.4 &#33410;</A>获取细节。</P><P><SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>包含一个<SPAN CLASS="QUOTE">"autovacuum"</SPAN>设施，
它可以自动进行日常的 vacuum 维护。关于手动和自动清理的更多细节，
参见<A HREF="routine-vacuuming.html">第 23.1 &#33410;</A>。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN81944"></A><H2>例子</H2><P>下面是一个在蜕变(regression)数据库里某个表上执行<TT CLASS="COMMAND">VACUUM</TT>的一个例子：
</P><PRE CLASS="PROGRAMLISTING">regression=# VACUUM (VERBOSE, ANALYZE) onek;
INFO:  vacuuming "public.onek"
INFO:  index "onek_unique1" now contains 1000 tuples in 14 pages
DETAIL:  3000 index tuples were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.01s/0.08u sec elapsed 0.18 sec.
INFO:  index "onek_unique2" now contains 1000 tuples in 16 pages
DETAIL:  3000 index tuples were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.00s/0.07u sec elapsed 0.23 sec.
INFO:  index "onek_hundred" now contains 1000 tuples in 13 pages
DETAIL:  3000 index tuples were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.01s/0.08u sec elapsed 0.17 sec.
INFO:  index "onek_stringu1" now contains 1000 tuples in 48 pages
DETAIL:  3000 index tuples were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.01s/0.09u sec elapsed 0.59 sec.
INFO:  "onek": removed 3000 tuples in 108 pages
DETAIL:  CPU 0.01s/0.06u sec elapsed 0.07 sec.
INFO:  "onek": found 3000 removable, 1000 nonremovable tuples in 143 pages
DETAIL:  0 dead tuples cannot be removed yet.
There were 0 unused item pointers.
0 pages are entirely empty.
CPU 0.07s/0.39u sec elapsed 1.56 sec.
INFO:  analyzing "public.onek"
INFO:  "onek": 36 pages, 1000 rows sampled, 1000 estimated total rows
VACUUM</PRE><P></P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN81949"></A><H2>兼容性</H2><P>SQL 标准里没有<TT CLASS="COMMAND">VACUUM</TT>语句。</P></DIV><DIV CLASS="REFSECT1"><A NAME="AEN81953"></A><H2>又见</H2><A HREF="app-vacuumdb.html"><SPAN CLASS="APPLICATION">vacuumdb</SPAN></A>, <A HREF="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST">第 18.4.4 &#33410;</A>, <A HREF="routine-vacuuming.html#AUTOVACUUM">第 23.1.6 &#33410;</A></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="sql-update.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="sql-values.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">UPDATE</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/sql-commands.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">VALUES</TD></TR></TABLE></DIV></BODY></HTML>
