<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>使用描述符范围</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="ECPG - 在C中嵌入SQL" HREF="http://school.yunwei.edu/manual/PostgreSQL/ecpg.html"><LINK REL="PREVIOUS" TITLE="pgtypes 库" HREF="ecpg-pgtypes.html"><LINK REL="NEXT" TITLE="错误处理" HREF="ecpg-errors.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/ecpg.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="pgtypes 库" HREF="ecpg-pgtypes.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/ecpg.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 33. <SPAN CLASS="APPLICATION">ECPG</SPAN> - 在C中嵌入<ACRONYM CLASS="ACRONYM">SQL</ACRONYM></TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="错误处理" HREF="ecpg-errors.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="ECPG-DESCRIPTORS">33.7. 使用描述符范围</A></H1><P>一个SQL描述符范围是处理<TT CLASS="COMMAND">SELECT</TT>, <TT CLASS="COMMAND">FETCH</TT>或者
<TT CLASS="COMMAND">DESCRIBE</TT>语句结果的更复杂的方法。
一个SQL描述符范围把一行数据里的数据和元数据项组合到一个数据结构中。
元数据在执行动态SQL语句时特别有用，那里的结果列的属性可能不能提前知道。
PostgreSQL提供了两种使用描述符范围的方法：
命名的SQL描述符范围和C结构SQLDAs。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-NAMED-DESCRIPTORS">33.7.1. 命名SQL描述符范围</A></H2><P>一个命名SQL描述符范围由一个头组成，
包含有关整个描述符的信息，一个或多个项描述符范围，
基本上每个描述结果行中的一个字段。</P><P>
在你使用SQL描述符范围之前，你需要分配一个：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL ALLOCATE DESCRIPTOR <TT
CLASS="REPLACEABLE"
><I
>identifier</I
></TT
>;</PRE><P>
标示符用作描述符范围的<SPAN CLASS="QUOTE">"变量名"</SPAN>。
当你不再需要这个描述符，你应该释放它：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL DEALLOCATE DESCRIPTOR <TT
CLASS="REPLACEABLE"
><I
>identifier</I
></TT
>;</PRE><P>
</P><P>
要使用一个描述符范围，在一个<TT CLASS="LITERAL">INTO</TT>子句的存储目标里声明它，
而不是列出宿主变量：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;</PRE><P>
如果结果集是空，描述符范围将包含来自查询的元数据，即字段名称。
</P><P>
为了尚未执行的预备查询，<TT CLASS="COMMAND">DESCRIBE</TT>语句可用于获得结果集的元数据：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;</PRE><P>
</P><P> PostgreSQL 9.0之前，<TT CLASS="LITERAL">SQL</TT>关键字是可选的，
所以使用<TT CLASS="LITERAL">DESCRIPTOR</TT>和<TT CLASS="LITERAL">SQL DESCRIPTOR</TT>
产生命名SQL描述符范围。
现在，它是强制性的，
省略<TT CLASS="LITERAL">SQL</TT>关键词产生SQLDA描述符范围，
参阅<A HREF="ecpg-descriptors.html#ECPG-SQLDA-DESCRIPTORS">第 33.7.2 &#33410;</A>。</P><P> 在<TT CLASS="COMMAND">DESCRIBE</TT>和<TT CLASS="COMMAND">FETCH</TT>语句中，
<TT CLASS="LITERAL">INTO</TT>和<TT CLASS="LITERAL">USING</TT>关键字使用类似：
它们产生结果集合和描述符范围的元数据。</P><P>
现在，我们应该如何从描述符范围里获取数据？
你可以把描述符范围看作是一个有着命名字段的结构。
要从头检索字段数值并且把它存储到一个宿主变量里，使用下面的命令：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL GET DESCRIPTOR <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> :<TT
CLASS="REPLACEABLE"
><I
>hostvar</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
>;</PRE><P>
目前只定义了一个头字段：<TT CLASS="REPLACEABLE"><I>COUNT</I></TT>，
这个字段告诉我们有几个项描述符范围存在（也就是说，在结果里包含多少个字段）。
宿主变量需要是一个整数类型。要从项描述符范围里获取一个字段，
使用下面的命令：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL GET DESCRIPTOR <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> VALUE <TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> :<TT
CLASS="REPLACEABLE"
><I
>hostvar</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
>;</PRE><P>
<TT CLASS="REPLACEABLE"><I>num</I></TT>可以是一个字符整数或者一个包含整数的宿主变量。
可能的字段有:
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">CARDINALITY</TT> (integer)</DT><DD><P>
结果集中的行数
</P></DD><DT><TT CLASS="LITERAL">DATA</TT></DT><DD><P>实际数据项（因此，这个字段的数据类型依赖于这个查询）</P></DD><DT><TT CLASS="LITERAL">DATETIME_INTERVAL_CODE</TT> (integer)</DT><DD><P> 当<TT CLASS="LITERAL">TYPE</TT>是<TT CLASS="LITERAL">9</TT>的时候，那么
<TT CLASS="LITERAL">DATETIME_INTERVAL_CODE</TT>将有<TT CLASS="LITERAL">DATE</TT>的<TT CLASS="LITERAL">1</TT>值，
<TT CLASS="LITERAL">TIME</TT>的<TT CLASS="LITERAL">2</TT>值，
<TT CLASS="LITERAL">TIMESTAMP</TT>的<TT CLASS="LITERAL">3</TT>值，
<TT CLASS="LITERAL">TIME WITH TIME ZONE</TT>的<TT CLASS="LITERAL">4</TT>值或者
<TT CLASS="LITERAL">TIMESTAMP WITH TIME ZONE</TT>的<TT CLASS="LITERAL">5</TT>值。
</P></DD><DT><TT CLASS="LITERAL">DATETIME_INTERVAL_PRECISION</TT> (integer)</DT><DD><P> 未实现。</P></DD><DT><TT CLASS="LITERAL">INDICATOR</TT> (integer)</DT><DD><P> 描述符（标识一个空值或者一个截断的值）</P></DD><DT><TT CLASS="LITERAL">KEY_MEMBER</TT> (integer)</DT><DD><P> 未实现</P></DD><DT><TT CLASS="LITERAL">LENGTH</TT> (integer)</DT><DD><P> 字符中数据长度</P></DD><DT><TT CLASS="LITERAL">NAME</TT> (string)</DT><DD><P> 字段名称</P></DD><DT><TT CLASS="LITERAL">NULLABLE</TT> (integer)</DT><DD><P> 未实现</P></DD><DT><TT CLASS="LITERAL">OCTET_LENGTH</TT> (integer)</DT><DD><P> 字节数据的字符表示的长度</P></DD><DT><TT CLASS="LITERAL">PRECISION</TT> (integer)</DT><DD><P> 精度（类型<TT CLASS="TYPE">numeric</TT>）</P></DD><DT><TT CLASS="LITERAL">RETURNED_LENGTH</TT> (integer)</DT><DD><P> 字符中数据长度 </P></DD><DT><TT CLASS="LITERAL">RETURNED_OCTET_LENGTH</TT> (integer)</DT><DD><P> 字节数据的字符表示的长度</P></DD><DT><TT CLASS="LITERAL">SCALE</TT> (integer)</DT><DD><P> 比例（类型<TT CLASS="TYPE">numeric</TT>）</P></DD><DT><TT CLASS="LITERAL">TYPE</TT> (integer)</DT><DD><P> 字段数据类型的数值代码 </P></DD></DL></DIV><P>
</P><P>
在<TT CLASS="COMMAND">EXECUTE</TT>, <TT CLASS="COMMAND">DECLARE</TT>和<TT CLASS="COMMAND">OPEN</TT>
语句中，<TT CLASS="LITERAL">INTO</TT>和<TT CLASS="LITERAL">USING</TT>关键字的作用是不同的。
描述符范围可以手动的编译，为一个查询或者游标提供输入参数，
并且<TT CLASS="LITERAL">USING SQL DESCRIPTOR <TT CLASS="REPLACEABLE"><I>name</I></TT></TT>是传递输入参数给一个参数化查询的一种方式。
编译命名SQL描述符范围的语句如下：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL SET DESCRIPTOR <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> VALUE <TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
> = :<TT
CLASS="REPLACEABLE"
><I
>hostvar</I
></TT
>;</PRE><P>
</P><P>
PostgreSQL支持检索更多的在一个<TT CLASS="COMMAND">FETCH</TT>语句中的记录和存储在宿主变量中的数据，
在这种情况下假设变量是一个数组。例如：
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;</PRE><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="ECPG-SQLDA-DESCRIPTORS">33.7.2. SQLDA描述符范围</A></H2><P>
SQLDA描述符范围是一个C语言结构，
它过去常常获取结果集和查询的元数据。
一个结构存储来自结果集中的一条记录。
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;</PRE><P>
注意省略<TT CLASS="LITERAL">SQL</TT>关键字。
<A HREF="ecpg-descriptors.html#ECPG-NAMED-DESCRIPTORS">第 33.7.1 &#33410;</A>中的<TT CLASS="LITERAL">INTO</TT>和<TT CLASS="LITERAL">USING</TT>关键字的
使用情况的段落有个例外，
也能适用于这里。在<TT CLASS="COMMAND">DESCRIBE</TT>语句中，如果使用了<TT CLASS="LITERAL">INTO</TT>关键字，
则<TT CLASS="LITERAL">DESCRIPTOR</TT>关键字完全省略。
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL DESCRIBE prepared_statement INTO mysqlda;</PRE><P>
</P><DIV CLASS="PROCEDURE"><P>
使用SQLDA程序流是：</P><OL TYPE="1"><LI CLASS="STEP"><P>准备一个查询，并且为它声明一个游标。</P></LI><LI CLASS="STEP"><P>为结果行声明SQLDA。</P></LI><LI CLASS="STEP"><P>为输入参数声明SQLDA，并且初始化它们(内存分配，参数设置)。</P></LI><LI CLASS="STEP"><P>打开具有输入SQLDA的游标</P></LI><LI CLASS="STEP"><P>从游标中抓取行，并且将它们存储到输出SQLDA中。</P></LI><LI CLASS="STEP"><P>从输出SQLDA中读取值到宿主变量中 (如果有必要使用转换)。</P></LI><LI CLASS="STEP"><P>关闭游标。</P></LI><LI CLASS="STEP"><P>自由内存区域分配给输入SQLDA。</P></LI></OL></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="AEN44454">33.7.2.1. SQLDA数据结构</A></H3><P> SQLDA使用三个数据结构类型：<TT CLASS="TYPE">sqlda_t</TT>，<TT CLASS="TYPE">sqlvar_t</TT>,
和<TT CLASS="TYPE">struct sqlname</TT>。</P><DIV CLASS="TIP"><BLOCKQUOTE CLASS="TIP"><P><B>&#25552;&#31034;: </B> PostgreSQL的SQLDA与IBM DB2通用数据库中的一个有类似的数据结构。
所以DB2的SQLDA上的一些技术信息可以更好的帮助理解PostgreSQL的。</P></BLOCKQUOTE></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="ECPG-SQLDA-SQLDA">33.7.2.1.1. sqlda_t 结构</A></H4><P> 结构类型<TT CLASS="TYPE">sqlda_t</TT>是实际SQLDA的类型。
它拥有一条记录。并且在链表中使用<TT CLASS="STRUCTFIELD">desc_next</TT>
字段指针可以连接两个或更多个<TT CLASS="TYPE">sqlda_t</TT>结构，
因此代表行的有序集合。因此，当抓取两个或更多行时，
应用程序通过每个<TT CLASS="TYPE">sqlda_t</TT>节点
随后<TT CLASS="STRUCTFIELD">desc_next</TT>指针可以读取它们。
</P><P>
<TT CLASS="TYPE">sqlda_t</TT>的定义是：
</P><PRE CLASS="PROGRAMLISTING">struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;</PRE><P>
该字段的意思是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">sqldaid</TT></DT><DD><P>
它包含文本字符串<TT CLASS="LITERAL">"SQLDA "</TT>。
</P></DD><DT><TT CLASS="LITERAL">sqldabc</TT></DT><DD><P> 它包含字节中分配空间的大小。</P></DD><DT><TT CLASS="LITERAL">sqln</TT></DT><DD><P> 它包含一个参数化查询的情况下的输入参数数，
使用<TT CLASS="LITERAL">USING</TT>关键字被传递给<TT CLASS="COMMAND">OPEN</TT>, <TT CLASS="COMMAND">DECLARE</TT>或者
<TT CLASS="COMMAND">EXECUTE</TT>语句。
在这种情况下它被作为<TT CLASS="COMMAND">SELECT</TT>,
<TT CLASS="COMMAND">EXECUTE</TT>或者<TT CLASS="COMMAND">FETCH</TT>语句的输出使用。
它的值和<TT CLASS="LITERAL">sqld</TT>语句是一样的。</P></DD><DT><TT CLASS="LITERAL">sqld</TT></DT><DD><P> 它包含结果集中的字段数量。</P></DD><DT><TT CLASS="LITERAL">desc_next</TT></DT><DD><P> 如果查询返回多条记录，那么返回多个链接SQLDA结构，
并且<TT CLASS="LITERAL">desc_next</TT>持有指向列表中下一项的指针。</P></DD><DT><TT CLASS="LITERAL">sqlvar</TT></DT><DD><P> 这是结构集中列数组。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="ECPG-SQLDA-SQLVAR">33.7.2.1.2. sqlvar_t结构</A></H4><P>
结构类型<TT CLASS="TYPE">sqlvar_t</TT>持有列值和元数据比如类型和长度。
该类型的定义是：
</P><PRE CLASS="PROGRAMLISTING">struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;</PRE><P>
该字段的含义是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">sqltype</TT></DT><DD><P>
包含该字段的类型标识符。
对于该值，参阅<TT CLASS="LITERAL">ecpgtype.h</TT>中的<TT CLASS="LITERAL">enum ECPGttype</TT>。
</P></DD><DT><TT CLASS="LITERAL">sqllen</TT></DT><DD><P> 包含该字段的二进制长度。比如4字节的<TT CLASS="TYPE">ECPGt_int</TT>。</P></DD><DT><TT CLASS="LITERAL">sqldata</TT></DT><DD><P> 指向该数据。关于数据的格式在<A HREF="ecpg-variables.html#ECPG-VARIABLES-TYPE-MAPPING">第 33.4.4 &#33410;</A>
中描述。</P></DD><DT><TT CLASS="LITERAL">sqlind</TT></DT><DD><P> 指向空指示器。0表示非空，-1表示空。</P></DD><DT><TT CLASS="LITERAL">sqlname</TT></DT><DD><P> 该字段名称。</P></DD></DL></DIV><P>
</P></DIV><DIV CLASS="SECT4"><H4 CLASS="SECT4"><A NAME="ECPG-SQLDA-SQLNAME">33.7.2.1.3. struct sqlname结构</A></H4><P>
<TT CLASS="TYPE">struct sqlname</TT>结构持有列名。
它作为<TT CLASS="TYPE">sqlvar_t</TT>结构成员被使用。
该结构定义是：
</P><PRE CLASS="PROGRAMLISTING">#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};</PRE><P>
该字段含义是：
<P></P></P><DIV CLASS="VARIABLELIST"><DL><DT><TT CLASS="LITERAL">length</TT></DT><DD><P>
包含该字段名长度。
</P></DD><DT><TT CLASS="LITERAL">data</TT></DT><DD><P> 包含实际字段名。 </P></DD></DL></DIV><P>
</P></DIV></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="ECPG-SQLDA-OUTPUT">33.7.2.2. 使用SQLDA检索结果集</A></H3><DIV CLASS="PROCEDURE"><P> 通过SQLDA检索查询结果集的一般步骤是：</P><OL TYPE="1"><LI CLASS="STEP"><P>声明<TT CLASS="TYPE">sqlda_t</TT>结构用来接收结果集。</P></LI><LI CLASS="STEP"><P>执行<TT CLASS="COMMAND">FETCH</TT>/<TT CLASS="COMMAND">EXECUTE</TT>/<TT CLASS="COMMAND">DESCRIBE</TT>命令用来处理指定已声明SQLDA的查询。</P></LI><LI CLASS="STEP"><P>通过查看<TT CLASS="STRUCTFIELD">sqln</TT>检查结果集中的记录数，<TT CLASS="TYPE">sqlda_t</TT>结构成员。</P></LI><LI CLASS="STEP"><P>从<TT CLASS="LITERAL">sqlvar[0]</TT>, <TT CLASS="LITERAL">sqlvar[1]</TT>等中获得每列的值，<TT CLASS="TYPE">sqlda_t</TT>结构成员</P></LI><LI CLASS="STEP"><P>通过<TT CLASS="STRUCTFIELD">desc_next</TT>指针转到下一行(<TT CLASS="TYPE">sqlda_t</TT>结构)，<TT CLASS="TYPE">sqlda_t</TT>结构成员。</P></LI><LI CLASS="STEP"><P>你需要重复以上步骤</P></LI></OL></DIV><P> 这是一个通过SQLDA检索结果集的例子。</P><P>
首先，声明一个<TT CLASS="TYPE">sqlda_t</TT>结构以接收结果集。
</P><PRE CLASS="PROGRAMLISTING">sqlda_t *sqlda1;</PRE><P>
</P><P>
接下来，在命令中声明SQLDA。这是<TT CLASS="COMMAND">FETCH</TT>命令实例。
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;</PRE><P>
</P><P>
在链接表后运行循环以检索行。
</P><PRE CLASS="PROGRAMLISTING">sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda-&#62;desc_next)
{
    ...
}</PRE><P>
</P><P>
在循环中，运行另外一个循环以检索行中的每列数据（<TT CLASS="TYPE">sqlvar_t</TT>结构）。
</P><PRE CLASS="PROGRAMLISTING">for (i = 0; i &lt; cur_sqlda-&#62;sqld; i++)
{
    sqlvar_t v = cur_sqlda-&#62;sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
} </PRE><P>
</P><P>
为了得到列值，检查<TT CLASS="STRUCTFIELD">sqltype</TT>值，<TT CLASS="TYPE">sqlvar_t</TT>结构成员。然后，
切换适当方式，依赖于列类型，从宿主变量<TT CLASS="STRUCTFIELD">sqlvar</TT>字段拷贝数据。
</P><PRE CLASS="PROGRAMLISTING">char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="ECPG-SQLDA-INPUT">33.7.2.3. 使用SQLDA传递查询参数</A></H3><DIV CLASS="PROCEDURE"><P> 使用SQLDA传递输入参数给预备查询的一般步骤是：</P><OL TYPE="1"><LI CLASS="STEP"><P>创建预备查询(预备语句)</P></LI><LI CLASS="STEP"><P>作为输入SQLDA声明sqlda_t结构。</P></LI><LI CLASS="STEP"><P>为了输入SQLDA分配内存区域(作为sqlda_t结构)。</P></LI><LI CLASS="STEP"><P>在已分配内存中设置（拷贝）输入值。</P></LI><LI CLASS="STEP"><P>打开具有声明输入SQLDA的游标。</P></LI></OL></DIV><P> 这有个例子。</P><P>
首先，创建一个预备语句。
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;</PRE><P>
</P><P>
下一步，为SQLDA分配内存，并且在<TT CLASS="STRUCTFIELD">sqln</TT>中设置输入参数数，
<TT CLASS="TYPE">sqlda_t</TT>结构成员变量。
当预备查询需要两个或更多个输入参数的时候，应用程序必须分配额外内存空间，它
是通过(nr. of params - 1) * sizeof(sqlvar_t)计算的。
这里显示的是为两个输入参数分配内存空间的例子。
</P><PRE CLASS="PROGRAMLISTING">sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2-&#62;sqln = 2; /* number of input variables */</PRE><P>
</P><P>
内存分配后，存储参数值到<TT CLASS="LITERAL">sqlvar[]</TT>数组。
（当该SQLDA正在接收结果集时，这是用于检索列值的相同数组。）
在这个例子中，输入参数是有字符串类型的<TT CLASS="LITERAL">"postgres"</TT>，
以及有整数类型的<TT CLASS="LITERAL">1</TT>。
</P><PRE CLASS="PROGRAMLISTING">sqlda2-&#62;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&#62;sqlvar[0].sqldata = "postgres";
sqlda2-&#62;sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2-&#62;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&#62;sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2-&#62;sqlvar[1].sqllen  = sizeof(intval);</PRE><P>
</P><P>
打开游标并且声明事先准备的SQLDA，将输入参数传递给预备语句。
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;</PRE><P>
</P><P>
最后，使用输入SQLDA之后，必须显式释放已分配内存空间，不像用于接收查询
结果的SQLDA。
</P><PRE CLASS="PROGRAMLISTING">free(sqlda2);</PRE><P>
</P></DIV><DIV CLASS="SECT3"><H3 CLASS="SECT3"><A NAME="ECPG-SQLDA-EXAMPLE">33.7.2.4. 使用SQLDA示例应用程序</A></H3><P> 这是一个示例程序，描述了如何获取数据库访问统计，通过输入参数声明，来自系统表。</P><P> 这个应用程序连接两个系统表，数据库OID上的pg_database和
pg_stat_database，并且读取、显示由两个输入参数（<TT CLASS="LITERAL">postgres</TT>和OID <TT CLASS="LITERAL">1</TT>）检索的数据库统计。</P><P>
首先，为输入声明SQLDA，以及为输出声明SQLDA。
</P><PRE CLASS="PROGRAMLISTING">EXEC SQL include sqlda.h;


sqlda_t *sqlda1; /*输出描述符*/
sqlda_t *sqlda2; /*输入描述符*/&#13;</PRE><P>
</P><P>
下一步，连接数据库，准备语句，并且为预备语句声明游标。
</P><PRE CLASS="PROGRAMLISTING">int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;</PRE><P>
</P><P>
接下来，为输入参数将一些值放在输入SQLDA中。为输入SQLDA分配内存，并且设置
输入参数数到<TT CLASS="LITERAL">sqln</TT>。存储类型，值以及值长度到<TT CLASS="LITERAL">sqltype</TT>，<TT CLASS="LITERAL">sqldata</TT>中，
并且将<TT CLASS="LITERAL">sqllen</TT>放在<TT CLASS="LITERAL">sqlvar</TT>结构中。
</P><PRE CLASS="PROGRAMLISTING">    
/*为输入参数创建SQLDA结构 */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2-&#62;sqln = 2; /*输入变量数*/

    sqlda2-&#62;sqlvar[0].sqltype = ECPGt_char;
    sqlda2-&#62;sqlvar[0].sqldata = "postgres";
    sqlda2-&#62;sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2-&#62;sqlvar[1].sqltype = ECPGt_int;
    sqlda2-&#62;sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2-&#62;sqlvar[1].sqllen  = sizeof(intval);</PRE><P>
</P><P>
在建立输入SQLDA后，打开具有输入SQLDA的一个游标。
</P><PRE CLASS="PROGRAMLISTING">    

/*打开具有输入参数的游标。*/

    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;&#13;</PRE><P>
</P><P>
从已打开的游标中读取行到输出SQLDA。（一般来说，你必须在循环中反复调用<TT CLASS="COMMAND">FETCH</TT>，
为了读取结果集中的所有行。）
</P><PRE CLASS="PROGRAMLISTING">    while (1)
    {
        sqlda_t *cur_sqlda;

/*分配描述符给游标*/

        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;</PRE><P>
</P><P>
接下来，从SQLDA中检索已读取记录，通过下面<TT CLASS="TYPE">sqlda_t</TT>结构中
的连接表。
</P><PRE CLASS="PROGRAMLISTING">    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda-&#62;desc_next)
    {
        ...</PRE><P>
</P><P>
读取第一条记录中的每一列。列数被存储在<TT CLASS="STRUCTFIELD">sqld</TT>中，
第一列的实际数据被存储在<TT CLASS="LITERAL">sqlvar[0]</TT>，<TT CLASS="TYPE">sqlda_t</TT>结构的两个
成员中。
</P><PRE CLASS="PROGRAMLISTING">   
        
/* 输出行中每一列*/
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1-&#62;sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';</PRE><P>
</P><P>
目前，该列数据被存储在变量<TT CLASS="VARNAME">v</TT>中。拷贝每个数据到宿主变量，
为了列类型查看<TT CLASS="LITERAL">v.sqltype</TT>。
</P><PRE CLASS="PROGRAMLISTING">            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* integer */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }</PRE><P>
</P><P>
在处理完所有记录之后关闭游标，并且断开数据库连接。
</P><PRE CLASS="PROGRAMLISTING">    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;</PRE><P>
</P><P> 在<A HREF="ecpg-descriptors.html#ECPG-SQLDA-EXAMPLE-EXAMPLE">&#20363; 33-1</A>中显示了整个程序。</P><DIV CLASS="EXAMPLE"><A NAME="ECPG-SQLDA-EXAMPLE-EXAMPLE"></A><P><B>&#20363; 33-1. SQLDA程序示例</B></P><PRE CLASS="PROGRAMLISTING">#include &lt;stdlib.h&#62;
#include &lt;string.h&#62;
#include &lt;stdlib.h&#62;
#include &lt;stdio.h&#62;
#include &lt;unistd.h&#62;

EXEC SQL include sqlda.h;


sqlda_t *sqlda1; /*输出描述符*/
sqlda_t *sqlda2; /*输入描述符*/

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

/*为输入参数创建SQLDA结构*/

    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2-&#62;sqln = 2; /* a number of input variables */

    sqlda2-&#62;sqlvar[0].sqltype = ECPGt_char;
    sqlda2-&#62;sqlvar[0].sqldata = "postgres";
    sqlda2-&#62;sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2-&#62;sqlvar[1].sqltype = ECPGt_int;
    sqlda2-&#62;sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2-&#62;sqlvar[1].sqllen  = sizeof(intval);

/*打开具有输入参数的游标*/

    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

/*分配描述符给游标*/ 
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda-&#62;desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

/*输出行中每一列*/
            for (i=0 ; i&lt;cur_sqlda-&#62;sqld ; i++)
            {
                sqlvar_t v = cur_sqlda-&#62;sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* integer */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}</PRE><P> 该例子输出应该看起来像下面这样（一些数字有所不同）。</P><PRE CLASS="SCREEN">oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)</PRE></DIV></DIV></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="ecpg-pgtypes.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="ecpg-errors.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">pgtypes 库</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/ecpg.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">错误处理</TD></TR></TABLE></DIV></BODY></HTML>
