<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>向数据库中添加记录</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="性能提升技巧" HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html"><LINK REL="PREVIOUS" TITLE="用明确的JOIN控制规划器" HREF="explicit-joins.html"><LINK REL="NEXT" TITLE="非持久性设置" HREF="non-durability.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/perform.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="用明确的JOIN控制规划器" HREF="explicit-joins.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#31456; 14. 性能提升技巧</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="非持久性设置" HREF="non-durability.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="POPULATE">14.4. 向数据库中添加记录</A></H1><P> 第一次填充数据库时可能需要做大量的表插入。下面是一些建议，可以尽可能高效地处理这些事情。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="DISABLE-AUTOCOMMIT">14.4.1. 关闭自动提交</A></H2><P> 当使用多条<TT CLASS="COMMAND">INSERT</TT>时，关闭自动提交，并且只在每次(数据拷贝)结束的时候做一次提交。
在纯SQL里，这就意味着在开始的时候发出<TT CLASS="COMMAND">BEGIN</TT>并且在结束的时候执行<TT CLASS="COMMAND">COMMIT</TT>。
有些客户端的库可能背着你干这些事情，
这种情况下你必须确信只有在你确实要那些库干这些事情的时候它才做。
如果你允许每个插入都独立地提交，那么<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>会为所增加的每行记录做大量的处理。
在一个事务里完成所有插入的动作的最大的好处就是，如果有一条记录插入失败，
那么，到该点为止的所有已插入记录都将被回滚，
这样你就不会很难受地面对一个只装载了一部分数据的表。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-COPY-FROM">14.4.2. 使用<TT CLASS="COMMAND">COPY</TT></A></H2><P> 使用<A HREF="sql-copy.html">COPY</A>在一条命令里装载所有记录，
而不是一连串的<TT CLASS="COMMAND">INSERT</TT>命令。<TT CLASS="COMMAND">COPY</TT>命令是为装载数量巨大的数据行优化过的；
它没<TT CLASS="COMMAND">INSERT</TT>那么灵活，但是在大量装载数据的情况下，导致的荷载也少很多。
因为<TT CLASS="COMMAND">COPY</TT>是单条命令，因此填充表的时候就没有必要关闭自动提交了。</P><P> 如果你不能使用<TT CLASS="COMMAND">COPY</TT>，那么使用<A HREF="sql-prepare.html">PREPARE</A>来创建一个预备<TT CLASS="COMMAND">INSERT</TT>，
然后使用<TT CLASS="COMMAND">EXECUTE</TT>多次效率更高。这样就避免了重复分析和规划<TT CLASS="COMMAND">INSERT</TT>的开销。
不同的接口提供便利的方式不同；查看接口文档的<SPAN CLASS="QUOTE">"已准备语句"</SPAN>。</P><P> 请注意，在装载大量数据行的时候，<TT CLASS="COMMAND">COPY</TT>几乎总是比<TT CLASS="COMMAND">INSERT</TT>快，
即使使用了<TT CLASS="COMMAND">PREPARE</TT>并且把多个<TT CLASS="COMMAND">INSERT</TT>命令绑在一个事务中也是这样。</P><P> 当在相同事务中作为较早的<TT CLASS="COMMAND">CREATE TABLE</TT>或者<TT CLASS="COMMAND">TRUNCATE</TT>命令
使用的时候，<TT CLASS="COMMAND">COPY</TT>是最快的。在这种情况下，没有WAL
需要写入，因为在错误情况下，这些文件包含新加载的数据将被删除。
然而，这种考虑只适用于当所有命令必须写WAL时，<A HREF="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</A>是<TT CLASS="LITERAL">最小的</TT>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-RM-INDEXES">14.4.3. 删除索引</A></H2><P> 如果你正在装载一个新创建的表，最快的方法是创建表，
用<TT CLASS="COMMAND">COPY</TT>批量装载，然后创建表需要的任何索引。
在已存在数据的表上创建索引要比递增地更新所装载的每一行记录要快。</P><P> 如果你对现有表增加大量的数据，可能先删除索引，装载表，
然后重新创建索引更快些。当然，在缺少索引的期间，其它数据库用户的数据库性能将有负面的影响。
并且我们在删除唯一索引之前还需要仔细考虑清楚，因为唯一约束提供的错误检查在缺少索引的时候会消失。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-RM-FKEYS">14.4.4. 删除外键约束</A></H2><P> 和索引一样，<SPAN CLASS="QUOTE">"批量地"</SPAN>检查外键约束比一行行检查更高效。因此，也许我们先删除外键约束，
装载数据，然后重建约束会更高效。同样，装载数据和缺少约束而失去错误检查之间也有一个平衡。</P><P> 更重要的是，当你将数据加载到已有外键约束的表中的时候，
每个新行需要等待触发事件的服务器列表中的项（因为它是触发器的触发，检查行的外键约束）。
装载数以百万计的行可以引起触发事件队列溢出可用内存，导致无法忍受的交换，
甚至命令的彻底失败。因此它可能是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">必要的</I></SPAN>，不只是理想的，当加载大量数据的时候，
删除并且重新申请外键约束。如果暂时删除约束是不能接受的，
唯一的其他资源可能会将负载操作分裂为更小的事务。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-WORK-MEM">14.4.5. 增大<TT CLASS="VARNAME">maintenance_work_mem</TT></A></H2><P> 在装载大量的数据的时候，临时增大<A HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</A>配置变量可以改进性能。
这个参数也可以帮助加速 <TT CLASS="COMMAND">CREATE INDEX</TT>和<TT CLASS="COMMAND">ALTER TABLE ADD FOREIGN KEY</TT>命令。
它不会对<TT CLASS="COMMAND">COPY</TT>本身有多大作用，所以这个建议只有在你使用上面的两个技巧时才有效。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-CHECKPOINT-SEGMENTS">14.4.6. 增大<TT CLASS="VARNAME">checkpoint_segments</TT></A></H2><P> 临时增大<A HREF="runtime-config-wal.html#GUC-CHECKPOINT-SEGMENTS">checkpoint_segments</A>配置变量也可以让大量数据装载得更快。
这是因为向<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>里面装载大量的数据可以导致检查点操作
(由配置变量<TT CLASS="VARNAME">checkpoint_timeout</TT>声明)
比平常更加频繁发生。在发生一个检查点的时候，所有脏数据都必须刷新到磁盘上。
通过在大量数据装载的时候临时增加<TT CLASS="VARNAME">checkpoint_segments</TT>，
所要求的检查点的数目可以减少。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-PITR">14.4.7. 禁用WAL归档和流复制</A></H2><P> 当加载大量数据到使用WAL归档或流复制的安装过程时，
加载完成之后采取新的基础备份比处理大量增量WAL数据可能会更快。当加载时为防止增量WAL日志，关闭归档和流复制，通过设置
<A HREF="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</A>到<TT CLASS="LITERAL">最小</TT>，<A HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</A>到<TT CLASS="LITERAL">off</TT>,
<A HREF="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</A>为零。 但是请注意，更改这些设置需要重新启动服务器。</P><P>
除了为归档或者WAL发送处理WAL数据来避免时间，
这样做实际上将使某些命令更快，因为如果<TT CLASS="VARNAME">wal_level</TT>
是<TT CLASS="LITERAL">最小的</TT>，他们设计不写WAL（他们可以保证碰撞安全性最后通过<CODE CLASS="FUNCTION">fsync</CODE>比写WAL更便宜）。
这适用于以下命令：
<P></P></P><UL><LI><P> <TT CLASS="COMMAND">CREATE TABLE AS SELECT</TT>
</P></LI><LI><P>
<TT CLASS="COMMAND">CREATE INDEX</TT> (正如
<TT CLASS="COMMAND">ALTER TABLE ADD PRIMARY KEY</TT>)
</P></LI><LI><P> <TT CLASS="COMMAND">ALTER TABLE SET TABLESPACE</TT>
</P></LI><LI><P> <TT CLASS="COMMAND">CLUSTER</TT>
</P></LI><LI><P> <TT CLASS="COMMAND">COPY FROM</TT>，当目标表在同一事务之前已经被创建或截断。</P></LI></UL><P>
</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-ANALYZE">14.4.8. 事后运行<TT CLASS="COMMAND">ANALYZE</TT></A></H2><P> 不管什么时候，如果你在更新了表中的大量数据之后，运行<A HREF="sql-analyze.html">ANALYZE</A>都是个好习惯。
这包含大量加载数据到表。运行<TT CLASS="COMMAND">ANALYZE</TT> (或者<TT CLASS="COMMAND">VACUUM ANALYZE</TT>)
可以保证规划器有表数据的最新统计。
如果没有统计数据或者统计数据太陈旧，那么规划器可能选择很差劲的查询规划，
导致表的错误或者不存在数据的性能恶化。
请注意如果启动autovacuum守护进程，可能自动运行<TT CLASS="COMMAND">ANALYZE</TT>；获取详情请
参阅<A HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS">第 23.1.3 &#33410;</A>和<A HREF="routine-vacuuming.html#AUTOVACUUM">第 23.1.6 &#33410;</A>。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="POPULATE-PG-DUMP">14.4.9. <SPAN CLASS="APPLICATION">pg_dump</SPAN>的一些注意事项</A></H2><P> <SPAN CLASS="APPLICATION">pg_dump</SPAN>生成的转储脚本自动使用上面的若干个技巧，但不是全部。
要尽可能快地装载<SPAN CLASS="APPLICATION">pg_dump</SPAN>转储，我们需要手工做几个事情。请注意，
这些要点适用于恢复一个<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">转储</I></SPAN>，而不是<SPAN CLASS="emphasis"><I CLASS="EMPHASIS">创建</I></SPAN>一个转储的时候。
同样的要点也适用于使用<SPAN CLASS="APPLICATION">psql</SPAN>或者<SPAN CLASS="APPLICATION">pg_restore</SPAN>从<SPAN CLASS="APPLICATION">pg_dump</SPAN>
归档文件装载文本复制的时候。</P><P>
缺省的时候，<SPAN CLASS="APPLICATION">pg_dump</SPAN>使用<TT CLASS="COMMAND">COPY</TT>，在它生成一个完整的模式和数据的转储的时候，
它会很小心地先装载数据，然后创建索引和外键。因此，在这个情况下，头几条技巧是自动处理的。
剩余的是你要做的：
<P></P></P><UL><LI><P>
设置比正常状况大的<TT CLASS="VARNAME">maintenance_work_mem</TT>和<TT CLASS="VARNAME">checkpoint_segments</TT>值。
</P></LI><LI><P> 如果使用WAL归档或流复制，可以考虑在恢复过程中禁用他们。要做到这一点，设置<TT CLASS="VARNAME">archive_mode</TT>为<TT CLASS="LITERAL">off</TT>，
<TT CLASS="VARNAME">wal_level</TT>为<TT CLASS="LITERAL">最小的</TT>，并且设置
<TT CLASS="VARNAME">max_wal_senders</TT>在装载前为零。随后，设置它们返回正确的值，并采取新的基础备份。</P></LI><LI><P> 使用<SPAN CLASS="APPLICATION">pg_dump</SPAN>和<SPAN CLASS="APPLICATION">pg_restore</SPAN>并行转储和恢复两种模式的实验，并找到
并行作业使用的最佳数目。平行转储和恢复通过<TT CLASS="OPTION">-j</TT>选项应提供给你串行模式中的更高的性能。</P></LI><LI><P> 考虑整个转储是否应作为单个事务进行恢复。要做到这一点，通过<TT CLASS="OPTION">-1</TT>或者
<TT CLASS="OPTION">-single-transaction</TT>命令行选项的<SPAN CLASS="APPLICATION">psql</SPAN>或者<SPAN CLASS="APPLICATION">pg_restore</SPAN>。
当使用此模式时，即使是最小的误差将回滚整个恢复，可能丢弃很多时间的处理。
取决于如何相互关联数据，这可能最好是手动清理或者没有。如果你使用单一事务并且WAL归档关闭，则<TT CLASS="COMMAND">COPY</TT>命令将运行速度最快。</P></LI><LI><P> 如果在数据库服务器中有多个CPU，可以考虑使用<SPAN CLASS="APPLICATION">pg_restore</SPAN>的<TT CLASS="OPTION">-jobs</TT> 选项。
这允许并发数据加载和索引的创建。</P></LI><LI><P> 之后运行<TT CLASS="COMMAND">ANALYZE</TT>。</P></LI></UL><P>
</P><P>
只保存数据的转储仍然会使用<TT CLASS="COMMAND">COPY</TT>，但是它不会删除或者重建索引，
并且它不会自动修改外键。
<A NAME="AEN24647" HREF="populate.html#FTN.AEN24647"><SPAN CLASS="footnote">[1]</SPAN></A>
因此当装载只有数据的转储时候，如果你想使用这些技术，删除以及重建索引和外键完全取决于你。
当加载数据时，增大<TT CLASS="VARNAME">checkpoint_segments</TT>仍然是有用的，
但是增大<TT CLASS="VARNAME">maintenance_work_mem</TT>就没什么必要了；
相反，你只是应该在事后手工创建索引和外键，
最后结束时不要忘记<TT CLASS="COMMAND">ANALYZE</TT>命令。参阅<A HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS">第 23.1.3 &#33410;</A>
和<A HREF="routine-vacuuming.html#AUTOVACUUM">第 23.1.6 &#33410;</A>获取更多详情。
</P></DIV></DIV><H3 CLASS="FOOTNOTES">&#22791;&#27880;</H3><TABLE BORDER="0" CLASS="FOOTNOTES" WIDTH="100%"><TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="5%"><A NAME="FTN.AEN24647" HREF="populate.html#AEN24647"><SPAN CLASS="footnote">[1]</SPAN></A></TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95%"><P>
你可以通过使用<TT CLASS="OPTION">-disable-triggers</TT>选项的方法获取关闭外键的效果。
不过要意识到这么做是消除，而不只是推迟违反外键约束，
因此如果你使用这个选项，将有可能插入坏数据。
</P></TD></TR></TABLE><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="explicit-joins.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="non-durability.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">用明确的<TT CLASS="LITERAL">JOIN</TT>控制规划器</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/performance-tips.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">非持久性设置</TD></TR></TABLE></DIV></BODY></HTML>
