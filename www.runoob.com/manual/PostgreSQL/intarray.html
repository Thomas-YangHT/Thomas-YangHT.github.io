<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><TITLE>intarray</TITLE><META NAME="GENERATOR" CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK REV="MADE" HREF="mailto:pgsql-docs@postgresql.org"><LINK REL="HOME" TITLE="PostgreSQL 9.3.1 中文手册" HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html"><LINK REL="UP" TITLE="额外提供的模块" HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html"><LINK REL="PREVIOUS" TITLE="intagg" HREF="intagg.html"><LINK REL="NEXT" TITLE="isn" HREF="isn.html"><LINK REL="STYLESHEET" TYPE="text/css" HREF="http://school.yunwei.edu/manual/PostgreSQL/stylesheet.css"><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><META NAME="creation" CONTENT="2015-07-11T14:00:17"></HEAD><BODY CLASS="SECT1">
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/master/postgresql/doc/src/sgml/intarray.sgml" target="_blank" title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV CLASS="NAVHEADER"><TABLE SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TH COLSPAN="5" ALIGN="center" VALIGN="bottom"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html">PostgreSQL 9.3.1 中文手册</A></TH></TR><TR><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A TITLE="intagg" HREF="intagg.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="10%" ALIGN="left" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="60%" ALIGN="center" VALIGN="bottom">&#38468;&#24405; F. 额外提供的模块</TD><TD WIDTH="20%" ALIGN="right" VALIGN="top"><A TITLE="isn" HREF="isn.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR></TABLE><HR ALIGN="LEFT" WIDTH="100%"></DIV><DIV CLASS="SECT1"><H1 CLASS="SECT1"><A NAME="INTARRAY">F.18. intarray</A></H1><P><TT CLASS="FILENAME">intarray</TT>模块为操作整数的null-free数组提供一些有用的函数和操作符。
也支持使用其中的一些操作符执行索引搜索。</P><P>如果提供的数组包含任何空元素，那么所有这些操作符都将抛出一个错误。</P><P>这些操作符中的一些只对一维数组敏感。尽管他们将接受多个维数的输入数组，
数据被按照存储的顺序当做一维数组。</P><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN146693">F.18.1. <TT CLASS="FILENAME">intarray</TT> 函数和操作符</A></H2><P><TT CLASS="FILENAME">intarray</TT>模块提供的函数显示在<A HREF="intarray.html#INTARRAY-FUNC-TABLE">&#34920; F-8</A>里，
操作符显示在<A HREF="intarray.html#INTARRAY-OP-TABLE">&#34920; F-9</A>里。</P><DIV CLASS="TABLE"><A NAME="INTARRAY-FUNC-TABLE"></A><P><B>&#34920; F-8. <TT CLASS="FILENAME">intarray</TT> 函数</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><COL><COL><THEAD><TR><TH>函数</TH><TH>返回类型</TH><TH>描述</TH><TH>示例</TH><TH>结果</TH></TR></THEAD><TBODY><TR><TD><CODE CLASS="FUNCTION">icount(int[])</CODE></TD><TD><TT CLASS="TYPE">int</TT></TD><TD>数组中元素的个数</TD><TD><TT CLASS="LITERAL">icount('{1,2,3}'::int[])</TT></TD><TD><TT CLASS="LITERAL">3</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">sort(int[], text dir)</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>给数组排序 &mdash; <TT CLASS="PARAMETER">dir</TT> 必须为 <TT CLASS="LITERAL">asc</TT> 或 <TT CLASS="LITERAL">desc</TT></TD><TD><TT CLASS="LITERAL">sort('{1,2,3}'::int[], 'desc')</TT></TD><TD><TT CLASS="LITERAL">{3,2,1}</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">sort(int[])</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>以升序顺序排序</TD><TD><TT CLASS="LITERAL">sort(array[11,77,44])</TT></TD><TD><TT CLASS="LITERAL">{11,44,77}</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">sort_asc(int[])</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>以升序顺序排序</TD><TD><TT CLASS="LITERAL"></TT></TD><TD><TT CLASS="LITERAL"></TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">sort_desc(int[])</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>以降序顺序排序</TD><TD><TT CLASS="LITERAL"></TT></TD><TD><TT CLASS="LITERAL"></TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">uniq(int[])</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>删除相邻的重复</TD><TD><TT CLASS="LITERAL">uniq(sort('{1,2,3,2,1}'::int[]))</TT></TD><TD><TT CLASS="LITERAL">{1,2,3}</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">idx(int[], int item)</CODE></TD><TD><TT CLASS="TYPE">int</TT></TD><TD>匹配<TT CLASS="PARAMETER">item</TT>的第一个元素中的索引 (如果没有则为0)</TD><TD><TT CLASS="LITERAL">idx(array[11,22,33,22,11], 22)</TT></TD><TD><TT CLASS="LITERAL">2</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">subarray(int[], int start, int len)</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>在 <TT CLASS="PARAMETER">start</TT> 位置开始的, <TT CLASS="PARAMETER">len</TT> 个元素的数组的一部分</TD><TD><TT CLASS="LITERAL">subarray('{1,2,3,2,1}'::int[], 2, 3)</TT></TD><TD><TT CLASS="LITERAL">{2,3,2}</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">subarray(int[], int start)</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>在 <TT CLASS="PARAMETER">start</TT> 位置开始的数组的一部分</TD><TD><TT CLASS="LITERAL">subarray('{1,2,3,2,1}'::int[], 2)</TT></TD><TD><TT CLASS="LITERAL">{2,3,2,1}</TT></TD></TR><TR><TD><CODE CLASS="FUNCTION">intset(int)</CODE></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>制作单个元素的数组</TD><TD><TT CLASS="LITERAL">intset(42)</TT></TD><TD><TT CLASS="LITERAL">{42}</TT></TD></TR></TBODY></TABLE></DIV><DIV CLASS="TABLE"><A NAME="INTARRAY-OP-TABLE"></A><P><B>&#34920; F-9. <TT CLASS="FILENAME">intarray</TT> 操作符</B></P><TABLE BORDER="1" CLASS="CALSTABLE"><COL><COL><COL><THEAD><TR><TH>操作符</TH><TH>返回</TH><TH>描述</TH></TR></THEAD><TBODY><TR><TD><TT CLASS="LITERAL">int[] &amp;&amp; int[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>重复 &mdash; 如果数组至少有一个共同元素则为<TT CLASS="LITERAL">true</TT> </TD></TR><TR><TD><TT CLASS="LITERAL">int[] @&gt; int[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>包含 &mdash; 如果左边的数组包含右边的数组则为<TT CLASS="LITERAL">true</TT> </TD></TR><TR><TD><TT CLASS="LITERAL">int[] &lt;@ int[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>包含于 &mdash; 如果左边的数组包含于右边的数组则为<TT CLASS="LITERAL">true</TT> </TD></TR><TR><TD><TT CLASS="LITERAL"># int[]</TT></TD><TD><TT CLASS="TYPE">int</TT></TD><TD>数组中元素的个数</TD></TR><TR><TD><TT CLASS="LITERAL">int[] # int</TT></TD><TD><TT CLASS="TYPE">int</TT></TD><TD>索引 (和<CODE CLASS="FUNCTION">idx</CODE> 函数相同)</TD></TR><TR><TD><TT CLASS="LITERAL">int[] + int</TT></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>将元素推入数组中(将元素添加到数组的末尾)</TD></TR><TR><TD><TT CLASS="LITERAL">int[] + int[] </TT></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>数组串联(右边的数组添加到左边的数组的后面)</TD></TR><TR><TD><TT CLASS="LITERAL">int[] - int</TT></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>删除匹配右边数组中元素的项</TD></TR><TR><TD><TT CLASS="LITERAL">int[] - int[]</TT></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>从左边数组中删除右边数组中的元素</TD></TR><TR><TD><TT CLASS="LITERAL">int[] | int</TT></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>参数的并集</TD></TR><TR><TD><TT CLASS="LITERAL">int[] | int[]</TT></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>数组的并集</TD></TR><TR><TD><TT CLASS="LITERAL">int[] &amp; int[]</TT></TD><TD><TT CLASS="TYPE">int[]</TT></TD><TD>数组的交集</TD></TR><TR><TD><TT CLASS="LITERAL">int[] @@ query_int</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>如果数组满足查询则为<TT CLASS="LITERAL">true</TT> (见下文)</TD></TR><TR><TD><TT CLASS="LITERAL">query_int ~~ int[]</TT></TD><TD><TT CLASS="TYPE">boolean</TT></TD><TD>如果数组满足查询则为<TT CLASS="LITERAL">true</TT> (<TT CLASS="LITERAL">@@</TT>的交换子)</TD></TR></TBODY></TABLE></DIV><P>（PostgreSQL 8.2之前，包含操作符<TT CLASS="LITERAL">@&gt;</TT>和<TT CLASS="LITERAL">&lt;@</TT>
分别称为<TT CLASS="LITERAL">@</TT> 和 <TT CLASS="LITERAL">~</TT>。这些名字仍然可以使用，但是已经废弃了并且最终会被撤销。
请注意，旧的名字从大会移除，之前跟随着核心几何数据类型！）</P><P>操作符<TT CLASS="LITERAL">&amp;&amp;</TT>, <TT CLASS="LITERAL">@&gt;</TT> 和 <TT CLASS="LITERAL">&lt;@</TT>等同于
<SPAN CLASS="PRODUCTNAME">PostgreSQL</SPAN>同名的内建操作符，除了它们只工作于整数数组不包含空值，
而内建操作符工作于任意数组类型。这个限制使它们在任何情况下都比内建操作符快的多。</P><P><TT CLASS="LITERAL">@@</TT> 和 <TT CLASS="LITERAL">~~</TT>操作符测试一个数组是否满足一个<I CLASS="FIRSTTERM">query</I>，
该查询表示为一个专门的数据类型<TT CLASS="TYPE">query_int</TT>的值。<I CLASS="FIRSTTERM">query</I>
由针对数组元素检查的整数值组成，可能混合使用操作符<TT CLASS="LITERAL">&amp;</TT>
(与), <TT CLASS="LITERAL">|</TT> (或), 和 <TT CLASS="LITERAL">!</TT> (非)。在需要时可以使用括号。
例如，查询<TT CLASS="LITERAL">1&amp;(2|3)</TT>匹配包含1也包含2或3的数组。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN146956">F.18.2. 索引支持</A></H2><P><TT CLASS="FILENAME">intarray</TT>为<TT CLASS="LITERAL">&amp;&amp;</TT>, <TT CLASS="LITERAL">@&gt;</TT>, <TT CLASS="LITERAL">&lt;@</TT>,
和 <TT CLASS="LITERAL">@@</TT>操作符还有普通数组相等提供索引支持，</P><P>提供两个GiST索引操作符类：<TT CLASS="LITERAL">gist__int_ops</TT>（缺省使用）
适合于小到中等的数据集，而<TT CLASS="LITERAL">gist__intbig_ops</TT>
使用一个大的签名并且更适合于索引大的数据集（也就是，
包含大量不同数组值的字段）。该实现使用一个RD树数据结构和内建的有损压缩。</P><P>还有一个非缺省的GIN操作符类<TT CLASS="LITERAL">gin__int_ops</TT>支持相同的操作符。</P><P>GiST和GIN索引的选择取决于GiST和GIN相关的性能特性，这个在别的地方讨论。
一般来说，GIN索引比GiST索引搜索起来更快一些，而建立或更新要慢一些；
所以GIN更适合于静态数据，而GiST更适合于经常更新的数据。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN146970">F.18.3. 示例</A></H2><PRE CLASS="PROGRAMLISTING">-- 一个message可以在一个或多个<SPAN
CLASS="QUOTE"
>"sections"</SPAN
>中
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], ...);

-- 创建专门的索引
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);

-- 在section 1或2中选择message -OVERLAP操作符
SELECT message.mid FROM message WHERE message.sections &amp;&amp; '{1,2}';

-- 在section 1和2中选择message -CONTAINS操作符
SELECT message.mid FROM message WHERE message.sections @&gt; '{1,2}';

-- 相同的，使用QUERY操作符
SELECT message.mid FROM message WHERE message.sections @@ '1&amp;2'::query_int;</PRE></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN146974">F.18.4. 基准</A></H2><P>源目录<TT CLASS="FILENAME">contrib/intarray/bench</TT>包含一个基准测试套件。运行：</P><PRE CLASS="PROGRAMLISTING">cd .../bench
createdb TEST
psql TEST &lt; ../_int.sql
./create_test.pl | psql TEST
./bench.pl</PRE><P><TT CLASS="FILENAME">bench.pl</TT>脚本有许多选项，当它不带任何参数的运行时显示。</P></DIV><DIV CLASS="SECT2"><H2 CLASS="SECT2"><A NAME="AEN146981">F.18.5. 作者</A></H2><P>所有工作都是Teodor Sigaev (<CODE CLASS="EMAIL">&#60;<A HREF="mailto:teodor@sigaev.ru">teodor@sigaev.ru</A>&#62;</CODE>)和
Oleg Bartunov (<CODE CLASS="EMAIL">&#60;<A HREF="mailto:oleg@sai.msu.su">oleg@sai.msu.su</A>&#62;</CODE>)完成的。参阅
<A HREF="http://www.sai.msu.su/~megera/postgres/gist/" TARGET="_top">http://www.sai.msu.su/~megera/postgres/gist/</A>获取额外的信息。
Andrey Oktyabrski在添加新的函数和操作符上做了一个伟大的工作。</P></DIV></DIV><DIV CLASS="NAVFOOTER"><HR ALIGN="LEFT" WIDTH="100%"><TABLE SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top"><A HREF="intagg.html" ACCESSKEY="P">&#19978;&#19968;&#39029;</A></TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/index.html" ACCESSKEY="H">&#36215;&#22987;&#39029;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top"><A HREF="isn.html" ACCESSKEY="N">&#19979;&#19968;&#39029;</A></TD></TR><TR><TD WIDTH="33%" ALIGN="left" VALIGN="top">intagg</TD><TD WIDTH="34%" ALIGN="center" VALIGN="top"><A HREF="http://school.yunwei.edu/manual/PostgreSQL/contrib.html" ACCESSKEY="U">&#19978;&#19968;&#32423;</A></TD><TD WIDTH="33%" ALIGN="right" VALIGN="top">isn</TD></TR></TABLE></DIV></BODY></HTML>
